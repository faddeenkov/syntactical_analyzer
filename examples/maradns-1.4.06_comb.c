/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

#line 25 "/usr/include/stdint.h"
typedef short int16_t;
#line 30 "/usr/include/stdint.h"
typedef int int32_t;
#line 35 "/usr/include/stdint.h"
typedef long long int64_t;
#line 45 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 50 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 19 "../libs/JsStr.h"
struct __anonstruct_js_string_1 {
   unsigned char *string ;
   unsigned int unit_size ;
   unsigned int unit_count ;
   unsigned int max_count ;
   int encoding ;
   int is_good ;
};
#line 19 "../libs/JsStr.h"
typedef struct __anonstruct_js_string_1 js_string;
#line 25 "../libs/MaraHash.h"
struct mhash_spot {
   js_string *key ;
   void *value ;
   int datatype ;
   struct mhash_spot *next ;
};
#line 25 "../libs/MaraHash.h"
typedef struct mhash_spot mhash_spot;
#line 33 "../libs/MaraHash.h"
struct __anonstruct_mhash_e_4 {
   void **point ;
   void *value ;
   int datatype ;
};
#line 33 "../libs/MaraHash.h"
typedef struct __anonstruct_mhash_e_4 mhash_e;
#line 41 "../libs/MaraHash.h"
struct __anonstruct_mhash_5 {
   int hash_bits ;
   mhash_spot **hash_table ;
   unsigned int spots ;
};
#line 41 "../libs/MaraHash.h"
typedef struct __anonstruct_mhash_5 mhash;
#line 162 "../MaraDns.h"
struct __anonstruct_conn_6 {
   unsigned char type ;
   void *d ;
   int addrlen ;
};
#line 162 "../MaraDns.h"
typedef struct __anonstruct_conn_6 conn;
#line 169 "../MaraDns.h"
struct __anonstruct_ipv4pair_7 {
   uint32_t ip ;
   uint32_t mask ;
};
#line 169 "../MaraDns.h"
typedef struct __anonstruct_ipv4pair_7 ipv4pair;
#line 176 "../MaraDns.h"
struct fila {
   struct fila *siguiente ;
   struct fila *previous ;
   unsigned char datatype ;
   void *record ;
   js_string *hash_point ;
   char nukable_hp ;
};
#line 176 "../MaraDns.h"
typedef struct fila fila;
#line 206
struct rr_list;
#line 206 "../MaraDns.h"
struct rr {
   int64_t expire ;
   uint32_t ttl ;
   uint32_t authoritative ;
   struct rr *next ;
   struct rr *ip ;
   js_string *ptr ;
   uint16_t rr_type ;
   js_string *query ;
   js_string *data ;
   fila *zap ;
   char seen ;
   uint16_t perms ;
   struct rr_list *list ;
   char rcode ;
};
#line 206 "../MaraDns.h"
typedef struct rr rr;
#line 231 "../MaraDns.h"
struct rr_list {
   uint16_t rr_type ;
   rr *data ;
   struct rr_list *next ;
};
#line 231 "../MaraDns.h"
typedef struct rr_list rr_list;
#line 239 "../MaraDns.h"
struct __anonstruct_q_header_8 {
   uint16_t id ;
   int qr ;
   int opcode ;
   int aa ;
   int tc ;
   int rd ;
   int ra ;
   int z ;
   int rcode ;
   uint16_t qdcount ;
   uint16_t ancount ;
   uint16_t nscount ;
   uint16_t arcount ;
};
#line 239 "../MaraDns.h"
typedef struct __anonstruct_q_header_8 q_header;
#line 41 "/usr/include/i386/_types.h"
typedef unsigned char __uint8_t;
#line 43 "/usr/include/i386/_types.h"
typedef unsigned short __uint16_t;
#line 44 "/usr/include/i386/_types.h"
typedef int __int32_t;
#line 45 "/usr/include/i386/_types.h"
typedef unsigned int __uint32_t;
#line 46 "/usr/include/i386/_types.h"
typedef long long __int64_t;
#line 47 "/usr/include/i386/_types.h"
typedef unsigned long long __uint64_t;
#line 90 "/usr/include/i386/_types.h"
typedef unsigned long __darwin_size_t;
#line 116 "/usr/include/i386/_types.h"
typedef __uint32_t __darwin_socklen_t;
#line 117 "/usr/include/i386/_types.h"
typedef long __darwin_ssize_t;
#line 118 "/usr/include/i386/_types.h"
typedef long __darwin_time_t;
#line 99 "/usr/include/sys/_types.h"
typedef __uint32_t __darwin_gid_t;
#line 110 "/usr/include/sys/_types.h"
typedef __int64_t __darwin_off_t;
#line 132 "/usr/include/sys/_types.h"
typedef __int32_t __darwin_suseconds_t;
#line 133 "/usr/include/sys/_types.h"
typedef __uint32_t __darwin_uid_t;
#line 78 "/usr/include/stdio.h"
typedef __darwin_size_t size_t;
#line 85 "/usr/include/stdio.h"
typedef __darwin_off_t fpos_t;
#line 96 "/usr/include/stdio.h"
struct __sbuf {
   unsigned char *_base ;
   int _size ;
};
#line 102
struct __sFILEX;
#line 130 "/usr/include/stdio.h"
struct __sFILE {
   unsigned char *_p ;
   int _r ;
   int _w ;
   short _flags ;
   short _file ;
   struct __sbuf _bf ;
   int _lbfsize ;
   void *_cookie ;
   int (*_close)(void * ) ;
   int (*_read)(void * , char * , int  ) ;
   fpos_t (*_seek)(void * , fpos_t  , int  ) ;
   int (*_write)(void * , char const   * , int  ) ;
   struct __sbuf _ub ;
   struct __sFILEX *_extra ;
   int _ur ;
   unsigned char _ubuf[3] ;
   unsigned char _nbuf[1] ;
   struct __sbuf _lb ;
   int _blksize ;
   fpos_t _offset ;
};
#line 130 "/usr/include/stdio.h"
typedef struct __sFILE FILE;
#line 442 "/usr/include/stdio.h"
typedef __darwin_ssize_t ssize_t;
#line 172 "/usr/include/sys/signal.h"
typedef __darwin_uid_t uid_t;
#line 77 "/usr/include/unistd.h"
typedef __darwin_gid_t gid_t;
#line 100 "/usr/include/sys/_structs.h"
struct timeval {
   __darwin_time_t tv_sec ;
   __darwin_suseconds_t tv_usec ;
};
#line 184 "/usr/include/sys/_structs.h"
struct fd_set {
   __int32_t fds_bits[1024UL / (sizeof(__int32_t ) * 8UL)] ;
};
#line 184 "/usr/include/sys/_structs.h"
typedef struct fd_set fd_set;
#line 89 "/usr/include/sys/resource.h"
typedef __uint64_t rlim_t;
#line 222 "/usr/include/sys/resource.h"
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
#line 419 "/usr/include/sys/fcntl.h"
#pragma pack(4)
#line 431
#pragma pack()
#line 126 "/usr/include/sys/types.h"
typedef __uint32_t in_addr_t;
#line 131 "/usr/include/sys/types.h"
typedef __uint16_t in_port_t;
#line 106 "/usr/include/sys/socket.h"
typedef __uint8_t sa_family_t;
#line 111 "/usr/include/sys/socket.h"
typedef __darwin_socklen_t socklen_t;
#line 322 "/usr/include/sys/socket.h"
struct sockaddr {
   __uint8_t sa_len ;
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 307 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 380 "/usr/include/netinet/in.h"
struct sockaddr_in {
   __uint8_t sin_len ;
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   char sin_zero[8] ;
};
#line 522
#pragma pack(4)
#line 565
#pragma pack()
#line 30 "../libs/JsStr.h"
struct __anonstruct_js_file_2 {
   int filetype ;
   int file_desc ;
   js_string *buffer ;
   int number ;
   int eof ;
};
#line 30 "../libs/JsStr.h"
typedef struct __anonstruct_js_file_2 js_file;
#line 522 "/usr/include/netinet/in.h"
#pragma pack(4)
#line 565
#pragma pack()
#line 58 "/usr/include/sys/_types.h"
struct __darwin_pthread_handler_rec {
   void (*__routine)(void * ) ;
   void *__arg ;
   struct __darwin_pthread_handler_rec *__next ;
};
#line 64 "/usr/include/sys/_types.h"
struct _opaque_pthread_attr_t {
   long __sig ;
   char __opaque[56] ;
};
#line 67 "/usr/include/sys/_types.h"
struct _opaque_pthread_mutex_t {
   long __sig ;
   char __opaque[56] ;
};
#line 72 "/usr/include/sys/_types.h"
struct _opaque_pthread_t {
   long __sig ;
   struct __darwin_pthread_handler_rec *__cleanup_stack ;
   char __opaque[1168] ;
};
#line 111 "/usr/include/sys/_types.h"
typedef __int32_t __darwin_pid_t;
#line 112 "/usr/include/sys/_types.h"
typedef struct _opaque_pthread_attr_t __darwin_pthread_attr_t;
#line 119 "/usr/include/sys/_types.h"
typedef struct _opaque_pthread_mutex_t __darwin_pthread_mutex_t;
#line 129 "/usr/include/sys/_types.h"
typedef struct _opaque_pthread_t *__darwin_pthread_t;
#line 87 "/usr/include/time.h"
typedef __darwin_time_t time_t;
#line 64 "/usr/include/pthread.h"
typedef __darwin_pthread_attr_t pthread_attr_t;
#line 84 "/usr/include/pthread.h"
typedef __darwin_pthread_mutex_t pthread_mutex_t;
#line 109 "/usr/include/pthread.h"
typedef __darwin_pthread_t pthread_t;
#line 191 "../MaraDns.h"
struct closer {
   unsigned int num_elements ;
   int64_t ttd ;
   int datatype ;
   void *data ;
   fila *zap ;
   struct closer *masked ;
   struct closer *next ;
};
#line 191 "../MaraDns.h"
typedef struct closer closer;
#line 414 "/usr/include/stdio.h"
typedef __darwin_off_t off_t;
#line 152 "/usr/include/sys/signal.h"
typedef __darwin_pid_t pid_t;
#line 522 "/usr/include/netinet/in.h"
#pragma pack(4)
#line 565
#pragma pack()
#line 419 "/usr/include/sys/fcntl.h"
#pragma pack(4)
#line 431
#pragma pack()
#line 55 "../rng/rng-alg-fst.h"
typedef unsigned int u32;
#line 91 "../rng/rng-api-fst.h"
typedef unsigned char MARA_BYTE;
#line 94 "../rng/rng-api-fst.h"
struct __anonstruct_keyInstance_22 {
   MARA_BYTE direction ;
   int keyLen ;
   char keyMaterial[65] ;
   int Nr ;
   u32 rk[60] ;
   u32 ek[60] ;
};
#line 94 "../rng/rng-api-fst.h"
typedef struct __anonstruct_keyInstance_22 keyInstance;
#line 104 "../rng/rng-api-fst.h"
struct __anonstruct_cipherInstance_23 {
   MARA_BYTE mode ;
   MARA_BYTE IV[16] ;
};
#line 104 "../rng/rng-api-fst.h"
typedef struct __anonstruct_cipherInstance_23 cipherInstance;
#line 121 "recursive.c"
struct __anonstruct_dnsreq_24 {
   int id ;
   int sock ;
   struct sockaddr_in client ;
   js_string *query ;
};
#line 121 "recursive.c"
typedef struct __anonstruct_dnsreq_24 dnsreq;
#line 90 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char *tm_zone ;
};
#line 522 "/usr/include/netinet/in.h"
#pragma pack(4)
#line 565
#pragma pack()
#line 522
#pragma pack(4)
#line 565
#pragma pack()
#line 522
#pragma pack(4)
#line 565
#pragma pack()
#line 419 "/usr/include/sys/fcntl.h"
#pragma pack(4)
#line 431
#pragma pack()
#line 83 "/usr/include/sys/file.h"
#pragma pack(4)
#line 98
#pragma pack()
#line 19 "MaraHash.h"
struct __anonstruct_mara_tuple_3 {
   int elements ;
   js_string **tuple_list ;
};
#line 19 "MaraHash.h"
typedef struct __anonstruct_mara_tuple_3 mara_tuple;
#line 256 "../MaraDns.h"
struct __anonstruct_q_question_6 {
   js_string *qname ;
   uint16_t qtype ;
   uint16_t qclass ;
};
#line 256 "../MaraDns.h"
typedef struct __anonstruct_q_question_6 q_question;
#line 263 "../MaraDns.h"
struct __anonstruct_q_rr_7 {
   js_string *name ;
   uint16_t type ;
   uint16_t class ;
   uint32_t ttl ;
   uint16_t rdlength ;
   js_string *rdata ;
};
#line 263 "../MaraDns.h"
typedef struct __anonstruct_q_rr_7 q_rr;
#line 409 "../MaraDns.h"
struct __anonstruct_rr_soa_8 {
   js_string *mname ;
   js_string *rname ;
   uint32_t serial ;
   int32_t refresh ;
   int32_t retry ;
   int32_t expire ;
   uint32_t minimum ;
};
#line 409 "../MaraDns.h"
typedef struct __anonstruct_rr_soa_8 rr_soa;
#line 20 "Compress_rrs.h"
struct rrdesc {
   int rr_num ;
   char *description ;
   char tocompress ;
   struct rrdesc *next ;
};
#line 20 "Compress_rrs.h"
typedef struct rrdesc rrdesc;
#line 44 "Compress.c"
struct compress_state {
   js_string *compressed ;
   js_string *uncompressed ;
   unsigned int uncompressed_offset ;
   unsigned int this_dlabel_begin ;
   int *dlabel_points ;
   unsigned int this_rdlength_begin ;
   int this_rr_type ;
   int current_rdlength ;
   int valid_state ;
   int number_answers ;
};
#line 44 "Compress.c"
typedef struct compress_state compress_state;
#line 24 "Csv2_read.h"
struct csv2_file {
   FILE *reading ;
   char *filename ;
   struct csv2_file *next ;
};
#line 24 "Csv2_read.h"
typedef struct csv2_file csv2_file;
#line 30 "Csv2_read.h"
struct csv2_read {
   FILE *reading ;
   char *filename ;
   csv2_file *stack ;
   char context[19] ;
   char chars_allowed ;
   char tilde_seen ;
   char tilde_handling ;
   int stack_height ;
   int cplace ;
   int mnum ;
   int mplace ;
   int linenum ;
   int justread ;
   int32_t unicode ;
   int ok_to_read ;
   char seen_bug_msg ;
};
#line 30 "Csv2_read.h"
typedef struct csv2_read csv2_read;
#line 27 "Csv2_database.h"
struct csv2_rr {
   js_string *query ;
   int rtype ;
   int32_t ttl ;
   js_string *data ;
   struct csv2_rr *next ;
};
#line 27 "Csv2_database.h"
typedef struct csv2_rr csv2_rr;
#line 35 "Csv2_database.h"
struct csv2_origin {
   js_string *origin ;
   struct csv2_origin *next ;
};
#line 35 "Csv2_database.h"
typedef struct csv2_origin csv2_origin;
#line 40 "Csv2_database.h"
struct csv2_add_state {
   csv2_rr *buffer ;
   js_string *zone ;
   js_string *origin ;
   csv2_origin *ostack ;
   int ostack_height ;
   int rrnum ;
   int add_method ;
   int32_t soa_serial ;
   int32_t default_ttl ;
   int in_ns ;
   int zone_nses_added ;
   mhash *bighash ;
};
#line 40 "Csv2_database.h"
typedef struct csv2_add_state csv2_add_state;
#line 94 "/usr/include/sys/_types.h"
typedef __int64_t __darwin_blkcnt_t;
#line 95 "/usr/include/sys/_types.h"
typedef __int32_t __darwin_blksize_t;
#line 96 "/usr/include/sys/_types.h"
typedef __int32_t __darwin_dev_t;
#line 101 "/usr/include/sys/_types.h"
typedef __uint64_t __darwin_ino64_t;
#line 109 "/usr/include/sys/_types.h"
typedef __uint16_t __darwin_mode_t;
#line 103 "/usr/include/sys/types.h"
typedef __darwin_dev_t dev_t;
#line 110 "/usr/include/sys/types.h"
typedef __darwin_blkcnt_t blkcnt_t;
#line 115 "/usr/include/sys/types.h"
typedef __darwin_blksize_t blksize_t;
#line 152 "/usr/include/sys/types.h"
typedef __darwin_mode_t mode_t;
#line 157 "/usr/include/sys/types.h"
typedef __uint16_t nlink_t;
#line 88 "/usr/include/sys/_structs.h"
struct timespec {
   __darwin_time_t tv_sec ;
   long tv_nsec ;
};
#line 225 "/usr/include/sys/stat.h"
struct stat {
   dev_t st_dev ;
   mode_t st_mode ;
   nlink_t st_nlink ;
   __darwin_ino64_t st_ino ;
   uid_t st_uid ;
   gid_t st_gid ;
   dev_t st_rdev ;
   struct timespec st_atimespec ;
   struct timespec st_mtimespec ;
   struct timespec st_ctimespec ;
   struct timespec st_birthtimespec ;
   off_t st_size ;
   blkcnt_t st_blocks ;
   blksize_t st_blksize ;
   __uint32_t st_flags ;
   __uint32_t st_gen ;
   __int32_t st_lspare ;
   __int64_t st_qspare[2] ;
};
#line 53 "rng-alg-fst.h"
typedef unsigned char u8;
/* compiler builtin: 
   char *__builtin___strncpy_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   unsigned long __builtin_object_size(void * , int  ) ;  */
/* compiler builtin: 
   int __builtin___snprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                char const   *  , ...) ;  */
/* compiler builtin: 
   void *__builtin___memset_chk(void * , int  , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   void __builtin_bzero(void * , unsigned long  ) ;  */
#line 1 "cil-srFhdPCQ.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-0T6Y0ksC.i","")
#line 66 "../libs/JsStr.h"
js_string *js_create(unsigned int max_count , unsigned int unit_size ) ;
#line 67
int js_set_encode(js_string *js , int encoding ) ;
#line 70
int js_destroy(js_string *object ) ;
#line 72
int js_has_sanity(js_string *object ) ;
#line 74
int js_js2str(js_string *js , char *string , int max ) ;
#line 75
int js_issame(js_string *js1 , js_string *js2 ) ;
#line 81
int js_append(js_string *toappend , js_string *target ) ;
#line 82
int js_copy(js_string *src , js_string *dest ) ;
#line 83
int js_substr(js_string *source , js_string *dest , int start , int count ) ;
#line 86
int js_qappend(char *toappend , js_string *target ) ;
#line 90
int js_adduint16(js_string *js , int number ) ;
#line 91
int js_addbyte(js_string *js , unsigned char byte ) ;
#line 92
int js_length(js_string *js ) ;
#line 93
int js_readuint16(js_string *js , unsigned int offset ) ;
#line 98
void *js_alloc(int unit_count , int unit_size ) ;
#line 99
int js_dealloc(void *pointer ) ;
#line 100
int js_show_stdout(js_string *js ) ;
#line 110
int js_qstr2js(js_string *js , char *string ) ;
#line 111
int js_adduint32(js_string *js , uint32_t number ) ;
#line 116
int js_tell_memory_allocated(void) ;
#line 117
int show_esc_stdout(js_string *js ) ;
#line 58 "../libs/MaraHash.h"
mhash *mhash_create(int hash_bits ) ;
#line 62
mhash_e mhash_get(mhash *hash , js_string *key___0 ) ;
#line 21 "../qual/qual_timestamp.h"
int64_t qual_get_time(void) ;
#line 26
int qual_set_time(void) ;
#line 165 "/usr/include/stdio.h"
extern FILE *__stdoutp ;
#line 243
extern int fflush(FILE * ) ;
#line 267
extern int ( /* format attribute */  printf)(char const   *  , ...) ;
#line 407 "/usr/include/sys/signal.h"
extern void (*signal(int  , void (*)(int  ) ))(int  ) ;
#line 473 "/usr/include/unistd.h"
extern int chdir(char const   * ) ;
#line 490
extern uid_t geteuid(void) ;
#line 514
extern int setgid(gid_t  ) ;
#line 517
extern int setuid(uid_t  ) ;
#line 519
extern unsigned int sleep(unsigned int  )  __asm__("_sleep")  ;
#line 576
extern int chroot(char const   * ) ;
#line 190 "/usr/include/sys/_structs.h"
__inline static int __darwin_fd_isset(int _n , struct fd_set  const  *_p ) 
{ 

  {
#line 193
  return (_p->fds_bits[(unsigned long )_n / (sizeof(__int32_t ) * 8UL)] & (1 << (unsigned long )_n % (sizeof(__int32_t ) * 8UL)));
}
}
#line 39 "/usr/include/sys/_select.h"
extern int select(int  , fd_set * , fd_set * , fd_set * , struct timeval * )  __asm__("_select$1050")  ;
#line 727 "/usr/include/unistd.h"
extern int setgroups(int  , gid_t const   * ) ;
#line 255 "/usr/include/sys/resource.h"
extern int setrlimit(int  , struct rlimit  const  * )  __asm__("_setrlimit")  ;
#line 44 "/usr/include/libkern/i386/_OSByteOrder.h"
__inline static __uint16_t _OSSwapInt16(__uint16_t _data ) 
{ 

  {
#line 50
  return ((__uint16_t )(((int )_data << 8) | ((int )_data >> 8)));
}
}
#line 60
//extern int ( /* missing proto */  __builtin_bswap32)() ;
#line 53 "/usr/include/libkern/i386/_OSByteOrder.h"
__inline static __uint32_t _OSSwapInt32(__uint32_t _data ) 
{ int tmp ;

  {
#line 60
  tmp = __builtin_bswap32(_data);
#line 60
  return ((__uint32_t )tmp);
}
}
#line 159 "/usr/include/stdlib.h"
extern  __attribute__((__noreturn__)) void exit(int  ) ;
#line 75 "/usr/include/sys/errno.h"
extern int *__error(void) ;
#line 91 "/usr/include/string.h"
extern char *strerror(int  )  __asm__("_strerror")  ;
#line 80 "/usr/include/secure/_string.h"
__inline static void *__inline_memset_chk(void *__dest , int __val , size_t __len ) 
{ unsigned long tmp ;
  void *tmp___0 ;

  {
#line 83
  tmp = __builtin_object_size(__dest, 0);
#line 83
  tmp___0 = __builtin___memset_chk(__dest, __val, __len, tmp);
#line 83
  return (tmp___0);
}
}
#line 127 "/usr/include/secure/_string.h"
__inline static char *__inline_strncpy_chk(char *__dest , char const   *__src , size_t __len ) 
{ unsigned long tmp ;
  char *tmp___0 ;

  {
#line 131
  tmp = __builtin_object_size((void *)__dest, 1);
#line 131
  tmp___0 = __builtin___strncpy_chk(__dest, __src, __len, tmp);
#line 131
  return (tmp___0);
}
}
#line 605 "/usr/include/sys/socket.h"
extern int bind(int  , struct sockaddr  const  * , socklen_t  )  __asm__("_bind")  ;
#line 614
extern ssize_t recvfrom(int  , void * , size_t  , int  , struct sockaddr * , socklen_t * )  __asm__("_recvfrom")  ;
#line 619
extern ssize_t sendto(int  , void const   * , size_t  , int  , struct sockaddr  const  * ,
                      socklen_t  )  __asm__("_sendto")  ;
#line 624
extern int socket(int  , int  , int  ) ;
#line 29 "../dns/functions_dns.h"
int decompress_data(js_string *compressed , js_string *uncompressed ) ;
#line 37
int dlabel_length(js_string *raw , unsigned int offset ) ;
#line 43
int compress_data(js_string *in , js_string *out ) ;
#line 52
int hname_2rfc1035(js_string *hostname ) ;
#line 68
void init_header(q_header *header ) ;
#line 75
int make_hdr(q_header *header , js_string *js ) ;
#line 84
int bobbit_label(js_string *js ) ;
#line 91
int read_hdr(js_string *js , q_header *header ) ;
#line 141
int hname_translate(js_string *hostname , int qtype ) ;
#line 158
int decomp_init(int alog_level ) ;
#line 33 "../parse/functions_parse.h"
int read_mararc(js_string *fileloc , js_string *errorstr , int *errorret ) ;
#line 39
int find_mararc(js_string *out ) ;
#line 69
int make_ip_acl(js_string *in , ipv4pair *out , int max , int depth ) ;
#line 110
int ddip_2_ip(js_string *ddip , js_string *ip , int offset ) ;
#line 28 "../parse/Csv2_functions.h"
int fold_case(js_string *js ) ;
#line 222
int csv2_parse_zone_bighash(js_string *zone , js_string *filename , mhash *bighash___0 ,
                            int32_t starwhitis ) ;
#line 23 "functions_server.h"
int check_ipv4_acl(uint32_t ip , ipv4pair *list ) ;
#line 31
int check_recursive_acl(uint32_t ip ) ;
#line 37
void init_rr(rr *data ) ;
#line 46
int launch_thread(int id , int sock , struct sockaddr_in client , js_string *query ) ;
#line 62
int populate_main(mhash *maintable , js_string *error , int recursive ) ;
#line 71
int ddip_check(int id , int sock , conn *ect , js_string *query ) ;
#line 86
int change_rtype(js_string *js , int newtype ) ;
#line 138
int get_rtype(js_string *js ) ;
#line 145
int how_many_threads(void) ;
#line 153
int cache_elements(void) ;
#line 160
int set_min_ttl(int norm , int cname ) ;
#line 183
int init_cache(int max_cache_elements , int max_threads , int max_glueless , int max_q_total ,
               int timeout , int verbose_query_value ) ;
#line 192
int init_spammers(js_string *spam_list ) ;
#line 203
int init_rng(js_string *seedfile , int rekey ) ;
#line 210
int init_rlog_level(int verbose_level ) ;
#line 217
void debug_show_ip(uint32_t ip ) ;
#line 242
int starwhitis_seek_any(js_string *query , int rr_type , int found , q_header *head ,
                        rr **w , int *a , js_string *most , js_string *ns , js_string *ar ) ;
#line 264
void harderror(char *why ) ;
#line 270
int init_handle_noreply(int value___0 ) ;
#line 274
void log_lock(void) ;
#line 275
void log_unlock(void) ;
#line 285
int make_starlabel(js_string *js ) ;
#line 298
int bobbit_starlabel_end(js_string *js ) ;
#line 308
int bobbit_starlabel(js_string *js ) ;
#line 311
int init_retry_cycles(int in ) ;
#line 316
int set_upstream_port(int num ) ;
#line 320
int set_port_range(int a , int b ) ;
#line 328
uint32_t determine_ttl(int64_t expire , uint32_t ttl ) ;
#line 334
int mara_send(conn *ect , int sock , js_string *reply ) ;
#line 348
int udperror(int sock , js_string *raw , struct sockaddr_in *from , js_string *question ,
             int error , char *why , int min_log_level , int rd_val , conn *ect ,
             int log_msg ) ;
#line 367
int udpsuccess(rr *where , int id , int sock , struct sockaddr_in *client , js_string *query ,
               void **rotate_point , int show_cname_a , int rd_val , conn *ect , int force_authoritative ,
               int ra_value ) ;
#line 32 "timestamp.h"
int set_timestamp(int type ) ;
#line 40
int show_timestamp(void) ;
#line 30 "read_kvars.h"
int read_numeric_kvar(char *name , int default_value ) ;
#line 43
js_string *read_string_kvar(char *name ) ;
#line 76 "MaraDNS.c"
mhash *bighash  ;
#line 77 "MaraDNS.c"
int log_level  =    1;
#line 80 "MaraDNS.c"
int no_fingerprint  =    0;
#line 85 "MaraDNS.c"
int rrany_set  =    3;
#line 90 "MaraDNS.c"
int max_ar_chain  =    1;
#line 93 "MaraDNS.c"
int max_chain  =    8;
#line 95 "MaraDNS.c"
int max_total  =    20;
#line 96 "MaraDNS.c"
int debug_delay  =    0;
#line 98 "MaraDNS.c"
int default_zonefile_enabled  =    0;
#line 101 "MaraDNS.c"
int no_cname_warnings  =    0;
#line 103 "MaraDNS.c"
int min_visible_ttl  =    30;
#line 107 "MaraDNS.c"
rr *seenlist[256]  ;
#line 108 "MaraDNS.c"
int seenlist_where  =    0;
#line 110 "MaraDNS.c"
int total_count  =    0;
#line 112 "MaraDNS.c"
int debug_msg_level  =    1;
#line 114 "MaraDNS.c"
int reject_aaaa  =    0;
#line 117 "MaraDNS.c"
int reject_ptr  =    0;
#line 120 "MaraDNS.c"
rr *ra_data  =    (rr *)0;
#line 127 "MaraDNS.c"
int dos_protection_level  =    0;
#line 131 "MaraDNS.c"
int bind_star_handling  =    0;
#line 133 "MaraDNS.c"
int remote_admin  =    0;
#line 138 "MaraDNS.c"
int force_auth  =    1;
#line 142 "MaraDNS.c"
int dns_port  =    53;
#line 144 "MaraDNS.c"
int csv2_tilde_handling  =    2;
#line 146 "MaraDNS.c"
int recurse_delegation  =    0;
#line 149 "MaraDNS.c"
int dns_records_served  =    0;
#line 151 "MaraDNS.c"
js_string *notthere_ip  =    (js_string *)0;
#line 156 "MaraDNS.c"
int recursion_enabled  =    0;
#line 159 "MaraDNS.c"
ipv4pair recurse_acl[512]  ;
#line 162 "MaraDNS.c"
ipv4pair bind_addresses[512]  ;
#line 167 "MaraDNS.c"
ipv4pair csv2_synthip_list[512]  ;
#line 176 "MaraDNS.c"
ipv4pair admin_acl[512]  ;
#line 180 "MaraDNS.c"
js_string *synth_soa_origin  =    (js_string *)0;
#line 181 "MaraDNS.c"
int synth_soa_serial  =    1;
#line 183 "MaraDNS.c"
js_string *show_synth_soa_origin(void) 
{ 

  {
#line 184
  return (synth_soa_origin);
}
}
#line 186 "MaraDNS.c"
int show_synth_soa_serial(void) 
{ 

  {
#line 187
  return (synth_soa_serial);
}
}
#line 201 "MaraDNS.c"
void debug_show_ip(uint32_t ip ) 
{ 

  {
#line 202
  printf("%d.%d.%d.%d", (ip & 4278190080U) >> 24, (ip & 16711680U) >> 16, (ip & 65280U) >> 8,
         ip & 255U);
#line 206
  return;
}
}
#line 226 "MaraDNS.c"
void handle_sigpipe(void) 
{ 

  {
#line 227
  if (log_level > 1) {
#line 228
    log_lock();
#line 229
    printf("%s%s", "Caught SIGPIPE", "\n");
#line 230
    log_unlock();
  }
#line 232
  return;
}
}
#line 235 "MaraDNS.c"
int got_hup_signal  =    0;
#line 238 "MaraDNS.c"
void handle_hup(void) 
{ 

  {
#line 239
  got_hup_signal = 1;
#line 240
  return;
}
}
#line 244 "MaraDNS.c"
void handle_signal(void) 
{ 

  {
#line 245
  if (log_level > 1) {
#line 246
    log_lock();
#line 247
    printf("%s%s", "Caught Signal", "\n");
#line 248
    log_unlock();
  }
#line 250
  return;
}
}
#line 267 "MaraDNS.c"
int mlog(char *logmessage ) 
{ 

  {
#line 269
  if (log_level == 0) {
#line 270
    return (1);
  }
#line 272
  if ((unsigned long )logmessage == (unsigned long )((char *)0)) {
#line 273
    return (-1);
  }
#line 274
  log_lock();
#line 275
  show_timestamp();
#line 276
  printf("%s%s%s", " Log: ", logmessage, "\n");
#line 280
  fflush(__stdoutp);
#line 281
  log_unlock();
#line 283
  return (1);
}
}
#line 291 "MaraDNS.c"
int jlog(js_string *logmessage ) 
{ int ret ;

  {
#line 295
  if (log_level == 0) {
#line 296
    return (1);
  }
#line 298
  log_lock();
#line 299
  printf("%s", " Log: ");
#line 300
  ret = show_esc_stdout(logmessage);
#line 301
  printf("%s", "\n");
#line 304
  fflush(__stdoutp);
#line 305
  log_unlock();
#line 307
  return (ret);
}
}
#line 314 "MaraDNS.c"
int zjlog(char *left , js_string *right ) 
{ int ret ;

  {
#line 316
  if (log_level == 0) {
#line 317
    return (1);
  }
#line 318
  if ((unsigned long )left == (unsigned long )((char *)0)) {
#line 319
    return (-1);
  }
#line 320
  log_lock();
#line 321
  printf("%s%s", " Log: ", left);
#line 322
  ret = show_esc_stdout(right);
#line 323
  printf("%s", "\n");
#line 326
  fflush(__stdoutp);
#line 327
  log_unlock();
#line 329
  return (ret);
}
}
#line 337 "MaraDNS.c"
void harderror(char *why ) 
{ 

  {
#line 338
  printf("%s%s%s", "Fatal error: ", why, "\n");
#line 341
  fflush(__stdoutp);
#line 343
  exit(3);
}
}
#line 351 "MaraDNS.c"
void sys_harderror(char *why ) 
{ int *tmp ;
  char *tmp___0 ;

  {
#line 352
  printf("%s%s%s", "Fatal error: ", why, "\n");
#line 353
  tmp = __error();
#line 353
  tmp___0 = strerror(*tmp);
#line 353
  printf("%s: %s%s", "System said", tmp___0, "\n");
#line 359
  fflush(__stdoutp);
#line 361
  exit(3);
}
}
#line 369 "MaraDNS.c"
int calc_ra_value(int want_ra ) 
{ 

  {
#line 373
  if (recursion_enabled == 0) {
#line 374
    return (0);
  }
#line 376
  return (want_ra);
}
}
#line 395 "MaraDNS.c"
js_string *make_notthere_ip(js_string *ddip ) 
{ js_string *out ;
  js_string *ip ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 396
  out = (js_string *)0;
#line 397
  ip = (js_string *)0;
#line 398
  out = js_create(19U, 1U);
#line 399
  if ((unsigned long )out == (unsigned long )((js_string *)0)) {
#line 400
    return ((js_string *)0);
  }
#line 402
  ip = js_create(10U, 1U);
#line 403
  if ((unsigned long )ip == (unsigned long )((js_string *)0)) {
#line 404
    js_destroy(out);
#line 405
    return ((js_string *)0);
  }
#line 407
  tmp = js_adduint16(out, 49164);
#line 407
  if (tmp == -1) {
#line 413
    js_destroy(out);
#line 414
    js_destroy(ip);
#line 415
    return ((js_string *)0);
  } else {
#line 407
    tmp___0 = js_adduint16(out, 1);
#line 407
    if (tmp___0 == -1) {
#line 413
      js_destroy(out);
#line 414
      js_destroy(ip);
#line 415
      return ((js_string *)0);
    } else {
#line 407
      tmp___1 = js_adduint16(out, 1);
#line 407
      if (tmp___1 == -1) {
#line 413
        js_destroy(out);
#line 414
        js_destroy(ip);
#line 415
        return ((js_string *)0);
      } else {
#line 407
        tmp___2 = js_adduint16(out, 0);
#line 407
        if (tmp___2 == -1) {
#line 413
          js_destroy(out);
#line 414
          js_destroy(ip);
#line 415
          return ((js_string *)0);
        } else {
#line 407
          tmp___3 = js_adduint16(out, 0);
#line 407
          if (tmp___3 == -1) {
#line 413
            js_destroy(out);
#line 414
            js_destroy(ip);
#line 415
            return ((js_string *)0);
          } else {
#line 407
            tmp___4 = js_adduint16(out, 4);
#line 407
            if (tmp___4 == -1) {
#line 413
              js_destroy(out);
#line 414
              js_destroy(ip);
#line 415
              return ((js_string *)0);
            }
          }
        }
      }
    }
  }
#line 417
  tmp___5 = ddip_2_ip(ddip, ip, 0);
#line 417
  if (tmp___5 == -1) {
#line 418
    js_destroy(out);
#line 419
    js_destroy(ip);
#line 420
    return ((js_string *)0);
  }
#line 422
  tmp___6 = js_append(ip, out);
#line 422
  if (tmp___6 == -1) {
#line 423
    js_destroy(out);
#line 424
    js_destroy(ip);
#line 425
    return ((js_string *)0);
  }
#line 427
  js_destroy(ip);
#line 428
  return (out);
}
}
#line 437 "MaraDNS.c"
uint32_t determine_ttl(int64_t expire , uint32_t ttl ) 
{ int64_t now ;

  {
#line 440
  if (expire == 0LL) {
#line 441
    return (ttl);
  }
#line 443
  now = qual_get_time();
#line 447
  if (expire < now - 10LL) {
#line 448
    return ((uint32_t )29);
  }
#line 451
  if (expire - now > (int64_t )min_visible_ttl) {
#line 452
    return ((uint32_t )(expire - now));
  }
#line 454
  return ((uint32_t )min_visible_ttl);
}
}
#line 459 "MaraDNS.c"
int get_header_rd(js_string *query ) 
{ int tmp ;

  {
#line 460
  tmp = js_has_sanity(query);
#line 460
  if (tmp == -1) {
#line 461
    return (0);
  }
#line 463
  if (query->unit_size != 1U) {
#line 464
    return (0);
  }
#line 466
  if (query->unit_count < 3U) {
#line 467
    return (0);
  } else
#line 466
  if (query->max_count < 3U) {
#line 467
    return (0);
  }
#line 469
  return ((int )*(query->string + 2) & 1);
}
}
#line 476 "MaraDNS.c"
int mara_send(conn *ect , int sock , js_string *reply ) 
{ 

  {
#line 477
  if ((unsigned long )ect == (unsigned long )((conn *)0)) {
#line 478
    return (-1);
  } else
#line 477
  if ((unsigned long )reply == (unsigned long )((js_string *)0)) {
#line 478
    return (-1);
  }
#line 480
  if ((int )ect->type == 4) {
#line 481
    sendto(sock, (void const   *)reply->string, (size_t )reply->unit_count, 0, (struct sockaddr  const  *)((struct sockaddr *)ect->d),
           (socklen_t )ect->addrlen);
#line 483
    return (1);
  } else {
#line 494
    return (-1);
  }
}
}
#line 510 "MaraDNS.c"
int udperror(int sock , js_string *raw , struct sockaddr_in *from , js_string *question ,
             int error , char *why , int min_log_level , int rd_val , conn *ect ,
             int log_msg ) 
{ q_header header ;
  js_string *reply ;
  int len_inet ;
  struct sockaddr_in *clin ;
  __uint32_t tmp ;
  __uint32_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 516
  len_inet = (int )sizeof(struct sockaddr );
#line 518
  if (log_level >= min_log_level) {
#line 518
    if (log_msg == 1) {
#line 519
      show_timestamp();
#line 520
      zjlog((char *)"Bad query received: ", raw);
#line 521
      if ((unsigned long )ect != (unsigned long )((conn *)0)) {
#line 521
        if ((int )ect->type == 4) {
#line 522
          clin = (struct sockaddr_in *)0;
#line 523
          clin = (struct sockaddr_in *)ect->d;
#line 524
          printf("From IP: ");
#line 525
          tmp = _OSSwapInt32(clin->sin_addr.s_addr);
#line 525
          debug_show_ip(tmp);
#line 526
          printf("\n");
        } else {
#line 521
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 528
      if ((unsigned long )from != (unsigned long )((struct sockaddr_in *)0)) {
#line 529
        printf("From IP: ");
#line 530
        tmp___0 = _OSSwapInt32(from->sin_addr.s_addr);
#line 530
        debug_show_ip(tmp___0);
#line 531
        printf("\n");
      }
    }
  }
#line 534
  if (log_level >= 2) {
#line 535
    mlog(why);
  }
#line 537
  if (raw->unit_count < 2U) {
#line 538
    return (-1);
  } else
#line 537
  if (raw->max_count < 3U) {
#line 538
    return (-1);
  }
#line 540
  reply = js_create(96U, 1U);
#line 540
  if ((unsigned long )reply == (unsigned long )((js_string *)0)) {
#line 541
    return (-1);
  }
#line 544
  header.id = (uint16_t )((((int )*(raw->string) & 255) << 8) | ((int )*(raw->string + 1) & 255));
#line 545
  header.qr = 1;
#line 546
  header.opcode = 0;
#line 547
  header.aa = 0;
#line 549
  header.tc = 0;
#line 550
  header.rd = rd_val;
#line 551
  header.ra = 0;
#line 552
  header.z = 0;
#line 553
  header.rcode = error;
#line 554
  if ((unsigned long )question == (unsigned long )((js_string *)0)) {
#line 555
    header.qdcount = (uint16_t )0;
  } else {
#line 557
    header.qdcount = (uint16_t )1;
  }
#line 558
  header.ancount = (uint16_t )0;
#line 559
  header.nscount = (uint16_t )0;
#line 560
  header.arcount = (uint16_t )0;
#line 563
  tmp___1 = make_hdr(& header, reply);
#line 563
  if (tmp___1 == -1) {
#line 564
    js_destroy(reply);
#line 565
    return (-1);
  }
#line 569
  if ((unsigned long )question != (unsigned long )((js_string *)0)) {
#line 570
    tmp___2 = js_append(question, reply);
#line 570
    if (tmp___2 == -1) {
#line 571
      js_destroy(reply);
#line 572
      return (-1);
    }
#line 574
    tmp___3 = js_adduint16(reply, 1);
#line 574
    if (tmp___3 == -1) {
#line 575
      js_destroy(reply);
#line 576
      return (-1);
    }
  }
#line 581
  if ((unsigned long )ect == (unsigned long )((conn *)0)) {
#line 582
    sendto(sock, (void const   *)reply->string, (size_t )reply->unit_count, 0, (struct sockaddr  const  *)((struct sockaddr *)from),
           (socklen_t )len_inet);
  } else {
#line 585
    mara_send(ect, sock, reply);
  }
#line 587
  js_destroy(reply);
#line 588
  return (1);
}
}
#line 609 "MaraDNS.c"
int add_answer(rr *where , js_string *most , js_string *ns , js_string *ar , uint16_t *ancount ,
               uint16_t *nscount , uint16_t *arcount , int add_ns , void **rotate_point ,
               js_string *starwhitis , unsigned char max_answers ) 
{ uint16_t first_rr_type ;
  rr *ipwhere ;
  int in_ns ;
  int a_count ;
  int ar_count ;
  int rotate_done ;
  rr *rotate_1st ;
  rr *rotate_2nd ;
  rr *rotate_last ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  uint32_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  uint32_t tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  uint32_t tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;

  {
#line 615
  ipwhere = (rr *)0;
#line 616
  in_ns = 0;
#line 617
  a_count = 0;
#line 618
  ar_count = 0;
#line 620
  rotate_done = 0;
#line 623
  rotate_1st = (rr *)0;
#line 623
  rotate_2nd = (rr *)0;
#line 623
  rotate_last = (rr *)0;
#line 626
  if ((unsigned long )where == (unsigned long )((rr *)0)) {
#line 627
    goto giveerror;
  }
#line 629
  if ((unsigned long )where->query == (unsigned long )((js_string *)0)) {
#line 630
    goto giveerror;
  }
#line 632
  tmp = js_has_sanity(where->query);
#line 632
  if (tmp == -1) {
#line 633
    goto giveerror;
  }
#line 635
  if ((unsigned long )where->data == (unsigned long )((js_string *)0)) {
#line 636
    goto giveerror;
  }
#line 638
  tmp___0 = js_has_sanity(where->data);
#line 638
  if (tmp___0 == -1) {
#line 639
    goto giveerror;
  }
#line 641
  if ((unsigned long )starwhitis != (unsigned long )((js_string *)0)) {
#line 641
    tmp___1 = js_has_sanity(starwhitis);
#line 641
    if (tmp___1 == -1) {
#line 642
      goto giveerror;
    }
  }
#line 644
  tmp___2 = get_rtype(where->query);
#line 644
  first_rr_type = (uint16_t )tmp___2;
#line 648
  if ((where->data)->unit_count < 0U) {
#line 649
    goto giveerror;
  } else
#line 648
  if ((where->data)->unit_count > 65535U) {
#line 649
    goto giveerror;
  }
#line 653
  rotate_1st = where;
#line 654
  rotate_2nd = where->next;
#line 656
  if ((unsigned long )rotate_2nd != (unsigned long )((rr *)0)) {
#line 656
    if ((int )first_rr_type != 2) {
#line 656
      if ((int )rotate_2nd->rr_type == 2) {
#line 658
        rotate_2nd = (rr *)0;
      }
    }
  }
#line 661
  while ((unsigned long )where != (unsigned long )((rr *)0)) {
#line 663
    if ((int )first_rr_type != 2) {
#line 663
      if ((int )where->rr_type == 2) {
#line 663
        if ((int )max_answers == 0) {
#line 670
          if ((unsigned long )rotate_2nd != (unsigned long )((rr *)0)) {
#line 670
            if (max_ar_chain == 1) {
#line 670
              if (rotate_done == 0) {
#line 670
                if ((int )first_rr_type != 2) {
#line 672
                  rotate_done = 1;
#line 674
                  rotate_1st->next = where;
#line 675
                  rotate_last->next = rotate_1st;
#line 676
                  *rotate_point = (void *)rotate_2nd;
                }
              }
            }
          }
#line 679
          a_count = 0;
#line 684
          if (add_ns == 1) {
#line 685
            in_ns = 1;
          } else {
#line 687
            return (1);
          }
        }
      }
    }
#line 690
    if (! in_ns) {
#line 690
      if (a_count < max_chain) {
#line 690
        if (total_count < max_total) {
#line 691
          a_count ++;
#line 693
          total_count ++;
#line 696
          if ((int )where->rr_type == 2) {
#line 696
            if ((int )first_rr_type != 2) {
#line 696
              if ((int )max_answers != 0) {
#line 698
                in_ns = 1;
#line 699
                goto max_answers_skip;
              }
            }
          }
#line 701
          *ancount = (uint16_t )((int )*ancount + 1);
#line 703
          if ((unsigned long )starwhitis == (unsigned long )((js_string *)0)) {
#line 703
            tmp___4 = js_append(where->query, most);
#line 703
            if (tmp___4 == -1) {
#line 705
              goto giveerror;
            } else {
#line 703
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 707
          if ((unsigned long )starwhitis != (unsigned long )((js_string *)0)) {
#line 707
            tmp___3 = js_append(starwhitis, most);
#line 707
            if (tmp___3 == -1) {
#line 709
              goto giveerror;
            }
          }
#line 712
          tmp___5 = js_adduint16(most, 1);
#line 712
          if (tmp___5 == -1) {
#line 713
            goto giveerror;
          }
#line 716
          tmp___6 = determine_ttl(where->expire, where->ttl);
#line 716
          tmp___7 = js_adduint32(most, tmp___6);
#line 716
          if (tmp___7 == -1) {
#line 718
            goto giveerror;
          }
#line 721
          tmp___8 = js_adduint16(most, (int )(where->data)->unit_count);
#line 721
          if (tmp___8 == -1) {
#line 722
            goto giveerror;
          }
#line 725
          tmp___9 = js_append(where->data, most);
#line 725
          if (tmp___9 == -1) {
#line 726
            goto giveerror;
          }
          max_answers_skip: 
#line 729
          if ((int )max_answers == 1) {
#line 730
            return (1);
          }
        } else {
#line 690
          goto _L___1;
        }
      } else {
#line 690
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 733
    if (a_count < max_chain) {
#line 733
      if (total_count < max_total) {
#line 733
        if ((int )max_answers == 0) {
#line 735
          a_count ++;
#line 735
          total_count ++;
#line 739
          tmp___10 = js_append(where->query, ns);
#line 739
          if (tmp___10 == -1) {
#line 740
            goto giveerror;
          }
#line 743
          tmp___11 = js_adduint16(ns, 1);
#line 743
          if (tmp___11 == -1) {
#line 744
            goto giveerror;
          }
#line 747
          tmp___12 = determine_ttl(where->expire, where->ttl);
#line 747
          tmp___13 = js_adduint32(ns, tmp___12);
#line 747
          if (tmp___13 == -1) {
#line 749
            goto giveerror;
          }
#line 752
          tmp___14 = js_adduint16(ns, (int )(where->data)->unit_count);
#line 752
          if (tmp___14 == -1) {
#line 753
            goto giveerror;
          }
#line 756
          tmp___15 = js_append(where->data, ns);
#line 756
          if (tmp___15 == -1) {
#line 757
            goto giveerror;
          }
#line 759
          *nscount = (uint16_t )((int )*nscount + 1);
        }
      }
    }
#line 763
    if ((unsigned long )where->ip != (unsigned long )((struct rr *)0)) {
#line 763
      if ((int )where->rr_type != 5) {
#line 763
        if ((int )max_answers == 0) {
#line 764
          ipwhere = where->ip;
#line 765
          ar_count = 0;
#line 767
          while (1) {
#line 767
            if ((unsigned long )ipwhere != (unsigned long )((rr *)0)) {
#line 767
              if ((int )ipwhere->rr_type != 2) {
#line 767
                if (ar_count < max_ar_chain) {
#line 767
                  if (! (total_count < max_total)) {
#line 767
                    break;
                  }
                } else {
#line 767
                  break;
                }
              } else {
#line 767
                break;
              }
            } else {
#line 767
              break;
            }
#line 769
            ar_count ++;
#line 771
            total_count ++;
#line 773
            if ((int )ipwhere->seen == 1) {
#line 776
              ipwhere = ipwhere->next;
#line 777
              continue;
            }
#line 780
            *arcount = (uint16_t )((int )*arcount + 1);
#line 782
            tmp___16 = js_append(ipwhere->query, ar);
#line 782
            if (tmp___16 == -1) {
#line 783
              goto giveerror;
            }
#line 786
            tmp___17 = js_adduint16(ar, 1);
#line 786
            if (tmp___17 == -1) {
#line 787
              goto giveerror;
            }
#line 790
            tmp___18 = determine_ttl(ipwhere->expire, ipwhere->ttl);
#line 790
            tmp___19 = js_adduint32(ar, tmp___18);
#line 790
            if (tmp___19 == -1) {
#line 792
              goto giveerror;
            }
#line 795
            tmp___20 = js_adduint16(ar, (int )(ipwhere->data)->unit_count);
#line 795
            if (tmp___20 == -1) {
#line 796
              goto giveerror;
            }
#line 799
            tmp___21 = js_append(ipwhere->data, ar);
#line 799
            if (tmp___21 == -1) {
#line 800
              goto giveerror;
            }
#line 803
            if (seenlist_where < 250) {
#line 804
              ipwhere->seen = (char)1;
#line 805
              seenlist[seenlist_where] = ipwhere;
#line 806
              seenlist_where ++;
            }
#line 808
            ipwhere = ipwhere->next;
          }
        }
      }
    }
#line 815
    rotate_last = where;
#line 817
    where = where->next;
  }
#line 820
  return (1);
  giveerror: 
#line 824
  return (-1);
}
}
#line 855 "MaraDNS.c"
int udpany(int id , int sock , struct sockaddr_in *client , js_string *query , int rr_set ,
           mhash *bighash___0 , int rd_val , conn *ect , int called_from_recursive ,
           js_string *origq ) 
{ js_string *most ;
  js_string *ns ;
  js_string *ar ;
  js_string *starwhitis ;
  int length_save ;
  int len_inet ;
  int found ;
  int authoritative ;
  rr *where ;
  rr_list *answer ;
  mhash_e spot_data ;
  int counter ;
  q_header header ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int rtype_save ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int labels ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;

  {
#line 863
  len_inet = (int )sizeof(struct sockaddr );
#line 864
  found = 0;
#line 865
  authoritative = 1;
#line 866
  where = (rr *)0;
#line 867
  answer = (rr_list *)0;
#line 873
  most = js_create(1024U, 1U);
#line 873
  if ((unsigned long )most == (unsigned long )((js_string *)0)) {
#line 874
    return (-1);
  }
#line 875
  ar = js_create(1024U, 1U);
#line 875
  if ((unsigned long )ar == (unsigned long )((js_string *)0)) {
#line 876
    js_destroy(most);
#line 877
    return (-1);
  }
#line 879
  ns = js_create(1024U, 1U);
#line 879
  if ((unsigned long )ns == (unsigned long )((js_string *)0)) {
#line 880
    js_destroy(most);
#line 880
    js_destroy(ar);
#line 881
    return (-1);
  }
#line 885
  total_count = 0;
#line 888
  header.id = (uint16_t )id;
#line 889
  header.rd = rd_val;
#line 890
  tmp = make_hdr(& header, most);
#line 890
  if (tmp == -1) {
#line 891
    goto giveerror;
  }
#line 894
  if ((unsigned long )origq == (unsigned long )((js_string *)0)) {
#line 895
    tmp___0 = js_append(query, most);
#line 895
    if (tmp___0 == -1) {
#line 896
      goto giveerror;
    }
  } else {
#line 899
    tmp___1 = js_append(origq, most);
#line 899
    if (tmp___1 == -1) {
#line 900
      goto giveerror;
    }
  }
#line 904
  tmp___2 = js_adduint16(most, 1);
#line 904
  if (tmp___2 == -1) {
#line 905
    goto giveerror;
  }
#line 909
  header.ancount = (uint16_t )0;
#line 910
  header.nscount = (uint16_t )0;
#line 911
  header.arcount = (uint16_t )0;
#line 913
  if (called_from_recursive == 1) {
#line 914
    goto use_old_udpany_code;
  }
#line 919
  spot_data = mhash_get(bighash___0, query);
#line 921
  if ((unsigned long )spot_data.value != (unsigned long )((void *)0)) {
#line 921
    if (spot_data.datatype == 6) {
#line 922
      answer = (rr_list *)spot_data.value;
#line 923
      counter = 0;
#line 923
      while (counter < 100) {
#line 924
        tmp___3 = add_answer(answer->data, most, ns, ar, & header.ancount, & header.nscount,
                             & header.arcount, 1, spot_data.point, (js_string *)0,
                             (unsigned char)2);
#line 924
        if (tmp___3 == -1) {
#line 927
          goto giveerror;
        }
#line 929
        if ((int )answer->rr_type != 2) {
#line 930
          found = 1;
        }
#line 932
        answer = answer->next;
#line 933
        if ((unsigned long )answer == (unsigned long )((rr_list *)0)) {
#line 934
          break;
        }
#line 923
        counter ++;
      }
#line 936
      goto old_udpany_code_disabled;
    }
  }
#line 940
  starwhitis = js_create(256U, 1U);
#line 940
  if ((unsigned long )starwhitis == (unsigned long )((js_string *)0)) {
#line 941
    goto giveerror;
  }
#line 943
  tmp___4 = js_copy(query, starwhitis);
#line 943
  if (tmp___4 == -1) {
#line 944
    js_destroy(starwhitis);
#line 945
    goto giveerror;
  }
#line 947
  tmp___5 = make_starlabel(starwhitis);
#line 947
  if (tmp___5 == -1) {
#line 948
    js_destroy(starwhitis);
#line 949
    goto giveerror;
  }
#line 952
  spot_data = mhash_get(bighash___0, starwhitis);
#line 953
  if ((unsigned long )spot_data.value != (unsigned long )((void *)0)) {
#line 953
    if (spot_data.datatype == 6) {
      starwhitis_any_found: 
#line 956
      answer = (rr_list *)spot_data.value;
#line 957
      found = 1;
#line 958
      counter = 0;
#line 958
      while (counter < 100) {
#line 959
        rtype_save = get_rtype(query);
#line 960
        tmp___6 = change_rtype(query, (int )(answer->data)->rr_type);
#line 960
        if (tmp___6 == -1) {
#line 961
          js_destroy(starwhitis);
#line 962
          goto giveerror;
        }
#line 964
        tmp___7 = add_answer(answer->data, most, ns, ar, & header.ancount, & header.nscount,
                             & header.arcount, 1, spot_data.point, query, (unsigned char)2);
#line 964
        if (tmp___7 == -1) {
#line 967
          js_destroy(starwhitis);
#line 968
          goto giveerror;
        }
#line 970
        answer = answer->next;
#line 971
        if ((unsigned long )answer == (unsigned long )((rr_list *)0)) {
#line 972
          break;
        }
#line 958
        counter ++;
      }
#line 974
      tmp___8 = change_rtype(query, rtype_save);
#line 974
      if (tmp___8 == -1) {
#line 975
        js_destroy(starwhitis);
#line 976
        goto giveerror;
      }
#line 978
      js_destroy(starwhitis);
#line 979
      goto old_udpany_code_disabled;
    }
  }
#line 982
  counter = 0;
#line 983
  while (1) {
#line 983
    tmp___9 = bobbit_starlabel(starwhitis);
#line 983
    if (! (tmp___9 == 1)) {
#line 983
      break;
    }
#line 984
    spot_data = mhash_get(bighash___0, starwhitis);
#line 985
    if ((unsigned long )spot_data.value != (unsigned long )((void *)0)) {
#line 985
      if (spot_data.datatype == 6) {
#line 986
        goto starwhitis_any_found;
      }
    }
#line 988
    counter ++;
#line 989
    if (counter > 100) {
#line 990
      break;
    }
  }
#line 995
  if (default_zonefile_enabled == 1) {
#line 999
    tmp___10 = js_copy(query, starwhitis);
#line 999
    if (tmp___10 == -1) {
#line 1000
      js_destroy(starwhitis);
#line 1001
      goto giveerror;
    }
#line 1003
    counter = 0;
#line 1004
    while (1) {
#line 1004
      labels = bobbit_starlabel_end(starwhitis);
#line 1004
      if (! (labels > 0)) {
#line 1004
        break;
      }
#line 1006
      if (labels > 120) {
#line 1007
        continue;
      }
#line 1009
      spot_data = mhash_get(bighash___0, starwhitis);
#line 1010
      if ((unsigned long )spot_data.value != (unsigned long )((void *)0)) {
#line 1010
        if (spot_data.datatype == 6) {
#line 1011
          goto starwhitis_any_found;
        }
      }
#line 1013
      counter ++;
#line 1014
      if (counter > 120) {
#line 1015
        break;
      }
    }
  }
#line 1020
  js_destroy(starwhitis);
#line 1021
  goto old_udpany_code_disabled;
  use_old_udpany_code: 
#line 1029
  tmp___11 = change_rtype(query, 1);
#line 1029
  if (tmp___11 == -1) {
#line 1030
    goto giveerror;
  }
#line 1031
  spot_data = mhash_get(bighash___0, query);
#line 1033
  if ((unsigned long )spot_data.value != (unsigned long )((void *)0)) {
#line 1033
    if (spot_data.datatype == 3) {
#line 1034
      found = 1;
#line 1035
      where = (rr *)spot_data.value;
#line 1036
      authoritative = (int )where->authoritative;
#line 1037
      tmp___12 = add_answer((rr *)spot_data.value, most, ns, ar, & header.ancount,
                            & header.nscount, & header.arcount, 1, spot_data.point,
                            (js_string *)0, (unsigned char)0);
#line 1037
      if (tmp___12 == -1) {
#line 1040
        goto giveerror;
      }
    }
  }
#line 1043
  tmp___13 = change_rtype(query, 15);
#line 1043
  if (tmp___13 == -1) {
#line 1044
    goto giveerror;
  }
#line 1045
  spot_data = mhash_get(bighash___0, query);
#line 1046
  if ((unsigned long )spot_data.value != (unsigned long )((void *)0)) {
#line 1046
    if (spot_data.datatype == 3) {
#line 1047
      if (found == 1) {
#line 1048
        tmp___14 = add_answer((rr *)spot_data.value, most, ns, ar, & header.ancount,
                              & header.nscount, & header.arcount, 0, spot_data.point,
                              (js_string *)0, (unsigned char)0);
#line 1048
        if (tmp___14 == -1) {
#line 1051
          goto giveerror;
        }
      } else {
#line 1054
        where = (rr *)spot_data.value;
#line 1055
        authoritative = (int )where->authoritative;
#line 1056
        tmp___15 = add_answer((rr *)spot_data.value, most, ns, ar, & header.ancount,
                              & header.nscount, & header.arcount, 1, spot_data.point,
                              (js_string *)0, (unsigned char)0);
#line 1056
        if (tmp___15 == -1) {
#line 1059
          goto giveerror;
        }
      }
#line 1061
      found = 1;
    }
  }
#line 1065
  if (rr_set == 15) {
#line 1067
    tmp___16 = change_rtype(query, 2);
#line 1067
    if (tmp___16 == -1) {
#line 1068
      goto giveerror;
    }
#line 1069
    spot_data = mhash_get(bighash___0, query);
#line 1070
    if ((unsigned long )spot_data.value != (unsigned long )((void *)0)) {
#line 1070
      if (spot_data.datatype == 3) {
#line 1071
        if (found == 1) {
#line 1072
          tmp___17 = add_answer((rr *)spot_data.value, most, ns, ar, & header.ancount,
                                & header.nscount, & header.arcount, 0, spot_data.point,
                                (js_string *)0, (unsigned char)0);
#line 1072
          if (tmp___17 == -1) {
#line 1075
            goto giveerror;
          }
        } else {
#line 1078
          where = (rr *)spot_data.value;
#line 1079
          authoritative = (int )where->authoritative;
#line 1080
          tmp___18 = add_answer((rr *)spot_data.value, most, ns, ar, & header.ancount,
                                & header.nscount, & header.arcount, 1, spot_data.point,
                                (js_string *)0, (unsigned char)0);
#line 1080
          if (tmp___18 == -1) {
#line 1083
            goto giveerror;
          }
        }
#line 1085
        found = 1;
      }
    }
#line 1088
    tmp___19 = change_rtype(query, 6);
#line 1088
    if (tmp___19 == -1) {
#line 1089
      goto giveerror;
    }
#line 1090
    spot_data = mhash_get(bighash___0, query);
#line 1091
    if ((unsigned long )spot_data.value != (unsigned long )((void *)0)) {
#line 1091
      if (spot_data.datatype == 3) {
#line 1092
        if (found == 1) {
#line 1093
          tmp___20 = add_answer((rr *)spot_data.value, most, ns, ar, & header.ancount,
                                & header.nscount, & header.arcount, 0, spot_data.point,
                                (js_string *)0, (unsigned char)0);
#line 1093
          if (tmp___20 == -1) {
#line 1096
            goto giveerror;
          }
        } else {
#line 1099
          where = (rr *)spot_data.value;
#line 1100
          authoritative = (int )where->authoritative;
#line 1101
          tmp___21 = add_answer((rr *)spot_data.value, most, ns, ar, & header.ancount,
                                & header.nscount, & header.arcount, 1, spot_data.point,
                                (js_string *)0, (unsigned char)0);
#line 1101
          if (tmp___21 == -1) {
#line 1104
            goto giveerror;
          }
        }
#line 1106
        found = 1;
      }
    }
  }
#line 1111
  if (found != 1) {
#line 1112
    found = fold_case(query);
#line 1113
    if (found == -1) {
#line 1114
      goto giveerror;
    }
#line 1115
    if (found == 1) {
#line 1116
      found = 0;
#line 1118
      tmp___22 = change_rtype(query, 1);
#line 1118
      if (tmp___22 == -1) {
#line 1119
        goto giveerror;
      }
#line 1120
      spot_data = mhash_get(bighash___0, query);
#line 1122
      if ((unsigned long )spot_data.value != (unsigned long )((void *)0)) {
#line 1122
        if (spot_data.datatype == 3) {
#line 1123
          found = 1;
#line 1124
          where = (rr *)spot_data.value;
#line 1125
          authoritative = (int )where->authoritative;
#line 1126
          tmp___23 = add_answer((rr *)spot_data.value, most, ns, ar, & header.ancount,
                                & header.nscount, & header.arcount, 1, spot_data.point,
                                (js_string *)0, (unsigned char)0);
#line 1126
          if (tmp___23 == -1) {
#line 1129
            goto giveerror;
          }
        }
      }
#line 1131
      tmp___24 = change_rtype(query, 15);
#line 1131
      if (tmp___24 == -1) {
#line 1132
        goto giveerror;
      }
#line 1133
      spot_data = mhash_get(bighash___0, query);
#line 1135
      if ((unsigned long )spot_data.value != (unsigned long )((void *)0)) {
#line 1135
        if (spot_data.datatype == 3) {
#line 1136
          if (found == 1) {
#line 1137
            tmp___25 = add_answer((rr *)spot_data.value, most, ns, ar, & header.ancount,
                                  & header.nscount, & header.arcount, 0, spot_data.point,
                                  (js_string *)0, (unsigned char)0);
#line 1137
            if (tmp___25 == -1) {
#line 1140
              goto giveerror;
            }
          } else {
#line 1143
            where = (rr *)spot_data.value;
#line 1144
            authoritative = (int )where->authoritative;
#line 1145
            tmp___26 = add_answer((rr *)spot_data.value, most, ns, ar, & header.ancount,
                                  & header.nscount, & header.arcount, 1, spot_data.point,
                                  (js_string *)0, (unsigned char)0);
#line 1145
            if (tmp___26 == -1) {
#line 1148
              goto giveerror;
            }
          }
        }
      }
#line 1152
      if (rr_set == 15) {
#line 1153
        tmp___27 = change_rtype(query, 2);
#line 1153
        if (tmp___27 == -1) {
#line 1154
          goto giveerror;
        }
#line 1155
        spot_data = mhash_get(bighash___0, query);
#line 1157
        if ((unsigned long )spot_data.value != (unsigned long )((void *)0)) {
#line 1157
          if (spot_data.datatype == 3) {
#line 1158
            if (found == 1) {
#line 1159
              tmp___28 = add_answer((rr *)spot_data.value, most, ns, ar, & header.ancount,
                                    & header.nscount, & header.arcount, 0, spot_data.point,
                                    (js_string *)0, (unsigned char)0);
#line 1159
              if (tmp___28 == -1) {
#line 1162
                goto giveerror;
              }
            } else {
#line 1165
              where = (rr *)spot_data.value;
#line 1166
              authoritative = (int )where->authoritative;
#line 1167
              tmp___29 = add_answer((rr *)spot_data.value, most, ns, ar, & header.ancount,
                                    & header.nscount, & header.arcount, 1, spot_data.point,
                                    (js_string *)0, (unsigned char)0);
#line 1167
              if (tmp___29 == -1) {
#line 1170
                goto giveerror;
              }
            }
          }
        }
#line 1173
        tmp___30 = change_rtype(query, 6);
#line 1173
        if (tmp___30 == -1) {
#line 1174
          goto giveerror;
        }
#line 1175
        spot_data = mhash_get(bighash___0, query);
#line 1177
        if ((unsigned long )spot_data.value != (unsigned long )((void *)0)) {
#line 1177
          if (spot_data.datatype == 3) {
#line 1178
            if (found == 1) {
#line 1179
              tmp___31 = add_answer((rr *)spot_data.value, most, ns, ar, & header.ancount,
                                    & header.nscount, & header.arcount, 0, spot_data.point,
                                    (js_string *)0, (unsigned char)0);
#line 1179
              if (tmp___31 == -1) {
#line 1182
                goto giveerror;
              }
            } else {
#line 1185
              where = (rr *)spot_data.value;
#line 1186
              authoritative = (int )where->authoritative;
#line 1187
              tmp___32 = add_answer((rr *)spot_data.value, most, ns, ar, & header.ancount,
                                    & header.nscount, & header.arcount, 1, spot_data.point,
                                    (js_string *)0, (unsigned char)0);
#line 1187
              if (tmp___32 == -1) {
#line 1190
                goto giveerror;
              }
            }
          }
        }
      }
    }
#line 1195
    if (found == 0) {
#line 1196
      found = starwhitis_seek_any(query, 1, 0, & header, & where, & authoritative,
                                  most, ns, ar);
#line 1198
      found = starwhitis_seek_any(query, 15, found, & header, & where, & authoritative,
                                  most, ns, ar);
#line 1200
      if (rr_set == 15) {
#line 1201
        found = starwhitis_seek_any(query, 2, found, & header, & where, & authoritative,
                                    most, ns, ar);
#line 1204
        found = starwhitis_seek_any(query, 6, found, & header, & where, & authoritative,
                                    most, ns, ar);
      }
#line 1208
      if (found == -1) {
#line 1209
        goto giveerror;
      }
    }
  }
#line 1216
  if (found == 0) {
#line 1217
    tmp___33 = change_rtype(query, 5);
#line 1217
    if (tmp___33 == -1) {
#line 1218
      goto giveerror;
    }
#line 1219
    spot_data = mhash_get(bighash___0, query);
#line 1221
    if ((unsigned long )spot_data.value != (unsigned long )((void *)0)) {
#line 1221
      if (spot_data.datatype == 3) {
#line 1222
        found = 1;
#line 1223
        tmp___34 = add_answer((rr *)spot_data.value, most, ns, ar, & header.ancount,
                              & header.nscount, & header.arcount, 1, spot_data.point,
                              (js_string *)0, (unsigned char)0);
#line 1223
        if (tmp___34 == -1) {
#line 1226
          goto giveerror;
        }
      }
    }
  }
#line 1231
  if (found == 0) {
#line 1232
    tmp___35 = change_rtype(query, 255);
#line 1232
    if (tmp___35 == -1) {
#line 1233
      goto giveerror;
    }
#line 1234
    found = ddip_check(id, sock, ect, query);
#line 1235
    if (found == -1) {
#line 1236
      goto giveerror;
    }
#line 1237
    if (found == 1) {
#line 1238
      js_destroy(ar);
#line 1239
      js_destroy(ns);
#line 1240
      js_destroy(most);
#line 1241
      return (1);
    }
  }
  old_udpany_code_disabled: 
#line 1248
  if ((int )header.ancount == 0) {
#line 1249
    js_destroy(ar);
#line 1250
    js_destroy(ns);
#line 1251
    js_destroy(most);
#line 1252
    return (0);
  } else
#line 1248
  if (found == 0) {
#line 1249
    js_destroy(ar);
#line 1250
    js_destroy(ns);
#line 1251
    js_destroy(most);
#line 1252
    return (0);
  }
#line 1257
  header.qr = 1;
#line 1258
  header.opcode = 0;
#line 1259
  header.tc = 0;
#line 1260
  header.rd = rd_val;
#line 1261
  header.ra = 0;
#line 1262
  header.aa = authoritative;
#line 1263
  header.z = 0;
#line 1264
  header.rcode = 0;
#line 1265
  header.qdcount = (uint16_t )1;
#line 1269
  length_save = (int )most->unit_count;
#line 1270
  make_hdr(& header, most);
#line 1271
  most->unit_count = (unsigned int )length_save;
#line 1274
  tmp___36 = js_append(ns, most);
#line 1274
  if (tmp___36 == -1) {
#line 1275
    goto giveerror;
  }
#line 1277
  tmp___37 = js_append(ar, most);
#line 1277
  if (tmp___37 == -1) {
#line 1278
    goto giveerror;
  }
#line 1282
  tmp___38 = compress_data(most, ar);
#line 1282
  if (tmp___38 == -1) {
#line 1283
    js_destroy(ar);
#line 1284
    js_destroy(ns);
#line 1285
    udperror(sock, most, client, (js_string *)0, 2, (char *)"compression failure",
             2, rd_val, ect, 1);
#line 1287
    js_destroy(most);
#line 1288
    return (-1);
  }
#line 1292
  if (ar->unit_count > 512U) {
#line 1295
    header.tc = 1;
#line 1296
    make_hdr(& header, ar);
  }
#line 1300
  if ((unsigned long )ect == (unsigned long )((conn *)0)) {
#line 1301
    sendto(sock, (void const   *)ar->string, (size_t )ar->unit_count, 0, (struct sockaddr  const  *)((struct sockaddr *)client),
           (socklen_t )len_inet);
  } else {
#line 1304
    mara_send(ect, sock, ar);
  }
#line 1307
  js_destroy(ar);
#line 1308
  js_destroy(ns);
#line 1309
  js_destroy(most);
#line 1312
  while (seenlist_where > 0) {
#line 1313
    seenlist_where --;
#line 1314
    if ((unsigned long )seenlist[seenlist_where] != (unsigned long )((rr *)0)) {
#line 1315
      (seenlist[seenlist_where])->seen = (char)0;
    }
  }
#line 1319
  return (1);
  giveerror: 
#line 1323
  js_destroy(ar);
#line 1324
  js_destroy(ns);
#line 1325
  udperror(sock, most, client, (js_string *)0, 2, (char *)"giveerror in udpany", 2,
           rd_val, ect, 1);
#line 1327
  js_destroy(most);
#line 1331
  while (seenlist_where > 0) {
#line 1332
    seenlist_where --;
#line 1333
    if ((unsigned long )seenlist[seenlist_where] != (unsigned long )((rr *)0)) {
#line 1334
      (seenlist[seenlist_where])->seen = (char)0;
    }
  }
#line 1337
  return (-1);
}
}
#line 1352 "MaraDNS.c"
int easter_egg(int id , int sock , conn *ect , js_string *query , char *hname , uint16_t type ,
               char *opt1 , char *opt2 ) 
{ js_string *reply ;
  js_string *hname_js ;
  js_string *data ;
  q_header header ;
  int result ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
#line 1359
  tmp = js_has_sanity(query);
#line 1359
  if (tmp == -1) {
#line 1360
    return (-1);
  }
#line 1361
  if ((unsigned long )hname == (unsigned long )((char *)0)) {
#line 1362
    return (-1);
  } else
#line 1361
  if ((unsigned long )opt1 == (unsigned long )((char *)0)) {
#line 1362
    return (-1);
  }
#line 1364
  reply = js_create(512U, 1U);
#line 1364
  if ((unsigned long )reply == (unsigned long )((js_string *)0)) {
#line 1365
    return (-1);
  }
#line 1366
  hname_js = js_create(256U, 1U);
#line 1366
  if ((unsigned long )hname_js == (unsigned long )((js_string *)0)) {
#line 1367
    js_destroy(reply);
#line 1368
    return (1);
  }
#line 1370
  data = js_create(256U, 1U);
#line 1370
  if ((unsigned long )data == (unsigned long )((js_string *)0)) {
#line 1371
    js_destroy(reply);
#line 1371
    js_destroy(hname_js);
#line 1372
    return (1);
  }
#line 1376
  hname_js->encoding = query->encoding;
#line 1378
  tmp___0 = js_qstr2js(hname_js, hname);
#line 1378
  if (tmp___0 == -1) {
#line 1379
    goto cleanup;
  }
#line 1381
  tmp___1 = hname_2rfc1035(hname_js);
#line 1381
  if (tmp___1 <= 0) {
#line 1382
    goto cleanup;
  }
#line 1384
  tmp___2 = js_adduint16(hname_js, (int )type);
#line 1384
  if (tmp___2 == -1) {
#line 1385
    goto cleanup;
  }
#line 1387
  result = js_issame(hname_js, query);
#line 1388
  if (result == -1) {
#line 1389
    goto cleanup;
  }
#line 1391
  if (result != 1) {
#line 1392
    js_destroy(reply);
#line 1392
    js_destroy(hname_js);
#line 1392
    js_destroy(data);
#line 1393
    return (0);
  }
#line 1402
  if ((int )type != 16) {
#line 1403
    js_destroy(reply);
#line 1403
    js_destroy(hname_js);
#line 1403
    js_destroy(data);
#line 1404
    return (0);
  }
#line 1407
  if ((unsigned long )opt2 == (unsigned long )((char *)0)) {
#line 1408
    goto cleanup;
  }
#line 1413
  tmp___3 = js_qstr2js(hname_js, (char *)"");
#line 1413
  if (tmp___3 == -1) {
#line 1414
    goto cleanup;
  }
#line 1415
  tmp___4 = js_qappend(opt1, hname_js);
#line 1415
  if (tmp___4 == -1) {
#line 1416
    goto cleanup;
  }
#line 1417
  tmp___5 = js_qappend(opt2, hname_js);
#line 1417
  if (tmp___5 == -1) {
#line 1418
    goto cleanup;
  }
#line 1419
  tmp___6 = js_qstr2js(data, (char *)"");
#line 1419
  if (tmp___6 == -1) {
#line 1420
    goto cleanup;
  }
#line 1421
  if (hname_js->unit_count > 255U) {
#line 1422
    goto cleanup;
  }
#line 1423
  tmp___7 = js_addbyte(data, (unsigned char )hname_js->unit_count);
#line 1423
  if (tmp___7 == -1) {
#line 1424
    goto cleanup;
  }
#line 1425
  tmp___8 = js_append(hname_js, data);
#line 1425
  if (tmp___8 == -1) {
#line 1426
    goto cleanup;
  }
#line 1429
  if (id > 0) {
#line 1429
    if (id < 65535) {
#line 1430
      header.id = (uint16_t )id;
    } else {
#line 1432
      goto cleanup;
    }
  } else {
#line 1432
    goto cleanup;
  }
#line 1434
  header.qr = 1;
#line 1435
  header.opcode = 0;
#line 1436
  header.aa = 0;
#line 1437
  header.tc = 0;
#line 1438
  header.rd = 0;
#line 1439
  header.ra = 0;
#line 1440
  header.z = 0;
#line 1441
  header.rcode = 0;
#line 1442
  header.qdcount = (uint16_t )1;
#line 1443
  header.ancount = (uint16_t )1;
#line 1444
  header.nscount = (uint16_t )0;
#line 1445
  header.arcount = (uint16_t )0;
#line 1448
  tmp___9 = make_hdr(& header, reply);
#line 1448
  if (tmp___9 == -1) {
#line 1449
    goto cleanup;
  }
#line 1452
  tmp___10 = js_append(query, reply);
#line 1452
  if (tmp___10 == -1) {
#line 1453
    goto cleanup;
  }
#line 1456
  tmp___11 = js_adduint16(reply, 1);
#line 1456
  if (tmp___11 == -1) {
#line 1457
    goto cleanup;
  }
#line 1460
  tmp___12 = js_append(query, reply);
#line 1460
  if (tmp___12 == -1) {
#line 1461
    goto cleanup;
  }
#line 1463
  tmp___13 = js_adduint16(reply, 1);
#line 1463
  if (tmp___13 == -1) {
#line 1464
    goto cleanup;
  }
#line 1466
  tmp___14 = js_adduint32(reply, (uint32_t )770616);
#line 1466
  if (tmp___14 == -1) {
#line 1467
    goto cleanup;
  }
#line 1469
  tmp___15 = js_adduint16(reply, (int )data->unit_count);
#line 1469
  if (tmp___15 == -1) {
#line 1470
    goto cleanup;
  }
#line 1472
  tmp___16 = js_append(data, reply);
#line 1472
  if (tmp___16 == -1) {
#line 1473
    goto cleanup;
  }
#line 1476
  mara_send(ect, sock, reply);
#line 1479
  js_destroy(reply);
#line 1480
  js_destroy(hname_js);
#line 1481
  js_destroy(data);
#line 1482
  return (1);
  cleanup: 
#line 1486
  js_destroy(reply);
#line 1487
  js_destroy(hname_js);
#line 1488
  js_destroy(data);
#line 1489
  return (-1);
}
}
#line 1497 "MaraDNS.c"
js_string *make_synth_ns_record(js_string *dname_they_wanted , int labels_to_zap ) 
{ js_string *out ;
  int length ;
  int point ;
  int labels_seen ;
  int tmp ;

  {
#line 1499
  out = (js_string *)0;
#line 1502
  out = js_create(dname_they_wanted->unit_count + 2U, 1U);
#line 1505
  if ((unsigned long )out == (unsigned long )((js_string *)0)) {
#line 1506
    return ((js_string *)0);
  }
#line 1511
  length = 0;
#line 1511
  point = length;
#line 1512
  labels_seen = 0;
#line 1513
  while (labels_seen < labels_to_zap) {
#line 1514
    length = (int )*(dname_they_wanted->string + point);
#line 1515
    if ((unsigned int )(point + length) > dname_they_wanted->unit_count) {
#line 1517
      js_destroy(out);
#line 1518
      return ((js_string *)0);
    } else
#line 1515
    if (length > 63) {
#line 1517
      js_destroy(out);
#line 1518
      return ((js_string *)0);
    }
#line 1521
    point += length + 1;
#line 1522
    if ((unsigned int )point > dname_they_wanted->unit_count) {
#line 1523
      js_destroy(out);
#line 1524
      return ((js_string *)0);
    }
#line 1526
    labels_seen ++;
  }
#line 1530
  length = 0;
#line 1531
  while ((unsigned int )point < dname_they_wanted->unit_count) {
#line 1532
    if ((unsigned int )length >= out->max_count) {
#line 1533
      js_destroy(out);
#line 1534
      return ((js_string *)0);
    }
#line 1536
    if ((unsigned int )point > dname_they_wanted->unit_count) {
#line 1537
      js_destroy(out);
#line 1538
      return ((js_string *)0);
    }
#line 1540
    *(out->string + length) = *(dname_they_wanted->string + point);
#line 1542
    length ++;
#line 1543
    point ++;
  }
#line 1547
  out->unit_count = (unsigned int )length;
#line 1549
  tmp = change_rtype(out, 2);
#line 1549
  if (tmp == -1) {
#line 1550
    js_destroy(out);
#line 1551
    return ((js_string *)0);
  }
#line 1553
  return (out);
}
}
#line 1571 "MaraDNS.c"
int udpstar(rr *where , int id , int sock , struct sockaddr_in *client , js_string *query ,
            js_string *answer , int rd_val , int endstar , conn *ect ) 
{ js_string *most ;
  js_string *ar ;
  uint16_t first_rr_type ;
  int in_ns ;
  int length_save ;
  int len_inet ;
  js_string *synth_ns_record ;
  q_header header ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  uint32_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  uint32_t tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;

  {
#line 1577
  in_ns = 0;
#line 1579
  len_inet = (int )sizeof(struct sockaddr );
#line 1580
  synth_ns_record = (js_string *)0;
#line 1584
  most = js_create(1024U, 1U);
#line 1584
  if ((unsigned long )most == (unsigned long )((js_string *)0)) {
#line 1585
    return (-1);
  }
#line 1586
  ar = js_create(1024U, 1U);
#line 1586
  if ((unsigned long )ar == (unsigned long )((js_string *)0)) {
#line 1587
    js_destroy(most);
#line 1588
    return (1);
  }
#line 1592
  init_header(& header);
#line 1593
  header.id = (uint16_t )id;
#line 1594
  header.rd = rd_val;
#line 1595
  tmp = make_hdr(& header, most);
#line 1595
  if (tmp == -1) {
#line 1596
    goto giveerror;
  }
#line 1599
  if ((unsigned long )where == (unsigned long )((rr *)0)) {
#line 1600
    goto giveerror;
  }
#line 1602
  if ((unsigned long )where->query == (unsigned long )((js_string *)0)) {
#line 1603
    goto giveerror;
  }
#line 1605
  tmp___0 = js_has_sanity(where->query);
#line 1605
  if (tmp___0 == -1) {
#line 1606
    goto giveerror;
  }
#line 1608
  if ((unsigned long )where->data == (unsigned long )((js_string *)0)) {
#line 1609
    goto giveerror;
  }
#line 1611
  tmp___1 = js_has_sanity(where->data);
#line 1611
  if (tmp___1 == -1) {
#line 1612
    goto giveerror;
  }
#line 1614
  tmp___2 = js_has_sanity(query);
#line 1614
  if (tmp___2 == -1) {
#line 1615
    goto giveerror;
  }
#line 1617
  tmp___3 = get_rtype(query);
#line 1617
  first_rr_type = (uint16_t )tmp___3;
#line 1621
  header.aa = (int )where->authoritative;
#line 1625
  if ((where->data)->unit_count < 0U) {
#line 1626
    goto giveerror;
  } else
#line 1625
  if ((where->data)->unit_count > 65535U) {
#line 1626
    goto giveerror;
  }
#line 1630
  tmp___4 = js_append(query, most);
#line 1630
  if (tmp___4 == -1) {
#line 1631
    goto giveerror;
  }
#line 1635
  tmp___5 = js_adduint16(most, 1);
#line 1635
  if (tmp___5 == -1) {
#line 1636
    goto giveerror;
  }
#line 1640
  header.ancount = (uint16_t )0;
#line 1641
  header.nscount = (uint16_t )0;
#line 1642
  header.arcount = (uint16_t )0;
#line 1645
  while ((unsigned long )where != (unsigned long )((rr *)0)) {
#line 1647
    if ((int )first_rr_type != 2) {
#line 1647
      if ((int )where->rr_type == 2) {
#line 1648
        in_ns = 1;
      }
    }
#line 1649
    if (! in_ns) {
#line 1650
      header.ancount = (uint16_t )((int )header.ancount + 1);
    } else {
#line 1652
      header.nscount = (uint16_t )((int )header.nscount + 1);
    }
#line 1654
    if (! in_ns) {
#line 1655
      tmp___6 = js_append(answer, most);
#line 1655
      if (tmp___6 == -1) {
#line 1656
        goto giveerror;
      }
    } else {
#line 1663
      if (endstar > 0) {
#line 1663
        if (endstar < 125) {
#line 1663
          if ((unsigned long )synth_ns_record == (unsigned long )((js_string *)0)) {
#line 1664
            synth_ns_record = make_synth_ns_record(answer, endstar - 1);
#line 1666
            if ((unsigned long )synth_ns_record == (unsigned long )((js_string *)0)) {
#line 1667
              goto giveerror;
            }
          }
        }
      }
#line 1670
      if ((unsigned long )synth_ns_record == (unsigned long )((js_string *)0)) {
#line 1671
        tmp___7 = js_append(where->query, most);
#line 1671
        if (tmp___7 == -1) {
#line 1672
          goto giveerror;
        }
      } else {
#line 1675
        tmp___8 = js_append(synth_ns_record, most);
#line 1675
        if (tmp___8 == -1) {
#line 1676
          goto giveerror;
        }
      }
    }
#line 1681
    tmp___9 = js_adduint16(most, 1);
#line 1681
    if (tmp___9 == -1) {
#line 1682
      goto giveerror;
    }
#line 1685
    tmp___10 = determine_ttl(where->expire, where->ttl);
#line 1685
    tmp___11 = js_adduint32(most, tmp___10);
#line 1685
    if (tmp___11 == -1) {
#line 1687
      goto giveerror;
    }
#line 1690
    tmp___12 = js_adduint16(most, (int )(where->data)->unit_count);
#line 1690
    if (tmp___12 == -1) {
#line 1691
      goto giveerror;
    }
#line 1694
    tmp___13 = js_append(where->data, most);
#line 1694
    if (tmp___13 == -1) {
#line 1695
      goto giveerror;
    }
#line 1699
    if ((unsigned long )where->ip != (unsigned long )((struct rr *)0)) {
#line 1699
      if ((int )where->rr_type != 5) {
#line 1701
        header.arcount = (uint16_t )((int )header.arcount + 1);
#line 1703
        tmp___14 = js_append((where->ip)->query, ar);
#line 1703
        if (tmp___14 == -1) {
#line 1704
          goto giveerror;
        }
#line 1707
        tmp___15 = js_adduint16(ar, 1);
#line 1707
        if (tmp___15 == -1) {
#line 1708
          goto giveerror;
        }
#line 1711
        tmp___16 = determine_ttl((where->ip)->expire, (where->ip)->ttl);
#line 1711
        tmp___17 = js_adduint32(ar, tmp___16);
#line 1711
        if (tmp___17 == -1) {
#line 1713
          goto giveerror;
        }
#line 1716
        tmp___18 = js_adduint16(ar, (int )((where->ip)->data)->unit_count);
#line 1716
        if (tmp___18 == -1) {
#line 1717
          goto giveerror;
        }
#line 1720
        tmp___19 = js_append((where->ip)->data, ar);
#line 1720
        if (tmp___19 == -1) {
#line 1721
          goto giveerror;
        }
      }
    }
#line 1728
    where = where->next;
  }
#line 1733
  header.qr = 1;
#line 1734
  header.opcode = 0;
#line 1735
  header.tc = 0;
#line 1736
  header.rd = 0;
#line 1737
  header.ra = 0;
#line 1738
  header.z = 0;
#line 1739
  header.rcode = 0;
#line 1740
  header.qdcount = (uint16_t )1;
#line 1744
  length_save = (int )most->unit_count;
#line 1745
  make_hdr(& header, most);
#line 1746
  most->unit_count = (unsigned int )length_save;
#line 1749
  tmp___20 = js_append(ar, most);
#line 1749
  if (tmp___20 == -1) {
#line 1750
    goto giveerror;
  }
#line 1754
  tmp___21 = compress_data(most, ar);
#line 1754
  if (tmp___21 == -1) {
#line 1755
    js_destroy(ar);
#line 1756
    udperror(sock, most, client, (js_string *)0, 2, (char *)"compression failure",
             2, rd_val, ect, 1);
#line 1758
    js_destroy(most);
#line 1759
    if ((unsigned long )synth_ns_record != (unsigned long )((js_string *)0)) {
#line 1759
      js_destroy(synth_ns_record);
    }
#line 1760
    return (-1);
  }
#line 1764
  if (ar->unit_count > 512U) {
#line 1767
    header.tc = 1;
#line 1768
    make_hdr(& header, ar);
  }
#line 1772
  if ((unsigned long )ect == (unsigned long )((conn *)0)) {
#line 1773
    sendto(sock, (void const   *)ar->string, (size_t )ar->unit_count, 0, (struct sockaddr  const  *)((struct sockaddr *)client),
           (socklen_t )len_inet);
  } else {
#line 1776
    mara_send(ect, sock, ar);
  }
#line 1779
  js_destroy(most);
#line 1780
  js_destroy(ar);
#line 1782
  if ((unsigned long )synth_ns_record != (unsigned long )((js_string *)0)) {
#line 1782
    js_destroy(synth_ns_record);
  }
#line 1784
  return (1);
  giveerror: 
#line 1788
  if ((unsigned long )synth_ns_record != (unsigned long )((js_string *)0)) {
#line 1788
    js_destroy(synth_ns_record);
  }
#line 1789
  js_destroy(ar);
#line 1790
  udperror(sock, most, client, (js_string *)0, 2, (char *)"giveerror in udpstar",
           2, rd_val, ect, 1);
#line 1792
  js_destroy(most);
#line 1793
  return (-1);
}
}
#line 1800 "MaraDNS.c"
int make_notthere_reply(int id , int sock , struct sockaddr_in *client , js_string *query ,
                        int rd_val , conn *ect ) 
{ js_string *most ;
  q_header header ;
  int len_inet ;

  {
#line 1804
  len_inet = (int )sizeof(struct sockaddr );
#line 1806
  init_header(& header);
#line 1807
  header.rd = rd_val;
#line 1808
  header.id = (uint16_t )id;
#line 1809
  header.qr = 1;
#line 1810
  header.opcode = 0;
#line 1811
  header.tc = 0;
#line 1812
  header.ra = calc_ra_value(rd_val);
#line 1813
  header.z = 0;
#line 1814
  header.rcode = 0;
#line 1816
  header.qdcount = (uint16_t )1;
#line 1817
  header.ancount = (uint16_t )1;
#line 1818
  header.nscount = (uint16_t )0;
#line 1819
  header.arcount = (uint16_t )0;
#line 1820
  most = js_create(520U, 1U);
#line 1820
  if ((unsigned long )most == (unsigned long )((js_string *)0)) {
#line 1821
    return (-1);
  }
#line 1823
  make_hdr(& header, most);
#line 1825
  js_append(query, most);
#line 1826
  js_adduint16(most, 1);
#line 1828
  js_append(notthere_ip, most);
#line 1831
  if ((unsigned long )ect == (unsigned long )((conn *)0)) {
#line 1832
    sendto(sock, (void const   *)most->string, (size_t )most->unit_count, 0, (struct sockaddr  const  *)((struct sockaddr *)client),
           (socklen_t )len_inet);
  } else {
#line 1835
    mara_send(ect, sock, most);
  }
#line 1838
  js_destroy(most);
#line 1839
  return (1);
}
}
#line 1880 "MaraDNS.c"
int udpnotfound(rr *where , int id , int sock , struct sockaddr_in *client , js_string *query ,
                int qtype , int rd_val , conn *ect , int recursive_call ) 
{ js_string *most ;
  js_string *compressed ;
  uint16_t first_rr_type ;
  int length_save ;
  int qtype_save ;
  int len_inet ;
  q_header header ;
  int always_not_there ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  uint32_t tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  mhash_e spot_data ;
  int tmp___17 ;
  int tmp___18 ;

  {
#line 1886
  length_save = 0;
#line 1886
  qtype_save = -1;
#line 1887
  len_inet = (int )sizeof(struct sockaddr );
#line 1890
  always_not_there = 0;
#line 1891
  if (recursive_call >= 4) {
#line 1892
    recursive_call -= 4;
#line 1893
    always_not_there = 4;
  }
#line 1896
  tmp = js_has_sanity(query);
#line 1896
  if (tmp == -1) {
#line 1897
    return (-1);
  }
#line 1899
  tmp___0 = get_rtype(query);
#line 1899
  first_rr_type = (uint16_t )tmp___0;
#line 1903
  if ((unsigned long )notthere_ip != (unsigned long )((js_string *)0)) {
#line 1903
    if ((recursive_call & 1) == 1) {
#line 1903
      if ((int )first_rr_type == 1) {
#line 1905
        tmp___1 = make_notthere_reply(id, sock, client, query, rd_val, ect);
#line 1905
        return (tmp___1);
      }
    }
  }
#line 1910
  most = js_create(1024U, 1U);
#line 1910
  if ((unsigned long )most == (unsigned long )((js_string *)0)) {
#line 1911
    return (-1);
  }
#line 1912
  compressed = js_create(1024U, 1U);
#line 1912
  if ((unsigned long )compressed == (unsigned long )((js_string *)0)) {
#line 1913
    js_destroy(most);
#line 1914
    return (-1);
  }
#line 1918
  init_header(& header);
#line 1919
  header.rd = rd_val;
#line 1920
  header.id = (uint16_t )id;
#line 1921
  tmp___2 = make_hdr(& header, most);
#line 1921
  if (tmp___2 == -1) {
#line 1922
    js_destroy(most);
#line 1922
    js_destroy(compressed);
#line 1923
    return (-1);
  }
#line 1927
  if ((unsigned long )where == (unsigned long )((rr *)0)) {
#line 1928
    goto giveerror;
  }
#line 1929
  if ((unsigned long )where->query == (unsigned long )((js_string *)0)) {
#line 1930
    goto giveerror;
  }
#line 1932
  tmp___3 = js_has_sanity(where->query);
#line 1932
  if (tmp___3 == -1) {
#line 1933
    goto giveerror;
  }
#line 1935
  if ((unsigned long )where->data == (unsigned long )((js_string *)0)) {
#line 1936
    goto giveerror;
  }
#line 1938
  tmp___4 = js_has_sanity(where->data);
#line 1938
  if (tmp___4 == -1) {
#line 1939
    goto giveerror;
  }
#line 1945
  header.aa = (int )where->authoritative;
#line 1949
  if ((where->data)->unit_count < 0U) {
#line 1950
    goto giveerror;
  } else
#line 1949
  if ((where->data)->unit_count > 65535U) {
#line 1950
    goto giveerror;
  }
#line 1956
  if (qtype != 0) {
#line 1957
    qtype_save = get_rtype(query);
#line 1958
    if (qtype_save == -1) {
#line 1959
      goto giveerror;
    }
#line 1960
    tmp___5 = change_rtype(query, qtype);
#line 1960
    if (tmp___5 == -1) {
#line 1961
      goto giveerror;
    }
  }
#line 1965
  tmp___6 = js_append(query, most);
#line 1965
  if (tmp___6 == -1) {
#line 1966
    change_rtype(query, qtype_save);
#line 1967
    goto giveerror;
  }
#line 1971
  tmp___7 = change_rtype(query, qtype);
#line 1971
  if (tmp___7 == -1) {
#line 1972
    goto giveerror;
  }
#line 1975
  tmp___8 = js_adduint16(most, 1);
#line 1975
  if (tmp___8 == -1) {
#line 1976
    goto giveerror;
  }
#line 1980
  header.ancount = (uint16_t )0;
#line 1981
  header.nscount = (uint16_t )1;
#line 1982
  header.arcount = (uint16_t )0;
#line 1991
  if ((int )*((where->query)->string) == 95) {
#line 1991
    goto _L;
  } else
#line 1991
  if (recursive_call == 2) {
#line 1991
    goto _L;
  } else
#line 1991
  if (recursive_call == 3) {
    _L: /* CIL Label */ 
#line 1993
    qtype_save = get_rtype(query);
#line 1994
    tmp___9 = change_rtype(query, 6);
#line 1994
    if (tmp___9 == -1) {
#line 1995
      goto giveerror;
    }
#line 1997
    tmp___10 = js_append(query, most);
#line 1997
    if (tmp___10 == -1) {
#line 1998
      goto giveerror;
    }
  } else {
#line 2001
    tmp___11 = js_append(where->query, most);
#line 2001
    if (tmp___11 == -1) {
#line 2002
      goto giveerror;
    }
  }
#line 2005
  tmp___12 = js_adduint16(most, 1);
#line 2005
  if (tmp___12 == -1) {
#line 2006
    goto giveerror;
  }
#line 2009
  tmp___13 = determine_ttl(where->expire, where->ttl);
#line 2009
  tmp___14 = js_adduint32(most, tmp___13);
#line 2009
  if (tmp___14 == -1) {
#line 2011
    goto giveerror;
  }
#line 2014
  tmp___15 = js_adduint16(most, (int )(where->data)->unit_count);
#line 2014
  if (tmp___15 == -1) {
#line 2015
    goto giveerror;
  }
#line 2018
  tmp___16 = js_append(where->data, most);
#line 2018
  if (tmp___16 == -1) {
#line 2019
    goto giveerror;
  }
#line 2024
  header.qr = 1;
#line 2025
  header.opcode = 0;
#line 2026
  header.tc = 0;
#line 2027
  header.rd = rd_val;
#line 2028
  header.ra = calc_ra_value(rd_val);
#line 2029
  header.z = 0;
#line 2033
  if (always_not_there == 4) {
#line 2034
    header.rcode = 0;
  } else
#line 2035
  if (recursive_call == 1) {
#line 2035
    goto _L___0;
  } else
#line 2035
  if (recursive_call == 3) {
    _L___0: /* CIL Label */ 
#line 2038
    if ((int )where->rcode == 3) {
#line 2039
      header.rcode = 3;
    } else {
#line 2041
      header.rcode = 0;
    }
  } else {
#line 2048
    qtype_save = get_rtype(query);
#line 2049
    tmp___17 = change_rtype(query, 255);
#line 2049
    if (tmp___17 == -1) {
#line 2050
      goto giveerror;
    }
#line 2054
    spot_data = mhash_get(bighash, query);
#line 2055
    if ((unsigned long )spot_data.value != (unsigned long )((void *)0)) {
#line 2055
      if (spot_data.datatype == 6) {
#line 2056
        header.rcode = 0;
      } else {
#line 2058
        header.rcode = 3;
      }
    } else {
#line 2058
      header.rcode = 3;
    }
  }
#line 2061
  header.qdcount = (uint16_t )1;
#line 2065
  length_save = (int )most->unit_count;
#line 2066
  make_hdr(& header, most);
#line 2067
  most->unit_count = (unsigned int )length_save;
#line 2070
  tmp___18 = compress_data(most, compressed);
#line 2070
  if (tmp___18 == -1) {
#line 2071
    js_destroy(compressed);
#line 2072
    udperror(sock, most, client, (js_string *)0, 2, (char *)"Compression failure",
             2, rd_val, ect, 1);
#line 2074
    js_destroy(most);
#line 2075
    return (-1);
  }
#line 2079
  if (compressed->unit_count > 512U) {
#line 2082
    header.tc = 1;
#line 2083
    make_hdr(& header, compressed);
  }
#line 2087
  if ((unsigned long )ect == (unsigned long )((conn *)0)) {
#line 2088
    sendto(sock, (void const   *)compressed->string, (size_t )compressed->unit_count,
           0, (struct sockaddr  const  *)((struct sockaddr *)client), (socklen_t )len_inet);
  } else {
#line 2091
    mara_send(ect, sock, compressed);
  }
#line 2094
  js_destroy(most);
#line 2095
  js_destroy(compressed);
#line 2097
  return (1);
  giveerror: 
#line 2102
  js_destroy(compressed);
#line 2103
  udperror(sock, most, client, (js_string *)0, 2, (char *)"giveerror in udpnotfound",
           2, rd_val, ect, 1);
#line 2105
  js_destroy(most);
#line 2106
  return (-1);
}
}
#line 2119 "MaraDNS.c"
int bobbit_starlabel(js_string *js ) 
{ int counter ;
  unsigned char length ;

  {
#line 2120
  counter = 1;
#line 2123
  if (js->unit_size != 1U) {
#line 2124
    return (-1);
  }
#line 2125
  if (js->unit_count >= js->max_count) {
#line 2126
    return (-1);
  }
#line 2127
  if (js->unit_count < 2U) {
#line 2128
    return (-1);
  }
#line 2129
  if ((int )*(js->string) != 95) {
#line 2130
    return (-1);
  }
#line 2131
  length = *(js->string + 1);
#line 2133
  if ((unsigned int )((int )length + 2) > js->unit_count) {
#line 2134
    return (-1);
  } else
#line 2133
  if ((int )length > 63) {
#line 2134
    return (-1);
  } else
#line 2135
  if ((int )length == 0) {
#line 2136
    return (0);
  }
#line 2138
  length = (unsigned char )((int )length + 1);
#line 2140
  while ((unsigned int )counter < (js->unit_count - (unsigned int )length) + 1U) {
#line 2141
    *(js->string + counter) = *((js->string + counter) + (int )length);
#line 2142
    counter ++;
  }
#line 2145
  js->unit_count -= (unsigned int )length;
#line 2147
  return (1);
}
}
#line 2159 "MaraDNS.c"
int make_starlabel(js_string *js ) 
{ int counter ;
  unsigned char length ;

  {
#line 2160
  counter = 1;
#line 2163
  if (js->unit_size != 1U) {
#line 2164
    return (-1);
  }
#line 2165
  if (js->unit_count >= js->max_count) {
#line 2166
    return (-1);
  }
#line 2167
  if (js->unit_count < 2U) {
#line 2168
    return (-1);
  }
#line 2169
  if ((int )*(js->string) == 95) {
#line 2170
    return (0);
  }
#line 2171
  length = *(js->string);
#line 2172
  *(js->string) = (unsigned char )'_';
#line 2174
  if ((unsigned int )length > js->unit_count) {
#line 2175
    return (-1);
  } else
#line 2174
  if ((int )length > 63) {
#line 2175
    return (-1);
  }
#line 2176
  if ((int )length == 0) {
#line 2177
    return (0);
  }
#line 2179
  while ((unsigned int )counter < js->unit_count - (unsigned int )length) {
#line 2180
    *(js->string + counter) = *((js->string + counter) + (int )length);
#line 2181
    counter ++;
  }
#line 2184
  js->unit_count -= (unsigned int )length;
#line 2186
  return (1);
}
}
#line 2202 "MaraDNS.c"
int bobbit_starlabel_end(js_string *js ) 
{ int counter ;
  int ret ;
  unsigned char toread ;
  int length ;
  int16_t rtype ;
  int tmp ;
  int tmp___0 ;

  {
#line 2203
  counter = 1;
#line 2204
  ret = 0;
#line 2209
  if (js->unit_size != 1U) {
#line 2210
    return (-1);
  }
#line 2211
  if (js->unit_count >= js->max_count) {
#line 2212
    return (-1);
  }
#line 2213
  if (js->unit_count < 2U) {
#line 2214
    return (-1);
  }
#line 2215
  if (js->unit_count == 3U) {
#line 2216
    return (0);
  }
#line 2218
  rtype = (int16_t )*((js->string + js->unit_count) - 1);
#line 2219
  rtype = (int16_t )((int )rtype + ((int )*((js->string + js->unit_count) - 2) << 8));
#line 2220
  js->unit_count -= 2U;
#line 2221
  counter = dlabel_length(js, 0U);
#line 2222
  counter --;
#line 2223
  if (counter < 0) {
#line 2224
    return (-1);
  } else
#line 2223
  if ((unsigned int )counter > js->unit_count) {
#line 2224
    return (-1);
  }
#line 2227
  if ((int )*(js->string + counter) == 0) {
#line 2228
    *(js->string + counter) = (unsigned char )'_';
#line 2229
    tmp = js_adduint16(js, (int )rtype);
#line 2229
    if (tmp == -1) {
#line 2230
      return (-1);
    }
#line 2232
    return (130);
  }
#line 2236
  length = 0;
#line 2237
  toread = *(js->string);
#line 2238
  counter = 0;
#line 2239
  while (1) {
#line 2239
    if (length < 256) {
#line 2239
      if ((int )toread > 0) {
#line 2239
        if (! ((int )toread != 95)) {
#line 2239
          break;
        }
      } else {
#line 2239
        break;
      }
    } else {
#line 2239
      break;
    }
#line 2240
    ret ++;
#line 2241
    if ((int )toread > 63) {
#line 2242
      return (-1);
    }
#line 2243
    length += (int )toread + 1;
#line 2245
    if ((unsigned int )length > js->unit_count) {
#line 2246
      return (-1);
    } else
#line 2245
    if ((unsigned int )length >= js->max_count) {
#line 2246
      return (-1);
    }
#line 2247
    counter = (int )toread;
#line 2248
    toread = *(js->string + length);
  }
#line 2250
  if (length >= 256) {
#line 2251
    return (-1);
  }
#line 2254
  counter ++;
#line 2255
  if ((unsigned int )counter > js->unit_count) {
#line 2256
    return (-1);
  } else
#line 2255
  if (counter > length) {
#line 2256
    return (-1);
  }
#line 2259
  js->unit_count -= (unsigned int )counter;
#line 2260
  if (js->unit_count < 1U) {
#line 2261
    return (-1);
  }
#line 2263
  *((js->string + js->unit_count) - 1) = (unsigned char )'_';
#line 2265
  tmp___0 = js_adduint16(js, (int )rtype);
#line 2265
  if (tmp___0 == -1) {
#line 2266
    return (-1);
  }
#line 2268
  return (ret);
}
}
#line 2282 "MaraDNS.c"
int starwhitis_seek_any(js_string *query , int rr_type , int found , q_header *head ,
                        rr **w , int *a , js_string *most , js_string *ns , js_string *ar ) 
{ js_string *star ;
  mhash_e spot_data ;
  int this_rr_found ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 2287
  this_rr_found = 0;
#line 2288
  if (found == -1) {
#line 2289
    return (-1);
  }
#line 2291
  star = js_create(256U, 1U);
#line 2291
  if ((unsigned long )star == (unsigned long )((js_string *)0)) {
#line 2292
    return (-1);
  }
#line 2295
  tmp = change_rtype(query, rr_type);
#line 2295
  if (tmp == -1) {
#line 2296
    js_destroy(star);
#line 2297
    return (-1);
  }
#line 2300
  tmp___0 = js_copy(query, star);
#line 2300
  if (tmp___0 == -1) {
#line 2301
    js_destroy(star);
#line 2302
    return (-1);
  }
#line 2304
  tmp___1 = make_starlabel(star);
#line 2304
  if (tmp___1 == -1) {
#line 2305
    js_destroy(star);
#line 2306
    return (-1);
  }
#line 2309
  while (this_rr_found == 0) {
#line 2310
    spot_data = mhash_get(bighash, star);
#line 2312
    if ((unsigned long )spot_data.value != (unsigned long )((void *)0)) {
#line 2312
      if (spot_data.datatype == 3) {
#line 2318
        if (found == 1) {
#line 2319
          this_rr_found = 1;
#line 2320
          tmp___2 = add_answer((rr *)spot_data.value, most, ns, ar, & head->ancount,
                               & head->nscount, & head->arcount, 0, spot_data.point,
                               query, (unsigned char)0);
#line 2320
          if (tmp___2 == -1) {
#line 2324
            js_destroy(star);
#line 2325
            return (-1);
          }
        } else {
#line 2335
          this_rr_found = 1;
#line 2336
          found = 1;
#line 2337
          *w = (rr *)spot_data.value;
#line 2338
          *a = (int )(*w)->authoritative;
#line 2339
          tmp___3 = add_answer((rr *)spot_data.value, most, ns, ar, & head->ancount,
                               & head->nscount, & head->arcount, 1, spot_data.point,
                               query, (unsigned char)0);
#line 2339
          if (tmp___3 == -1) {
#line 2343
            js_destroy(star);
#line 2344
            return (-1);
          }
        }
      }
    }
#line 2348
    tmp___4 = bobbit_starlabel(star);
#line 2348
    if (tmp___4 <= 0) {
#line 2349
      break;
    }
  }
#line 2351
  js_destroy(star);
#line 2352
  return (found);
}
}
#line 2360 "MaraDNS.c"
int fold_case(js_string *js ) 
{ int counter ;
  int ret ;

  {
#line 2361
  counter = 0;
#line 2362
  ret = 0;
#line 2364
  if (js->max_count <= js->unit_count) {
#line 2365
    return (-1);
  }
#line 2367
  if (js->unit_size != 1U) {
#line 2368
    return (-1);
  }
#line 2370
  if (js->unit_count < 2U) {
#line 2371
    return (-1);
  }
#line 2373
  while ((unsigned int )(counter + 2) < js->unit_count) {
#line 2376
    if ((int )*(js->string + counter) >= 65) {
#line 2376
      if ((int )*(js->string + counter) <= 90) {
#line 2377
        *(js->string + counter) = (unsigned char )((int )*(js->string + counter) + 32);
#line 2378
        ret = 1;
      }
    }
#line 2380
    counter ++;
  }
#line 2383
  return (ret);
}
}
#line 2395 "MaraDNS.c"
int ddip_check(int id , int sock , conn *ect , js_string *query ) 
{ unsigned char ip[4] ;
  unsigned char length ;
  unsigned char val ;
  int counter ;
  int critter ;
  int lenl ;
  int value___0 ;
  js_string *reply ;
  q_header header ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 2403
  if (query->unit_size != 1U) {
#line 2404
    return (-1);
  }
#line 2405
  if (query->unit_count >= query->max_count) {
#line 2406
    return (-1);
  }
#line 2410
  tmp = get_rtype(query);
#line 2410
  if (tmp != 1) {
#line 2410
    tmp___0 = get_rtype(query);
#line 2410
    if (tmp___0 != 255) {
#line 2411
      return (0);
    }
  }
#line 2413
  if (query->unit_count < 9U) {
#line 2415
    return (0);
  }
#line 2417
  lenl = 0;
#line 2418
  counter = 0;
#line 2418
  while (counter < 4) {
#line 2419
    length = *(query->string + lenl);
#line 2420
    if ((int )length < 1) {
#line 2421
      return (0);
    } else
#line 2420
    if ((int )length > 3) {
#line 2421
      return (0);
    }
#line 2422
    critter = lenl + 1;
#line 2423
    lenl += (int )length + 1;
#line 2424
    if ((unsigned int )lenl > query->unit_count) {
#line 2425
      return (-1);
    }
#line 2426
    value___0 = 0;
#line 2426
    while (critter < lenl) {
#line 2427
      val = *(query->string + critter);
#line 2428
      if ((int )val > 57) {
#line 2429
        return (0);
      } else
#line 2428
      if ((int )val < 48) {
#line 2429
        return (0);
      }
#line 2430
      value___0 *= 10;
#line 2431
      value___0 += (int )val - 48;
#line 2426
      critter ++;
    }
#line 2433
    if (value___0 < 0) {
#line 2434
      return (0);
    } else
#line 2433
    if (value___0 > 255) {
#line 2434
      return (0);
    }
#line 2435
    ip[counter] = (unsigned char )value___0;
#line 2418
    counter ++;
  }
#line 2438
  if ((int )*(query->string + lenl) != 0) {
#line 2439
    return (0);
  }
#line 2443
  reply = js_create(512U, 1U);
#line 2443
  if ((unsigned long )reply == (unsigned long )((js_string *)0)) {
#line 2444
    return (-1);
  }
#line 2447
  if (id > 0) {
#line 2447
    if (id < 65535) {
#line 2448
      header.id = (uint16_t )id;
    } else {
#line 2450
      goto cleanup;
    }
  } else {
#line 2450
    goto cleanup;
  }
#line 2452
  header.qr = 1;
#line 2453
  header.opcode = 0;
#line 2454
  header.aa = 0;
#line 2455
  header.tc = 0;
#line 2456
  header.rd = 0;
#line 2457
  header.ra = 0;
#line 2458
  header.z = 0;
#line 2459
  header.rcode = 0;
#line 2460
  header.qdcount = (uint16_t )1;
#line 2461
  header.ancount = (uint16_t )1;
#line 2462
  header.nscount = (uint16_t )0;
#line 2463
  header.arcount = (uint16_t )0;
#line 2466
  tmp___1 = make_hdr(& header, reply);
#line 2466
  if (tmp___1 == -1) {
#line 2467
    goto cleanup;
  }
#line 2470
  tmp___2 = js_append(query, reply);
#line 2470
  if (tmp___2 == -1) {
#line 2471
    goto cleanup;
  }
#line 2474
  tmp___3 = js_adduint16(reply, 1);
#line 2474
  if (tmp___3 == -1) {
#line 2475
    goto cleanup;
  }
#line 2478
  tmp___4 = change_rtype(query, 1);
#line 2478
  if (tmp___4 == -1) {
#line 2479
    goto cleanup;
  }
#line 2482
  tmp___5 = js_append(query, reply);
#line 2482
  if (tmp___5 == -1) {
#line 2483
    goto cleanup;
  }
#line 2485
  tmp___6 = js_adduint16(reply, 1);
#line 2485
  if (tmp___6 == -1) {
#line 2486
    goto cleanup;
  }
#line 2488
  tmp___7 = js_adduint32(reply, (uint32_t )19770616);
#line 2488
  if (tmp___7 == -1) {
#line 2489
    goto cleanup;
  }
#line 2491
  tmp___8 = js_adduint16(reply, 4);
#line 2491
  if (tmp___8 == -1) {
#line 2492
    goto cleanup;
  }
#line 2494
  counter = 0;
#line 2494
  while (counter < 4) {
#line 2495
    tmp___9 = js_addbyte(reply, ip[counter]);
#line 2495
    if (tmp___9 == -1) {
#line 2496
      goto cleanup;
    }
#line 2494
    counter ++;
  }
#line 2500
  mara_send(ect, sock, reply);
#line 2503
  js_destroy(reply);
#line 2504
  return (1);
  cleanup: 
#line 2508
  js_destroy(reply);
#line 2509
  return (-1);
}
}
#line 2517 "MaraDNS.c"
int check_ipv4_acl(uint32_t ip , ipv4pair *list ) 
{ int counter ;
  int ret ;

  {
#line 2518
  counter = 0;
#line 2518
  ret = 0;
#line 2519
  while (1) {
#line 2519
    if (counter < 500) {
#line 2519
      if (! ((list + counter)->ip != 4294967295U)) {
#line 2519
        break;
      }
    } else {
#line 2519
      break;
    }
#line 2520
    if ((ip & (list + counter)->mask) == ((list + counter)->ip & (list + counter)->mask)) {
#line 2523
      ret = 1;
#line 2524
      break;
    }
#line 2526
    counter ++;
  }
#line 2528
  return (ret);
}
}
#line 2537 "MaraDNS.c"
int check_recursive_acl(uint32_t ip ) 
{ int tmp ;

  {
#line 2538
  tmp = check_ipv4_acl(ip, recurse_acl);
#line 2538
  return (tmp);
}
}
#line 2550 "MaraDNS.c"
int hunt_single_query(js_string *query , int id , int sock , conn *ect , js_string *question ,
                      int rd_val ) 
{ mhash_e spot_data ;
  int qtype_o ;
  int qtype_q ;

  {
#line 2556
  qtype_o = get_rtype(question);
#line 2557
  qtype_q = get_rtype(query);
#line 2559
  if (qtype_o == -1) {
#line 2560
    return (-1);
  } else
#line 2559
  if (qtype_q == -1) {
#line 2560
    return (-1);
  }
#line 2564
  spot_data = mhash_get(bighash, query);
#line 2566
  if ((unsigned long )spot_data.value != (unsigned long )((void *)0)) {
#line 2566
    if (spot_data.datatype == 3) {
#line 2567
      if (qtype_o == 1) {
#line 2572
        udpsuccess((rr *)spot_data.value, id, sock, (struct sockaddr_in *)0, question,
                   spot_data.point, 1, rd_val, ect, force_auth, rd_val);
      } else
#line 2567
      if (qtype_q == 5) {
#line 2572
        udpsuccess((rr *)spot_data.value, id, sock, (struct sockaddr_in *)0, question,
                   spot_data.point, 1, rd_val, ect, force_auth, rd_val);
      } else {
#line 2581
        udpsuccess((rr *)spot_data.value, id, sock, (struct sockaddr_in *)0, question,
                   spot_data.point, 0, rd_val, ect, force_auth, rd_val);
      }
#line 2585
      return (1);
    }
  }
#line 2589
  return (0);
}
}
#line 2597 "MaraDNS.c"
int star_collision(js_string *lookfor , mhash *bighash___0 ) 
{ js_string *be_anal ;
  mhash_e spot_data ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2598
  be_anal = (js_string *)0;
#line 2600
  tmp = js_length(lookfor);
#line 2600
  if (tmp < 2) {
#line 2601
    return (0);
  }
#line 2603
  be_anal = js_create(257U, 1U);
#line 2604
  tmp___0 = js_copy(lookfor, be_anal);
#line 2604
  if (tmp___0 == -1) {
#line 2605
    js_destroy(be_anal);
#line 2606
    return (-1);
  }
#line 2612
  (be_anal->string) ++;
#line 2613
  (be_anal->unit_count) --;
#line 2614
  tmp___1 = change_rtype(be_anal, 255);
#line 2614
  if (tmp___1 == -1) {
#line 2615
    (be_anal->string) --;
#line 2616
    js_destroy(be_anal);
#line 2617
    return (-1);
  }
#line 2619
  spot_data = mhash_get(bighash___0, be_anal);
#line 2620
  if ((unsigned long )spot_data.value != (unsigned long )((void *)0)) {
#line 2620
    if (spot_data.datatype == 6) {
#line 2624
      (be_anal->string) --;
#line 2625
      js_destroy(be_anal);
#line 2626
      return (1);
    }
  }
#line 2628
  (be_anal->string) --;
#line 2629
  js_destroy(be_anal);
#line 2630
  return (0);
}
}
#line 2639 "MaraDNS.c"
int proc_query(js_string *raw , conn *ect , int sock ) 
{ q_header header ;
  js_string *lookfor ;
  js_string *origq ;
  js_string *lc ;
  rr *nxstore ;
  int length ;
  int result_code ;
  int qtype ;
  int has_recursive_authority ;
  mhash_e spot_data ;
  int have_authority ;
  rr *point ;
  uint32_t ip ;
  int desires_recursion ;
  char *num_string ;
  unsigned int mem_usage ;
  struct sockaddr_in *z ;
  int always_not_there ;
  int rd_val ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  __uint32_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  unsigned long tmp___10 ;
  int tmp___11 ;
  void *tmp___12 ;
  unsigned long tmp___13 ;
  int64_t the_time___0 ;
  void *tmp___14 ;
  unsigned long tmp___15 ;
  unsigned long tmp___16 ;
  unsigned long tmp___17 ;
  void *tmp___18 ;
  int tmp___19 ;
  unsigned long tmp___20 ;
  int new_verbose_level ;
  char *query_string ;
  void *tmp___21 ;
  void *tmp___22 ;
  unsigned long tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  unsigned long tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int rtype_saver ;
  int tmp___38 ;
  int tmp___39 ;
  int r ;
  int rtype_saver___0 ;
  int tmp___40 ;
  int r___0 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int rtype_saver___1 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int labels ;
  int tmp___54 ;
  int store_rtype ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;

  {
#line 2642
  lookfor = (js_string *)0;
#line 2643
  origq = (js_string *)0;
#line 2644
  lc = (js_string *)0;
#line 2645
  nxstore = (rr *)0;
#line 2648
  result_code = 0;
#line 2650
  has_recursive_authority = 0;
#line 2653
  have_authority = 0;
#line 2655
  point = (rr *)0;
#line 2657
  desires_recursion = 0;
#line 2658
  num_string = (char *)0;
#line 2663
  always_not_there = 0;
#line 2664
  rd_val = 0;
#line 2668
  tmp = js_has_sanity(raw);
#line 2668
  if (tmp == -1) {
#line 2669
    return (1);
  }
#line 2670
  if (raw->unit_size != 1U) {
#line 2671
    return (1);
  }
#line 2674
  tmp___0 = read_hdr(raw, & header);
#line 2674
  if (tmp___0 == -1) {
#line 2676
    udperror(sock, raw, (struct sockaddr_in *)0, (js_string *)0, 1, (char *)"Couldn\'t get header",
             2, 0, ect, 1);
#line 2677
    return (1);
  }
#line 2681
  rd_val = header.rd;
#line 2681
  desires_recursion = rd_val;
#line 2685
  if (header.qr != 0) {
#line 2686
    return (1);
  }
#line 2690
  if ((int )header.qdcount != 1) {
#line 2691
    if (no_fingerprint != 1) {
#line 2692
      udperror(sock, raw, (struct sockaddr_in *)0, (js_string *)0, 4, (char *)"Qdcount not 1",
               2, desires_recursion, ect, 1);
    }
#line 2694
    return (1);
  }
#line 2698
  if (raw->unit_count < 14U) {
#line 2699
    if (no_fingerprint != 1) {
#line 2700
      udperror(sock, raw, (struct sockaddr_in *)0, (js_string *)0, 1, (char *)"bad question hdr",
               2, desires_recursion, ect, 1);
    }
#line 2702
    return (1);
  }
#line 2706
  length = dlabel_length(raw, 12U);
#line 2707
  if (length < 0) {
#line 2707
    goto _L;
  } else
#line 2707
  if (length > 255) {
    _L: /* CIL Label */ 
#line 2708
    if (no_fingerprint != 1) {
#line 2709
      udperror(sock, raw, (struct sockaddr_in *)0, (js_string *)0, 1, (char *)"bad question length",
               2, desires_recursion, ect, 1);
    }
#line 2711
    return (1);
  }
#line 2714
  if (raw->unit_count < (unsigned int )(16 + length)) {
#line 2716
    if (no_fingerprint != 1) {
#line 2717
      udperror(sock, raw, (struct sockaddr_in *)0, (js_string *)0, 1, (char *)"question doesn\'t fit",
               2, desires_recursion, ect, 1);
    }
#line 2719
    return (1);
  }
#line 2723
  lookfor = js_create(256U, 1U);
#line 2723
  if ((unsigned long )lookfor == (unsigned long )((js_string *)0)) {
#line 2724
    if (no_fingerprint != 1) {
#line 2725
      udperror(sock, raw, (struct sockaddr_in *)0, (js_string *)0, 2, (char *)"can\'t create lookfor string",
               2, desires_recursion, ect, 1);
    }
#line 2727
    return (-1);
  }
#line 2729
  origq = js_create(256U, 1U);
#line 2729
  if ((unsigned long )origq == (unsigned long )((js_string *)0)) {
#line 2730
    udperror(sock, raw, (struct sockaddr_in *)0, (js_string *)0, 2, (char *)"can\'t create origq string",
             2, desires_recursion, ect, 1);
#line 2732
    js_destroy(lookfor);
#line 2733
    return (-1);
  }
#line 2737
  tmp___1 = js_substr(raw, lookfor, 12, length + 2);
#line 2737
  if (tmp___1 == -1) {
#line 2738
    goto serv_fail;
  }
#line 2743
  if (header.opcode != 0) {
#line 2746
    udperror(sock, raw, (struct sockaddr_in *)0, lookfor, 4, (char *)"non-0 opcode",
             2, desires_recursion, ect, 1);
#line 2748
    js_destroy(origq);
#line 2748
    js_destroy(lookfor);
#line 2749
    return (1);
  }
#line 2754
  if ((int )*((raw->string + length) + 14) != 0) {
#line 2754
    if ((int )*((raw->string + length) + 15) != 1) {
#line 2756
      if (no_fingerprint != 1) {
#line 2757
        udperror(sock, raw, (struct sockaddr_in *)0, lookfor, 4, (char *)"Class not 1",
                 2, desires_recursion, ect, 1);
      }
#line 2760
      js_destroy(origq);
#line 2760
      js_destroy(lookfor);
#line 2761
      return (-1);
    }
  }
#line 2765
  tmp___2 = js_copy(lookfor, origq);
#line 2765
  if (tmp___2 == -1) {
#line 2766
    goto serv_fail;
  }
#line 2771
  fold_case(lookfor);
#line 2774
  qtype = get_rtype(origq);
#line 2775
  if (qtype == -1) {
#line 2776
    goto serv_fail;
  }
#line 2780
  if (qtype == 28) {
#line 2780
    if (reject_aaaa != 0) {
#line 2781
      udpnotfound(ra_data, (int )header.id, sock, (struct sockaddr_in *)0, origq,
                  0, desires_recursion, ect, 2);
#line 2783
      js_destroy(lookfor);
#line 2783
      js_destroy(origq);
#line 2783
      js_destroy(lc);
#line 2784
      return (1);
    }
  }
#line 2788
  if (qtype == 12) {
#line 2788
    if (reject_ptr != 0) {
#line 2789
      udpnotfound(ra_data, (int )header.id, sock, (struct sockaddr_in *)0, origq,
                  0, desires_recursion, ect, 2);
#line 2791
      js_destroy(lookfor);
#line 2791
      js_destroy(origq);
#line 2791
      js_destroy(lc);
#line 2792
      return (1);
    }
  }
#line 2795
  if (qtype >= 250) {
#line 2795
    if (qtype <= 254) {
#line 2796
      goto not_impl;
    }
  }
#line 2800
  z = (struct sockaddr_in *)ect->d;
#line 2801
  tmp___3 = _OSSwapInt32(z->sin_addr.s_addr);
#line 2801
  ip = tmp___3;
#line 2805
  has_recursive_authority = check_recursive_acl(ip);
#line 2806
  if (has_recursive_authority == -1) {
#line 2807
    goto serv_fail;
  }
#line 2814
  if (dos_protection_level == 78) {
#line 2815
    goto recursive_call;
  }
#line 2820
  if (dos_protection_level == 79) {
#line 2821
    goto report_version;
  }
#line 2826
  if (dos_protection_level > 13) {
#line 2827
    goto skip_rrany;
  }
#line 2831
  if (qtype == 255) {
#line 2832
    result_code = udpany((int )header.id, sock, (struct sockaddr_in *)0, lookfor,
                         rrany_set, bighash, desires_recursion, ect, 0, origq);
#line 2834
    if (result_code == 1) {
#line 2835
      js_destroy(lookfor);
#line 2835
      js_destroy(origq);
#line 2835
      js_destroy(lc);
#line 2836
      return (1);
    } else
#line 2838
    if (result_code == -1) {
#line 2839
      goto serv_fail;
    }
  }
  skip_rrany: 
#line 2853
  tmp___4 = hunt_single_query(lookfor, (int )header.id, sock, ect, origq, rd_val);
#line 2853
  if (tmp___4 != 0) {
#line 2854
    js_destroy(lookfor);
#line 2854
    js_destroy(origq);
#line 2854
    js_destroy(lc);
#line 2855
    return (1);
  }
#line 2860
  if (dos_protection_level > 7) {
#line 2861
    goto skip_cname;
  }
#line 2865
  tmp___5 = change_rtype(lookfor, 5);
#line 2865
  if (tmp___5 == -1) {
#line 2866
    goto serv_fail;
  }
#line 2868
  tmp___6 = hunt_single_query(lookfor, (int )header.id, sock, ect, origq, rd_val);
#line 2868
  if (tmp___6 != 0) {
#line 2869
    js_destroy(lookfor);
#line 2869
    js_destroy(origq);
#line 2869
    js_destroy(lc);
#line 2870
    return (1);
  }
  skip_cname: 
#line 2878
  if (dos_protection_level > 0) {
#line 2879
    goto skip_easter_egg;
  }
#line 2885
  tmp___7 = check_ipv4_acl(ip, admin_acl);
#line 2885
  if (tmp___7 != 1) {
#line 2886
    goto skip_easter_egg;
  }
  report_version: 
#line 2899
  if (origq->unit_count == 19U) {
#line 2899
    if ((int )*(origq->string) == 7) {
#line 2899
      if (no_fingerprint != 1) {
#line 2899
        if (debug_msg_level >= 1) {
#line 2901
          result_code = easter_egg((int )header.id, sock, ect, origq, (char *)"Tversion.maradns.",
                                   (uint16_t )16, (char *)"MaraDNS version ", (char *)"1.4.06");
#line 2909
          if (result_code == 1) {
#line 2910
            js_destroy(lookfor);
#line 2910
            js_destroy(origq);
#line 2910
            js_destroy(lc);
#line 2911
            return (1);
          }
#line 2913
          if (result_code == -1) {
#line 2914
            goto serv_fail;
          }
        }
      }
    }
  }
#line 2920
  if (dos_protection_level == 79) {
#line 2920
    if (debug_msg_level <= 1) {
#line 2921
      goto recursive_call;
    }
  }
#line 2929
  if (origq->unit_count == 22U) {
#line 2929
    if ((int )*(origq->string) == 10) {
#line 2929
      if (no_fingerprint != 1) {
#line 2929
        if (debug_msg_level >= 2) {
#line 2932
          tmp___8 = js_alloc(32, 1);
#line 2932
          num_string = (char *)tmp___8;
#line 2932
          if ((unsigned long )num_string == (unsigned long )((char *)0)) {
#line 2933
            js_destroy(lookfor);
#line 2933
            js_destroy(origq);
#line 2933
            js_destroy(lc);
#line 2934
            return (-1);
          }
#line 2936
          tmp___9 = how_many_threads();
#line 2936
          tmp___10 = __builtin_object_size((void *)num_string, 1);
#line 2936
          __builtin___snprintf_chk(num_string, 10UL, 0, tmp___10, "%d", tmp___9);
#line 2937
          result_code = easter_egg((int )header.id, sock, ect, origq, (char *)"Tnumthreads.maradns.",
                                   (uint16_t )16, (char *)"Number threads running: ",
                                   num_string);
#line 2940
          js_dealloc((void *)num_string);
#line 2941
          if (result_code == 1) {
#line 2942
            js_destroy(lookfor);
#line 2942
            js_destroy(origq);
#line 2942
            js_destroy(lc);
#line 2943
            return (1);
          }
#line 2945
          if (result_code == -1) {
#line 2946
            goto serv_fail;
          }
        }
      }
    }
  }
#line 2955
  if (origq->unit_count == 20U) {
#line 2955
    if ((int )*(origq->string) == 8) {
#line 2955
      if (no_fingerprint != 1) {
#line 2955
        if (debug_msg_level >= 2) {
#line 2958
          tmp___11 = js_tell_memory_allocated();
#line 2958
          mem_usage = (unsigned int )tmp___11;
#line 2959
          if (mem_usage > 0U) {
#line 2960
            tmp___12 = js_alloc(32, 1);
#line 2960
            num_string = (char *)tmp___12;
#line 2960
            if ((unsigned long )num_string == (unsigned long )((char *)0)) {
#line 2961
              js_destroy(lookfor);
#line 2961
              js_destroy(origq);
#line 2961
              js_destroy(lc);
#line 2962
              return (-1);
            }
#line 2964
            tmp___13 = __builtin_object_size((void *)num_string, 1);
#line 2964
            __builtin___snprintf_chk(num_string, 14UL, 0, tmp___13, "%d", mem_usage);
#line 2965
            result_code = easter_egg((int )header.id, sock, ect, origq, (char *)"Tmemusage.maradns.",
                                     (uint16_t )16, (char *)"Memory usage, in bytes: ",
                                     num_string);
#line 2968
            js_dealloc((void *)num_string);
          } else {
#line 2971
            result_code = easter_egg((int )header.id, sock, ect, origq, (char *)"Tmemusage.maradns.",
                                     (uint16_t )16, (char *)"Memory usage unknown; ",
                                     (char *)"try compiling with make debug (note that this will greatly slow down MaraDNS)");
          }
#line 2976
          if (result_code == 1) {
#line 2977
            js_destroy(lookfor);
#line 2977
            js_destroy(origq);
#line 2977
            js_destroy(lc);
#line 2978
            return (1);
          }
#line 2980
          if (result_code == -1) {
#line 2981
            goto serv_fail;
          }
        }
      }
    }
  }
#line 2989
  if (origq->unit_count == 21U) {
#line 2989
    if ((int )*(origq->string) == 9) {
#line 2989
      if (no_fingerprint != 1) {
#line 2989
        if (debug_msg_level >= 3) {
#line 2993
          the_time___0 = qual_get_time();
#line 2994
          if (the_time___0 > 0LL) {
#line 2995
            tmp___14 = js_alloc(32, 1);
#line 2995
            num_string = (char *)tmp___14;
#line 2995
            if ((unsigned long )num_string == (unsigned long )((char *)0)) {
#line 2996
              js_destroy(lookfor);
#line 2996
              js_destroy(origq);
#line 2996
              js_destroy(lc);
#line 2997
              return (-1);
            }
#line 2999
            if (sizeof(int ) < 8UL) {
#line 2999
              if (the_time___0 > 2147483647LL) {
#line 3000
                tmp___16 = __builtin_object_size((void *)num_string, 0);
#line 3000
                if (tmp___16 != 0xffffffffffffffffUL) {
#line 3000
                  tmp___15 = __builtin_object_size((void *)num_string, 1);
#line 3000
                  __builtin___strncpy_chk(num_string, "pastY2038", 11UL, tmp___15);
                } else {
#line 3000
                  __inline_strncpy_chk(num_string, "pastY2038", (size_t )11);
                }
              } else {
#line 3003
                tmp___17 = __builtin_object_size((void *)num_string, 1);
#line 3003
                __builtin___snprintf_chk(num_string, 14UL, 0, tmp___17, "%d", (int )the_time___0);
              }
            } else {
#line 3003
              tmp___17 = __builtin_object_size((void *)num_string, 1);
#line 3003
              __builtin___snprintf_chk(num_string, 14UL, 0, tmp___17, "%d", (int )the_time___0);
            }
#line 3005
            result_code = easter_egg((int )header.id, sock, ect, origq, (char *)"Ttimestamp.maradns.",
                                     (uint16_t )16, (char *)"Timestamp: ", num_string);
#line 3008
            js_dealloc((void *)num_string);
          } else {
#line 3011
            result_code = easter_egg((int )header.id, sock, ect, origq, (char *)"Tmemusage.maradns.",
                                     (uint16_t )16, (char *)"Memory usage unknown; ",
                                     (char *)"try compiling with make debug (note that this will greatly slow down MaraDNS)");
          }
#line 3016
          if (result_code == 1) {
#line 3017
            js_destroy(lookfor);
#line 3017
            js_destroy(origq);
#line 3017
            js_destroy(lc);
#line 3018
            return (1);
          }
#line 3020
          if (result_code == -1) {
#line 3021
            goto serv_fail;
          }
        }
      }
    }
  }
#line 3030
  if (origq->unit_count == 26U) {
#line 3030
    if ((int )*(origq->string) == 14) {
#line 3030
      if (no_fingerprint != 1) {
#line 3030
        if (debug_msg_level >= 2) {
#line 3033
          tmp___18 = js_alloc(32, 1);
#line 3033
          num_string = (char *)tmp___18;
#line 3033
          if ((unsigned long )num_string == (unsigned long )((char *)0)) {
#line 3034
            js_destroy(lookfor);
#line 3034
            js_destroy(origq);
#line 3034
            js_destroy(lc);
#line 3035
            return (-1);
          }
#line 3037
          tmp___19 = cache_elements();
#line 3037
          tmp___20 = __builtin_object_size((void *)num_string, 1);
#line 3037
          __builtin___snprintf_chk(num_string, 10UL, 0, tmp___20, "%d", tmp___19);
#line 3038
          result_code = easter_egg((int )header.id, sock, ect, origq, (char *)"Tcache-elements.maradns.",
                                   (uint16_t )16, (char *)"Elements in DNS cache: ",
                                   num_string);
#line 3041
          js_dealloc((void *)num_string);
#line 3042
          if (result_code == 1) {
#line 3043
            js_destroy(lookfor);
#line 3043
            js_destroy(origq);
#line 3043
            js_destroy(lc);
#line 3044
            return (1);
          }
#line 3046
          if (result_code == -1) {
#line 3047
            goto serv_fail;
          }
        }
      }
    }
  }
#line 3055
  if (origq->unit_count == 27U) {
#line 3055
    if ((int )*(origq->string) == 1) {
#line 3055
      if (no_fingerprint != 1) {
#line 3055
        if (remote_admin == 1) {
#line 3059
          new_verbose_level = (int )*(origq->string + 1) - 48;
#line 3060
          if (new_verbose_level < 0) {
#line 3061
            goto skip_easter_egg;
          } else
#line 3060
          if (new_verbose_level > 9) {
#line 3061
            goto skip_easter_egg;
          }
#line 3064
          tmp___21 = js_alloc(4, 1);
#line 3064
          num_string = (char *)tmp___21;
#line 3064
          if ((unsigned long )num_string == (unsigned long )((char *)0)) {
#line 3065
            js_destroy(lookfor);
#line 3065
            js_destroy(origq);
#line 3065
            js_destroy(lc);
#line 3066
            return (-1);
          }
#line 3068
          *num_string = (char )(new_verbose_level + 48);
#line 3069
          *(num_string + 1) = (char)0;
#line 3070
          tmp___22 = js_alloc(37, 1);
#line 3070
          query_string = (char *)tmp___22;
#line 3070
          if ((unsigned long )query_string == (unsigned long )((char *)0)) {
#line 3071
            js_dealloc((void *)num_string);
#line 3072
            js_destroy(lookfor);
#line 3072
            js_destroy(origq);
#line 3072
            js_destroy(lc);
#line 3073
            return (-1);
          }
#line 3075
          tmp___28 = __builtin_object_size((void *)query_string, 0);
#line 3075
          if (tmp___28 != 0xffffffffffffffffUL) {
#line 3075
            tmp___24 = __builtin_object_size((void *)query_string, 1);
#line 3075
            tmp___25 = __builtin___strncpy_chk(query_string, "T0.verbose_level.maradns.",
                                               29UL, tmp___24);
#line 3075
            tmp___27 = tmp___25;
          } else {
#line 3075
            tmp___26 = __inline_strncpy_chk(query_string, "T0.verbose_level.maradns.",
                                            (size_t )29);
#line 3075
            tmp___27 = tmp___26;
          }
#line 3075
          if ((unsigned long )tmp___27 == (unsigned long )((char *)0)) {
#line 3076
            js_dealloc((void *)query_string);
#line 3077
            js_dealloc((void *)num_string);
#line 3078
            js_destroy(lookfor);
#line 3078
            js_destroy(origq);
#line 3078
            js_destroy(lc);
#line 3079
            return (-1);
          }
#line 3081
          *(query_string + 1) = (char )(48 + new_verbose_level);
#line 3082
          result_code = easter_egg((int )header.id, sock, ect, origq, query_string,
                                   (uint16_t )16, (char *)"Verbose level is now ",
                                   num_string);
#line 3084
          js_dealloc((void *)num_string);
#line 3085
          js_dealloc((void *)query_string);
#line 3086
          if (result_code == 1) {
#line 3087
            log_level = new_verbose_level;
#line 3088
            log_lock();
#line 3089
            printf("Verbose_level remotely set to %d\n", new_verbose_level);
#line 3090
            log_unlock();
#line 3092
            init_rlog_level(new_verbose_level);
#line 3094
            js_destroy(lookfor);
#line 3094
            js_destroy(origq);
#line 3094
            js_destroy(lc);
#line 3095
            return (1);
          }
#line 3097
          if (result_code == -1) {
#line 3098
            goto serv_fail;
          }
        }
      }
    }
  }
  skip_easter_egg: 
#line 3106
  if (dos_protection_level > 11) {
#line 3107
    goto skip_delegation_ns;
  }
#line 3112
  tmp___29 = change_rtype(lookfor, 2);
#line 3112
  if (tmp___29 == -1) {
#line 3113
    goto serv_fail;
  }
#line 3116
  spot_data = mhash_get(bighash, lookfor);
#line 3117
  point = (rr *)spot_data.value;
#line 3119
  if ((unsigned long )spot_data.value != (unsigned long )((void *)0)) {
#line 3119
    if (spot_data.datatype == 3) {
#line 3119
      if (point->authoritative == 0U) {
#line 3123
        if (recurse_delegation == 1) {
#line 3123
          if (desires_recursion == 1) {
#line 3123
            if (has_recursive_authority == 1) {
#line 3126
              if ((int )ect->type != 4) {
#line 3127
                js_destroy(lookfor);
#line 3127
                js_destroy(origq);
#line 3127
                js_destroy(lc);
#line 3128
                return (-1);
              }
#line 3132
              z = (struct sockaddr_in *)ect->d;
#line 3133
              launch_thread((int )header.id, sock, *z, origq);
#line 3134
              js_destroy(lookfor);
#line 3134
              js_destroy(origq);
#line 3134
              js_destroy(lc);
#line 3135
              return (1);
            }
          }
        }
#line 3139
        udpsuccess((rr *)spot_data.value, (int )header.id, sock, (struct sockaddr_in *)0,
                   origq, spot_data.point, 0, desires_recursion, ect, 0, 0);
#line 3141
        js_destroy(lookfor);
#line 3141
        js_destroy(origq);
#line 3141
        js_destroy(lc);
#line 3142
        return (1);
      }
    }
  }
#line 3146
  if (no_fingerprint != 1) {
#line 3147
    result_code = ddip_check((int )header.id, sock, ect, origq);
#line 3148
    if (result_code == 1) {
#line 3149
      js_destroy(lookfor);
#line 3149
      js_destroy(origq);
#line 3149
      js_destroy(lc);
#line 3150
      return (1);
    }
#line 3152
    if (result_code == -1) {
#line 3153
      goto serv_fail;
    }
  }
#line 3165
  nxstore = (rr *)((void *)0);
#line 3167
  if (has_recursive_authority != 1) {
#line 3167
    goto _L___0;
  } else
#line 3167
  if (desires_recursion != 1) {
#line 3167
    goto _L___0;
  } else
#line 3167
  if (recurse_delegation != 1) {
    _L___0: /* CIL Label */ 
#line 3172
    while (1) {
#line 3173
      spot_data = mhash_get(bighash, lookfor);
#line 3174
      point = (rr *)spot_data.value;
#line 3177
      if ((unsigned long )spot_data.value != (unsigned long )((void *)0)) {
#line 3177
        if (spot_data.datatype == 3) {
#line 3177
          if (point->authoritative != 0U) {
#line 3179
            have_authority = 1;
#line 3182
            tmp___30 = change_rtype(lookfor, 6);
#line 3182
            if (tmp___30 == -1) {
#line 3183
              goto serv_fail;
            }
#line 3185
            spot_data = mhash_get(bighash, lookfor);
#line 3186
            if ((unsigned long )spot_data.value != (unsigned long )((void *)0)) {
#line 3186
              if (spot_data.datatype == 3) {
#line 3187
                nxstore = (rr *)spot_data.value;
              }
            }
#line 3189
            break;
          }
        }
      }
#line 3192
      if ((unsigned long )spot_data.value != (unsigned long )((void *)0)) {
#line 3192
        if (spot_data.datatype == 3) {
#line 3194
          udpsuccess((rr *)spot_data.value, (int )header.id, sock, (struct sockaddr_in *)0,
                     origq, spot_data.point, 0, desires_recursion, ect, 0, 0);
#line 3196
          js_destroy(lookfor);
#line 3196
          js_destroy(origq);
#line 3196
          js_destroy(lc);
#line 3197
          return (1);
        }
      }
#line 3172
      tmp___31 = bobbit_label(lookfor);
#line 3172
      if (! (tmp___31 > 0)) {
#line 3172
        break;
      }
    }
  }
  skip_delegation_ns: 
#line 3206
  if (dos_protection_level > 17) {
#line 3207
    goto skip_starwhitis;
  }
#line 3214
  if (bind_star_handling >= 1) {
#line 3215
    tmp___32 = js_copy(origq, lookfor);
#line 3215
    if (tmp___32 == -1) {
#line 3216
      goto serv_fail;
    }
#line 3217
    tmp___33 = fold_case(lookfor);
#line 3217
    if (tmp___33 == -1) {
#line 3218
      goto serv_fail;
    }
#line 3221
    tmp___34 = change_rtype(lookfor, 255);
#line 3221
    if (tmp___34 == -1) {
#line 3222
      goto serv_fail;
    }
#line 3224
    spot_data = mhash_get(bighash, lookfor);
#line 3225
    if ((unsigned long )spot_data.value != (unsigned long )((void *)0)) {
#line 3225
      if (spot_data.datatype == 6) {
#line 3226
        always_not_there = 4;
#line 3227
        goto skip_starwhitis;
      }
    }
  }
#line 3235
  tmp___35 = js_copy(origq, lookfor);
#line 3235
  if (tmp___35 == -1) {
#line 3236
    goto serv_fail;
  }
#line 3238
  tmp___36 = fold_case(lookfor);
#line 3238
  if (tmp___36 == -1) {
#line 3239
    goto serv_fail;
  }
#line 3242
  tmp___37 = make_starlabel(lookfor);
#line 3242
  if (tmp___37 == -1) {
#line 3243
    goto serv_fail;
  }
#line 3247
  spot_data = mhash_get(bighash, lookfor);
#line 3248
  if ((unsigned long )spot_data.value != (unsigned long )((void *)0)) {
#line 3248
    if (spot_data.datatype == 3) {
#line 3249
      udpstar((rr *)spot_data.value, (int )header.id, sock, (struct sockaddr_in *)0,
              origq, origq, desires_recursion, 0, ect);
#line 3251
      js_destroy(lookfor);
#line 3251
      js_destroy(origq);
#line 3251
      js_destroy(lc);
#line 3252
      return (1);
    }
  }
#line 3257
  if (bind_star_handling >= 1) {
#line 3259
    rtype_saver = get_rtype(lookfor);
#line 3260
    tmp___38 = change_rtype(lookfor, 255);
#line 3260
    if (tmp___38 == -1) {
#line 3261
      goto serv_fail;
    }
#line 3263
    spot_data = mhash_get(bighash, lookfor);
#line 3264
    if ((unsigned long )spot_data.value != (unsigned long )((void *)0)) {
#line 3264
      if (spot_data.datatype == 6) {
#line 3265
        always_not_there = 4;
      }
    }
#line 3267
    tmp___39 = change_rtype(lookfor, rtype_saver);
#line 3267
    if (tmp___39 == -1) {
#line 3268
      goto serv_fail;
    }
  }
#line 3275
  if (bind_star_handling == 2) {
#line 3277
    r = star_collision(lookfor, bighash);
#line 3278
    if (r == -1) {
#line 3279
      goto serv_fail;
    } else
#line 3280
    if (r == 1) {
#line 3281
      udpnotfound(nxstore, (int )header.id, sock, (struct sockaddr_in *)0, origq,
                  0, desires_recursion, ect, always_not_there);
#line 3283
      js_destroy(lookfor);
#line 3283
      js_destroy(origq);
#line 3283
      js_destroy(lc);
#line 3284
      return (1);
    }
  }
#line 3291
  while (1) {
#line 3291
    tmp___42 = bobbit_starlabel(lookfor);
#line 3291
    if (! (tmp___42 > 0)) {
#line 3291
      break;
    }
#line 3292
    rtype_saver___0 = 1;
#line 3294
    if (bind_star_handling >= 1) {
#line 3295
      rtype_saver___0 = get_rtype(lookfor);
    }
#line 3297
    spot_data = mhash_get(bighash, lookfor);
#line 3298
    point = (rr *)spot_data.value;
#line 3299
    if ((unsigned long )spot_data.value != (unsigned long )((void *)0)) {
#line 3299
      if (spot_data.datatype == 3) {
#line 3302
        udpstar((rr *)spot_data.value, (int )header.id, sock, (struct sockaddr_in *)0,
                origq, origq, desires_recursion, 0, ect);
#line 3304
        js_destroy(lookfor);
#line 3304
        js_destroy(origq);
#line 3304
        js_destroy(lc);
#line 3305
        return (1);
      } else {
#line 3299
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 3309
    if (bind_star_handling >= 1) {
#line 3310
      tmp___40 = change_rtype(lookfor, 255);
#line 3310
      if (tmp___40 == -1) {
#line 3311
        goto serv_fail;
      }
#line 3313
      spot_data = mhash_get(bighash, lookfor);
#line 3314
      if ((unsigned long )spot_data.value != (unsigned long )((void *)0)) {
#line 3314
        if (spot_data.datatype == 6) {
#line 3316
          always_not_there = 4;
        } else {
#line 3314
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 3321
      if (bind_star_handling == 2) {
#line 3323
        r___0 = star_collision(lookfor, bighash);
#line 3324
        if (r___0 == -1) {
#line 3325
          goto serv_fail;
        } else
#line 3326
        if (r___0 == 1) {
#line 3327
          udpnotfound(nxstore, (int )header.id, sock, (struct sockaddr_in *)0, origq,
                      0, desires_recursion, ect, always_not_there & 3);
#line 3329
          js_destroy(lookfor);
#line 3329
          js_destroy(origq);
#line 3329
          js_destroy(lc);
#line 3330
          return (1);
        }
      }
#line 3334
      tmp___41 = change_rtype(lookfor, rtype_saver___0);
#line 3334
      if (tmp___41 == -1) {
#line 3335
        goto serv_fail;
      }
    }
  }
#line 3348
  if (dos_protection_level > 7) {
#line 3349
    goto skip_starwhitis;
  }
#line 3354
  tmp___43 = js_copy(origq, lookfor);
#line 3354
  if (tmp___43 == -1) {
#line 3355
    goto serv_fail;
  }
#line 3356
  tmp___44 = fold_case(lookfor);
#line 3356
  if (tmp___44 == -1) {
#line 3357
    goto serv_fail;
  }
#line 3359
  tmp___45 = make_starlabel(lookfor);
#line 3359
  if (tmp___45 == -1) {
#line 3360
    goto serv_fail;
  }
#line 3362
  tmp___46 = change_rtype(lookfor, 5);
#line 3362
  if (tmp___46 == -1) {
#line 3363
    goto serv_fail;
  }
#line 3366
  spot_data = mhash_get(bighash, lookfor);
#line 3367
  if ((unsigned long )spot_data.value != (unsigned long )((void *)0)) {
#line 3367
    if (spot_data.datatype == 3) {
#line 3369
      tmp___47 = js_copy(origq, lookfor);
#line 3369
      if (tmp___47 == -1) {
#line 3370
        goto serv_fail;
      }
#line 3371
      tmp___48 = change_rtype(lookfor, 5);
#line 3371
      if (tmp___48 == -1) {
#line 3372
        goto serv_fail;
      }
#line 3373
      udpstar((rr *)spot_data.value, (int )header.id, sock, (struct sockaddr_in *)0,
              origq, lookfor, desires_recursion, 0, ect);
#line 3375
      js_destroy(lookfor);
#line 3375
      js_destroy(origq);
#line 3375
      js_destroy(lc);
#line 3376
      return (1);
    }
  }
#line 3380
  while (1) {
#line 3380
    tmp___53 = bobbit_starlabel(lookfor);
#line 3380
    if (! (tmp___53 > 0)) {
#line 3380
      break;
    }
#line 3381
    spot_data = mhash_get(bighash, lookfor);
#line 3384
    if (bind_star_handling >= 1) {
#line 3386
      rtype_saver___1 = get_rtype(lookfor);
#line 3387
      tmp___49 = change_rtype(lookfor, 255);
#line 3387
      if (tmp___49 == -1) {
#line 3388
        goto serv_fail;
      }
#line 3390
      spot_data = mhash_get(bighash, lookfor);
#line 3391
      if ((unsigned long )spot_data.value != (unsigned long )((void *)0)) {
#line 3391
        if (spot_data.datatype == 6) {
#line 3393
          goto skip_starwhitis;
        }
      }
#line 3395
      tmp___50 = change_rtype(lookfor, rtype_saver___1);
#line 3395
      if (tmp___50 == -1) {
#line 3396
        goto serv_fail;
      }
    }
#line 3400
    if ((unsigned long )spot_data.value != (unsigned long )((void *)0)) {
#line 3400
      if (spot_data.datatype == 3) {
#line 3401
        tmp___51 = js_copy(origq, lookfor);
#line 3401
        if (tmp___51 == -1) {
#line 3402
          goto serv_fail;
        }
#line 3403
        tmp___52 = change_rtype(lookfor, 5);
#line 3403
        if (tmp___52 == -1) {
#line 3404
          goto serv_fail;
        }
#line 3405
        udpstar((rr *)spot_data.value, (int )header.id, sock, (struct sockaddr_in *)0,
                origq, lookfor, desires_recursion, 0, ect);
#line 3407
        js_destroy(lookfor);
#line 3407
        js_destroy(origq);
#line 3407
        js_destroy(lc);
#line 3408
        return (1);
      }
    }
  }
  skip_starwhitis: 
#line 3418
  if (default_zonefile_enabled == 1) {
#line 3421
    tmp___54 = js_copy(origq, lookfor);
#line 3421
    if (tmp___54 == -1) {
#line 3422
      goto serv_fail;
    }
#line 3424
    while (1) {
#line 3424
      labels = bobbit_starlabel_end(lookfor);
#line 3424
      if (! (labels > 0)) {
#line 3424
        break;
      }
#line 3433
      if (labels > 120) {
#line 3434
        continue;
      }
#line 3435
      spot_data = mhash_get(bighash, lookfor);
#line 3436
      point = (rr *)spot_data.value;
#line 3437
      if ((unsigned long )point != (unsigned long )((rr *)0)) {
#line 3437
        if (spot_data.datatype == 3) {
#line 3438
          udpstar(point, (int )header.id, sock, (struct sockaddr_in *)0, origq, origq,
                  desires_recursion, labels, ect);
#line 3440
          js_destroy(lookfor);
#line 3440
          js_destroy(origq);
#line 3440
          js_destroy(lc);
#line 3441
          return (1);
        }
      }
#line 3445
      store_rtype = get_rtype(lookfor);
#line 3446
      if (store_rtype == -1) {
#line 3447
        goto serv_fail;
      }
#line 3449
      tmp___55 = change_rtype(lookfor, 255);
#line 3449
      if (tmp___55 == -1) {
#line 3450
        goto serv_fail;
      }
#line 3452
      spot_data = mhash_get(bighash, lookfor);
#line 3453
      tmp___56 = change_rtype(lookfor, store_rtype);
#line 3453
      if (tmp___56 == -1) {
#line 3454
        goto serv_fail;
      }
#line 3456
      if ((unsigned long )spot_data.value != (unsigned long )((void *)0)) {
#line 3456
        if (spot_data.datatype == 6) {
#line 3457
          always_not_there = 4;
        }
      }
    }
#line 3465
    tmp___57 = change_rtype(lookfor, 6);
#line 3465
    if (tmp___57 == -1) {
#line 3466
      js_destroy(lookfor);
#line 3466
      js_destroy(origq);
#line 3466
      js_destroy(lc);
#line 3467
      return (-1);
    }
#line 3469
    spot_data = mhash_get(bighash, lookfor);
#line 3470
    point = (rr *)spot_data.value;
#line 3471
    if ((unsigned long )point == (unsigned long )((rr *)0)) {
#line 3472
      js_destroy(lookfor);
#line 3472
      js_destroy(origq);
#line 3472
      js_destroy(lc);
#line 3473
      return (-1);
    } else
#line 3471
    if (spot_data.datatype != 3) {
#line 3472
      js_destroy(lookfor);
#line 3472
      js_destroy(origq);
#line 3472
      js_destroy(lc);
#line 3473
      return (-1);
    }
#line 3475
    udpnotfound(point, (int )header.id, sock, (struct sockaddr_in *)0, origq, 0, desires_recursion,
                ect, always_not_there);
#line 3477
    js_destroy(lookfor);
#line 3477
    js_destroy(origq);
#line 3477
    js_destroy(lc);
#line 3478
    return (1);
  }
  recursive_call: 
#line 3484
  if (have_authority == 0) {
#line 3484
    if (default_zonefile_enabled != 1) {
#line 3491
      if (has_recursive_authority == 1) {
#line 3491
        if (desires_recursion == 1) {
#line 3493
          if ((int )ect->type != 4) {
#line 3494
            js_destroy(lookfor);
#line 3494
            js_destroy(origq);
#line 3494
            js_destroy(lc);
#line 3495
            return (-1);
          }
#line 3499
          z = (struct sockaddr_in *)ect->d;
#line 3500
          launch_thread((int )header.id, sock, *z, origq);
        } else {
#line 3504
          udperror(sock, raw, (struct sockaddr_in *)0, (js_string *)0, 5, (char *)"I\'m sorry Dave (recurse attempt)",
                   3, desires_recursion, ect, 1);
        }
      } else {
#line 3504
        udperror(sock, raw, (struct sockaddr_in *)0, (js_string *)0, 5, (char *)"I\'m sorry Dave (recurse attempt)",
                 3, desires_recursion, ect, 1);
      }
#line 3506
      js_destroy(lookfor);
#line 3507
      js_destroy(origq);
#line 3508
      js_destroy(lc);
#line 3509
      return (1);
    }
  }
#line 3515
  udpnotfound(nxstore, (int )header.id, sock, (struct sockaddr_in *)0, origq, 0, desires_recursion,
              ect, always_not_there);
#line 3517
  js_destroy(lookfor);
#line 3517
  js_destroy(origq);
#line 3517
  js_destroy(lc);
#line 3519
  return (1);
  serv_fail: 
#line 3524
  js_destroy(origq);
#line 3525
  if ((unsigned long )lc != (unsigned long )((js_string *)0)) {
#line 3526
    js_destroy(lc);
  }
#line 3528
  if (no_fingerprint != 1) {
#line 3529
    udperror(sock, raw, (struct sockaddr_in *)0, lookfor, 2, (char *)"serv_fail in proc_query",
             2, desires_recursion, ect, 1);
  }
#line 3531
  js_destroy(lookfor);
#line 3532
  return (-1);
  not_impl: 
#line 3535
  js_destroy(origq);
#line 3536
  js_destroy(lc);
#line 3537
  if (no_fingerprint != 1) {
#line 3538
    udperror(sock, raw, (struct sockaddr_in *)0, lookfor, 4, (char *)"not_impl in proc_query",
             2, desires_recursion, ect, 1);
  }
#line 3540
  js_destroy(lookfor);
#line 3541
  return (-1);
}
}
#line 3554 "MaraDNS.c"
int udp_ipv4_bind(int *sockets , ipv4pair *addresses ) 
{ int len_inet ;
  struct sockaddr_in dns_udp ;
  int counter ;
  int tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  __uint16_t tmp___2 ;
  __uint32_t tmp___3 ;
  int tmp___4 ;

  {
#line 3560
  if ((unsigned long )sockets == (unsigned long )((int *)0)) {
#line 3561
    return (-1);
  }
#line 3563
  counter = 0;
#line 3566
  while (1) {
#line 3566
    if (counter < 500) {
#line 3566
      if (! ((addresses + counter)->ip != 4294967295U)) {
#line 3566
        break;
      }
    } else {
#line 3566
      break;
    }
#line 3568
    tmp = socket(2, 2, 0);
#line 3568
    *(sockets + counter) = tmp;
#line 3568
    if (tmp == -1) {
#line 3569
      return (-1);
    }
#line 3572
    tmp___1 = __builtin_object_size((void *)(& dns_udp), 0);
#line 3572
    if (tmp___1 != 0xffffffffffffffffUL) {
#line 3572
      tmp___0 = __builtin_object_size((void *)(& dns_udp), 0);
#line 3572
      __builtin___memset_chk((void *)(& dns_udp), 0, sizeof(dns_udp), tmp___0);
    } else {
#line 3572
      __inline_memset_chk((void *)(& dns_udp), 0, sizeof(dns_udp));
    }
#line 3573
    dns_udp.sin_family = (sa_family_t )2;
#line 3576
    tmp___2 = _OSSwapInt16((__uint16_t )dns_port);
#line 3576
    dns_udp.sin_port = (__uint16_t )((int )tmp___2);
#line 3577
    tmp___3 = _OSSwapInt32((addresses + counter)->ip);
#line 3577
    dns_udp.sin_addr.s_addr = tmp___3;
#line 3577
    if (dns_udp.sin_addr.s_addr == 4294967295U) {
#line 3579
      return (-1);
    }
#line 3581
    len_inet = (int )sizeof(dns_udp);
#line 3585
    tmp___4 = bind(*(sockets + counter), (struct sockaddr  const  *)((struct sockaddr *)(& dns_udp)),
                   (socklen_t )len_inet);
#line 3585
    if (tmp___4 == -1) {
#line 3586
      return (-1);
    }
#line 3588
    counter ++;
  }
#line 3592
  return (1);
}
}
#line 3659 "MaraDNS.c"
ipv4pair *get_bind_addr_list(void) 
{ 

  {
#line 3660
  return (bind_addresses);
}
}
#line 3666 "MaraDNS.c"
ipv4pair *get_synthip_list(void) 
{ 

  {
#line 3667
  if (csv2_synthip_list[0].ip == 4294967295U) {
#line 3668
    return (bind_addresses);
  }
#line 3670
  return (csv2_synthip_list);
}
}
#line 3682 "MaraDNS.c"
int getudp(int *sock , ipv4pair *addr , conn *ect , js_string *data , int max_len ,
           int have_ipv6_address ) 
{ int len_inet ;
  int counter ;
  int len ;
  fd_set rx_fd ;
  int select_output ;
  int max_socket ;
  struct timeval timeout ;
  struct sockaddr_in *ipv4_client ;
  int tmp ;
  int __fd ;
  void *tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;

  {
#line 3698
  if ((unsigned long )ect == (unsigned long )((conn *)0)) {
#line 3699
    return (-1);
  } else
#line 3698
  if ((unsigned long )data == (unsigned long )((js_string *)0)) {
#line 3699
    return (-1);
  }
#line 3700
  tmp = js_has_sanity(data);
#line 3700
  if (tmp == -1) {
#line 3701
    return (-1);
  }
#line 3702
  if (data->unit_size != 1U) {
#line 3703
    return (-1);
  }
#line 3704
  if (max_len < 0) {
#line 3705
    return (-1);
  } else
#line 3704
  if ((unsigned int )max_len >= data->max_count) {
#line 3705
    return (-1);
  }
#line 3707
  __builtin_bzero((void *)(& rx_fd), sizeof(rx_fd));
#line 3708
  counter = 0;
#line 3709
  max_socket = 0;
#line 3710
  while (1) {
#line 3710
    if (counter < 500) {
#line 3710
      if (! ((addr + counter)->ip != 4294967295U)) {
#line 3710
        break;
      }
    } else {
#line 3710
      break;
    }
#line 3711
    while (1) {
#line 3711
      __fd = *(sock + counter);
#line 3711
      rx_fd.fds_bits[(unsigned long )__fd / (sizeof(__int32_t ) * 8UL)] |= 1 << (unsigned long )__fd % (sizeof(__int32_t ) * 8UL);
#line 3711
      break;
    }
#line 3712
    if (*(sock + counter) + 1 > max_socket) {
#line 3713
      max_socket = *(sock + counter) + 1;
    }
#line 3715
    counter ++;
  }
#line 3728
  if (max_socket == 0) {
#line 3729
    return (-1);
  }
#line 3732
  timeout.tv_sec = (__darwin_time_t )1;
#line 3733
  timeout.tv_usec = 0;
#line 3736
  select_output = select(max_socket, & rx_fd, (fd_set *)((void *)0), (fd_set *)((void *)0),
                         & timeout);
#line 3738
  if (select_output <= 0) {
#line 3739
    return (-1);
  }
#line 3743
  counter = 0;
#line 3744
  while (1) {
#line 3744
    if (counter < 500) {
#line 3744
      if (! ((addr + counter)->ip != 4294967295U)) {
#line 3744
        break;
      }
    } else {
#line 3744
      break;
    }
#line 3745
    tmp___2 = __darwin_fd_isset(*(sock + counter), (struct fd_set  const  *)(& rx_fd));
#line 3745
    if (tmp___2) {
#line 3746
      len_inet = (int )sizeof(struct sockaddr_in );
#line 3747
      ect->addrlen = len_inet;
#line 3749
      tmp___0 = js_alloc(1, (int )sizeof(struct sockaddr_in ));
#line 3749
      ipv4_client = (struct sockaddr_in *)tmp___0;
#line 3750
      if ((unsigned long )ipv4_client == (unsigned long )((struct sockaddr_in *)0)) {
#line 3751
        return (-1);
      }
#line 3756
      tmp___1 = recvfrom(*(sock + counter), (void *)data->string, (size_t )max_len,
                         0, (struct sockaddr *)ipv4_client, (socklen_t *)(& ect->addrlen));
#line 3756
      len = (int )tmp___1;
#line 3759
      if (len < 0) {
#line 3760
        js_dealloc((void *)ipv4_client);
#line 3761
        return (-1);
      }
#line 3763
      ect->type = (unsigned char)4;
#line 3764
      ect->d = (void *)ipv4_client;
#line 3766
      data->unit_count = (unsigned int )len;
#line 3768
      return (*(sock + counter));
    }
#line 3770
    counter ++;
  }
#line 3810
  ect->type = (unsigned char)0;
#line 3811
  ect->d = (void *)0;
#line 3812
  return (-1);
}
}
#line 3820 "MaraDNS.c"
rr *init_ra_data(void) 
{ js_string *rq ;
  js_string *rv ;
  rr *lra_data ;
  void *tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  struct rr *tmp___2 ;
  js_string *tmp___3 ;

  {
#line 3825
  rq = js_create(256U, 1U);
#line 3826
  rv = js_create(256U, 1U);
#line 3827
  if ((unsigned long )rq == (unsigned long )((js_string *)0)) {
#line 3828
    harderror((char *)"reject_aaaa error 1");
  } else
#line 3827
  if ((unsigned long )rv == (unsigned long )((js_string *)0)) {
#line 3828
    harderror((char *)"reject_aaaa error 1");
  }
#line 3830
  tmp = js_alloc(1, (int )sizeof(rr ));
#line 3830
  lra_data = (rr *)tmp;
#line 3830
  if ((unsigned long )lra_data == (unsigned long )((rr *)0)) {
#line 3831
    harderror((char *)"reject_aaaa error 2");
  }
#line 3835
  init_rr(lra_data);
#line 3837
  tmp___1 = (uint32_t )0;
#line 3837
  lra_data->authoritative = tmp___1;
#line 3837
  tmp___0 = tmp___1;
#line 3837
  lra_data->ttl = tmp___0;
#line 3837
  lra_data->expire = (int64_t )tmp___0;
#line 3838
  lra_data->rr_type = (uint16_t )0;
#line 3838
  tmp___2 = (struct rr *)0;
#line 3838
  lra_data->ip = tmp___2;
#line 3838
  lra_data->next = tmp___2;
#line 3839
  tmp___3 = (js_string *)0;
#line 3839
  lra_data->data = tmp___3;
#line 3839
  lra_data->query = tmp___3;
#line 3839
  lra_data->seen = (char)0;
#line 3840
  lra_data->zap = (fila *)0;
#line 3840
  lra_data->ptr = (js_string *)0;
#line 3843
  js_addbyte(rq, (unsigned char)0);
#line 3844
  js_adduint16(rq, 6);
#line 3848
  js_addbyte(rv, (unsigned char)0);
#line 3851
  js_addbyte(rv, (unsigned char)1);
#line 3851
  js_addbyte(rv, (unsigned char )'m');
#line 3852
  js_addbyte(rv, (unsigned char)1);
#line 3852
  js_addbyte(rv, (unsigned char )'m');
#line 3853
  js_addbyte(rv, (unsigned char)1);
#line 3853
  js_addbyte(rv, (unsigned char )'m');
#line 3854
  js_addbyte(rv, (unsigned char)0);
#line 3856
  js_adduint16(rv, 0);
#line 3856
  js_adduint16(rv, 1);
#line 3858
  js_adduint16(rv, 0);
#line 3858
  js_adduint16(rv, 60);
#line 3860
  js_adduint16(rv, 0);
#line 3860
  js_adduint16(rv, 60);
#line 3862
  js_adduint16(rv, 0);
#line 3862
  js_adduint16(rv, 60);
#line 3864
  js_adduint16(rv, 0);
#line 3864
  js_adduint16(rv, 60);
#line 3867
  lra_data->expire = (int64_t )0;
#line 3868
  lra_data->ttl = (uint32_t )60;
#line 3869
  lra_data->authoritative = (uint32_t )1;
#line 3870
  lra_data->rr_type = (uint16_t )6;
#line 3871
  lra_data->data = rv;
#line 3872
  lra_data->query = rq;
#line 3873
  return (lra_data);
}
}
#line 3878 "MaraDNS.c"
int main(int argc , char **argv ) 
{ js_string *mararc_loc ;
  js_string *errors ;
  js_string *bind_address ;
  js_string *ipv6_bind_address ;
  js_string *csv2_synthip_address ;
  js_string *ipv4_bind_address ;
  js_string *incoming ;
  js_string *uncomp ;
  js_string *verbstr ;
  unsigned char chroot_zt[255] ;
  uid_t uid ;
  gid_t gid ;
  int errorn ;
  int value___0 ;
  int maxprocs ;
  int counter ;
  int sock[514] ;
  int cache_size ;
  int min_ttl_n ;
  int min_ttl_c ;
  int timestamp_type___0 ;
  int max_glueless ;
  int max_q_total ;
  int timeout ;
  int handle_noreply___0 ;
  int retry_cycles___0 ;
  int thread_overhead ;
  int verbose_query___0 ;
  struct sockaddr client ;
  struct sockaddr_in *clin ;
  struct rlimit rlim ;
  int have_ipv6_address ;
  int default_dos_level ;
  int recurse_min_bind_port___0 ;
  int recurse_number_ports___0 ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  uid_t tmp___45 ;
  int tmp___46 ;
  int *tmp___47 ;
  int tmp___48 ;
  js_string *zone ;
  int q ;
  int tmp___49 ;
  int tmp___50 ;
  int sock_num ;
  conn ect ;
  __uint32_t tmp___51 ;
  int tmp___52 ;
  __uint32_t tmp___53 ;
  int tmp___54 ;

  {
#line 3880
  mararc_loc = (js_string *)0;
#line 3880
  errors = (js_string *)0;
#line 3880
  bind_address = (js_string *)0;
#line 3880
  ipv6_bind_address = (js_string *)0;
#line 3880
  csv2_synthip_address = (js_string *)0;
#line 3880
  ipv4_bind_address = (js_string *)0;
#line 3880
  incoming = (js_string *)0;
#line 3880
  uncomp = (js_string *)0;
#line 3880
  verbstr = (js_string *)0;
#line 3895
  min_ttl_n = 300;
#line 3895
  min_ttl_c = 300;
#line 3896
  timestamp_type___0 = 5;
#line 3902
  handle_noreply___0 = 1;
#line 3904
  retry_cycles___0 = 2;
#line 3906
  thread_overhead = 536870912;
#line 3916
  verbose_query___0 = 0;
#line 3918
  clin = (struct sockaddr_in *)0;
#line 3922
  have_ipv6_address = 0;
#line 3923
  default_dos_level = 78;
#line 3934
  recurse_min_bind_port___0 = 15000;
#line 3935
  recurse_number_ports___0 = 4096;
#line 3938
  tmp___0 = __builtin_object_size((void *)(& client), 0);
#line 3938
  if (tmp___0 != 0xffffffffffffffffUL) {
#line 3938
    tmp = __builtin_object_size((void *)(& client), 0);
#line 3938
    __builtin___memset_chk((void *)(& client), 0, sizeof(client), tmp);
  } else {
#line 3938
    __inline_memset_chk((void *)(& client), 0, sizeof(client));
  }
#line 3939
  clin = (struct sockaddr_in *)(& client);
#line 3948
  mararc_loc = js_create(256U, 1U);
#line 3948
  if ((unsigned long )mararc_loc == (unsigned long )((js_string *)0)) {
#line 3949
    harderror((char *)"Could not create mararc_loc string");
  }
#line 3950
  tmp___1 = js_set_encode(mararc_loc, 3);
#line 3950
  if (tmp___1 == -1) {
#line 3951
    harderror((char *)"Could not set locale for mararc_loc string");
  }
#line 3953
  errors = js_create(256U, 1U);
#line 3953
  if ((unsigned long )errors == (unsigned long )((js_string *)0)) {
#line 3954
    harderror((char *)"Could not create errors string");
  }
#line 3955
  tmp___2 = js_set_encode(errors, 3);
#line 3955
  if (tmp___2 == -1) {
#line 3956
    harderror((char *)"Could not set locale for errors string");
  }
#line 3958
  incoming = js_create(768U, 1U);
#line 3958
  if ((unsigned long )incoming == (unsigned long )((js_string *)0)) {
#line 3959
    harderror((char *)"Could not create incoming string");
  }
#line 3960
  tmp___3 = js_set_encode(incoming, 3);
#line 3960
  if (tmp___3 == -1) {
#line 3961
    harderror((char *)"Could not set locale for incoming string");
  }
#line 3963
  uncomp = js_create(768U, 1U);
#line 3963
  if ((unsigned long )uncomp == (unsigned long )((js_string *)0)) {
#line 3964
    harderror((char *)"Could not create uncomp string");
  }
#line 3965
  tmp___4 = js_set_encode(uncomp, 3);
#line 3965
  if (tmp___4 == -1) {
#line 3966
    harderror((char *)"Could not set locale for uncomp string");
  }
#line 3969
  if (argc == 1) {
#line 3970
    tmp___5 = find_mararc(mararc_loc);
#line 3970
    if (tmp___5 == -1) {
#line 3971
      harderror((char *)"Error locating mararc file");
    }
  } else
#line 3973
  if (argc == 2) {
#line 3974
    printf("%s %s\n%s %s\n%s\n", "This is MaraDNS version", "1.4.06", "Compiled on a",
           "Darwin system at reede, 29. juuli 2011. 12:58:22 CEST", "For usage information, \'man maradns\'");
#line 3976
    exit(0);
  } else
#line 3978
  if (argc == 3) {
#line 3979
    tmp___6 = js_qstr2js(mararc_loc, *(argv + 2));
#line 3979
    if (tmp___6 == -1) {
#line 3980
      harderror((char *)"Could not get mararc from command line");
    }
  } else {
#line 3983
    harderror((char *)"Usage: mararc [-f mararc_location]");
  }
#line 3986
  tmp___7 = read_mararc(mararc_loc, errors, & errorn);
#line 3986
  if (tmp___7 == -1) {
#line 3987
    harderror((char *)"Error parsing contents of mararc file");
  }
#line 3989
  js_destroy(mararc_loc);
#line 3990
  if (errorn != 0) {
#line 3992
    if (errorn != -1) {
#line 3994
      printf("%s%d%s", "Error parsing contents of mararc file on line ", errorn, "\n");
    }
#line 3995
    printf("%s", "Error code: ");
#line 3996
    js_show_stdout(errors);
#line 3997
    printf("%s", "\n");
#line 3998
    exit(2);
  }
#line 4002
  verbstr = read_string_kvar((char *)"hide_disclaimer");
#line 4003
  if ((unsigned long )verbstr == (unsigned long )((js_string *)0)) {
#line 4003
    goto _L;
  } else {
#line 4003
    tmp___8 = js_length(verbstr);
#line 4003
    if (tmp___8 != 3) {
      _L: /* CIL Label */ 
#line 4004
      printf("%s", "THIS SOFTWARE IS PROVIDED BY THE AUTHORS \'\'AS IS\'\' AND ANY EXPRESS OR\n");
#line 4005
      printf("%s", "IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n");
#line 4006
      printf("%s", "OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n");
#line 4007
      printf("%s", "IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n");
#line 4008
      printf("%s", "INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n");
#line 4009
      printf("%s", "(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n");
#line 4010
      printf("%s", "SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n");
#line 4011
      printf("%s", "HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n");
#line 4012
      printf("%s", "STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n");
#line 4013
      printf("%s", "IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n");
#line 4014
      printf("%s", "POSSIBILITY OF SUCH DAMAGE.\n");
#line 4015
      printf("\nTo not display this message, add the follwing to your ");
#line 4016
      printf("mararc file:\n\nhide_disclaimer = \"YES\"\n\n");
    }
  }
#line 4018
  js_destroy(verbstr);
#line 4019
  verbstr = (js_string *)0;
#line 4023
  maxprocs = read_numeric_kvar((char *)"maxprocs", 64);
#line 4024
  if (maxprocs == 0) {
#line 4025
    maxprocs = 64;
  }
#line 4028
  if (maxprocs > 5000) {
#line 4029
    maxprocs = 5000;
#line 4030
    mlog((char *)"maxprocs can not be greater than 5000\nSetting maxprocs to 5000");
  }
#line 4034
  rlim.rlim_max = (rlim_t )maxprocs;
#line 4034
  rlim.rlim_cur = rlim.rlim_max;
#line 4039
  tmp___9 = setrlimit(7, (struct rlimit  const  *)(& rlim));
#line 4039
  if (tmp___9 != 0) {
#line 4039
    tmp___10 = __error();
#line 4039
    if (*tmp___10 != 78) {
#line 4040
      sys_harderror((char *)"Unable to set maximum number of processes");
    }
  }
#line 4046
  cache_size = read_numeric_kvar((char *)"maximum_cache_elements", 1024);
#line 4047
  if (cache_size < 32) {
#line 4048
    mlog((char *)"maximum_cache_size has invalid value.  Reverting to default value.");
#line 4049
    cache_size = 1024;
  } else
#line 4047
  if (cache_size > 268435455) {
#line 4048
    mlog((char *)"maximum_cache_size has invalid value.  Reverting to default value.");
#line 4049
    cache_size = 1024;
  }
#line 4053
  log_level = read_numeric_kvar((char *)"verbose_level", 1);
#line 4055
  init_rlog_level(log_level);
#line 4062
  verbstr = read_string_kvar((char *)"notthere_ip");
#line 4063
  if ((unsigned long )verbstr != (unsigned long )((js_string *)0)) {
#line 4064
    notthere_ip = make_notthere_ip(verbstr);
#line 4065
    js_destroy(verbstr);
  }
#line 4067
  verbstr = (js_string *)0;
#line 4080
  bind_star_handling = read_numeric_kvar((char *)"bind_star_handling", 1);
#line 4081
  if (bind_star_handling < 0) {
#line 4082
    harderror((char *)"bind_star_handling must have a value of 0, 1, or 2");
  } else
#line 4081
  if (bind_star_handling > 2) {
#line 4082
    harderror((char *)"bind_star_handling must have a value of 0, 1, or 2");
  }
#line 4094
  remote_admin = read_numeric_kvar((char *)"remote_admin", 0);
#line 4095
  if (remote_admin < 0) {
#line 4096
    harderror((char *)"remote_admin must have a value of 0 or 1");
  } else
#line 4095
  if (remote_admin > 1) {
#line 4096
    harderror((char *)"remote_admin must have a value of 0 or 1");
  }
#line 4100
  timestamp_type___0 = read_numeric_kvar((char *)"timestamp_type", 5);
#line 4101
  set_timestamp(timestamp_type___0);
#line 4104
  min_ttl_n = read_numeric_kvar((char *)"min_ttl", 300);
#line 4105
  min_ttl_c = read_numeric_kvar((char *)"min_ttl_cname", min_ttl_n);
#line 4106
  min_visible_ttl = read_numeric_kvar((char *)"min_visible_ttl", 30);
#line 4107
  if (min_visible_ttl < 5) {
#line 4108
    min_visible_ttl = 5;
  }
#line 4111
  handle_noreply___0 = read_numeric_kvar((char *)"handle_noreply", 1);
#line 4112
  if (handle_noreply___0 < 0) {
#line 4113
    harderror((char *)"handle_noreply must have a value between 0 and 2");
  } else
#line 4112
  if (handle_noreply___0 > 2) {
#line 4113
    harderror((char *)"handle_noreply must have a value between 0 and 2");
  }
#line 4115
  init_handle_noreply(handle_noreply___0);
#line 4117
  retry_cycles___0 = read_numeric_kvar((char *)"retry_cycles", 2);
#line 4118
  if (retry_cycles___0 < 1) {
#line 4119
    harderror((char *)"retry_cycles must have a value between 1 and 31");
  } else
#line 4118
  if (retry_cycles___0 > 31) {
#line 4119
    harderror((char *)"retry_cycles must have a value between 1 and 31");
  }
#line 4121
  init_retry_cycles(retry_cycles___0);
#line 4123
  recurse_min_bind_port___0 = read_numeric_kvar((char *)"recurse_min_bind_port", 15000);
#line 4124
  if (recurse_min_bind_port___0 < 1024) {
#line 4125
    harderror((char *)"recurse_min_bind_port must have a minimum value of 1024");
  }
#line 4127
  recurse_number_ports___0 = read_numeric_kvar((char *)"recurse_number_ports", 4096);
#line 4128
  if (recurse_number_ports___0 < 256) {
#line 4129
    harderror((char *)"recurse_number_ports must have a value between 256 and 32768");
  } else
#line 4128
  if (recurse_number_ports___0 > 32768) {
#line 4129
    harderror((char *)"recurse_number_ports must have a value between 256 and 32768");
  }
#line 4132
  if ((recurse_number_ports___0 & (recurse_number_ports___0 - 1)) != 0) {
#line 4133
    harderror((char *)"recurse_number_ports must be a power of two");
  }
#line 4135
  if (recurse_min_bind_port___0 + recurse_number_ports___0 >= 65535) {
#line 4136
    harderror((char *)"recurse_min_bind_port + recurse_number_ports too large for 16-bit portnum");
  }
#line 4139
  set_port_range(recurse_min_bind_port___0, recurse_number_ports___0);
#line 4144
  set_min_ttl(min_ttl_n, min_ttl_c);
#line 4149
  no_fingerprint = read_numeric_kvar((char *)"no_fingerprint", 0);
#line 4151
  reject_aaaa = read_numeric_kvar((char *)"reject_aaaa", 0);
#line 4152
  reject_ptr = read_numeric_kvar((char *)"reject_ptr", 0);
#line 4153
  if (reject_aaaa != 0) {
#line 4154
    ra_data = init_ra_data();
  } else
#line 4153
  if (reject_ptr != 0) {
#line 4154
    ra_data = init_ra_data();
  }
#line 4159
  rrany_set = read_numeric_kvar((char *)"default_rrany_set", 3);
#line 4165
  max_ar_chain = read_numeric_kvar((char *)"max_ar_chain", 1);
#line 4168
  max_chain = read_numeric_kvar((char *)"max_chain", 8);
#line 4170
  max_total = read_numeric_kvar((char *)"max_total", 20);
#line 4172
  no_cname_warnings = read_numeric_kvar((char *)"no_cname_warnings", 0);
#line 4174
  verbose_query___0 = read_numeric_kvar((char *)"verbose_query", 0);
#line 4177
  dns_port = read_numeric_kvar((char *)"dns_port", 53);
#line 4178
  if (dns_port < 1) {
#line 4179
    harderror((char *)"dns_port must be between 1 and 65530");
#line 4180
    exit(1);
  } else
#line 4178
  if (dns_port > 65530) {
#line 4179
    harderror((char *)"dns_port must be between 1 and 65530");
#line 4180
    exit(1);
  }
#line 4185
  synth_soa_serial = read_numeric_kvar((char *)"synth_soa_serial", 1);
#line 4186
  if (synth_soa_serial < 1) {
#line 4187
    harderror((char *)"Fatal: synth_soa_serial must be 1 or 2\n");
  } else
#line 4186
  if (synth_soa_serial > 2) {
#line 4187
    harderror((char *)"Fatal: synth_soa_serial must be 1 or 2\n");
  }
#line 4197
  verbstr = read_string_kvar((char *)"synth_soa_origin");
#line 4198
  if ((unsigned long )verbstr != (unsigned long )((js_string *)0)) {
#line 4198
    tmp___15 = js_length(verbstr);
#line 4198
    if (tmp___15 > 0) {
#line 4199
      synth_soa_origin = js_create(256U, 1U);
#line 4200
      if ((unsigned long )synth_soa_origin == (unsigned long )((js_string *)0)) {
#line 4201
        harderror((char *)"Fatal: can not create synth_soa_origin string");
      }
#line 4203
      tmp___11 = js_qstr2js(synth_soa_origin, (char *)"Z");
#line 4203
      if (tmp___11 != 1) {
#line 4204
        harderror((char *)"Fatal: could not make synth_soa_origin string Z");
      }
#line 4206
      tmp___12 = js_append(verbstr, synth_soa_origin);
#line 4206
      if (tmp___12 == -1) {
#line 4207
        harderror((char *)"Fatal: could not append to synth_soa_origin string");
      }
#line 4210
      tmp___13 = js_qappend((char *)".", synth_soa_origin);
#line 4210
      if (tmp___13 == -1) {
#line 4211
        harderror((char *)"Fatal: could not append final dot to soa_synth_origin");
      }
#line 4214
      tmp___14 = hname_2rfc1035(synth_soa_origin);
#line 4214
      if (tmp___14 <= 0) {
#line 4215
        harderror((char *)"Fatal: Malformed synth_soa_origin value.\nPlease make sure that synth_soa_origin is a valid hostname\n*without* a dot at the end.  For example:\n\n\tsynth_soa_origin = \"example.com\"\n");
      }
    }
  }
#line 4241
  counter = 0;
#line 4241
  while (counter < 511) {
#line 4242
    recurse_acl[counter].ip = 4294967295U;
#line 4241
    counter ++;
  }
#line 4244
  verbstr = read_string_kvar((char *)"recursive_acl");
#line 4245
  if ((unsigned long )verbstr != (unsigned long )((js_string *)0)) {
#line 4245
    tmp___22 = js_length(verbstr);
#line 4245
    if (tmp___22 > 0) {
#line 4246
      recursion_enabled = 1;
#line 4249
      tmp___16 = make_ip_acl(verbstr, recurse_acl, 500, 0);
#line 4249
      if (tmp___16 == -1) {
#line 4250
        harderror((char *)"Could not make ip ACL list for recursive queries");
      }
#line 4253
      max_glueless = read_numeric_kvar((char *)"max_glueless_level", 10);
#line 4254
      if (max_glueless == 0) {
#line 4255
        harderror((char *)"max_glueless_level needs to be a number, and be greater than zero");
      }
#line 4259
      max_q_total = read_numeric_kvar((char *)"max_queries_total", 32);
#line 4260
      if (max_q_total == 0) {
#line 4261
        harderror((char *)"max_queries_total needs to be a number, and be greater than zero");
      }
#line 4265
      timeout = read_numeric_kvar((char *)"timeout_seconds", 2);
#line 4266
      if (timeout < 1) {
#line 4267
        harderror((char *)"timeout_seconds needs to be a number, and be greater than zero");
      }
#line 4270
      counter = init_cache(cache_size, maxprocs, max_glueless, max_q_total, timeout,
                           verbose_query___0);
#line 4272
      thread_overhead += maxprocs * 16777216;
#line 4273
      if (counter < 0) {
#line 4274
        switch (counter) {
        case -7: 
#line 4279
        harderror((char *)"root_servers[\".\"] or upstream_servers[\".\"] must be set in the\nmararc file\ne.g. root_servers[\".\"] = \"198.41.0.4\"\nIn addition, root_servers = {} (or upstream_servers = {}) must preceed this\nline");
        case -11: 
#line 4281
        harderror((char *)"root_servers[\".\"] (or upstream_servers) in the mararc file\nis invalid.\nExample good value: root_servers[\".\"] = \"198.41.0.4\"");
        case -14: 
#line 4283
        harderror((char *)"Both root_servers and upstream_servers are set in the mararc file\nPlease choose one or the other; both can not be active at the same time.");
        default: 
#line 4285
        printf("Error value (for software devlopers): ");
#line 4286
        printf("%d\n", counter);
#line 4287
        harderror((char *)"Init_cache() failed.  If you are seeing this, it is a bug.\nPlease read the MaraDNS FAQ");
        }
      }
#line 4293
      if ((unsigned long )verbstr != (unsigned long )((js_string *)0)) {
#line 4293
        js_destroy(verbstr);
#line 4293
        verbstr = (js_string *)0;
      }
#line 4294
      verbstr = read_string_kvar((char *)"spammers");
#line 4297
      if ((unsigned long )verbstr != (unsigned long )((js_string *)0)) {
#line 4297
        tmp___19 = js_length(verbstr);
#line 4297
        if (tmp___19 > 0) {
#line 4298
          tmp___17 = init_spammers(verbstr);
#line 4298
          if (tmp___17 == -1) {
#line 4299
            harderror((char *)"Could not make spammers list");
          }
        } else {
#line 4297
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 4303
        tmp___18 = init_spammers((js_string *)0);
#line 4303
        if (tmp___18 == -1) {
#line 4304
          harderror((char *)"Could not make spammers list");
        }
      }
#line 4307
      if ((unsigned long )verbstr != (unsigned long )((js_string *)0)) {
#line 4307
        js_destroy(verbstr);
#line 4307
        verbstr = (js_string *)0;
      }
#line 4310
      verbstr = read_string_kvar((char *)"random_seed_file");
#line 4311
      if ((unsigned long )verbstr != (unsigned long )((js_string *)0)) {
#line 4311
        tmp___21 = js_length(verbstr);
#line 4311
        if (tmp___21 > 0) {
#line 4312
          counter = init_rng(verbstr, 0);
#line 4313
          if (counter < 0) {
#line 4314
            switch (counter) {
            case -2: 
#line 4316
            sys_harderror((char *)"Could not open the random_seed_file");
            case -3: 
#line 4318
            harderror((char *)"The random_seed_file needs to be 16 bytes or longer");
            default: 
#line 4320
            harderror((char *)"Init_crypto() failed.  If you are seeing this, it is a bug.\nPlease read the MaraDNS FAQ");
            }
          }
        } else {
#line 4311
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 4324
      if (recurse_acl[0].ip != 4294967295U) {
#line 4326
        if ((unsigned long )verbstr != (unsigned long )((js_string *)0)) {
#line 4326
          js_destroy(verbstr);
#line 4326
          verbstr = (js_string *)0;
        }
#line 4327
        verbstr = js_create(256U, 1U);
#line 4328
        tmp___20 = js_qstr2js(verbstr, (char *)"/dev/urandom");
#line 4328
        if (tmp___20 == -1) {
#line 4329
          harderror((char *)"Could not create kvar_query");
        }
#line 4330
        counter = init_rng(verbstr, 0);
#line 4331
        if (counter < 0) {
#line 4332
          switch (counter) {
          case -2: 
#line 4334
          sys_harderror((char *)"MaraDNS was unable to open up the file /dev/urandom\nMaraDNS needs a random seed for security purposes.  Please create a file \nwith 16 or more bytes of random data in it, and have your mararc file point\nto this random seed as follows:\n\n\trandom_seed_file = \"filename\"\n\nWhere filename is the name of the file\nwith 16 or more bytes of random data.\n");
          case -3: 
#line 4342
          harderror((char *)"The file /dev/urandom is not 16 bytes long.\nThis is very unusual.\n\nMaraDNS needs a random seed for security purposes.  Please create a file \nwith 16 or more bytes of random data in it, and have your mararc file point\nto this random seed as follows:\n\n\trandom_seed_file = \"filename\"\n\nWhere filename is the name of the file\nwith 16 or more bytes of random data.\n");
          default: 
#line 4350
          harderror((char *)"Init_crypto() failed.  If you are seeing this, it is a bug.\nPlease read the MaraDNS FAQ");
          }
        }
      }
    } else {
#line 4356
      thread_overhead = 0;
    }
  } else {
#line 4356
    thread_overhead = 0;
  }
#line 4369
  counter = 0;
#line 4369
  while (counter < 511) {
#line 4370
    admin_acl[counter].ip = 4294967295U;
#line 4369
    counter ++;
  }
#line 4371
  if ((unsigned long )verbstr != (unsigned long )((js_string *)0)) {
#line 4371
    js_destroy(verbstr);
#line 4371
    verbstr = (js_string *)0;
  }
#line 4372
  verbstr = read_string_kvar((char *)"admin_acl");
#line 4373
  if ((unsigned long )verbstr != (unsigned long )((js_string *)0)) {
#line 4373
    tmp___24 = js_length(verbstr);
#line 4373
    if (tmp___24 > 0) {
#line 4374
      tmp___23 = make_ip_acl(verbstr, admin_acl, 500, 0);
#line 4374
      if (tmp___23 == -1) {
#line 4375
        harderror((char *)"Could not make admin_acl list");
      }
    }
  }
#line 4377
  default_dos_level = 78;
#line 4379
  if (admin_acl[0].ip != 4294967295U) {
#line 4380
    default_dos_level = 79;
  }
#line 4388
  debug_delay = read_numeric_kvar((char *)"debug_response_delay", 0);
#line 4391
  debug_msg_level = read_numeric_kvar((char *)"debug_msg_level", 1);
#line 4396
  tmp___45 = geteuid();
#line 4396
  if (tmp___45 == 0U) {
#line 4399
    if ((unsigned long )verbstr != (unsigned long )((js_string *)0)) {
#line 4399
      js_destroy(verbstr);
#line 4399
      verbstr = (js_string *)0;
    }
#line 4400
    verbstr = read_string_kvar((char *)"chroot_dir");
#line 4401
    if ((unsigned long )verbstr == (unsigned long )((js_string *)0)) {
#line 4402
      harderror((char *)"Problem getting chroot kvar.\nYou must have chroot_dir set if you start this as root");
    }
#line 4404
    tmp___25 = js_length(verbstr);
#line 4404
    if (tmp___25 <= 0) {
#line 4405
      harderror((char *)"Problem getting chroot kvar.\nYou must have chroot_dir set if you start this as root");
    }
#line 4406
    tmp___26 = js_js2str(verbstr, (char *)(chroot_zt), 200);
#line 4406
    if (tmp___26 == -1) {
#line 4407
      harderror((char *)"Problem making chroot nt string.\nMake sure the chroot directory is 200 chars or less");
    }
#line 4408
    tmp___27 = chdir((char const   *)((char *)(chroot_zt)));
#line 4408
    if (tmp___27 != 0) {
#line 4409
      sys_harderror((char *)"Problem changing to chroot dir.\nMake sure chroot_dir points to a valid directory");
    }
#line 4411
    tmp___28 = chroot((char const   *)((char *)(chroot_zt)));
#line 4411
    if (tmp___28 != 0) {
#line 4412
      sys_harderror((char *)"Problem changing the root directory.");
    }
#line 4415
    mlog((char *)"Root directory changed");
#line 4424
    bind_address = read_string_kvar((char *)"bind_address");
#line 4425
    csv2_synthip_address = read_string_kvar((char *)"csv2_synthip_list");
#line 4426
    ipv4_bind_address = read_string_kvar((char *)"ipv4_bind_addresses");
#line 4428
    tmp___29 = js_length(ipv4_bind_address);
#line 4428
    if (tmp___29 < 1) {
#line 4428
      tmp___30 = js_length(bind_address);
#line 4428
      if (tmp___30 < 1) {
#line 4429
        harderror((char *)"The mararc variable ipv4_bind_addresses must be set.\nThis is the IP or list of IPs that your MaraDNS DNS server will have.\nThis can be a single IP, such as:\n\n\tipv4_bind_addresses = \"127.0.0.1\"\n\nOr a list of IPs, such as:\n\n\tipv4_bind_addresses = \"127.0.0.1,10.7.14.86\"\n");
      }
    }
#line 4436
    tmp___31 = js_length(ipv4_bind_address);
#line 4436
    if (tmp___31 >= 1) {
#line 4436
      tmp___32 = js_length(bind_address);
#line 4436
      if (tmp___32 >= 1) {
#line 4438
        harderror((char *)"Both bind_address and ipv4_bind_addresses can not be set.");
      }
    }
#line 4440
    counter = 0;
#line 4440
    while (counter < 512) {
#line 4441
      bind_addresses[counter].ip = 4294967295U;
#line 4442
      csv2_synthip_list[counter].ip = 4294967295U;
#line 4443
      sock[counter] = 0;
#line 4440
      counter ++;
    }
#line 4445
    tmp___35 = js_length(bind_address);
#line 4445
    if (tmp___35 >= 1) {
#line 4446
      tmp___33 = make_ip_acl(bind_address, bind_addresses, 500, 0);
#line 4446
      if (tmp___33 == -1) {
#line 4447
        harderror((char *)"Can not make ip acl for the bind addresses\nMake sure you have a correctly formatted value for the bind_address in your\nmararc file");
      }
    } else {
#line 4451
      tmp___34 = make_ip_acl(ipv4_bind_address, bind_addresses, 500, 0);
#line 4451
      if (tmp___34 == -1) {
#line 4452
        harderror((char *)"Can not make ip acl for the ipv4 bind addresses\nMake sure you have a correctly formatted value for the ipv4_bind_address in\nyour mararc file");
      }
    }
#line 4457
    tmp___37 = js_length(csv2_synthip_address);
#line 4457
    if (tmp___37 >= 1) {
#line 4458
      tmp___36 = make_ip_acl(csv2_synthip_address, csv2_synthip_list, 500, 0);
#line 4458
      if (tmp___36 == -1) {
#line 4460
        harderror((char *)"Looks like there is a malformed csv2_synthip_list");
      }
    }
#line 4463
    tmp___38 = udp_ipv4_bind(sock, bind_addresses);
#line 4463
    if (tmp___38 == -1) {
#line 4464
      sys_harderror((char *)"Problem binding to port 53.\n");
    }
#line 4465
    tmp___39 = js_length(bind_address);
#line 4465
    if (tmp___39 >= 1) {
#line 4466
      zjlog((char *)"Binding to address ", bind_address);
    } else {
#line 4468
      zjlog((char *)"Binding to address ", ipv4_bind_address);
    }
#line 4470
    mlog((char *)"Socket opened on UDP port 53");
#line 4471
    js_destroy(bind_address);
#line 4472
    js_destroy(csv2_synthip_address);
#line 4473
    js_destroy(ipv4_bind_address);
#line 4475
    ipv6_bind_address = read_string_kvar((char *)"ipv6_bind_address");
#line 4478
    tmp___40 = js_length(ipv6_bind_address);
#line 4478
    if (tmp___40 >= 1) {
#line 4479
      harderror((char *)"maradns must be compiled as authonly to have ipv6 support\n./configure --authonly ; make will compile maradns thusly\nNote that this will disable recursion and caching");
    }
#line 4510
    tmp___41 = read_numeric_kvar((char *)"maradns_gid", 99);
#line 4510
    gid = (gid_t )tmp___41;
#line 4513
    setgroups(1, (gid_t const   *)(& gid));
#line 4516
    setgid(gid);
#line 4520
    tmp___42 = read_numeric_kvar((char *)"maradns_uid", 99);
#line 4520
    uid = (uid_t )tmp___42;
#line 4521
    if (uid < 10U) {
#line 4522
      harderror((char *)"maradns_uid is less than 10 or not a number.\nThis uid must have a value of 10 or more");
    }
#line 4523
    tmp___43 = setuid(uid);
#line 4523
    if (tmp___43 != 0) {
#line 4524
      sys_harderror((char *)"Could not drop root uid");
    }
#line 4527
    tmp___44 = setuid((uid_t )0);
#line 4527
    if (tmp___44 == 0) {
#line 4528
      sys_harderror((char *)"We seem to still be root");
    }
#line 4530
    mlog((char *)"Root privileges dropped");
  } else {
#line 4541
    harderror((char *)"Running MaraDNS 1.2 as a non-root server support disabled");
  }
#line 4575
  csv2_tilde_handling = read_numeric_kvar((char *)"csv2_tilde_handling", 2);
#line 4578
  if (csv2_tilde_handling < 0) {
#line 4579
    harderror((char *)"csv2_tilde_handling must have a value between 0 and 3");
#line 4581
    exit(1);
  } else
#line 4578
  if (csv2_tilde_handling > 3) {
#line 4579
    harderror((char *)"csv2_tilde_handling must have a value between 0 and 3");
#line 4581
    exit(1);
  }
#line 4584
  recurse_delegation = read_numeric_kvar((char *)"recurse_delegation", 0);
#line 4587
  if (recurse_delegation < 0) {
#line 4588
    harderror((char *)"recurse_delegation must have a value between 0 and 1");
#line 4590
    exit(1);
  } else
#line 4587
  if (recurse_delegation > 1) {
#line 4588
    harderror((char *)"recurse_delegation must have a value between 0 and 1");
#line 4590
    exit(1);
  }
#line 4595
  tmp___46 = read_numeric_kvar((char *)"upstream_port", 53);
#line 4595
  set_upstream_port(tmp___46);
#line 4599
  bighash = (mhash *)0;
#line 4600
  bighash = mhash_create(8);
#line 4601
  if ((unsigned long )bighash == (unsigned long )((mhash *)0)) {
#line 4602
    harderror((char *)"Could not create big hash");
  }
#line 4605
  qual_set_time();
#line 4606
  value___0 = populate_main(bighash, errors, recursion_enabled);
#line 4607
  if (dns_records_served > 0) {
#line 4608
    printf("MaraDNS proudly serves you %d DNS records\n", dns_records_served);
  }
#line 4616
  maxprocs = read_numeric_kvar((char *)"max_mem", (1048576 + thread_overhead) + (cache_size + dns_records_served) * 1536);
#line 4619
  if (maxprocs < 262144) {
#line 4619
    if (maxprocs > 0) {
#line 4619
      maxprocs = 262144;
    }
  }
#line 4620
  if (maxprocs > 0) {
#line 4621
    rlim.rlim_max = (rlim_t )maxprocs;
#line 4621
    rlim.rlim_cur = rlim.rlim_max;
#line 4622
    tmp___48 = setrlimit(5, (struct rlimit  const  *)(& rlim));
#line 4622
    if (tmp___48 != 0) {
#line 4623
      tmp___47 = __error();
#line 4623
      if (*tmp___47 == 78) {
#line 4624
        printf("WARNING: Your system does not allow setting memory allocation limits!");
      } else {
#line 4632
        harderror((char *)"Unable to set memory allocation limits");
      }
    } else {
#line 4636
      printf("MaraDNS maximum memory allocation set to %d bytes\n", maxprocs);
    }
  }
#line 4649
  if (value___0 == 1) {
#line 4650
    default_dos_level = 0;
  }
#line 4653
  if (value___0 == -1) {
#line 4654
    harderror((char *)"Error running populate_main program.  Please read the MaraDNS FAQ");
  } else
#line 4655
  if (value___0 == -2) {
#line 4656
    js_show_stdout(errors);
#line 4657
    printf("%s", "\n");
#line 4658
    harderror((char *)"This error in populate hash is fatal");
  }
#line 4661
  if ((unsigned long )verbstr != (unsigned long )((js_string *)0)) {
#line 4661
    js_destroy(verbstr);
#line 4661
    verbstr = (js_string *)0;
  }
#line 4662
  verbstr = read_string_kvar((char *)"csv2_default_zonefile");
#line 4663
  if ((unsigned long )verbstr != (unsigned long )((js_string *)0)) {
#line 4663
    tmp___50 = js_length(verbstr);
#line 4663
    if (tmp___50 > 0) {
#line 4666
      if (recursion_enabled == 1) {
#line 4667
        harderror((char *)"Default zonefile not permitted when recursion is enabled");
      }
#line 4669
      zone = js_create(12U, 1U);
#line 4669
      if ((unsigned long )zone == (unsigned long )((js_string *)0)) {
#line 4670
        harderror((char *)"Unable to create zone js_string");
      }
#line 4672
      tmp___49 = js_qstr2js(zone, (char *)"*");
#line 4672
      if (tmp___49 == -1) {
#line 4673
        harderror((char *)"Unable to create zone string");
      }
#line 4675
      q = csv2_parse_zone_bighash(zone, verbstr, bighash, 1);
#line 4676
      if (q < 0) {
#line 4677
        printf("Error parsing csv2 default zonefile %d\n", q);
      }
#line 4679
      printf("Csv2 default zonefile parsed\n");
#line 4680
      default_zonefile_enabled = 1;
#line 4681
      default_dos_level = 0;
    }
  }
#line 4686
  dos_protection_level = read_numeric_kvar((char *)"dos_protection_level", default_dos_level);
#line 4689
  mlog((char *)"All RRs have been loaded");
#line 4698
  signal(1, (void (*)(int  ))(& handle_hup));
#line 4708
  decomp_init(log_level);
#line 4711
  fflush(__stdoutp);
#line 4713
  if (log_level >= 3) {
#line 4714
    mlog((char *)"Awaiting data on port 53");
  }
#line 4716
  while (1) {
#line 4719
    ect.type = (unsigned char)0;
#line 4720
    ect.d = (void *)0;
#line 4721
    ect.addrlen = 0;
#line 4723
    if (got_hup_signal != 0) {
#line 4724
      printf("HUP signal sent to MaraDNS process\n");
#line 4725
      printf("Exiting with return value of 8\n");
#line 4726
      exit(8);
    }
#line 4729
    qual_set_time();
#line 4730
    if (log_level >= 50) {
#line 4731
      mlog((char *)"Awaiting data on port 53");
    }
#line 4732
    sock_num = getudp(sock, bind_addresses, & ect, incoming, 512, have_ipv6_address);
#line 4734
    if (sock_num == -1) {
#line 4735
      goto __Cont;
    }
#line 4736
    if (log_level >= 3) {
#line 4737
      mlog((char *)"Message received, processing");
    }
#line 4738
    tmp___52 = decompress_data(incoming, uncomp);
#line 4738
    if (tmp___52 == -1) {
#line 4739
      if (log_level >= 4) {
#line 4740
        if ((int )ect.type == 4) {
#line 4741
          clin = (struct sockaddr_in *)ect.d;
        }
#line 4751
        log_lock();
#line 4752
        show_timestamp();
#line 4753
        printf("%s ", "Query from");
#line 4754
        if ((int )ect.type == 4) {
#line 4755
          tmp___51 = _OSSwapInt32(clin->sin_addr.s_addr);
#line 4755
          debug_show_ip(tmp___51);
        } else {
#line 4763
          printf(" UNKNOWN ");
        }
#line 4766
        printf("has decompression error: ");
#line 4767
        show_esc_stdout(incoming);
#line 4768
        printf("\n");
#line 4769
        log_unlock();
      }
#line 4771
      if ((unsigned long )ect.d != (unsigned long )((void *)0)) {
#line 4772
        js_dealloc(ect.d);
      }
#line 4774
      goto __Cont;
    }
#line 4776
    if (log_level >= 5) {
#line 4777
      log_lock();
#line 4778
      show_timestamp();
#line 4779
      printf("Decompressed packet: ");
#line 4780
      show_esc_stdout(uncomp);
#line 4781
      printf("\n");
#line 4782
      log_unlock();
    }
#line 4784
    if (log_level >= 3) {
#line 4784
      if (uncomp->unit_count > 12U) {
#line 4786
        counter = dlabel_length(uncomp, 12U);
#line 4787
        value___0 = js_readuint16(uncomp, (unsigned int )(12 + counter));
#line 4788
        tmp___54 = js_substr(uncomp, incoming, 12, counter);
#line 4788
        if (tmp___54 != -1) {
#line 4789
          clin = (struct sockaddr_in *)ect.d;
#line 4796
          hname_translate(incoming, value___0);
#line 4798
          log_lock();
#line 4799
          show_timestamp();
#line 4800
          printf("%s: ", "Query from");
#line 4801
          if ((int )ect.type == 4) {
#line 4802
            tmp___53 = _OSSwapInt32(clin->sin_addr.s_addr);
#line 4802
            debug_show_ip(tmp___53);
          } else {
#line 4810
            printf(" UNKNOWN ");
          }
#line 4813
          printf(" ");
#line 4814
          js_show_stdout(incoming);
#line 4815
          printf("\n");
#line 4816
          log_unlock();
        }
      }
    }
#line 4821
    if (debug_delay > 0) {
#line 4822
      sleep((unsigned int )debug_delay);
    }
#line 4825
    proc_query(uncomp, & ect, sock_num);
#line 4827
    if ((unsigned long )ect.d != (unsigned long )((void *)0)) {
#line 4828
      js_dealloc(ect.d);
    }
    __Cont: /* CIL Label */ ;
  }
#line 4834
  exit(7);
}
}
#line 1 "MaraBigHash.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-FbuvHhAI.i","")
#line 73 "../libs/JsStr.h"
int js_str2js(js_string *js , char *string , int count , int size ) ;
#line 76
int js_fgrep(js_string *exp , js_string *js ) ;
#line 103
int js_open_read(js_string *filename , js_file *desc___0 ) ;
#line 106
int js_close(js_file *desc___0 ) ;
#line 107
int js_buf_eof(js_file *desc___0 ) ;
#line 109
int js_buf_getline(js_file *desc___0 , js_string *js ) ;
#line 61 "../libs/MaraHash.h"
int mhash_put(mhash *hash , js_string *key___0 , void *value___0 , int datatype ) ;
#line 64
js_string *mhash_get_js(mhash *hash , js_string *key___0 ) ;
#line 65
int mhash_firstkey(mhash *hash , js_string *key___0 ) ;
#line 66
int mhash_nextkey(mhash *hash , js_string *key___0 ) ;
#line 73
js_string *mhash_get_immutable_key(mhash *hash , js_string *key___0 ) ;
#line 21 "../libs/functions_MaraHash.h"
int mhash_autogrow(mhash *hash ) ;
#line 40
void *mhash_undef(mhash *hash , js_string *key___0 ) ;
#line 45 "../parse/functions_parse.h"
mhash *dvar_raw(int index___0 ) ;
#line 79
int parse_csv1_line(js_string *line___0 , js_string *name , js_string *data , uint32_t *ttl ) ;
#line 90
int bs_process(js_string *in , js_string *out , js_string *sub ) ;
#line 127
int dq_keyword2n(char *in ) ;
#line 23 "../parse/Csv2_functions.h"
int starrecord_to_meta(js_string *rr___0 , int recursive ) ;
#line 24
int add_rr_to_bighash(mhash *bighash___0 , js_string *query , js_string *data , uint32_t ttl ,
                      js_string *zone , uint16_t perms ) ;
#line 41
void human_readable_dns_query(js_string *query , int hide_qtype ) ;
#line 202
int csv2_parse_main_bighash(mhash *main_table , int32_t starwhitis ) ;
#line 122 "functions_server.h"
int add_an(mhash *bighash___0 , js_string *error ) ;
#line 131
int answer_ip_query(int qtype , js_string *qu , js_string *ar ) ;
#line 224
int mhash_add_rr(mhash *hash , js_string *query , js_string *value___0 , uint32_t ttl ,
                 uint32_t authoritative , uint32_t expire , uint16_t perms ) ;
#line 235
int mhash_add_ptr(mhash *hash , js_string *query , js_string *value___0 ) ;
#line 251
int any_add_rr(mhash *hash , js_string *query , rr *data ) ;
#line 258
int any_zap_rr(mhash *hash , js_string *query , rr *data ) ;
#line 52 "MaraBigHash.c"
int cname_warnings_shown  =    0;
#line 60 "MaraBigHash.c"
int warning(js_string *msg , int line___0 ) 
{ 

  {
#line 61
  if (log_level == 0) {
#line 62
    return (1);
  }
#line 63
  printf("%s", "Warning: ");
#line 64
  js_show_stdout(msg);
#line 65
  if (line___0 != -1) {
#line 66
    printf("%s%d", " on line ", line___0);
  }
#line 67
  printf("%s", "\n");
#line 68
  return (1);
}
}
#line 80 "MaraBigHash.c"
int starrecord_to_meta(js_string *rr___0 , int recursive ) 
{ int counter ;
  int tmp ;

  {
#line 83
  tmp = js_has_sanity(rr___0);
#line 83
  if (tmp == -1) {
#line 84
    return (-1);
  }
#line 85
  if (rr___0->unit_size != 1U) {
#line 86
    return (-1);
  }
#line 89
  if (rr___0->unit_count < 2U) {
#line 90
    return (1);
  }
#line 93
  if ((int )*(rr___0->string) == 1) {
#line 93
    if ((int )*(rr___0->string + 1) == 42) {
#line 94
      *(rr___0->string) = (unsigned char )'_';
#line 95
      if (rr___0->unit_count > rr___0->max_count) {
#line 96
        return (-1);
      }
#line 97
      counter = 1;
#line 97
      while ((unsigned int )counter < rr___0->unit_count) {
#line 98
        *(rr___0->string + counter) = *((rr___0->string + counter) + 1);
#line 97
        counter ++;
      }
#line 99
      (rr___0->unit_count) --;
    }
  }
#line 105
  counter = dlabel_length(rr___0, 0U);
#line 106
  counter -= 3;
#line 107
  if (counter < 0) {
#line 108
    return (1);
  }
#line 109
  if ((int )*(rr___0->string + counter) == 1) {
#line 109
    if ((int )*((rr___0->string + counter) + 1) == 42) {
#line 110
      *(rr___0->string + counter) = (unsigned char )'_';
#line 111
      counter ++;
#line 112
      while ((unsigned int )counter < rr___0->unit_count) {
#line 113
        *(rr___0->string + counter) = *((rr___0->string + counter) + 2);
#line 112
        counter ++;
      }
#line 114
      rr___0->unit_count -= 2U;
#line 115
      if (recursive == 1) {
#line 116
        show_timestamp();
#line 117
        printf("Warning: star labels at the end can not be used when recursion is enabled\n");
      }
    }
  }
#line 122
  return (1);
}
}
#line 131 "MaraBigHash.c"
int get_rtype(js_string *js ) 
{ int rtype ;
  int tmp ;

  {
#line 136
  tmp = js_has_sanity(js);
#line 136
  if (tmp == -1) {
#line 137
    return (-1);
  }
#line 138
  if (js->unit_count < 3U) {
#line 139
    return (-1);
  }
#line 142
  rtype = ((int )*((js->string + js->unit_count) - 1) & 255) | (((int )*((js->string + js->unit_count) - 2) & 255) << 8);
#line 145
  return (rtype);
}
}
#line 154 "MaraBigHash.c"
int change_rtype(js_string *js , int newtype ) 
{ int tmp ;

  {
#line 157
  tmp = js_has_sanity(js);
#line 157
  if (tmp == -1) {
#line 158
    return (-1);
  }
#line 159
  if (js->unit_count < 3U) {
#line 160
    return (-1);
  }
#line 161
  if (newtype < 0) {
#line 162
    return (-1);
  } else
#line 161
  if (newtype > 65535) {
#line 162
    return (-1);
  }
#line 165
  *((js->string + js->unit_count) - 1) = (unsigned char )(newtype & 255);
#line 166
  *((js->string + js->unit_count) - 2) = (unsigned char )((newtype & 65280) >> 8);
#line 168
  return (1);
}
}
#line 176 "MaraBigHash.c"
void init_rr(rr *data ) 
{ uint32_t tmp ;
  uint32_t tmp___0 ;
  uint16_t tmp___1 ;
  struct rr *tmp___2 ;
  js_string *tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;

  {
#line 177
  tmp___1 = (uint16_t )0;
#line 177
  data->rr_type = tmp___1;
#line 177
  tmp___0 = (uint32_t )tmp___1;
#line 177
  data->authoritative = tmp___0;
#line 177
  tmp = tmp___0;
#line 177
  data->ttl = tmp;
#line 177
  data->expire = (int64_t )tmp;
#line 178
  tmp___2 = (struct rr *)0;
#line 178
  data->ip = tmp___2;
#line 178
  data->next = tmp___2;
#line 179
  tmp___3 = (js_string *)0;
#line 179
  data->data = tmp___3;
#line 179
  data->query = tmp___3;
#line 180
  data->ptr = (js_string *)0;
#line 181
  data->seen = (char)0;
#line 182
  data->zap = (fila *)0;
#line 183
  tmp___5 = (uint32_t )0;
#line 183
  data->authoritative = tmp___5;
#line 183
  tmp___4 = tmp___5;
#line 183
  data->ttl = tmp___4;
#line 183
  data->expire = (int64_t )tmp___4;
#line 184
  data->perms = (uint16_t )0;
#line 185
  data->list = (struct rr_list *)0;
#line 186
  data->rcode = (char)0;
#line 187
  return;
}
}
#line 196 "MaraBigHash.c"
int mhash_put_rr(mhash *hash , js_string *query , js_string *value___0 , uint32_t ttl ,
                 uint32_t authoritative , uint32_t expire , uint16_t perms ) 
{ rr *data ;
  js_string *new ;
  int ret ;
  int rrtype ;
  void *tmp ;
  int tmp___0 ;
  struct rr *tmp___1 ;
  int tmp___2 ;

  {
#line 199
  data = (rr *)0;
#line 200
  new = (js_string *)0;
#line 203
  tmp = js_alloc(1, (int )sizeof(rr ));
#line 203
  data = (rr *)tmp;
#line 203
  if ((unsigned long )data == (unsigned long )((rr *)0)) {
#line 204
    return (-1);
  }
#line 207
  init_rr(data);
#line 210
  data->expire = (int64_t )0;
#line 211
  data->ttl = ttl;
#line 212
  data->authoritative = authoritative;
#line 213
  data->perms = perms;
#line 215
  rrtype = get_rtype(query);
#line 216
  if (rrtype == -1) {
#line 217
    js_dealloc((void *)data);
#line 218
    return (-1);
  }
#line 220
  if (rrtype < 0) {
#line 221
    js_dealloc((void *)data);
#line 222
    return (-1);
  } else
#line 220
  if (rrtype > 65535) {
#line 221
    js_dealloc((void *)data);
#line 222
    return (-1);
  }
#line 224
  data->rr_type = (uint16_t )rrtype;
#line 227
  new = js_create(value___0->unit_count + 1U, value___0->unit_size);
#line 227
  if ((unsigned long )new == (unsigned long )((js_string *)0)) {
#line 228
    js_dealloc((void *)data);
#line 229
    return (-1);
  }
#line 231
  tmp___0 = js_copy(value___0, new);
#line 231
  if (tmp___0 == -1) {
#line 232
    js_dealloc((void *)data);
#line 233
    js_destroy(new);
#line 234
    return (-1);
  }
#line 237
  data->data = new;
#line 240
  tmp___1 = (struct rr *)0;
#line 240
  data->next = tmp___1;
#line 240
  data->ip = tmp___1;
#line 243
  ret = mhash_put(hash, query, (void *)data, 3);
#line 246
  tmp___2 = any_add_rr(hash, query, data);
#line 246
  if (tmp___2 == -1) {
#line 247
    return (-1);
  }
#line 251
  mhash_autogrow(hash);
#line 259
  data->query = mhash_get_immutable_key(hash, query);
#line 261
  if (ret == -1) {
#line 262
    js_dealloc((void *)data);
#line 263
    js_destroy(new);
#line 264
    return (-1);
  }
#line 267
  return (1);
}
}
#line 276 "MaraBigHash.c"
int mhash_add_rr(mhash *hash , js_string *query , js_string *value___0 , uint32_t ttl ,
                 uint32_t authoritative , uint32_t expire , uint16_t perms ) 
{ rr *data ;
  rr *point ;
  js_string *new ;
  mhash_e spot_data ;
  int rrtype ;
  void *tmp ;
  int tmp___0 ;

  {
#line 285
  tmp = js_alloc(1, (int )sizeof(rr ));
#line 285
  data = (rr *)tmp;
#line 285
  if ((unsigned long )data == (unsigned long )((rr *)0)) {
#line 286
    return (-1);
  }
#line 289
  init_rr(data);
#line 292
  data->expire = (int64_t )0;
#line 293
  data->ttl = ttl;
#line 294
  data->authoritative = authoritative;
#line 295
  data->perms = perms;
#line 298
  rrtype = get_rtype(query);
#line 299
  if (rrtype == -1) {
#line 300
    js_dealloc((void *)data);
#line 301
    return (-1);
  }
#line 303
  if (rrtype < 0) {
#line 304
    js_dealloc((void *)data);
#line 305
    return (-1);
  } else
#line 303
  if (rrtype > 65535) {
#line 304
    js_dealloc((void *)data);
#line 305
    return (-1);
  }
#line 307
  data->rr_type = (uint16_t )rrtype;
#line 310
  new = js_create(value___0->unit_count + 1U, value___0->unit_size);
#line 310
  if ((unsigned long )new == (unsigned long )((js_string *)0)) {
#line 311
    js_dealloc((void *)data);
#line 312
    return (-1);
  }
#line 314
  tmp___0 = js_copy(value___0, new);
#line 314
  if (tmp___0 == -1) {
#line 315
    js_dealloc((void *)data);
#line 316
    js_destroy(new);
#line 317
    return (-1);
  }
#line 320
  data->data = new;
#line 323
  spot_data = mhash_get(hash, query);
#line 324
  if ((unsigned long )spot_data.value == (unsigned long )((void *)0)) {
#line 325
    js_dealloc((void *)data);
#line 326
    js_destroy(new);
#line 327
    return (-1);
  }
#line 331
  if (spot_data.datatype != 3) {
#line 332
    js_dealloc((void *)data);
#line 333
    js_destroy(new);
#line 334
    return (-1);
  }
#line 341
  point = (rr *)spot_data.value;
#line 346
  data->query = point->query;
#line 349
  while (1) {
#line 349
    if ((unsigned long )point->next != (unsigned long )((struct rr *)0)) {
#line 349
      if (! ((int )(point->next)->rr_type != 2)) {
#line 349
        break;
      }
    } else {
#line 349
      break;
    }
#line 350
    point = point->next;
  }
#line 352
  data->next = point->next;
#line 353
  point->next = data;
#line 355
  return (1);
}
}
#line 368 "MaraBigHash.c"
int mhash_add_ptr(mhash *hash , js_string *query , js_string *value___0 ) 
{ rr *point ;
  js_string *new ;
  mhash_e spot_data ;
  int tmp ;

  {
#line 375
  new = js_create(value___0->unit_count + 1U, value___0->unit_size);
#line 375
  if ((unsigned long )new == (unsigned long )((js_string *)0)) {
#line 379
    return (-1);
  }
#line 381
  tmp = js_copy(value___0, new);
#line 381
  if (tmp == -1) {
#line 382
    js_destroy(new);
#line 383
    return (-1);
  }
#line 388
  spot_data = mhash_get(hash, query);
#line 389
  if ((unsigned long )spot_data.value == (unsigned long )((void *)0)) {
#line 390
    js_destroy(new);
#line 391
    return (-1);
  }
#line 395
  if (spot_data.datatype != 3) {
#line 396
    js_destroy(new);
#line 397
    return (-1);
  }
#line 403
  point = (rr *)spot_data.value;
#line 406
  if ((unsigned long )point->ptr != (unsigned long )((js_string *)0)) {
#line 407
    js_destroy(new);
#line 408
    return (1);
  }
#line 411
  point->ptr = new;
#line 412
  return (1);
}
}
#line 426 "MaraBigHash.c"
int mhash_add_ip(mhash *hash , js_string *query , js_string *value___0 ) 
{ rr *data ;
  rr *point ;
  js_string *new ;
  js_string *new_query ;
  mhash_e spot_data ;
  int rrtype ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 428
  data = (rr *)0;
#line 428
  point = (rr *)0;
#line 429
  new = (js_string *)0;
#line 429
  new_query = (js_string *)0;
#line 434
  tmp = js_alloc(1, (int )sizeof(rr ));
#line 434
  data = (rr *)tmp;
#line 434
  if ((unsigned long )data == (unsigned long )((rr *)0)) {
#line 435
    return (-1);
  }
#line 438
  init_rr(data);
#line 441
  rrtype = 1;
#line 442
  data->rr_type = (uint16_t )rrtype;
#line 445
  new = js_create(value___0->unit_count + 1U, value___0->unit_size);
#line 445
  if ((unsigned long )new == (unsigned long )((js_string *)0)) {
#line 446
    js_dealloc((void *)data);
#line 450
    return (-1);
  }
#line 452
  tmp___0 = js_copy(value___0, new);
#line 452
  if (tmp___0 == -1) {
#line 453
    js_dealloc((void *)data);
#line 454
    js_destroy(new);
#line 455
    return (-1);
  }
#line 458
  data->data = new;
#line 461
  spot_data = mhash_get(hash, query);
#line 462
  if ((unsigned long )spot_data.value == (unsigned long )((void *)0)) {
#line 463
    js_dealloc((void *)data);
#line 464
    js_destroy(new);
#line 465
    return (-1);
  }
#line 469
  if (spot_data.datatype != 3) {
#line 470
    js_dealloc((void *)data);
#line 471
    js_destroy(new);
#line 472
    return (-1);
  }
#line 479
  point = (rr *)spot_data.value;
#line 483
  if ((unsigned long )point->ip != (unsigned long )((struct rr *)0)) {
#line 484
    js_dealloc((void *)data);
#line 485
    js_destroy(new);
#line 486
    return (-1);
  }
#line 491
  new_query = js_create((point->data)->unit_count + 3U, 1U);
#line 491
  if ((unsigned long )new_query == (unsigned long )((js_string *)0)) {
#line 492
    js_dealloc((void *)data);
#line 493
    js_destroy(new);
#line 498
    return (-1);
  }
#line 500
  tmp___1 = js_copy(point->data, new_query);
#line 500
  if (tmp___1 == -1) {
#line 501
    js_dealloc((void *)data);
#line 502
    js_destroy(new);
#line 503
    js_destroy(new_query);
#line 504
    return (-1);
  }
#line 506
  tmp___2 = js_adduint16(new_query, 1);
#line 506
  if (tmp___2 == -1) {
#line 507
    js_dealloc((void *)data);
#line 508
    js_destroy(new);
#line 509
    js_destroy(new_query);
#line 510
    return (-1);
  }
#line 515
  data->query = new_query;
#line 518
  data->next = (struct rr *)0;
#line 519
  point->ip = data;
#line 521
  data->expire = point->expire;
#line 522
  data->ttl = point->ttl;
#line 523
  data->authoritative = point->authoritative;
#line 525
  return (1);
}
}
#line 534 "MaraBigHash.c"
int mhash_add_ns(mhash *hash , js_string *query , js_string *ns ) 
{ rr *point ;
  rr *ns_rr ;
  mhash_e spot_data ;
  int rrtype ;

  {
#line 541
  rrtype = get_rtype(query);
#line 542
  if (rrtype == -1) {
#line 543
    return (-1);
  }
#line 545
  if (rrtype < 0) {
#line 546
    return (-1);
  } else
#line 545
  if (rrtype > 65535) {
#line 546
    return (-1);
  }
#line 550
  if (rrtype == 2) {
#line 551
    return (1);
  }
#line 554
  rrtype = get_rtype(ns);
#line 555
  if (rrtype == -1) {
#line 556
    return (-1);
  }
#line 558
  if (rrtype < 0) {
#line 559
    return (-1);
  } else
#line 558
  if (rrtype > 65535) {
#line 559
    return (-1);
  }
#line 563
  if (rrtype != 2) {
#line 564
    return (1);
  }
#line 567
  spot_data = mhash_get(hash, query);
#line 568
  if ((unsigned long )spot_data.value == (unsigned long )((void *)0)) {
#line 569
    return (-1);
  }
#line 572
  if (spot_data.datatype != 3) {
#line 573
    return (-1);
  }
#line 576
  point = (rr *)spot_data.value;
#line 579
  spot_data = mhash_get(hash, ns);
#line 580
  if ((unsigned long )spot_data.value == (unsigned long )((void *)0)) {
#line 581
    return (1);
  }
#line 585
  if (spot_data.datatype != 3) {
#line 586
    return (-1);
  }
#line 589
  ns_rr = (rr *)spot_data.value;
#line 594
  while ((unsigned long )point->next != (unsigned long )((struct rr *)0)) {
#line 595
    point = point->next;
  }
#line 597
  point->next = ns_rr;
#line 599
  return (1);
}
}
#line 613 "MaraBigHash.c"
int parse_csv1s(mhash *maintable , js_string *error , int recursive ) 
{ mhash *csvs ;
  js_string *zone ;
  js_string *udpzone ;
  js_string *filename ;
  js_string *line___0 ;
  js_string *soaline ;
  js_string *pline ;
  js_string *query ;
  js_string *data ;
  js_file *desc___0 ;
  uint32_t ttl ;
  int rr_type ;
  int linenum ;
  int rrnum ;
  int in_ns ;
  int result ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  mhash *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  js_string *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;

  {
#line 620
  linenum = 0;
#line 620
  rrnum = 0;
#line 620
  in_ns = 1;
#line 624
  tmp = js_has_sanity(error);
#line 624
  if (tmp == -1) {
#line 625
    return (-1);
  }
#line 628
  js_qstr2js(error, (char *)"");
#line 632
  udpzone = js_create(128U, 1U);
#line 632
  if ((unsigned long )udpzone == (unsigned long )((js_string *)0)) {
#line 633
    return (-1);
  }
#line 635
  filename = js_create(256U, 1U);
#line 635
  if ((unsigned long )filename == (unsigned long )((js_string *)0)) {
#line 636
    js_destroy(udpzone);
#line 637
    return (-1);
  }
#line 639
  line___0 = js_create(428U, 1U);
#line 639
  if ((unsigned long )line___0 == (unsigned long )((js_string *)0)) {
#line 640
    js_destroy(filename);
#line 641
    js_destroy(udpzone);
#line 642
    return (-1);
  }
#line 644
  tmp___0 = js_set_encode(line___0, 3);
#line 644
  if (tmp___0 == -1) {
#line 645
    js_destroy(line___0);
#line 646
    js_destroy(filename);
#line 647
    js_destroy(udpzone);
#line 648
    return (-1);
  }
#line 650
  pline = js_create(428U, 1U);
#line 650
  if ((unsigned long )pline == (unsigned long )((js_string *)0)) {
#line 651
    js_destroy(line___0);
#line 652
    js_destroy(filename);
#line 653
    js_destroy(udpzone);
#line 654
    return (-1);
  }
#line 656
  tmp___1 = js_set_encode(pline, 3);
#line 656
  if (tmp___1 == -1) {
#line 657
    js_destroy(pline);
#line 658
    js_destroy(line___0);
#line 659
    js_destroy(filename);
#line 660
    js_destroy(udpzone);
#line 661
    return (-1);
  }
#line 663
  soaline = js_create(256U, 1U);
#line 663
  if ((unsigned long )soaline == (unsigned long )((js_string *)0)) {
#line 664
    js_destroy(pline);
#line 665
    js_destroy(line___0);
#line 666
    js_destroy(filename);
#line 667
    js_destroy(udpzone);
#line 668
    return (-1);
  }
#line 670
  tmp___2 = js_set_encode(soaline, 3);
#line 670
  if (tmp___2 == -1) {
#line 671
    js_destroy(soaline);
#line 672
    js_destroy(pline);
#line 673
    js_destroy(line___0);
#line 674
    js_destroy(filename);
#line 675
    js_destroy(udpzone);
#line 676
    return (-1);
  }
#line 678
  query = js_create(256U, 1U);
#line 678
  if ((unsigned long )query == (unsigned long )((js_string *)0)) {
#line 679
    js_destroy(soaline);
#line 680
    js_destroy(pline);
#line 681
    js_destroy(line___0);
#line 682
    js_destroy(filename);
#line 683
    js_destroy(udpzone);
#line 684
    return (-1);
  }
#line 686
  data = js_create(428U, 1U);
#line 686
  if ((unsigned long )data == (unsigned long )((js_string *)0)) {
#line 687
    js_destroy(query);
#line 688
    js_destroy(soaline);
#line 689
    js_destroy(pline);
#line 690
    js_destroy(line___0);
#line 691
    js_destroy(filename);
#line 692
    js_destroy(udpzone);
#line 693
    return (-1);
  }
#line 695
  zone = js_create(256U, 1U);
#line 695
  if ((unsigned long )zone == (unsigned long )((js_string *)0)) {
#line 696
    js_destroy(data);
#line 697
    js_destroy(query);
#line 698
    js_destroy(soaline);
#line 699
    js_destroy(pline);
#line 700
    js_destroy(line___0);
#line 701
    js_destroy(filename);
#line 702
    js_destroy(udpzone);
#line 703
    return (-1);
  }
#line 705
  tmp___3 = js_alloc(1, (int )sizeof(js_file ));
#line 705
  desc___0 = (js_file *)tmp___3;
#line 705
  if ((unsigned long )desc___0 == (unsigned long )((js_file *)0)) {
#line 706
    js_destroy(zone);
#line 707
    js_destroy(data);
#line 708
    js_destroy(query);
#line 709
    js_destroy(soaline);
#line 710
    js_destroy(pline);
#line 711
    js_destroy(line___0);
#line 712
    js_destroy(filename);
#line 713
    js_destroy(udpzone);
#line 714
    return (-1);
  }
#line 720
  tmp___4 = dq_keyword2n((char *)"csv1");
#line 720
  tmp___5 = dvar_raw(tmp___4);
#line 720
  csvs = tmp___5;
#line 722
  if ((unsigned long )csvs == (unsigned long )((mhash *)0)) {
#line 725
    js_destroy(udpzone);
#line 725
    js_destroy(filename);
#line 725
    js_destroy(line___0);
#line 726
    js_destroy(pline);
#line 726
    js_destroy(soaline);
#line 726
    js_destroy(query);
#line 727
    js_destroy(data);
#line 727
    js_destroy(zone);
#line 727
    js_dealloc((void *)desc___0);
#line 728
    return (0);
  }
#line 734
  tmp___6 = mhash_firstkey(csvs, zone);
#line 734
  if (tmp___6 == 0) {
#line 737
    js_destroy(udpzone);
#line 737
    js_destroy(filename);
#line 737
    js_destroy(line___0);
#line 738
    js_destroy(pline);
#line 738
    js_destroy(soaline);
#line 738
    js_destroy(query);
#line 739
    js_destroy(data);
#line 739
    js_destroy(zone);
#line 739
    js_dealloc((void *)desc___0);
#line 740
    return (0);
  }
#line 742
  while (1) {
#line 745
    if ((unsigned long )zone != (unsigned long )((js_string *)0)) {
#line 748
      tmp___7 = js_qstr2js(udpzone, (char *)"A");
#line 748
      if (tmp___7 == -1) {
#line 749
        js_destroy(udpzone);
#line 749
        js_destroy(filename);
#line 749
        js_destroy(line___0);
#line 750
        js_destroy(pline);
#line 750
        js_destroy(soaline);
#line 750
        js_destroy(query);
#line 751
        js_destroy(data);
#line 751
        js_destroy(zone);
#line 751
        js_dealloc((void *)desc___0);
#line 752
        return (-1);
      }
#line 754
      tmp___8 = js_append(zone, udpzone);
#line 754
      if (tmp___8 == -1) {
#line 755
        js_destroy(udpzone);
#line 755
        js_destroy(filename);
#line 755
        js_destroy(line___0);
#line 756
        js_destroy(pline);
#line 756
        js_destroy(soaline);
#line 756
        js_destroy(query);
#line 757
        js_destroy(data);
#line 757
        js_destroy(zone);
#line 757
        js_dealloc((void *)desc___0);
#line 758
        return (-1);
      }
#line 760
      tmp___10 = hname_2rfc1035(udpzone);
#line 760
      if (tmp___10 == -1) {
#line 761
        js_qstr2js(error, (char *)"A zone file is incorrectly named.  All zone files must end with a dot, e.g.\ncsv1[\"example.com.\"] = \"filename\".\nHere is the line in the mararc with the problem: ");
#line 762
        js_qappend((char *)"\ncsv1[\"", error);
#line 763
        js_append(zone, error);
#line 764
        js_qappend((char *)"\"] = \"", error);
#line 765
        tmp___9 = mhash_get_js(csvs, zone);
#line 765
        js_append(tmp___9, error);
#line 766
        js_qappend((char *)"\"\n", error);
#line 767
        js_destroy(udpzone);
#line 767
        js_destroy(filename);
#line 767
        js_destroy(line___0);
#line 768
        js_destroy(pline);
#line 768
        js_destroy(soaline);
#line 768
        js_destroy(query);
#line 769
        js_destroy(data);
#line 769
        js_destroy(zone);
#line 769
        js_dealloc((void *)desc___0);
#line 770
        return (-2);
      }
#line 774
      tmp___11 = js_addbyte(udpzone, (unsigned char)0);
#line 774
      if (tmp___11 == -1) {
#line 775
        js_destroy(udpzone);
#line 775
        js_destroy(filename);
#line 775
        js_destroy(line___0);
#line 776
        js_destroy(pline);
#line 776
        js_destroy(soaline);
#line 776
        js_destroy(query);
#line 777
        js_destroy(data);
#line 777
        js_destroy(zone);
#line 777
        js_dealloc((void *)desc___0);
#line 778
        return (-1);
      }
#line 780
      tmp___12 = js_addbyte(udpzone, (unsigned char)2);
#line 780
      if (tmp___12 == -1) {
#line 781
        js_destroy(udpzone);
#line 781
        js_destroy(filename);
#line 781
        js_destroy(line___0);
#line 782
        js_destroy(pline);
#line 782
        js_destroy(soaline);
#line 782
        js_destroy(query);
#line 783
        js_destroy(data);
#line 783
        js_destroy(zone);
#line 783
        js_dealloc((void *)desc___0);
#line 784
        return (-1);
      }
#line 788
      js_destroy(filename);
#line 789
      filename = mhash_get_js(csvs, zone);
#line 791
      tmp___13 = js_open_read(filename, desc___0);
#line 791
      if (tmp___13 == -1) {
#line 792
        js_qstr2js(error, (char *)"Can not open zone file for zone ");
#line 793
        js_append(zone, error);
#line 794
        warning(error, -1);
#line 795
        goto __Cont;
      }
#line 799
      rrnum = 0;
#line 799
      linenum = rrnum;
#line 800
      in_ns = 1;
#line 803
      while (1) {
#line 803
        tmp___22 = js_buf_eof(desc___0);
#line 803
        if (tmp___22) {
#line 803
          break;
        }
#line 806
        result = js_buf_getline(desc___0, line___0);
#line 807
        if (result == -1) {
#line 808
          js_destroy(udpzone);
#line 808
          js_destroy(filename);
#line 809
          js_destroy(line___0);
#line 810
          js_destroy(pline);
#line 810
          js_destroy(soaline);
#line 810
          js_destroy(query);
#line 811
          js_destroy(data);
#line 811
          js_destroy(zone);
#line 811
          js_dealloc((void *)desc___0);
#line 812
          return (-1);
        } else
#line 814
        if (result == -2) {
#line 815
          printf("%s%d%s", "Line number ", linenum + 1, " is too long in file ");
#line 816
          show_esc_stdout(filename);
#line 817
          printf("\n");
#line 819
          js_destroy(udpzone);
#line 819
          js_destroy(filename);
#line 820
          js_destroy(line___0);
#line 821
          js_destroy(pline);
#line 821
          js_destroy(soaline);
#line 821
          js_destroy(query);
#line 822
          js_destroy(data);
#line 822
          js_destroy(zone);
#line 822
          js_dealloc((void *)desc___0);
#line 823
          return (-1);
        }
#line 827
        linenum ++;
#line 831
        tmp___16 = js_buf_eof(desc___0);
#line 831
        if (tmp___16) {
#line 831
          if (in_ns) {
#line 831
            if (line___0->unit_count == 0U) {
#line 834
              tmp___14 = js_length(soaline);
#line 834
              if (tmp___14 == 0) {
#line 835
                continue;
              }
#line 838
              tmp___15 = parse_csv1_line(soaline, query, data, & ttl);
#line 838
              if (tmp___15 != 6) {
#line 840
                js_destroy(udpzone);
#line 840
                js_destroy(filename);
#line 841
                js_destroy(line___0);
#line 842
                js_destroy(pline);
#line 842
                js_destroy(soaline);
#line 843
                js_destroy(query);
#line 844
                js_destroy(data);
#line 844
                js_destroy(zone);
#line 844
                js_dealloc((void *)desc___0);
#line 845
                return (-1);
              }
#line 847
              add_rr_to_bighash(maintable, query, data, ttl, udpzone, (uint16_t )0);
#line 848
              break;
            }
          }
        }
#line 852
        tmp___17 = js_buf_eof(desc___0);
#line 852
        if (tmp___17) {
#line 852
          if (line___0->unit_count == 0U) {
#line 853
            break;
          }
        }
#line 856
        tmp___18 = bs_process(line___0, pline, zone);
#line 856
        if (tmp___18 == -1) {
#line 857
          js_destroy(udpzone);
#line 857
          js_destroy(filename);
#line 858
          js_destroy(line___0);
#line 859
          js_destroy(pline);
#line 859
          js_destroy(soaline);
#line 859
          js_destroy(query);
#line 860
          js_destroy(data);
#line 860
          js_destroy(zone);
#line 860
          js_dealloc((void *)desc___0);
#line 861
          return (-1);
        }
#line 865
        rr_type = parse_csv1_line(pline, query, data, & ttl);
#line 869
        starrecord_to_meta(query, recursive);
#line 872
        if (rr_type == -1) {
#line 873
          js_qstr2js(error, (char *)"Fatal error in zone file ");
#line 874
          js_append(zone, error);
#line 875
          js_qappend((char *)" (aborting this zone file)", error);
#line 876
          warning(error, linenum);
#line 878
          break;
        }
#line 880
        if (rr_type == -2) {
#line 881
          js_qstr2js(error, (char *)"Syntax error in zone file ");
#line 882
          js_append(zone, error);
#line 883
          js_qappend((char *)" (", error);
#line 884
          js_append(data, error);
#line 885
          js_qappend((char *)")", error);
#line 886
          warning(error, linenum);
#line 887
          continue;
        }
#line 890
        if (rr_type > 0) {
#line 891
          rrnum ++;
#line 893
          if (rrnum == 1) {
#line 893
            if (rr_type != 6) {
#line 894
              js_qstr2js(error, (char *)"First record in csv1 zone file must be SOA record.");
#line 896
              js_qappend((char *)"Zone: ", error);
#line 897
              js_append(zone, error);
#line 898
              warning(error, 1);
#line 899
              break;
            } else {
#line 893
              goto _L___1;
            }
          } else
          _L___1: /* CIL Label */ 
#line 905
          if (rrnum == 1) {
#line 906
            tmp___19 = js_copy(pline, soaline);
#line 906
            if (tmp___19 == -1) {
#line 907
              js_destroy(udpzone);
#line 907
              js_destroy(filename);
#line 908
              js_destroy(line___0);
#line 909
              js_destroy(pline);
#line 909
              js_destroy(soaline);
#line 910
              js_destroy(query);
#line 911
              js_destroy(data);
#line 911
              js_destroy(zone);
#line 912
              js_dealloc((void *)desc___0);
#line 913
              return (-1);
            }
          } else
#line 917
          if (rrnum != 1) {
#line 917
            if (rr_type == 6) {
#line 918
              js_qstr2js(error, (char *)"Second SOA in zone file ");
#line 919
              js_append(zone, error);
#line 920
              warning(error, linenum);
#line 921
              continue;
            } else {
#line 917
              goto _L___0;
            }
          } else
          _L___0: /* CIL Label */ 
#line 928
          if (rr_type != 2) {
#line 928
            goto _L;
          } else {
#line 928
            tmp___21 = js_issame(query, udpzone);
#line 928
            if (tmp___21) {
#line 966
              add_rr_to_bighash(maintable, query, data, ttl, udpzone, (uint16_t )0);
            } else
            _L: /* CIL Label */ 
#line 928
            if (in_ns) {
#line 931
              tmp___20 = parse_csv1_line(soaline, query, data, & ttl);
#line 931
              if (tmp___20 != 6) {
#line 933
                js_destroy(udpzone);
#line 933
                js_destroy(filename);
#line 934
                js_destroy(line___0);
#line 935
                js_destroy(pline);
#line 935
                js_destroy(soaline);
#line 936
                js_destroy(query);
#line 937
                js_destroy(data);
#line 937
                js_destroy(zone);
#line 938
                js_dealloc((void *)desc___0);
#line 939
                return (-1);
              }
#line 941
              add_rr_to_bighash(maintable, query, data, ttl, udpzone, (uint16_t )0);
#line 944
              rr_type = parse_csv1_line(pline, query, data, & ttl);
#line 945
              if (rr_type == -1) {
#line 946
                js_qstr2js(error, (char *)"Fatal error in zone file ");
#line 947
                js_append(zone, error);
#line 948
                js_qappend((char *)" (aborting zone file)", error);
#line 949
                warning(error, linenum);
#line 951
                break;
              } else
#line 953
              if (rr_type == -2) {
#line 954
                js_qstr2js(error, (char *)"Syntax error in zone file ");
#line 955
                js_append(zone, error);
#line 956
                js_qappend((char *)" (", error);
#line 957
                js_append(data, error);
#line 958
                js_qappend((char *)")", error);
#line 959
                warning(error, linenum);
#line 960
                continue;
              }
#line 962
              add_rr_to_bighash(maintable, query, data, ttl, udpzone, (uint16_t )0);
#line 963
              in_ns = 0;
            } else {
#line 966
              add_rr_to_bighash(maintable, query, data, ttl, udpzone, (uint16_t )0);
            }
          }
        }
      }
#line 969
      js_close(desc___0);
    }
    __Cont: /* CIL Label */ 
#line 742
    tmp___23 = mhash_nextkey(csvs, zone);
#line 742
    if (! (tmp___23 != 0)) {
#line 742
      break;
    }
  }
#line 972
  js_destroy(udpzone);
#line 972
  js_destroy(filename);
#line 972
  js_destroy(line___0);
#line 973
  js_destroy(pline);
#line 973
  js_destroy(soaline);
#line 973
  js_destroy(query);
#line 974
  js_destroy(data);
#line 974
  js_destroy(zone);
#line 974
  js_dealloc((void *)desc___0);
#line 975
  return (1);
}
}
#line 980 "MaraBigHash.c"
int populate_main(mhash *maintable , js_string *error , int recursive ) 
{ int tmp ;

  {
#line 982
  parse_csv1s(maintable, error, recursive);
#line 983
  csv2_parse_main_bighash(maintable, 0);
#line 986
  tmp = add_an(maintable, error);
#line 986
  return (tmp);
}
}
#line 994 "MaraBigHash.c"
int warn_ddip(js_string *query ) 
{ 

  {
#line 995
  if (log_level == 0) {
#line 996
    return (1);
  }
#line 998
  printf("%s%s", "Dotted decimal IP for NS, CNAME, or MX does not work with some DNS servers",
         "\n");
#line 999
  return (1);
}
}
#line 1010 "MaraBigHash.c"
int make_ddip(mhash *bighash___0 , js_string *query ) 
{ unsigned char ip[4] ;
  unsigned char length ;
  unsigned char val ;
  int critter ;
  int counter ;
  int lenl ;
  int value___0 ;
  js_string *js_ip ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1016
  if (query->unit_size != 1U) {
#line 1017
    return (-1);
  }
#line 1018
  if (query->unit_count >= query->max_count) {
#line 1019
    return (-1);
  }
#line 1023
  tmp = get_rtype(query);
#line 1023
  if (tmp != 1) {
#line 1024
    return (0);
  }
#line 1026
  if (query->unit_count < 9U) {
#line 1028
    return (0);
  }
#line 1031
  lenl = 0;
#line 1032
  counter = 0;
#line 1032
  while (counter < 4) {
#line 1033
    length = *(query->string + lenl);
#line 1034
    if ((int )length < 1) {
#line 1035
      return (0);
    } else
#line 1034
    if ((int )length > 3) {
#line 1035
      return (0);
    }
#line 1036
    critter = lenl + 1;
#line 1037
    lenl += (int )length + 1;
#line 1038
    if ((unsigned int )lenl > query->unit_count) {
#line 1039
      return (-1);
    }
#line 1040
    value___0 = 0;
#line 1040
    while (critter < lenl) {
#line 1041
      val = *(query->string + critter);
#line 1042
      if ((int )val > 57) {
#line 1043
        return (0);
      } else
#line 1042
      if ((int )val < 48) {
#line 1043
        return (0);
      }
#line 1044
      value___0 *= 10;
#line 1045
      value___0 += (int )val - 48;
#line 1040
      critter ++;
    }
#line 1047
    if (value___0 < 0) {
#line 1048
      return (0);
    } else
#line 1047
    if (value___0 > 255) {
#line 1048
      return (0);
    }
#line 1049
    ip[counter] = (unsigned char )value___0;
#line 1032
    counter ++;
  }
#line 1052
  if ((int )*(query->string + lenl) != 0) {
#line 1053
    return (0);
  }
#line 1057
  js_ip = js_create(5U, 1U);
#line 1057
  if ((unsigned long )js_ip == (unsigned long )((js_string *)0)) {
#line 1058
    return (-1);
  }
#line 1060
  tmp___0 = js_str2js(js_ip, (char *)(ip), 4, 1);
#line 1060
  if (tmp___0 == -1) {
#line 1061
    js_destroy(js_ip);
#line 1062
    return (-1);
  }
#line 1065
  tmp___1 = mhash_put_rr(bighash___0, query, js_ip, (uint32_t )8675309, (uint32_t )1,
                         (uint32_t )0, (uint16_t )0);
#line 1065
  if (tmp___1 == -1) {
#line 1066
    js_destroy(js_ip);
#line 1067
    return (-1);
  } else {
#line 1070
    js_destroy(js_ip);
#line 1071
    return (1);
  }
}
}
#line 1085 "MaraBigHash.c"
int add_an(mhash *bighash___0 , js_string *error ) 
{ js_string *query ;
  js_string *a_query ;
  mhash_e qdata ;
  mhash_e adata ;
  rr *record ;
  int qtype ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1088
  qdata.point = (void **)0;
#line 1088
  qdata.value = (void *)0;
#line 1088
  qdata.datatype = 0;
#line 1088
  adata.point = (void **)0;
#line 1088
  adata.value = (void *)0;
#line 1088
  adata.datatype = 0;
#line 1092
  a_query = js_create(256U, 1U);
#line 1092
  if ((unsigned long )a_query == (unsigned long )((js_string *)0)) {
#line 1093
    return (-1);
  }
#line 1094
  query = js_create(256U, 1U);
#line 1094
  if ((unsigned long )query == (unsigned long )((js_string *)0)) {
#line 1095
    js_destroy(a_query);
#line 1096
    return (-1);
  }
#line 1101
  tmp = mhash_firstkey(bighash___0, query);
#line 1101
  if (tmp <= 0) {
#line 1102
    js_destroy(a_query);
#line 1103
    js_destroy(query);
#line 1104
    return (0);
  }
#line 1107
  while (1) {
#line 1109
    qtype = get_rtype(query);
#line 1110
    if (qtype == -1) {
#line 1111
      goto __Cont;
    }
#line 1112
    qdata = mhash_get(bighash___0, query);
#line 1115
    if (qtype == 15) {
#line 1115
      goto _L___0;
    } else
#line 1115
    if (qtype == 2) {
      _L___0: /* CIL Label */ 
#line 1116
      if (qdata.datatype == 3) {
#line 1119
        record = (rr *)qdata.value;
#line 1120
        while (1) {
#line 1121
          tmp___0 = answer_ip_query(qtype, record->data, a_query);
#line 1121
          if (tmp___0 == -1) {
#line 1122
            goto __Cont___0;
          }
#line 1123
          tmp___1 = change_rtype(a_query, 1);
#line 1123
          if (tmp___1 == -1) {
#line 1124
            goto __Cont___0;
          }
#line 1125
          adata = mhash_get(bighash___0, a_query);
#line 1127
          if (adata.datatype == 3) {
#line 1128
            if ((unsigned long )record != (unsigned long )((rr *)0)) {
#line 1128
              if ((unsigned long )adata.value != (unsigned long )((void *)0)) {
#line 1129
                record->ip = (struct rr *)adata.value;
              }
            }
          } else {
#line 1132
            tmp___2 = make_ddip(bighash___0, a_query);
#line 1132
            if (tmp___2 == 1) {
#line 1133
              warn_ddip(query);
#line 1134
              adata = mhash_get(bighash___0, a_query);
#line 1135
              if (adata.datatype == 3) {
#line 1136
                if ((unsigned long )record != (unsigned long )((rr *)0)) {
#line 1136
                  if ((unsigned long )adata.value != (unsigned long )((void *)0)) {
#line 1137
                    record->ip = (struct rr *)adata.value;
                  }
                }
              }
            }
          }
          __Cont___0: /* CIL Label */ 
#line 1120
          record = record->next;
#line 1120
          if (! ((unsigned long )record != (unsigned long )((rr *)0))) {
#line 1120
            break;
          }
        }
      }
    } else
#line 1145
    if (qtype == 5) {
#line 1148
      record = (rr *)qdata.value;
#line 1149
      while (1) {
#line 1150
        tmp___3 = answer_ip_query(qtype, record->data, a_query);
#line 1150
        if (tmp___3 == -1) {
#line 1151
          goto __Cont___1;
        }
#line 1152
        if ((int )record->rr_type != 5) {
#line 1153
          break;
        }
#line 1154
        tmp___4 = change_rtype(a_query, 255);
#line 1154
        if (tmp___4 == -1) {
#line 1155
          goto __Cont___1;
        }
#line 1156
        adata = mhash_get(bighash___0, a_query);
#line 1158
        if (adata.datatype == 6) {
#line 1159
          if ((unsigned long )record != (unsigned long )((rr *)0)) {
#line 1159
            if ((unsigned long )adata.value != (unsigned long )((void *)0)) {
#line 1160
              record->list = (struct rr_list *)adata.value;
            }
          }
        } else
#line 1162
        if (no_cname_warnings == 0) {
#line 1162
          if (cname_warnings_shown < 10) {
#line 1164
            printf("Warning: The CNAME record ");
#line 1165
            human_readable_dns_query(query, 1);
#line 1166
            printf(" is a dangling CNAME record.\nPlease read the FAQ entry about FAQ entry about dangling CNAME records.\n");
#line 1168
            cname_warnings_shown ++;
          } else {
#line 1162
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 1170
        if (no_cname_warnings == 0) {
#line 1170
          if (cname_warnings_shown == 10) {
#line 1172
            printf("Warning: More dangling CNAME records exist.\n");
#line 1173
            cname_warnings_shown ++;
          }
        }
        __Cont___1: /* CIL Label */ 
#line 1149
        record = record->next;
#line 1149
        if (! ((unsigned long )record != (unsigned long )((rr *)0))) {
#line 1149
          break;
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 1107
    tmp___5 = mhash_nextkey(bighash___0, query);
#line 1107
    if (! (tmp___5 != 0)) {
#line 1107
      break;
    }
  }
#line 1178
  js_destroy(a_query);
#line 1179
  js_destroy(query);
#line 1180
  return (1);
}
}
#line 1191 "MaraBigHash.c"
int answer_ip_query(int qtype , js_string *qu , js_string *ar ) 
{ int start ;
  int length ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1195
  tmp = js_has_sanity(qu);
#line 1195
  if (tmp == -1) {
#line 1196
    return (-1);
  }
#line 1197
  if (qu->unit_size != 1U) {
#line 1198
    return (-1);
  }
#line 1199
  tmp___0 = js_has_sanity(ar);
#line 1199
  if (tmp___0 == -1) {
#line 1200
    return (-1);
  }
#line 1201
  if (ar->unit_size != 1U) {
#line 1202
    return (-1);
  }
#line 1205
  ar->unit_count = 0U;
#line 1210
  switch (qtype) {
  case 2: 
  case 5: 
#line 1213
  start = 0;
#line 1215
  length = (int )(qu->unit_count - (unsigned int )start);
#line 1216
  break;
  case 15: 
#line 1218
  start = 2;
#line 1220
  length = (int )(qu->unit_count - (unsigned int )start);
#line 1221
  break;
  default: 
#line 1224
  return (1);
  }
#line 1228
  tmp___1 = js_substr(qu, ar, start, length);
#line 1228
  if (tmp___1 == -1) {
#line 1229
    return (-1);
  }
#line 1233
  tmp___2 = js_addbyte(ar, (unsigned char)0);
#line 1233
  if (tmp___2 == -1) {
#line 1234
    return (-1);
  }
#line 1235
  tmp___3 = js_addbyte(ar, (unsigned char)1);
#line 1235
  if (tmp___3 == -1) {
#line 1236
    return (-1);
  }
#line 1238
  return (1);
}
}
#line 1269 "MaraBigHash.c"
int add_rr_to_bighash(mhash *bighash___0 , js_string *query , js_string *data , uint32_t ttl ,
                      js_string *zone , uint16_t perms ) 
{ int label_len ;
  int has_authority ;
  int qtype ;
  mhash_e hash_spot ;
  rr *nukeme ;
  rr *point ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 1273
  has_authority = 0;
#line 1278
  tmp = js_has_sanity(query);
#line 1278
  if (tmp == -1) {
#line 1280
    return (-1);
  } else {
#line 1278
    tmp___0 = js_has_sanity(data);
#line 1278
    if (tmp___0 == -1) {
#line 1280
      return (-1);
    } else {
#line 1278
      tmp___1 = js_has_sanity(query);
#line 1278
      if (tmp___1 == -1) {
#line 1280
        return (-1);
      }
    }
  }
#line 1281
  if (query->unit_count < 3U) {
#line 1282
    return (-1);
  } else
#line 1281
  if (zone->unit_count < 3U) {
#line 1282
    return (-1);
  }
#line 1285
  qtype = get_rtype(query);
#line 1285
  if (qtype == -1) {
#line 1286
    return (-1);
  }
#line 1289
  if (qtype == 255) {
#line 1290
    return (-1);
  }
#line 1293
  if (qtype == 251) {
#line 1294
    return (-1);
  } else
#line 1293
  if (qtype == 252) {
#line 1294
    return (-1);
  }
#line 1297
  dns_records_served ++;
#line 1301
  tmp___2 = change_rtype(zone, qtype);
#line 1301
  if (tmp___2 == -1) {
#line 1302
    change_rtype(zone, 2);
#line 1303
    return (-1);
  }
#line 1307
  tmp___5 = js_issame(zone, query);
#line 1307
  if (tmp___5) {
#line 1308
    has_authority = 1;
  } else {
#line 1314
    tmp___4 = get_rtype(query);
#line 1314
    if (tmp___4 != 2) {
#line 1316
      label_len = -1;
#line 1318
      if ((int )*(query->string) != 95) {
#line 1318
        if ((int )*(query->string) < 64) {
#line 1319
          label_len = (int )*(query->string) + 1;
        } else {
#line 1318
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1320
      if ((int )*(query->string) == 95) {
#line 1321
        label_len = 1;
      } else {
#line 1323
        change_rtype(zone, 2);
#line 1324
        return (-1);
      }
#line 1328
      if (zone->unit_count == query->unit_count - (unsigned int )label_len) {
#line 1328
        tmp___3 = js_fgrep(zone, query);
#line 1328
        if (tmp___3 == label_len) {
#line 1330
          has_authority = 1;
        }
      }
    }
  }
#line 1338
  change_rtype(zone, 2);
#line 1340
  hash_spot = mhash_get(bighash___0, query);
#line 1343
  if ((unsigned long )hash_spot.value == (unsigned long )((void *)0)) {
#line 1345
    tmp___6 = mhash_put_rr(bighash___0, query, data, ttl, (uint32_t )has_authority,
                           (uint32_t )0, perms);
#line 1345
    if (tmp___6 == -1) {
#line 1347
      return (-1);
    }
#line 1348
    tmp___7 = mhash_add_ns(bighash___0, query, zone);
#line 1348
    if (tmp___7 == -1) {
#line 1349
      return (-1);
    }
#line 1350
    return (1);
  }
#line 1354
  if (hash_spot.datatype != 3) {
#line 1355
    return (-1);
  }
#line 1357
  point = (rr *)hash_spot.value;
#line 1365
  if (point->authoritative == 1U) {
#line 1365
    if (has_authority == 1) {
#line 1365
      goto _L___0;
    } else {
#line 1365
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 1365
  if (point->authoritative == 0U) {
#line 1365
    if (has_authority == 0) {
      _L___0: /* CIL Label */ 
#line 1367
      tmp___8 = mhash_add_rr(bighash___0, query, data, ttl, (uint32_t )has_authority,
                             (uint32_t )0, perms);
#line 1367
      if (tmp___8 == -1) {
#line 1369
        return (-1);
      }
#line 1370
      return (1);
    }
  }
#line 1376
  if (point->authoritative == 0U) {
#line 1376
    if (has_authority == 1) {
#line 1381
      tmp___9 = mhash_undef(bighash___0, query);
#line 1381
      nukeme = (rr *)tmp___9;
#line 1382
      if ((unsigned long )nukeme == (unsigned long )((rr *)0)) {
#line 1383
        return (-1);
      }
#line 1386
      tmp___10 = any_zap_rr(bighash___0, query, nukeme);
#line 1386
      if (tmp___10 == -1) {
#line 1387
        return (-1);
      }
#line 1390
      tmp___11 = js_dealloc((void *)nukeme);
#line 1390
      if (tmp___11 == -1) {
#line 1391
        return (-1);
      }
#line 1394
      tmp___12 = mhash_put_rr(bighash___0, query, data, ttl, (uint32_t )has_authority,
                              (uint32_t )0, perms);
#line 1394
      if (tmp___12 == -1) {
#line 1396
        return (-1);
      }
#line 1397
      tmp___13 = mhash_add_ns(bighash___0, query, zone);
#line 1397
      if (tmp___13 == -1) {
#line 1398
        return (-1);
      }
#line 1399
      return (1);
    }
  }
#line 1405
  if (point->authoritative == 1U) {
#line 1405
    if (has_authority == 0) {
#line 1406
      return (1);
    }
  }
#line 1409
  return (-1);
}
}
#line 1 "recursive.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-DR3Z9t7v.i","")
#line 133 "/usr/include/time.h"
extern time_t time(time_t * ) ;
#line 252 "/usr/include/pthread.h"
extern int pthread_attr_destroy(pthread_attr_t * ) ;
#line 270
extern int pthread_attr_init(pthread_attr_t * ) ;
#line 271
extern int pthread_attr_setdetachstate(pthread_attr_t * , int  ) ;
#line 304
extern int pthread_create(pthread_t * , pthread_attr_t const   * , void *(*)(void * ) ,
                          void * ) ;
#line 321
extern int pthread_mutex_lock(pthread_mutex_t * ) ;
#line 324
extern int pthread_mutex_unlock(pthread_mutex_t * ) ;
#line 77 "../libs/JsStr.h"
int js_fgrep_offset(js_string *exp , js_string *js , int offset ) ;
#line 95
int js_qissame(char *expression , js_string *target ) ;
#line 114
uint32_t js_readuint32(js_string *js , unsigned int offset ) ;
#line 115
int js_strnlen(char *s , uint32_t limit ) ;
#line 122
int js_tolower(js_string *js ) ;
#line 476 "/usr/include/unistd.h"
extern int close(int  )  __asm__("_close")  ;
#line 499
extern pid_t getpid(void) ;
#line 504
extern off_t lseek(int  , off_t  , int  ) ;
#line 511
extern ssize_t read(int  , void * , size_t  )  __asm__("_read")  ;
#line 224 "/usr/include/stdlib.h"
extern long random(void) ;
#line 606 "/usr/include/sys/socket.h"
extern int connect(int  , struct sockaddr  const  * , socklen_t  )  __asm__("_connect")  ;
#line 613
extern ssize_t recv(int  , void * , size_t  , int  )  __asm__("_recv")  ;
#line 617
extern ssize_t send(int  , void const   * , size_t  , int  )  __asm__("_send")  ;
#line 464 "/usr/include/sys/fcntl.h"
extern int open(char const   * , int   , ...)  __asm__("_open")  ;
#line 111 "../rng/rng-api-fst.h"
int makeKey(keyInstance *key___0 , MARA_BYTE direction , int keyLen , char *keyMaterial ) ;
#line 113
int cipherInit(cipherInstance *cipher , MARA_BYTE mode , char *IV ) ;
#line 115
int blockEncrypt(cipherInstance *cipher , keyInstance *key___0 , MARA_BYTE *input ,
                 int inputLen , MARA_BYTE *outBuffer ) ;
#line 59 "recursive.c"
pthread_mutex_t big_lock  =    {850045863L, {(char)0}};
#line 60 "recursive.c"
int in_big_lock  =    0;
#line 61 "recursive.c"
pthread_mutex_t logwrite_lock  =    {850045863L, {(char)0}};
#line 62 "recursive.c"
pthread_mutex_t rng_lock  =    {850045863L, {(char)0}};
#line 63 "recursive.c"
pthread_mutex_t thr_lock  =    {850045863L, {(char)0}};
#line 69 "recursive.c"
mhash *dnscache  =    (mhash *)0;
#line 72 "recursive.c"
int num_of_threads_running  =    0;
#line 73 "recursive.c"
int maximum_num_of_threads  =    96;
#line 77 "recursive.c"
int max_glueless_level  =    10;
#line 79 "recursive.c"
int max_queries_total  =    32;
#line 81 "recursive.c"
int timeout_seconds  =    2;
#line 83 "recursive.c"
fila *top  =    (fila *)0;
#line 89 "recursive.c"
int root_or_upstream  =    0;
#line 93 "recursive.c"
int verbose_query  =    0;
#line 97 "recursive.c"
int min_ttl_cname  =    300;
#line 98 "recursive.c"
int min_ttl_normal  =    300;
#line 103 "recursive.c"
int rlog_level  =    1;
#line 107 "recursive.c"
int handle_noreply  =    2;
#line 111 "recursive.c"
int retry_cycles  =    2;
#line 114 "recursive.c"
int upstream_port  =    53;
#line 118 "recursive.c"
int recurse_min_bind_port  =    15000;
#line 119 "recursive.c"
int recurse_number_ports  =    4095;
#line 149
int mhash_put_data(mhash *hash , js_string *query , js_string *value___0 , uint32_t ttl ,
                   uint32_t authoritative , uint32_t expire , int datatype , int rtype ,
                   int action , int rcode ) ;
#line 152
int recurse_call(int id , int sock , struct sockaddr_in client , js_string *query ,
                 int queries_sent , int glueless_level , uint32_t *ipret , js_string *ptrret ) ;
#line 155
int unlink_rr(rr *fatma , int depth ) ;
#line 156
int unlink_closer(closer *fatma ) ;
#line 157
int in_bailiwick(js_string *host , js_string *bailiwick ) ;
#line 158
int cmp_ips(js_string *compare , int offset , uint32_t ip ) ;
#line 159
int add_closer_jsip(js_string *zone , js_string *ipjs , int if_exists ) ;
#line 160
int add_closer_jsip_offset(js_string *js , int offset , js_string *ipjs , int if_exists ) ;
#line 162
int add_closer_js_offset(js_string *js , int offset1 , int offset2 , int if_exists ) ;
#line 172 "recursive.c"
MARA_BYTE r_inBlock[17]  ;
#line 172 "recursive.c"
MARA_BYTE r_outBlock[17]  ;
#line 172 "recursive.c"
MARA_BYTE r_binSeed[17]  ;
#line 173 "recursive.c"
MARA_BYTE r_seedMaterial[320]  ;
#line 174 "recursive.c"
keyInstance r_seedInst  ;
#line 175 "recursive.c"
cipherInstance r_cipherInst  ;
#line 176 "recursive.c"
uint32_t r_counter  =    (uint32_t )0;
#line 178 "recursive.c"
int r_place  =    0;
#line 180 "recursive.c"
int custodian_mode  =    0;
#line 182 "recursive.c"
int cache_max  =    0;
#line 186 "recursive.c"
rr *rra_data  =    (rr *)0;
#line 189 "recursive.c"
ipv4pair spammers[512]  ;
#line 191 "recursive.c"
void log_lock(void) 
{ 

  {
#line 192
  pthread_mutex_lock(& logwrite_lock);
#line 193
  return;
}
}
#line 195 "recursive.c"
void log_unlock(void) 
{ 

  {
#line 196
  pthread_mutex_unlock(& logwrite_lock);
#line 197
  return;
}
}
#line 199 "recursive.c"
void do_big_lock(void) 
{ 

  {
#line 200
  pthread_mutex_lock(& big_lock);
#line 201
  in_big_lock = 1;
#line 202
  return;
}
}
#line 204 "recursive.c"
void big_unlock(void) 
{ 

  {
#line 205
  if (in_big_lock != 1) {
#line 206
    log_lock();
#line 207
    show_timestamp();
#line 208
    printf("WARNING: Attempting to unlock when not locked\n");
#line 209
    log_unlock();
#line 210
    return;
  }
#line 212
  in_big_lock = 0;
#line 213
  pthread_mutex_unlock(& big_lock);
#line 214
  return;
}
}
#line 216 "recursive.c"
void srng_lock(void) 
{ 

  {
#line 217
  pthread_mutex_lock(& rng_lock);
#line 218
  return;
}
}
#line 220 "recursive.c"
void srng_unlock(void) 
{ 

  {
#line 221
  pthread_mutex_unlock(& rng_lock);
#line 222
  return;
}
}
#line 224 "recursive.c"
void tcount_lock(void) 
{ 

  {
#line 225
  pthread_mutex_lock(& thr_lock);
#line 226
  return;
}
}
#line 228 "recursive.c"
void tcount_unlock(void) 
{ 

  {
#line 229
  pthread_mutex_unlock(& thr_lock);
#line 230
  return;
}
}
#line 238 "recursive.c"
int how_many_threads(void) 
{ int ret ;

  {
#line 240
  tcount_lock();
#line 241
  ret = num_of_threads_running;
#line 242
  tcount_unlock();
#line 243
  return (ret);
}
}
#line 253 "recursive.c"
int cache_elements(void) 
{ int ret ;

  {
#line 255
  ret = (int )dnscache->spots;
#line 256
  return (ret);
}
}
#line 263 "recursive.c"
int init_handle_noreply(int value___0 ) 
{ 

  {
#line 264
  handle_noreply = value___0;
#line 265
  return (value___0);
}
}
#line 280 "recursive.c"
int arpa_at_end_p(js_string *query ) 
{ js_string *match ;
  int result ;
  int counter ;
  int tmp ;
  int tmp___0 ;

  {
#line 283
  counter = 0;
#line 285
  match = js_create(10U, 1U);
#line 285
  if ((unsigned long )match == (unsigned long )((js_string *)0)) {
#line 286
    return (-1);
  }
#line 290
  tmp = js_qstr2js(match, (char *)"XarpaX");
#line 290
  if (tmp == -1) {
#line 291
    js_destroy(match);
#line 292
    return (-1);
  }
#line 294
  *(match->string + 0) = (unsigned char)4;
#line 295
  *(match->string + 5) = (unsigned char)0;
#line 297
  result = js_fgrep(match, query);
#line 298
  while (1) {
#line 298
    if (result != -2) {
#line 298
      if (! ((unsigned int )result < query->unit_count - 8U)) {
#line 298
        break;
      }
    } else {
#line 298
      break;
    }
#line 299
    result = js_fgrep_offset(match, query, result + 1);
#line 300
    tmp___0 = counter;
#line 300
    counter ++;
#line 300
    if (tmp___0 > 45) {
#line 301
      break;
    }
  }
#line 304
  if ((unsigned int )result != query->unit_count - 8U) {
#line 305
    js_destroy(match);
#line 306
    return (0);
  }
#line 309
  js_destroy(match);
#line 310
  return (1);
}
}
#line 323 "recursive.c"
int move_to_top(fila *element ) 
{ fila *before ;
  fila *after ;

  {
#line 325
  if ((unsigned long )element == (unsigned long )((void *)0)) {
#line 326
    return (1);
  }
#line 328
  if ((unsigned long )element == (unsigned long )top) {
#line 329
    return (1);
  }
#line 332
  before = element->previous;
#line 333
  after = element->siguiente;
#line 334
  if ((unsigned long )before != (unsigned long )((fila *)0)) {
#line 335
    before->siguiente = after;
  }
#line 336
  if ((unsigned long )after != (unsigned long )((fila *)0)) {
#line 337
    after->previous = before;
  }
#line 340
  if ((unsigned long )top != (unsigned long )((fila *)0)) {
#line 341
    (top->previous)->siguiente = element;
#line 342
    element->previous = top->previous;
#line 343
    element->siguiente = top;
#line 344
    top->previous = element;
  } else {
#line 347
    element->previous = element;
#line 348
    element->siguiente = element;
  }
#line 350
  top = element;
#line 352
  return (1);
}
}
#line 362 "recursive.c"
int remove_fila(fila *zap ) 
{ fila *before ;
  fila *after ;
  int tmp ;

  {
#line 366
  before = zap->previous;
#line 367
  after = zap->siguiente;
#line 368
  if ((unsigned long )before != (unsigned long )((fila *)0)) {
#line 369
    before->siguiente = after;
  }
#line 370
  if ((unsigned long )after != (unsigned long )((fila *)0)) {
#line 371
    after->previous = before;
  }
#line 373
  if ((unsigned long )zap == (unsigned long )top) {
#line 376
    if ((unsigned long )after != (unsigned long )top) {
#line 377
      top = after;
    } else {
#line 379
      top = (fila *)0;
    }
  }
#line 383
  if ((int )zap->nukable_hp >= 1) {
#line 384
    js_destroy(zap->hash_point);
  }
#line 386
  tmp = js_dealloc((void *)zap);
#line 386
  return (tmp);
}
}
#line 404 "recursive.c"
fila *new_fila(void *point , unsigned char type , js_string *hquery , char nukable_hp ) 
{ fila *new ;
  void *tmp ;

  {
#line 409
  if ((unsigned long )point == (unsigned long )((void *)0)) {
#line 410
    return ((fila *)0);
  } else
#line 409
  if ((int )type > 1) {
#line 410
    return ((fila *)0);
  }
#line 413
  tmp = js_alloc(1, (int )sizeof(fila ));
#line 413
  new = (fila *)tmp;
#line 413
  if ((unsigned long )new == (unsigned long )((fila *)0)) {
#line 414
    return ((fila *)0);
  }
#line 419
  if ((unsigned long )top != (unsigned long )((fila *)0)) {
#line 420
    (top->previous)->siguiente = new;
#line 421
    new->siguiente = top;
#line 422
    new->previous = top->previous;
#line 423
    top->previous = new;
  } else {
#line 427
    new->siguiente = new;
#line 428
    new->previous = new;
  }
#line 432
  new->datatype = type;
#line 434
  new->record = point;
#line 436
  new->hash_point = hquery;
#line 438
  new->nukable_hp = nukable_hp;
#line 441
  top = new;
#line 444
  return (new);
}
}
#line 454 "recursive.c"
int custodian(void) 
{ int counter ;
  closer *cpoint ;
  fila *zap ;
  void *bye ;
  rr *rrb ;
  void *tmp ;

  {
#line 460
  if ((unsigned long )dnscache == (unsigned long )((mhash *)0)) {
#line 461
    return (-1);
  } else
#line 460
  if (cache_max == 0) {
#line 461
    return (-1);
  }
#line 463
  if (dnscache->spots < (unsigned int )cache_max) {
#line 463
    if (custodian_mode <= 0) {
#line 464
      return (1);
    }
  }
#line 467
  if (dnscache->spots >= (unsigned int )cache_max) {
#line 468
    custodian_mode = cache_max / 100;
  }
#line 472
  counter = 8;
#line 473
  while (counter > 0) {
#line 476
    if ((unsigned long )top != (unsigned long )((fila *)0)) {
#line 477
      zap = top->previous;
    } else {
#line 479
      return (-1);
    }
#line 481
    bye = zap->record;
#line 483
    if (rlog_level >= 4) {
#line 484
      log_lock();
#line 485
      show_timestamp();
#line 486
      printf("Custodian is zapping record ");
#line 487
      show_esc_stdout(zap->hash_point);
#line 488
      printf(" at %p\n", zap->record);
#line 489
      log_unlock();
    }
#line 493
    tmp = mhash_undef(dnscache, zap->hash_point);
#line 493
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 496
      rrb = (rr *)zap->record;
#line 498
      show_timestamp();
#line 499
      printf("Unable to remove element from hash.\n");
#line 500
      printf("I thought I fixed this bug.  Please report this\n");
#line 501
      printf("to list@maradns.org.\n");
#line 502
      printf("The element is (for debugging purposes): %p %p ", zap->hash_point, zap->record);
#line 504
      if ((int )zap->datatype == 0) {
#line 505
        printf("--rr-- %p ", rrb->query);
#line 506
        show_esc_stdout(rrb->query);
      } else
#line 508
      if ((int )zap->datatype == 1) {
#line 509
        printf("--closer--");
      }
#line 511
      printf(" ||| ");
#line 512
      show_esc_stdout(zap->hash_point);
#line 513
      printf("\n");
#line 514
      exit(1);
    }
#line 518
    switch ((int )zap->datatype) {
    case 0: 
#line 520
    if ((unsigned long )bye != (unsigned long )((void *)0)) {
#line 521
      unlink_rr((rr *)bye, 0);
    }
#line 522
    break;
    case 1: 
#line 524
    cpoint = (closer *)bye;
#line 525
    if ((unsigned long )bye != (unsigned long )((void *)0)) {
#line 525
      if (cpoint->ttd != 0LL) {
#line 528
        unlink_closer(cpoint);
      }
    }
    }
#line 531
    counter --;
  }
#line 534
  custodian_mode -= 8;
#line 535
  return (1);
}
}
#line 544 "recursive.c"
uint16_t srng(void) 
{ uint16_t ret ;
  int tmp ;

  {
#line 546
  srng_lock();
#line 549
  if (r_place >= 16) {
#line 552
    r_inBlock[8] = r_outBlock[12];
#line 553
    r_inBlock[9] = r_outBlock[13];
#line 554
    r_inBlock[10] = r_outBlock[14];
#line 555
    r_inBlock[11] = r_outBlock[15];
#line 559
    r_inBlock[12] = (MARA_BYTE )((r_counter >> 24) & 255U);
#line 560
    r_inBlock[13] = (MARA_BYTE )((r_counter >> 16) & 255U);
#line 561
    r_inBlock[14] = (MARA_BYTE )((r_counter >> 8) & 255U);
#line 562
    r_inBlock[15] = (MARA_BYTE )(r_counter & 255U);
#line 563
    r_counter ++;
#line 566
    time((time_t *)(& r_inBlock[0]));
#line 569
    if ((r_counter & 1048575U) == 1048575U) {
#line 570
      if (rlog_level >= 3) {
#line 571
        printf("\nRe-keying rng seed...\n");
      }
#line 573
      tmp = init_rng((js_string *)0, 1);
#line 573
      if (tmp < 0) {
#line 574
        printf("WARNING: Problem rekeying\n");
      }
    }
#line 577
    blockEncrypt(& r_cipherInst, & r_seedInst, r_inBlock, 128, r_outBlock);
#line 578
    r_place = 0;
  }
#line 580
  ret = (uint16_t )((((int )r_outBlock[r_place] & 255) << 8) | ((int )r_outBlock[r_place + 1] & 255));
#line 582
  r_place += 2;
#line 584
  srng_unlock();
#line 585
  return (ret);
}
}
#line 595 "recursive.c"
int unlink_closer(closer *fatma ) 
{ closer *remember ;

  {
#line 599
  while ((unsigned long )fatma != (unsigned long )((void *)0)) {
#line 600
    switch (fatma->datatype) {
    case 2: 
#line 602
    if ((unsigned long )fatma->data != (unsigned long )((void *)0)) {
#line 603
      js_destroy((js_string *)fatma->data);
    }
#line 604
    break;
    default: 
#line 606
    if ((unsigned long )fatma->data != (unsigned long )((void *)0)) {
#line 607
      js_dealloc(fatma->data);
    }
#line 608
    break;
    }
#line 610
    remember = fatma;
#line 612
    if ((unsigned long )remember->zap != (unsigned long )((void *)0)) {
#line 613
      remove_fila(remember->zap);
    }
#line 614
    fatma = fatma->next;
#line 615
    js_dealloc((void *)remember);
  }
#line 618
  return (1);
}
}
#line 628 "recursive.c"
int unlink_rr(rr *fatma , int depth ) 
{ rr *remember ;

  {
#line 644
  if (depth > 32) {
#line 645
    if (rlog_level >= 4) {
#line 646
      log_lock();
#line 647
      show_timestamp();
#line 648
      printf(" unlinking depth exceeded\n");
#line 649
      log_unlock();
    }
#line 651
    return (-1);
  }
#line 654
  while ((unsigned long )fatma != (unsigned long )((rr *)0)) {
#line 656
    if (rlog_level >= 4) {
#line 657
      log_lock();
#line 658
      show_timestamp();
#line 659
      printf("Unlinking RR at %p, depth %d, next %p\n", fatma, depth, fatma->next);
#line 661
      log_unlock();
    }
#line 664
    if ((unsigned long )fatma->ip != (unsigned long )((struct rr *)0)) {
#line 665
      unlink_rr(fatma->ip, depth + 1);
    }
#line 669
    if (rlog_level >= 4) {
#line 670
      log_lock();
#line 671
      show_timestamp();
#line 672
      printf("Destroying data at %p\n", fatma->data);
#line 673
      log_unlock();
    }
#line 675
    js_destroy(fatma->data);
#line 676
    if ((unsigned long )fatma->ptr != (unsigned long )((js_string *)0)) {
#line 677
      if (rlog_level >= 4) {
#line 678
        log_lock();
#line 679
        show_timestamp();
#line 680
        printf("Destroying ptr at %p\n", fatma->ptr);
#line 681
        log_unlock();
      }
#line 683
      js_destroy(fatma->ptr);
    }
#line 687
    if ((unsigned long )fatma->zap == (unsigned long )((void *)0)) {
#line 687
      if (depth >= 1) {
#line 688
        if (rlog_level >= 4) {
#line 689
          log_lock();
#line 690
          show_timestamp();
#line 691
          printf("Destroying query at %p\n", fatma->query);
#line 692
          log_unlock();
        }
#line 694
        js_destroy(fatma->query);
      }
    }
#line 696
    remember = fatma;
#line 697
    fatma = fatma->next;
#line 698
    if ((unsigned long )remember->zap != (unsigned long )((void *)0)) {
#line 701
      if ((int )(remember->zap)->nukable_hp == 2) {
#line 702
        js_destroy(remember->query);
      }
#line 704
      remove_fila(remember->zap);
    }
#line 707
    if (rlog_level >= 4) {
#line 708
      log_lock();
#line 709
      show_timestamp();
#line 710
      printf("Destroying remember at %p\n", remember);
#line 711
      log_unlock();
    }
#line 714
    js_dealloc((void *)remember);
  }
#line 717
  return (1);
}
}
#line 729 "recursive.c"
int substring_issame(js_string *longjs , int offset , int length , js_string *shortjs ) 
{ js_string *compare ;
  int ret ;
  int tmp ;

  {
#line 734
  if (longjs->unit_size != 1U) {
#line 735
    return (-1);
  } else
#line 734
  if (shortjs->unit_size != 1U) {
#line 735
    return (-1);
  }
#line 736
  if (offset < 0) {
#line 737
    return (-1);
  } else
#line 736
  if (length < 1) {
#line 737
    return (-1);
  }
#line 739
  compare = js_create((unsigned int )(length + 1), 1U);
#line 739
  if ((unsigned long )compare == (unsigned long )((js_string *)0)) {
#line 740
    return (-1);
  }
#line 741
  tmp = js_substr(longjs, compare, offset, length);
#line 741
  if (tmp == -1) {
#line 742
    js_destroy(compare);
#line 743
    return (-1);
  }
#line 745
  ret = js_issame(shortjs, compare);
#line 746
  js_destroy(compare);
#line 747
  return (ret);
}
}
#line 761 "recursive.c"
int substring_issame_case(js_string *longjs , int offset , int length , js_string *shortjs ) 
{ js_string *compare ;
  js_string *lower ;
  int ret ;
  int case_folded1 ;
  int case_folded2 ;
  int counter ;
  int qtype_long ;
  int qtype_short ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 766
  lower = (js_string *)0;
#line 768
  if (longjs->unit_size != 1U) {
#line 769
    return (-1);
  } else
#line 768
  if (shortjs->unit_size != 1U) {
#line 769
    return (-1);
  }
#line 770
  if (offset < 0) {
#line 771
    return (-1);
  } else
#line 770
  if (length < 1) {
#line 771
    return (-1);
  }
#line 773
  compare = js_create((unsigned int )(length + 1), 1U);
#line 773
  if ((unsigned long )compare == (unsigned long )((js_string *)0)) {
#line 774
    return (-1);
  }
#line 775
  tmp = js_substr(longjs, compare, offset, length);
#line 775
  if (tmp == -1) {
#line 776
    js_destroy(compare);
#line 777
    return (-1);
  }
#line 780
  qtype_long = get_rtype(compare);
#line 781
  qtype_short = get_rtype(shortjs);
#line 783
  if (qtype_long == -1) {
#line 784
    js_destroy(compare);
#line 785
    return (-1);
  } else
#line 783
  if (qtype_short == -1) {
#line 784
    js_destroy(compare);
#line 785
    return (-1);
  }
#line 789
  if (qtype_short == 255) {
#line 790
    tmp___0 = change_rtype(shortjs, qtype_long);
#line 790
    if (tmp___0 == -1) {
#line 791
      js_destroy(compare);
#line 792
      return (-1);
    }
  }
#line 797
  ret = js_issame(shortjs, compare);
#line 799
  if (ret == -1) {
#line 800
    js_destroy(compare);
#line 801
    change_rtype(shortjs, qtype_short);
#line 802
    return (-1);
  }
#line 805
  if (ret == 0) {
#line 806
    lower = js_create(shortjs->unit_count + 1U, 1U);
#line 806
    if ((unsigned long )lower == (unsigned long )((js_string *)0)) {
#line 807
      js_destroy(compare);
#line 808
      change_rtype(shortjs, qtype_short);
#line 809
      return (-1);
    }
#line 811
    ret = -1;
#line 812
    tmp___1 = js_copy(shortjs, lower);
#line 812
    if (tmp___1 == -1) {
#line 813
      goto cleanup;
    }
#line 814
    case_folded1 = fold_case(lower);
#line 815
    case_folded2 = fold_case(compare);
#line 818
    if (case_folded1 == 1) {
#line 818
      goto _L;
    } else
#line 818
    if (case_folded2 == 1) {
      _L: /* CIL Label */ 
#line 821
      ret = js_issame(lower, compare);
#line 822
      if (ret == -1) {
#line 823
        goto cleanup;
      }
#line 824
      if (ret == 0) {
#line 825
        goto cleanup;
      }
#line 830
      if (case_folded1 == 1) {
#line 831
        fold_case(shortjs);
      }
#line 834
      if (case_folded2 == 1) {
#line 835
        counter = offset;
#line 836
        while (counter + 2 < offset + length) {
#line 837
          if ((int )*(longjs->string + counter) >= 65) {
#line 837
            if ((int )*(longjs->string + counter) <= 90) {
#line 839
              *(longjs->string + counter) = (unsigned char )((int )*(longjs->string + counter) + 32);
            }
          }
#line 841
          counter ++;
        }
      }
    } else {
#line 846
      ret = 0;
    }
  }
  cleanup: 
#line 850
  if ((unsigned long )lower != (unsigned long )((js_string *)0)) {
#line 851
    js_destroy(lower);
  }
#line 852
  js_destroy(compare);
#line 853
  change_rtype(shortjs, qtype_short);
#line 854
  return (ret);
}
}
#line 863 "recursive.c"
int check_case_of_answer(js_string *uindata , js_string *query , int offset ) 
{ js_string *copy ;
  int result ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 866
  copy = js_create(query->unit_count + 3U, 1U);
#line 866
  if ((unsigned long )copy == (unsigned long )((js_string *)0)) {
#line 867
    return (-1);
  }
#line 868
  tmp = js_copy(query, copy);
#line 868
  if (tmp == -1) {
#line 869
    js_destroy(copy);
#line 870
    return (-1);
  }
#line 874
  tmp___0 = change_rtype(copy, 2);
#line 874
  if (tmp___0 == -1) {
#line 875
    js_destroy(copy);
#line 876
    return (-1);
  }
#line 879
  result = 0;
#line 880
  while (1) {
#line 882
    tmp___1 = dlabel_length(uindata, (unsigned int )offset);
#line 882
    result = substring_issame_case(uindata, offset, tmp___1 + 2, copy);
#line 880
    tmp___2 = bobbit_label(copy);
#line 880
    if (tmp___2 > 0) {
#line 880
      if (! (result <= 0)) {
#line 880
        break;
      }
    } else {
#line 880
      break;
    }
  }
#line 887
  js_destroy(copy);
#line 888
  return (1);
}
}
#line 899 "recursive.c"
int substring_add_rr(mhash *hashp , js_string *longjs , int offset , int length ,
                     uint32_t ttl , js_string *query , int action , int datatype ,
                     int rcode ) 
{ js_string *sub ;
  int ret ;
  uint32_t ttd ;
  int tmp ;
  int64_t tmp___0 ;

  {
#line 902
  sub = (js_string *)0;
#line 906
  if (longjs->unit_size != 1U) {
#line 907
    return (-1);
  } else
#line 906
  if (query->unit_size != 1U) {
#line 907
    return (-1);
  }
#line 908
  if (offset < 0) {
#line 909
    return (-1);
  } else
#line 908
  if (length < 1) {
#line 909
    return (-1);
  }
#line 910
  if (action < 1) {
#line 911
    return (-1);
  } else
#line 910
  if (action > 2) {
#line 911
    return (-1);
  }
#line 914
  sub = js_create((unsigned int )(length + 1), 1U);
#line 914
  if ((unsigned long )sub == (unsigned long )((js_string *)0)) {
#line 915
    return (-1);
  }
#line 916
  tmp = js_substr(longjs, sub, offset, length);
#line 916
  if (tmp == -1) {
#line 917
    js_destroy(sub);
#line 918
    return (-1);
  }
#line 922
  tmp___0 = qual_get_time();
#line 922
  ttd = (uint32_t )(tmp___0 + (int64_t )ttl);
#line 925
  ret = mhash_put_data(hashp, query, sub, ttl, 0, ttd, datatype, 255, action, rcode);
#line 926
  custodian();
#line 927
  js_destroy(sub);
#line 928
  return (ret);
}
}
#line 939 "recursive.c"
int offset_bailiwick(js_string *js , int offset , js_string *bailiwick ) 
{ js_string *sub ;
  int len ;
  int ret ;
  int len_save ;
  int tmp ;

  {
#line 944
  if (bailiwick->unit_size != 1U) {
#line 945
    return (-1);
  }
#line 948
  len = dlabel_length(js, (unsigned int )offset);
#line 949
  if (len == -1) {
#line 950
    return (-1);
  }
#line 953
  sub = js_create((unsigned int )(len + 1), 1U);
#line 953
  if ((unsigned long )sub == (unsigned long )((js_string *)0)) {
#line 954
    return (-1);
  }
#line 955
  tmp = js_substr(js, sub, offset, len);
#line 955
  if (tmp == -1) {
#line 956
    js_destroy(sub);
#line 957
    return (-1);
  }
#line 962
  len_save = (int )bailiwick->unit_count;
#line 963
  len = dlabel_length(bailiwick, 0U);
#line 964
  if (len == -1) {
#line 965
    js_destroy(sub);
#line 966
    return (-1);
  }
#line 968
  bailiwick->unit_count = (unsigned int )len;
#line 970
  ret = in_bailiwick(sub, bailiwick);
#line 971
  bailiwick->unit_count = (unsigned int )len_save;
#line 972
  js_destroy(sub);
#line 973
  return (ret);
}
}
#line 986 "recursive.c"
int in_bailiwick(js_string *host , js_string *bailiwick ) 
{ js_string *get ;
  js_string *b_lower ;
  int result ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 989
  get = js_create(host->unit_count + 3U, 1U);
#line 989
  if ((unsigned long )get == (unsigned long )((js_string *)0)) {
#line 990
    return (-1);
  }
#line 991
  b_lower = js_create(bailiwick->unit_count + 3U, 1U);
#line 991
  if ((unsigned long )b_lower == (unsigned long )((js_string *)0)) {
#line 992
    js_destroy(get);
#line 993
    return (-1);
  }
#line 995
  tmp = js_copy(host, get);
#line 995
  if (tmp == -1) {
#line 996
    js_destroy(get);
#line 997
    js_destroy(b_lower);
#line 998
    return (-1);
  }
#line 1000
  tmp___0 = js_copy(bailiwick, b_lower);
#line 1000
  if (tmp___0 == -1) {
#line 1001
    js_destroy(get);
#line 1002
    js_destroy(b_lower);
#line 1003
    return (-1);
  }
#line 1006
  get->encoding = 2;
#line 1007
  b_lower->encoding = 2;
#line 1010
  tmp___1 = js_tolower(get);
#line 1010
  if (tmp___1 == -1) {
#line 1011
    js_destroy(get);
#line 1012
    js_destroy(b_lower);
#line 1013
    return (-1);
  }
#line 1015
  tmp___2 = js_tolower(b_lower);
#line 1015
  if (tmp___2 == -1) {
#line 1016
    js_destroy(get);
#line 1017
    js_destroy(b_lower);
#line 1018
    return (-1);
  }
#line 1021
  get->encoding = bailiwick->encoding;
#line 1022
  b_lower->encoding = bailiwick->encoding;
#line 1024
  result = 0;
#line 1025
  tmp___3 = js_issame(get, b_lower);
#line 1025
  if (tmp___3 == 1) {
#line 1026
    js_destroy(get);
#line 1027
    js_destroy(b_lower);
#line 1028
    return (1);
  }
#line 1030
  while (1) {
#line 1030
    if (result == 0) {
#line 1030
      if (! (get->unit_count > b_lower->unit_count)) {
#line 1030
        break;
      }
    } else {
#line 1030
      break;
    }
#line 1031
    tmp___4 = bobbit_label(get);
#line 1031
    if (tmp___4 == -1) {
#line 1032
      js_destroy(get);
#line 1033
      js_destroy(b_lower);
#line 1034
      return (-1);
    }
#line 1036
    tmp___5 = js_issame(get, b_lower);
#line 1036
    if (tmp___5 == 1) {
#line 1037
      js_destroy(get);
#line 1038
      js_destroy(b_lower);
#line 1039
      return (1);
    }
  }
#line 1042
  js_destroy(get);
#line 1043
  js_destroy(b_lower);
#line 1044
  return (result);
}
}
#line 1050 "recursive.c"
int q_bailiwick(js_string *host , js_string *bailiwick ) 
{ int ret ;

  {
#line 1052
  if (host->unit_count < 3U) {
#line 1053
    return (-1);
  }
#line 1055
  if (bailiwick->unit_count < 3U) {
#line 1056
    return (-1);
  }
#line 1058
  host->unit_count -= 2U;
#line 1059
  bailiwick->unit_count -= 2U;
#line 1060
  ret = in_bailiwick(host, bailiwick);
#line 1061
  host->unit_count += 2U;
#line 1062
  bailiwick->unit_count += 2U;
#line 1063
  return (ret);
}
}
#line 1080 "recursive.c"
int mhash_put_data(mhash *hash , js_string *query , js_string *value___0 , uint32_t ttl ,
                   uint32_t authoritative , uint32_t expire , int datatype , int rtype ,
                   int action , int rcode ) 
{ rr *data ;
  rr *point ;
  js_string *new ;
  js_string *new_query ;
  js_string *zap_query ;
  int retz ;
  int rrtype ;
  int add_zap ;
  int use_immutable_key ;
  mhash_e spot_data ;
  void *tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint16_t tmp___2 ;
  struct rr *tmp___3 ;
  js_string *tmp___4 ;
  int64_t tmp___5 ;
  int64_t tmp___6 ;
  int64_t tmp___7 ;
  int64_t tmp___8 ;
  int tmp___9 ;
  struct rr *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 1084
  data = (rr *)0;
#line 1084
  point = (rr *)0;
#line 1085
  new = (js_string *)0;
#line 1085
  new_query = (js_string *)0;
#line 1085
  zap_query = (js_string *)0;
#line 1086
  retz = -1;
#line 1088
  add_zap = 0;
#line 1089
  use_immutable_key = 0;
#line 1093
  tmp = js_alloc(1, (int )sizeof(rr ));
#line 1093
  data = (rr *)tmp;
#line 1093
  if ((unsigned long )data == (unsigned long )((rr *)0)) {
#line 1094
    return (-1);
  }
#line 1096
  if (rlog_level >= 4) {
#line 1097
    log_lock();
#line 1098
    show_timestamp();
#line 1099
    printf("Adding RR/psudo-NXDOMAIN ");
#line 1100
    show_esc_stdout(query);
#line 1101
    printf(" to cache at %p\n", data);
#line 1102
    log_unlock();
  }
#line 1106
  init_rr(data);
#line 1108
  tmp___2 = (uint16_t )0;
#line 1108
  data->rr_type = tmp___2;
#line 1108
  tmp___1 = (uint32_t )tmp___2;
#line 1108
  data->authoritative = tmp___1;
#line 1108
  tmp___0 = tmp___1;
#line 1108
  data->ttl = tmp___0;
#line 1108
  data->expire = (int64_t )tmp___0;
#line 1109
  tmp___3 = (struct rr *)0;
#line 1109
  data->ip = tmp___3;
#line 1109
  data->next = tmp___3;
#line 1110
  tmp___4 = (js_string *)0;
#line 1110
  data->data = tmp___4;
#line 1110
  data->query = tmp___4;
#line 1111
  data->ptr = (js_string *)0;
#line 1112
  data->seen = (char)0;
#line 1113
  data->zap = (fila *)0;
#line 1116
  data->authoritative = authoritative;
#line 1117
  if (rcode == 3) {
#line 1118
    data->rcode = (char)3;
  } else {
#line 1120
    data->rcode = (char)0;
  }
#line 1123
  if (datatype == 5) {
#line 1124
    rrtype = 6;
  } else
#line 1125
  if (rtype == 255) {
#line 1126
    rrtype = get_rtype(query);
  } else {
#line 1128
    rrtype = rtype;
  }
#line 1129
  if (rrtype == -1) {
#line 1130
    js_dealloc((void *)data);
#line 1131
    return (-1);
  }
#line 1133
  if (rrtype < 0) {
#line 1134
    js_dealloc((void *)data);
#line 1135
    return (-1);
  } else
#line 1133
  if (rrtype > 65535) {
#line 1134
    js_dealloc((void *)data);
#line 1135
    return (-1);
  }
#line 1137
  data->rr_type = (uint16_t )rrtype;
#line 1141
  data->ttl = ttl;
#line 1142
  if (rrtype == 5) {
#line 1143
    if (ttl < (uint32_t )min_ttl_cname) {
#line 1144
      tmp___5 = qual_get_time();
#line 1144
      data->expire = tmp___5 + (int64_t )min_ttl_cname;
#line 1145
      data->ttl = (uint32_t )min_ttl_cname;
    } else {
#line 1147
      tmp___6 = qual_get_time();
#line 1147
      data->expire = tmp___6 + (int64_t )ttl;
    }
  } else
#line 1150
  if (ttl < (uint32_t )min_ttl_normal) {
#line 1151
    tmp___7 = qual_get_time();
#line 1151
    data->expire = tmp___7 + (int64_t )min_ttl_normal;
#line 1152
    data->ttl = (uint32_t )min_ttl_normal;
  } else {
#line 1154
    tmp___8 = qual_get_time();
#line 1154
    data->expire = tmp___8 + (int64_t )ttl;
  }
#line 1167
  new = js_create(value___0->unit_count + 1U, value___0->unit_size);
#line 1167
  if ((unsigned long )new == (unsigned long )((js_string *)0)) {
#line 1168
    js_dealloc((void *)data);
#line 1169
    return (-1);
  }
#line 1171
  tmp___9 = js_copy(value___0, new);
#line 1171
  if (tmp___9 == -1) {
#line 1172
    js_dealloc((void *)data);
#line 1173
    js_destroy(new);
#line 1174
    return (-1);
  }
#line 1177
  data->data = new;
#line 1180
  tmp___10 = (struct rr *)0;
#line 1180
  data->next = tmp___10;
#line 1180
  data->ip = tmp___10;
#line 1188
  if (datatype == 5) {
#line 1188
    goto _L;
  } else
#line 1188
  if (rtype != 255) {
    _L: /* CIL Label */ 
#line 1189
    new_query = js_create(query->unit_count + 1U, 1U);
#line 1189
    if ((unsigned long )new_query == (unsigned long )((js_string *)0)) {
#line 1190
      js_dealloc((void *)data);
#line 1191
      js_destroy(new);
#line 1192
      return (-1);
    }
#line 1194
    tmp___11 = js_copy(query, new_query);
#line 1194
    if (tmp___11 == -1) {
#line 1195
      js_destroy(new_query);
#line 1196
      js_dealloc((void *)data);
#line 1197
      js_destroy(new);
#line 1198
      return (-1);
    }
#line 1200
    tmp___12 = change_rtype(new_query, rrtype);
#line 1200
    if (tmp___12 == -1) {
#line 1201
      js_destroy(new_query);
#line 1202
      js_dealloc((void *)data);
#line 1203
      js_destroy(new);
#line 1204
      return (-1);
    }
#line 1206
    zap_query = js_create(query->unit_count + 1U, 1U);
#line 1206
    if ((unsigned long )zap_query == (unsigned long )((js_string *)0)) {
#line 1207
      js_destroy(new_query);
#line 1208
      js_dealloc((void *)data);
#line 1209
      js_destroy(new);
#line 1210
      return (-1);
    }
#line 1212
    tmp___13 = js_copy(query, zap_query);
#line 1212
    if (tmp___13 == -1) {
#line 1213
      js_destroy(new_query);
#line 1214
      js_destroy(zap_query);
#line 1215
      js_dealloc((void *)data);
#line 1216
      js_destroy(new);
#line 1217
      return (-1);
    }
#line 1219
    data->query = new_query;
#line 1220
    add_zap = -1;
  } else {
#line 1226
    use_immutable_key = 1;
  }
#line 1233
  spot_data = mhash_get(hash, query);
#line 1234
  if ((unsigned long )spot_data.value != (unsigned long )((void *)0)) {
#line 1237
    if (action == 1) {
#line 1237
      goto _L___0;
    } else
#line 1237
    if (spot_data.datatype == 4) {
      _L___0: /* CIL Label */ 
#line 1238
      if (rlog_level >= 4) {
#line 1239
        log_lock();
#line 1240
        show_timestamp();
#line 1241
        printf("Element already in hash at %p, zapping\n", spot_data.value);
#line 1243
        log_unlock();
      }
#line 1246
      if (add_zap == 0) {
#line 1247
        add_zap = 1;
      }
#line 1250
      switch (spot_data.datatype) {
      case 3: 
      case 5: 
#line 1253
      unlink_rr((rr *)spot_data.value, 0);
#line 1254
      mhash_undef(hash, query);
#line 1255
      break;
      case 4: 
#line 1257
      unlink_closer((closer *)spot_data.value);
#line 1258
      mhash_undef(hash, query);
#line 1259
      break;
      default: 
#line 1262
      js_dealloc((void *)data);
#line 1263
      js_destroy(new);
#line 1264
      if (add_zap == -1) {
#line 1265
        js_destroy(new_query);
#line 1266
        js_destroy(zap_query);
      }
#line 1268
      return (-1);
      }
    } else
#line 1271
    if (action == 2) {
#line 1272
      if (rlog_level >= 4) {
#line 1273
        log_lock();
#line 1274
        show_timestamp();
#line 1275
        printf("Appending element in hash at %p\n", spot_data.value);
#line 1277
        log_unlock();
      }
#line 1279
      point = (rr *)spot_data.value;
#line 1280
      while ((unsigned long )point->next != (unsigned long )((void *)0)) {
#line 1281
        point = point->next;
      }
#line 1282
      point->next = data;
    }
  }
#line 1288
  if (action == 1) {
#line 1288
    goto _L___1;
  } else
#line 1288
  if ((unsigned long )spot_data.value == (unsigned long )((void *)0)) {
    _L___1: /* CIL Label */ 
#line 1290
    retz = mhash_put(hash, query, (void *)data, datatype);
#line 1291
    if (retz == -1) {
#line 1292
      js_dealloc((void *)data);
#line 1293
      js_destroy(new);
#line 1294
      if (add_zap == -1) {
#line 1295
        js_destroy(new_query);
#line 1296
        js_destroy(zap_query);
      }
#line 1298
      return (-1);
    }
#line 1300
    if (add_zap == 0) {
#line 1301
      add_zap = 1;
    }
  }
#line 1306
  if (use_immutable_key == 1) {
#line 1307
    data->query = mhash_get_immutable_key(hash, query);
  }
#line 1311
  if (add_zap == 1) {
#line 1312
    data->zap = new_fila((void *)data, (unsigned char)0, data->query, (char)0);
  } else
#line 1313
  if (add_zap == -1) {
#line 1314
    data->zap = new_fila((void *)data, (unsigned char)0, zap_query, (char)2);
  }
#line 1316
  if (rlog_level >= 4) {
#line 1317
    log_lock();
#line 1318
    show_timestamp();
#line 1319
    printf("Sucessfully added ");
#line 1320
    show_esc_stdout(query);
#line 1321
    printf(" to cache at %p\n", data);
#line 1322
    log_unlock();
  }
#line 1325
  return (1);
}
}
#line 1340 "recursive.c"
int handle_negative_data(js_string *query , js_string *server_reply , int offset ,
                         q_header *header ) 
{ int query_type ;
  int len ;
  uint32_t ttl ;
  int rdlength ;
  int ret ;

  {
#line 1347
  query_type = get_rtype(query);
#line 1348
  if (query_type == -1) {
#line 1349
    return (-1);
  }
#line 1360
  len = dlabel_length(server_reply, (unsigned int )offset);
#line 1361
  if (len == -1) {
#line 1362
    return (-1);
  }
#line 1364
  len += 2;
#line 1366
  offset += len + 2;
#line 1370
  ttl = js_readuint32(server_reply, (unsigned int )offset);
#line 1371
  if (ttl == 4294967295U) {
#line 1372
    return (-1);
  }
#line 1373
  offset += 4;
#line 1375
  rdlength = js_readuint16(server_reply, (unsigned int )offset);
#line 1376
  if (rdlength == -1) {
#line 1377
    return (-1);
  }
#line 1379
  offset += 2;
#line 1380
  ret = substring_add_rr(dnscache, server_reply, offset, rdlength, ttl, query, 1,
                         5, header->rcode);
#line 1382
  return (ret);
}
}
#line 1393 "recursive.c"
int cmp_dnames(js_string *js , int p1 , int p2 ) 
{ int temp ;
  int length ;
  int tmp ;
  int tmp___0 ;
  char cg_l ;
  char cg_r ;

  {
#line 1396
  tmp = js_has_sanity(js);
#line 1396
  if (tmp == -1) {
#line 1397
    return (-1);
  }
#line 1400
  if (p1 > p2) {
#line 1401
    temp = p1;
#line 1402
    p1 = p2;
#line 1403
    p2 = temp;
  }
#line 1407
  if (p1 == p2) {
#line 1408
    return (1);
  }
#line 1413
  if (p1 < 0) {
#line 1414
    return (-1);
  } else
#line 1413
  if ((unsigned int )p1 > js->unit_count) {
#line 1414
    return (-1);
  } else
#line 1413
  if ((unsigned int )p2 > js->unit_count) {
#line 1414
    return (-1);
  }
#line 1416
  length = dlabel_length(js, (unsigned int )p1);
#line 1419
  if (p1 + length > p2) {
#line 1420
    return (0);
  }
#line 1423
  tmp___0 = dlabel_length(js, (unsigned int )p2);
#line 1423
  if (length != tmp___0) {
#line 1424
    return (0);
  }
#line 1428
  if ((unsigned int )(p2 + length) > js->unit_count) {
#line 1429
    return (-1);
  }
#line 1432
  temp = 0;
#line 1433
  while (temp < length) {
#line 1438
    cg_l = (char )*((js->string + p1) + temp);
#line 1439
    cg_r = (char )*((js->string + p2) + temp);
#line 1440
    if ((int )cg_l >= 65) {
#line 1440
      if ((int )cg_l <= 90) {
#line 1440
        cg_l = (char )((int )cg_l + 32);
      }
    }
#line 1441
    if ((int )cg_r >= 65) {
#line 1441
      if ((int )cg_r <= 90) {
#line 1441
        cg_r = (char )((int )cg_r + 32);
      }
    }
#line 1442
    if ((int )cg_l != (int )cg_r) {
#line 1443
      return (0);
    }
#line 1445
    temp ++;
  }
#line 1449
  return (1);
}
}
#line 1467 "recursive.c"
int query_nameserver(int remote_ip , js_string *query , js_string *bailiwick ) 
{ struct sockaddr_in dns_udp ;
  struct sockaddr_in server ;
  int len_inet ;
  int s ;
  int nspoint ;
  int offset ;
  int len ;
  int type ;
  int class ;
  int rdlength ;
  int cname_original_record ;
  uint32_t ttl ;
  uint16_t sid ;
  uint16_t ns_record_type ;
  int record_added ;
  int return_code_check ;
  js_string *outdata ;
  js_string *indata ;
  js_string *uindata ;
  js_string *jsip ;
  uint32_t ipq ;
  js_string *ptrq ;
  q_header header ;
  int counter ;
  int count ;
  int ret ;
  fd_set rx_set ;
  int maxd ;
  struct timeval tv ;
  int n ;
  uint16_t ns_record[32] ;
  uint16_t ns_domain[32] ;
  struct sockaddr_in dummy ;
  mhash_e point ;
  rr *spot ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  __uint16_t tmp___1 ;
  __uint32_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  uint16_t tmp___12 ;
  __uint16_t tmp___13 ;
  int tmp___14 ;
  ssize_t tmp___15 ;
  int __fd ;
  ssize_t tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int is_arpa_address ;
  int tmp___19 ;
  int rdlength___0 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;

  {
#line 1474
  cname_original_record = 0;
#line 1483
  record_added = 0;
#line 1484
  return_code_check = 0;
#line 1490
  ptrq = (js_string *)0;
#line 1510
  if ((unsigned int )remote_ip == 4294967295U) {
#line 1510
    goto _L;
  } else
#line 1510
  if (remote_ip == 0) {
    _L: /* CIL Label */ 
#line 1512
    if (rlog_level >= 4) {
#line 1513
      log_lock();
#line 1514
      show_timestamp();
#line 1515
      printf("Invalid ip ");
#line 1516
      debug_show_ip((uint32_t )remote_ip);
#line 1517
      printf(" rejected\n");
#line 1518
      log_unlock();
    }
#line 1520
    return (-1);
  }
#line 1525
  if (rlog_level >= 4) {
#line 1526
    log_lock();
#line 1527
    show_timestamp();
#line 1528
    printf("Querying DNS server with ip ");
#line 1529
    debug_show_ip((uint32_t )remote_ip);
#line 1530
    printf(" for ");
#line 1531
    show_esc_stdout(query);
#line 1532
    printf(" with bailiwick ");
#line 1533
    show_esc_stdout(bailiwick);
#line 1534
    printf("\n");
#line 1535
    log_unlock();
  }
#line 1539
  counter = 0;
#line 1540
  while (1) {
#line 1540
    if (counter < 500) {
#line 1540
      if (! (spammers[counter].ip != 4294967295U)) {
#line 1540
        break;
      }
    } else {
#line 1540
      break;
    }
#line 1541
    if (((unsigned int )remote_ip & spammers[counter].mask) == (spammers[counter].ip & spammers[counter].mask)) {
#line 1543
      if (rlog_level >= 4) {
#line 1544
        log_lock();
#line 1545
        show_timestamp();
#line 1546
        debug_show_ip((uint32_t )remote_ip);
#line 1547
        printf(" is a DNS server we won\'t talk to\n");
#line 1548
        log_unlock();
      }
#line 1550
      return (-1);
    }
#line 1553
    counter ++;
  }
#line 1557
  ns_record[0] = (uint16_t )0;
#line 1558
  ns_domain[0] = (uint16_t )0;
#line 1561
  indata = js_create(512U, 1U);
#line 1561
  if ((unsigned long )indata == (unsigned long )((js_string *)0)) {
#line 1562
    if (rlog_level >= 4) {
#line 1563
      log_lock();
#line 1564
      show_timestamp();
#line 1565
      printf("Unable to allocate indata string\n");
#line 1566
      log_unlock();
    }
#line 1568
    return (-1);
  }
#line 1570
  uindata = js_create(2048U, 1U);
#line 1570
  if ((unsigned long )uindata == (unsigned long )((js_string *)0)) {
#line 1571
    if (rlog_level >= 4) {
#line 1572
      log_lock();
#line 1573
      show_timestamp();
#line 1574
      printf("Unable to allocate uindata string\n");
#line 1575
      log_unlock();
    }
#line 1577
    js_destroy(indata);
#line 1578
    return (-1);
  }
#line 1580
  outdata = js_create(512U, 1U);
#line 1580
  if ((unsigned long )outdata == (unsigned long )((js_string *)0)) {
#line 1581
    if (rlog_level >= 4) {
#line 1582
      log_lock();
#line 1583
      show_timestamp();
#line 1584
      printf("Unable to allocate outdata string\n");
#line 1585
      log_unlock();
    }
#line 1587
    js_destroy(indata);
#line 1588
    js_destroy(uindata);
#line 1589
    return (-1);
  }
#line 1593
  tmp___0 = __builtin_object_size((void *)(& server), 0);
#line 1593
  if (tmp___0 != 0xffffffffffffffffUL) {
#line 1593
    tmp = __builtin_object_size((void *)(& server), 0);
#line 1593
    __builtin___memset_chk((void *)(& server), 0, sizeof(server), tmp);
  } else {
#line 1593
    __inline_memset_chk((void *)(& server), 0, sizeof(server));
  }
#line 1594
  server.sin_family = (sa_family_t )2;
#line 1595
  tmp___1 = _OSSwapInt16((__uint16_t )upstream_port);
#line 1595
  server.sin_port = (__uint16_t )((int )tmp___1);
#line 1596
  tmp___2 = _OSSwapInt32((__uint32_t )remote_ip);
#line 1596
  server.sin_addr.s_addr = tmp___2;
#line 1596
  if (server.sin_addr.s_addr == 4294967295U) {
#line 1597
    if (rlog_level >= 4) {
#line 1598
      log_lock();
#line 1599
      show_timestamp();
#line 1600
      printf("Failure running htonl\n");
#line 1601
      log_unlock();
    }
#line 1603
    goto cleanup;
  }
#line 1608
  tmp___4 = __builtin_object_size((void *)(& dns_udp), 0);
#line 1608
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 1608
    tmp___3 = __builtin_object_size((void *)(& dns_udp), 0);
#line 1608
    __builtin___memset_chk((void *)(& dns_udp), 0, sizeof(dns_udp), tmp___3);
  } else {
#line 1608
    __inline_memset_chk((void *)(& dns_udp), 0, sizeof(dns_udp));
  }
#line 1609
  dns_udp.sin_family = (sa_family_t )2;
#line 1611
  dns_udp.sin_addr.s_addr = (in_addr_t )((__uint16_t )((int )((__uint16_t )0)));
#line 1613
  len_inet = (int )sizeof(dns_udp);
#line 1616
  sid = srng();
#line 1617
  header.id = sid;
#line 1618
  header.qr = 0;
#line 1619
  header.opcode = 0;
#line 1620
  header.aa = 0;
#line 1621
  header.tc = 0;
#line 1627
  header.rd = root_or_upstream;
#line 1628
  header.ra = 0;
#line 1629
  header.z = 0;
#line 1630
  header.rcode = 0;
#line 1631
  header.qdcount = (uint16_t )1;
#line 1632
  header.ancount = (uint16_t )0;
#line 1633
  header.nscount = (uint16_t )0;
#line 1634
  header.arcount = (uint16_t )0;
#line 1637
  tmp___6 = make_hdr(& header, outdata);
#line 1637
  if (tmp___6 == -1) {
#line 1638
    if (rlog_level >= 4) {
#line 1639
      log_lock();
#line 1640
      show_timestamp();
#line 1641
      printf("Failure running make_hdr\n");
#line 1642
      log_unlock();
    }
#line 1644
    goto cleanup;
  }
#line 1646
  tmp___7 = js_append(query, outdata);
#line 1646
  if (tmp___7 == -1) {
#line 1647
    if (rlog_level >= 4) {
#line 1648
      log_lock();
#line 1649
      show_timestamp();
#line 1650
      printf("Failure running js_append\n");
#line 1651
      log_unlock();
    }
#line 1653
    goto cleanup;
  }
#line 1655
  tmp___8 = js_adduint16(outdata, 1);
#line 1655
  if (tmp___8 == -1) {
#line 1656
    if (rlog_level >= 4) {
#line 1657
      log_lock();
#line 1658
      show_timestamp();
#line 1659
      printf("Failure running js_adduint16\n");
#line 1660
      log_unlock();
    }
#line 1662
    goto cleanup;
  }
#line 1672
  s = socket(2, 2, 0);
#line 1672
  if (s == -1) {
#line 1673
    if (rlog_level >= 2) {
#line 1674
      log_lock();
#line 1675
      show_timestamp();
#line 1676
      printf("WARNING: Failure creating socket\n");
#line 1677
      log_unlock();
    }
#line 1679
    goto cleanup;
  }
#line 1684
  counter = 0;
#line 1686
  while (1) {
#line 1687
    if (rlog_level >= 4) {
#line 1687
      if (counter > 0) {
#line 1688
        log_lock();
#line 1689
        show_timestamp();
#line 1690
        printf("Bind failed, trying again\n");
#line 1691
        log_unlock();
      }
    }
#line 1694
    tmp___12 = srng();
#line 1694
    tmp___13 = _OSSwapInt16((__uint16_t )(recurse_min_bind_port + ((int )tmp___12 & recurse_number_ports)));
#line 1694
    dns_udp.sin_port = (__uint16_t )((int )tmp___13);
#line 1696
    counter ++;
#line 1686
    tmp___14 = bind(s, (struct sockaddr  const  *)((struct sockaddr *)(& dns_udp)),
                    (socklen_t )sizeof(dns_udp));
#line 1686
    if (tmp___14 < 0) {
#line 1686
      if (! (counter < 10)) {
#line 1686
        break;
      }
    } else {
#line 1686
      break;
    }
  }
#line 1700
  if (counter >= 10) {
#line 1701
    close(s);
#line 1702
    if (rlog_level >= 4) {
#line 1703
      log_lock();
#line 1704
      show_timestamp();
#line 1705
      printf("Failure binding, giving up\n");
#line 1706
      log_unlock();
    }
#line 1708
    goto cleanup;
  }
#line 1723
  connect(s, (struct sockaddr  const  *)((struct sockaddr *)(& server)), (socklen_t )sizeof(server));
#line 1724
  tmp___15 = send(s, (void const   *)outdata->string, (size_t )outdata->unit_count,
                  0);
#line 1724
  counter = (int )tmp___15;
#line 1725
  if (counter < 0) {
#line 1726
    close(s);
#line 1727
    if (rlog_level >= 4) {
#line 1728
      log_lock();
#line 1729
      show_timestamp();
#line 1730
      printf("Sendto failure\n");
#line 1731
      log_unlock();
    }
#line 1733
    goto cleanup;
  }
#line 1737
  __builtin_bzero((void *)(& rx_set), sizeof(rx_set));
#line 1738
  while (1) {
#line 1738
    __fd = s;
#line 1738
    rx_set.fds_bits[(unsigned long )__fd / (sizeof(__int32_t ) * 8UL)] |= 1 << (unsigned long )__fd % (sizeof(__int32_t ) * 8UL);
#line 1738
    break;
  }
#line 1739
  maxd = s + 1;
#line 1740
  tv.tv_sec = (__darwin_time_t )timeout_seconds;
#line 1741
  tv.tv_usec = 0;
#line 1745
  big_unlock();
#line 1746
  n = select(maxd, & rx_set, (fd_set *)((void *)0), (fd_set *)((void *)0), & tv);
#line 1749
  do_big_lock();
#line 1750
  if (n == -1) {
#line 1751
    if (rlog_level >= 4) {
#line 1752
      log_lock();
#line 1753
      show_timestamp();
#line 1754
      printf("Select error\n");
#line 1755
      log_unlock();
    }
#line 1757
    close(s);
#line 1758
    goto cleanup;
  }
#line 1760
  if (n == 0) {
#line 1761
    close(s);
#line 1762
    if (rlog_level >= 4) {
#line 1763
      log_lock();
#line 1764
      show_timestamp();
#line 1765
      printf("Timeout contacting remote nameserver\n");
#line 1766
      log_unlock();
    }
#line 1768
    goto minus2;
  }
#line 1771
  tmp___16 = recv(s, (void *)indata->string, (size_t )indata->max_count, 0);
#line 1771
  count = (int )tmp___16;
#line 1771
  if (count < 0) {
#line 1772
    close(s);
#line 1773
    if (rlog_level >= 4) {
#line 1774
      log_lock();
#line 1775
      show_timestamp();
#line 1776
      printf("recvfrom error\n");
#line 1777
      log_unlock();
    }
#line 1779
    goto minus3;
  }
#line 1782
  close(s);
#line 1784
  indata->unit_count = (unsigned int )count;
#line 1785
  tmp___17 = decompress_data(indata, uindata);
#line 1785
  if (tmp___17 == -1) {
#line 1786
    if (rlog_level >= 4) {
#line 1787
      log_lock();
#line 1788
      show_timestamp();
#line 1789
      printf("Decompress failure: ");
#line 1790
      show_esc_stdout(indata);
#line 1791
      printf("\n");
#line 1792
      log_unlock();
    }
#line 1794
    goto minus3;
  }
#line 1796
  if (rlog_level >= 5) {
#line 1797
    log_lock();
#line 1798
    show_timestamp();
#line 1799
    printf("Decompressed packet: ");
#line 1800
    show_esc_stdout(uindata);
#line 1801
    printf("\n");
#line 1802
    log_unlock();
  }
#line 1804
  tmp___18 = read_hdr(uindata, & header);
#line 1804
  if (tmp___18 == -1) {
#line 1805
    if (rlog_level >= 4) {
#line 1806
      log_lock();
#line 1807
      show_timestamp();
#line 1808
      printf("read_hdr failure\n");
#line 1809
      log_unlock();
    }
#line 1811
    goto minus3;
  }
#line 1834
  if ((int )header.id != (int )sid) {
#line 1835
    if (rlog_level >= 4) {
#line 1836
      log_lock();
#line 1837
      show_timestamp();
#line 1838
      printf("Bad id from remote server (possible spoof attempt)\n");
#line 1839
      log_unlock();
    }
#line 1841
    goto cleanup;
  }
#line 1847
  if (header.rcode != 0) {
#line 1847
    if (header.rcode != 3) {
#line 1848
      if (rlog_level >= 4) {
#line 1849
        log_lock();
#line 1850
        show_timestamp();
#line 1851
        printf("Bad rcode from remote server\n");
#line 1852
        log_unlock();
      }
#line 1854
      goto cleanup;
    }
  }
#line 1858
  count = (int )header.qdcount;
#line 1859
  offset = 12;
#line 1860
  while (count > 0) {
#line 1861
    len = dlabel_length(uindata, (unsigned int )offset);
#line 1862
    if (len == -1) {
#line 1863
      if (rlog_level >= 4) {
#line 1864
        log_lock();
#line 1865
        show_timestamp();
#line 1866
        printf("Bad dlabel_length\n");
#line 1867
        log_unlock();
      }
#line 1869
      goto cleanup;
    }
#line 1871
    offset += len;
#line 1872
    offset += 4;
#line 1873
    count --;
  }
#line 1877
  if ((int )header.ancount > 0) {
#line 1885
    nspoint = 1;
#line 1887
    counter = (int )header.ancount;
#line 1888
    while (1) {
#line 1889
      is_arpa_address = 0;
#line 1891
      len = dlabel_length(uindata, (unsigned int )offset);
#line 1892
      if (len == -1) {
#line 1893
        if (rlog_level >= 4) {
#line 1894
          log_lock();
#line 1895
          show_timestamp();
#line 1896
          printf("Bad dlabel_length\n");
#line 1897
          log_unlock();
        }
#line 1899
        goto cleanup;
      }
#line 1902
      len += 2;
#line 1905
      return_code_check = substring_issame_case(uindata, offset, len, query);
#line 1907
      if (return_code_check == -1) {
#line 1908
        if (rlog_level >= 4) {
#line 1909
          log_lock();
#line 1910
          show_timestamp();
#line 1911
          printf("Bad return_code_check\n");
#line 1912
          log_unlock();
        }
#line 1914
        goto cleanup;
      }
#line 1916
      cname_original_record = 0;
#line 1917
      if (return_code_check != 1) {
#line 1920
        cname_original_record = get_rtype(query);
#line 1921
        if (cname_original_record == -1) {
#line 1922
          if (rlog_level >= 4) {
#line 1923
            log_lock();
#line 1924
            show_timestamp();
#line 1925
            printf("Bad cname_original_record\n");
#line 1926
            log_unlock();
          }
#line 1928
          goto cleanup;
        }
#line 1930
        tmp___19 = change_rtype(query, 5);
#line 1930
        if (tmp___19 == -1) {
#line 1931
          if (rlog_level >= 4) {
#line 1932
            log_lock();
#line 1933
            show_timestamp();
#line 1934
            printf("change_rtype problem\n");
#line 1935
            log_unlock();
          }
#line 1937
          goto cleanup;
        }
#line 1941
        tmp___21 = substring_issame_case(uindata, offset, len, query);
#line 1941
        if (tmp___21 != 1) {
#line 1946
          if (rlog_level >= 4) {
#line 1947
            log_lock();
#line 1948
            show_timestamp();
#line 1949
            printf("substring_issame_case is skipping answer\n");
#line 1950
            log_unlock();
          }
#line 1953
          offset += len + 6;
#line 1955
          if ((unsigned int )(offset + 2) > uindata->unit_count) {
#line 1956
            if (rlog_level >= 4) {
#line 1957
              log_lock();
#line 1958
              show_timestamp();
#line 1959
              printf("uindata string truncated\n");
#line 1960
              log_unlock();
            }
#line 1962
            goto minus2;
          }
#line 1965
          rdlength___0 = (((int )*(uindata->string + offset) & 255) << 8) + (int )*((uindata->string + offset) + 1);
#line 1968
          offset += rdlength___0 + 2;
#line 1970
          if ((unsigned int )offset >= uindata->unit_count) {
#line 1971
            if (rlog_level >= 4) {
#line 1972
              log_lock();
#line 1973
              show_timestamp();
#line 1974
              printf("uindata string ended\n");
#line 1975
              log_unlock();
            }
#line 1977
            goto minus2;
          }
#line 1981
          counter --;
#line 1982
          is_arpa_address = 0;
#line 1983
          tmp___20 = change_rtype(query, cname_original_record);
#line 1983
          if (tmp___20 == -1) {
#line 1984
            if (rlog_level >= 4) {
#line 1985
              log_lock();
#line 1986
              show_timestamp();
#line 1987
              printf("change_rtype restore problem\n");
#line 1988
              log_unlock();
            }
#line 1990
            goto cleanup;
          }
#line 1993
          goto __Cont;
        }
#line 2002
        counter = 0;
      }
#line 2005
      offset += len + 2;
#line 2007
      ttl = js_readuint32(uindata, (unsigned int )offset);
#line 2009
      if (ttl == 4294967295U) {
#line 2010
        if (rlog_level >= 4) {
#line 2011
          log_lock();
#line 2012
          show_timestamp();
#line 2013
          printf("bad ttl\n");
#line 2014
          log_unlock();
        }
#line 2016
        goto minus2;
      }
#line 2020
      if (ttl < 20U) {
#line 2021
        ttl = (uint32_t )20;
      }
#line 2022
      if (ttl > 63072000U) {
#line 2023
        ttl = (uint32_t )63072000;
      }
#line 2026
      if (ttl > 900U) {
#line 2026
        if (cname_original_record != 0) {
#line 2027
          ttl = (uint32_t )900;
        }
      }
#line 2029
      offset += 4;
#line 2031
      rdlength = js_readuint16(uindata, (unsigned int )offset);
#line 2032
      if (rdlength == -1) {
#line 2033
        if (rlog_level >= 4) {
#line 2034
          log_lock();
#line 2035
          show_timestamp();
#line 2036
          printf("bad rdlength\n");
#line 2037
          log_unlock();
        }
#line 2039
        goto minus2;
      }
#line 2042
      offset += 2;
#line 2043
      ret = substring_add_rr(dnscache, uindata, offset, rdlength, ttl, query, nspoint,
                             3, header.rcode);
#line 2049
      jsip = js_create(256U, 1U);
#line 2049
      if ((unsigned long )jsip == (unsigned long )((js_string *)0)) {
#line 2050
        if (rlog_level >= 4) {
#line 2051
          log_lock();
#line 2052
          show_timestamp();
#line 2053
          printf("bad jsip\n");
#line 2054
          log_unlock();
        }
#line 2056
        goto cleanup;
      }
#line 2058
      ipq = (uint32_t )0;
#line 2061
      point = mhash_get(dnscache, query);
#line 2062
      if ((unsigned long )point.value != (unsigned long )((void *)0)) {
#line 2062
        if (point.datatype == 3) {
#line 2063
          spot = (rr *)point.value;
#line 2066
          move_to_top(spot->zap);
#line 2068
          if ((unsigned long )spot->data != (unsigned long )((js_string *)0)) {
#line 2068
            if ((int )spot->rr_type == 5) {
#line 2073
              tmp___22 = js_copy(spot->data, jsip);
#line 2073
              if (tmp___22 == -1) {
#line 2074
                if (rlog_level >= 4) {
#line 2075
                  log_lock();
#line 2076
                  show_timestamp();
#line 2077
                  printf("bad js_copy\n");
#line 2078
                  log_unlock();
                }
#line 2080
                goto cleanup_jsip;
              }
#line 2087
              is_arpa_address = arpa_at_end_p(query);
#line 2088
              if (is_arpa_address == 1) {
#line 2089
                tmp___23 = js_adduint16(jsip, 12);
#line 2089
                if (tmp___23 == -1) {
#line 2090
                  if (rlog_level >= 4) {
#line 2091
                    log_lock();
#line 2092
                    show_timestamp();
#line 2093
                    printf("bad js_adduint16 RR_PTR\n");
#line 2094
                    log_unlock();
                  }
#line 2096
                  goto cleanup_jsip;
                }
#line 2098
                ptrq = js_create(257U, 1U);
#line 2098
                if ((unsigned long )ptrq == (unsigned long )((js_string *)0)) {
#line 2099
                  goto cleanup_jsip;
                }
#line 2101
                if (rlog_level >= 4) {
#line 2102
                  log_lock();
#line 2103
                  show_timestamp();
#line 2104
                  printf("About to recursively chase ptr ");
#line 2105
                  show_esc_stdout(jsip);
#line 2106
                  printf("\n");
#line 2107
                  log_unlock();
                }
#line 2109
                tmp___24 = recurse_call(0, 0, dummy, jsip, 0, 0, (uint32_t *)0, ptrq);
#line 2109
                if (tmp___24 == -1) {
#line 2111
                  js_destroy(ptrq);
#line 2112
                  goto cleanup_jsip;
                }
#line 2114
                ipq = (uint32_t )0;
              } else {
#line 2117
                tmp___25 = js_adduint16(jsip, 1);
#line 2117
                if (tmp___25 == -1) {
#line 2118
                  if (rlog_level >= 4) {
#line 2119
                    log_lock();
#line 2120
                    show_timestamp();
#line 2121
                    printf("bad js_adduint16 RR_A\n");
#line 2122
                    log_unlock();
                  }
#line 2124
                  goto cleanup_jsip;
                }
#line 2126
                tmp___26 = recurse_call(0, 0, dummy, jsip, 0, 0, & ipq, (js_string *)0);
#line 2126
                if (tmp___26 == -1) {
#line 2127
                  goto cleanup_jsip;
                }
              }
            }
          }
        }
      }
#line 2133
      if (ipq != 0U) {
#line 2134
        *(jsip->string) = (unsigned char )((ipq & 4278190080U) >> 24);
#line 2135
        *(jsip->string + 1) = (unsigned char )((ipq & 16711680U) >> 16);
#line 2136
        *(jsip->string + 2) = (unsigned char )((ipq & 65280U) >> 8);
#line 2137
        *(jsip->string + 3) = (unsigned char )(ipq & 255U);
#line 2138
        jsip->unit_count = 4U;
#line 2139
        mhash_add_ip(dnscache, query, jsip);
#line 2141
        js_destroy(jsip);
      } else
#line 2143
      if ((unsigned long )ptrq != (unsigned long )((js_string *)0)) {
#line 2143
        tmp___27 = js_qissame((char *)"NotQual", ptrq);
#line 2143
        if (tmp___27) {
#line 2143
          goto _L___0;
        } else {
#line 2144
          mhash_add_ptr(dnscache, query, ptrq);
#line 2145
          js_destroy(ptrq);
#line 2146
          js_destroy(jsip);
        }
      } else {
        _L___0: /* CIL Label */ 
#line 2150
        if ((unsigned long )ptrq != (unsigned long )((js_string *)0)) {
#line 2151
          js_destroy(ptrq);
        }
#line 2155
        js_destroy(jsip);
      }
#line 2157
      nspoint = 2;
#line 2158
      counter --;
#line 2159
      offset += rdlength;
#line 2160
      if (cname_original_record != 0) {
#line 2161
        tmp___28 = change_rtype(query, cname_original_record);
#line 2161
        if (tmp___28 == -1) {
#line 2162
          if (rlog_level >= 4) {
#line 2163
            log_lock();
#line 2164
            show_timestamp();
#line 2165
            printf("bad change_rtype return code\n");
#line 2166
            log_unlock();
          }
#line 2168
          goto cleanup;
        }
      }
      __Cont: /* CIL Label */ 
#line 1888
      if (! (counter > 0)) {
#line 1888
        break;
      }
    }
#line 2173
    js_destroy(indata);
#line 2174
    js_destroy(uindata);
#line 2175
    js_destroy(outdata);
#line 2176
    if (cname_original_record == 0) {
#line 2177
      return (2);
    } else {
#line 2179
      return (3);
    }
  }
#line 2185
  if ((int )header.nscount == 0) {
#line 2186
    goto minus2;
  }
#line 2189
  count = (int )header.nscount;
#line 2190
  nspoint = 0;
#line 2192
  if (count > 29) {
#line 2193
    count = 29;
  }
#line 2200
  nspoint = 0;
#line 2201
  while (nspoint < count) {
#line 2203
    len = dlabel_length(uindata, (unsigned int )offset);
#line 2204
    if (len == -1) {
#line 2205
      goto cleanup;
    }
#line 2209
    tmp___29 = js_readuint16(uindata, (unsigned int )(offset + len));
#line 2209
    ns_record_type = (uint16_t )tmp___29;
#line 2213
    if (nspoint == 0) {
#line 2213
      if ((int )ns_record_type == 6) {
#line 2214
        js_destroy(indata);
#line 2215
        js_destroy(outdata);
#line 2216
        ret = handle_negative_data(query, uindata, offset, & header);
#line 2217
        js_destroy(uindata);
#line 2218
        return (ret);
      }
    }
#line 2224
    if (root_or_upstream != 0) {
#line 2225
      if (rlog_level >= 5) {
#line 2226
        printf("WARNING: We do not follow NS referrals when using upstream servers\n");
      }
#line 2228
      goto cleanup;
    }
#line 2234
    if ((int )ns_record_type == 2) {
#line 2234
      if (offset > 0) {
#line 2235
        ns_domain[nspoint] = (uint16_t )offset;
      } else {
#line 2237
        ns_domain[nspoint] = (uint16_t )1;
      }
    } else {
#line 2237
      ns_domain[nspoint] = (uint16_t )1;
    }
#line 2240
    tmp___30 = offset_bailiwick(uindata, offset, bailiwick);
#line 2240
    if (tmp___30 != 1) {
#line 2241
      ns_domain[nspoint] = (uint16_t )1;
    }
#line 2243
    ns_domain[nspoint + 1] = (uint16_t )0;
#line 2244
    offset += len + 8;
#line 2245
    len = js_readuint16(uindata, (unsigned int )offset);
#line 2246
    if (len == -1) {
#line 2247
      goto cleanup;
    }
#line 2250
    if ((int )ns_domain[nspoint] > 2) {
#line 2251
      ns_record[nspoint] = (uint16_t )(offset + 2);
    } else {
#line 2254
      ns_record[nspoint] = (uint16_t )1;
    }
#line 2256
    ns_record[nspoint + 1] = (uint16_t )0;
#line 2257
    offset += len + 2;
#line 2258
    nspoint ++;
  }
#line 2262
  jsip = js_create(6U, 1U);
#line 2262
  if ((unsigned long )jsip == (unsigned long )((js_string *)0)) {
#line 2263
    goto cleanup;
  }
#line 2269
  count = (int )header.arcount;
#line 2270
  while (count > 0) {
#line 2272
    len = dlabel_length(uindata, (unsigned int )offset);
#line 2273
    if (len == -1) {
#line 2274
      goto cleanup_jsip;
    }
#line 2280
    type = js_readuint16(uindata, (unsigned int )(offset + len));
#line 2281
    class = js_readuint16(uindata, (unsigned int )((offset + len) + 2));
#line 2282
    ttl = js_readuint32(uindata, (unsigned int )((offset + len) + 4));
#line 2283
    rdlength = js_readuint16(uindata, (unsigned int )((offset + len) + 8));
#line 2284
    if (type == -1) {
#line 2286
      goto cleanup_jsip;
    } else
#line 2284
    if (class == -1) {
#line 2286
      goto cleanup_jsip;
    } else
#line 2284
    if (ttl == 4294967295U) {
#line 2286
      goto cleanup_jsip;
    } else
#line 2284
    if (rdlength == -1) {
#line 2286
      goto cleanup_jsip;
    }
#line 2289
    if (type != 1) {
#line 2290
      offset += (len + rdlength) + 10;
#line 2293
      count --;
#line 2294
      continue;
    } else
#line 2289
    if (class != 1) {
#line 2290
      offset += (len + rdlength) + 10;
#line 2293
      count --;
#line 2294
      continue;
    } else
#line 2289
    if (rdlength != 4) {
#line 2290
      offset += (len + rdlength) + 10;
#line 2293
      count --;
#line 2294
      continue;
    }
#line 2298
    nspoint = 0;
#line 2299
    while ((int )ns_record[nspoint] != 0) {
#line 2301
      tmp___31 = js_substr(uindata, jsip, (len + offset) + 10, 4);
#line 2301
      if (tmp___31 == -1) {
#line 2302
        goto cleanup_jsip;
      }
#line 2305
      if ((int )ns_record[nspoint] > 8) {
#line 2305
        tmp___35 = cmp_dnames(uindata, (int )ns_record[nspoint], offset);
#line 2305
        if (tmp___35 == 1) {
#line 2310
          tmp___32 = cmp_ips(uindata, offset, (uint32_t )remote_ip);
#line 2310
          if (tmp___32 != 0) {
#line 2311
            js_destroy(jsip);
#line 2312
            goto minus4;
          }
#line 2314
          if (record_added == 0) {
#line 2315
            record_added = 1;
#line 2317
            check_case_of_answer(uindata, query, (int )ns_domain[nspoint]);
#line 2318
            tmp___33 = add_closer_jsip_offset(uindata, (int )ns_domain[nspoint], jsip,
                                              1);
#line 2318
            if (tmp___33 == -1) {
#line 2320
              goto cleanup_jsip;
            }
          } else {
#line 2325
            check_case_of_answer(uindata, query, (int )ns_domain[nspoint]);
#line 2326
            tmp___34 = add_closer_jsip_offset(uindata, (int )ns_domain[nspoint], jsip,
                                              2);
#line 2326
            if (tmp___34 == -1) {
#line 2328
              goto cleanup_jsip;
            }
          }
        }
      }
#line 2349
      nspoint ++;
    }
#line 2351
    offset += (len + rdlength) + 10;
#line 2352
    count --;
  }
#line 2358
  nspoint = 0;
#line 2359
  while ((int )ns_record[nspoint] != 0) {
#line 2361
    if ((int )ns_record[nspoint] > 8) {
#line 2362
      if (record_added == 0) {
#line 2363
        record_added = 1;
#line 2365
        check_case_of_answer(uindata, query, (int )ns_domain[nspoint]);
#line 2366
        tmp___36 = add_closer_js_offset(uindata, (int )ns_domain[nspoint], (int )ns_record[nspoint],
                                        1);
#line 2366
        if (tmp___36 == -1) {
#line 2368
          goto cleanup_jsip;
        }
      } else {
#line 2373
        check_case_of_answer(uindata, query, (int )ns_domain[nspoint]);
#line 2374
        tmp___37 = add_closer_js_offset(uindata, (int )ns_domain[nspoint], (int )ns_record[nspoint],
                                        2);
#line 2374
        if (tmp___37 == -1) {
#line 2376
          goto cleanup_jsip;
        }
      }
    }
#line 2380
    nspoint ++;
  }
#line 2383
  js_destroy(jsip);
#line 2384
  js_destroy(indata);
#line 2385
  js_destroy(uindata);
#line 2386
  js_destroy(outdata);
#line 2387
  if (record_added == 1) {
#line 2388
    return (1);
  } else {
#line 2390
    return (-4);
  }
  cleanup_jsip: 
#line 2393
  js_destroy(jsip);
  cleanup: 
#line 2395
  js_destroy(indata);
#line 2396
  js_destroy(uindata);
#line 2397
  js_destroy(outdata);
#line 2398
  return (-1);
  minus2: 
#line 2401
  js_destroy(indata);
#line 2402
  js_destroy(uindata);
#line 2403
  js_destroy(outdata);
#line 2404
  return (-2);
  minus3: 
#line 2407
  js_destroy(indata);
#line 2408
  js_destroy(uindata);
#line 2409
  js_destroy(outdata);
#line 2410
  return (-3);
  minus4: 
#line 2413
  js_destroy(indata);
#line 2414
  js_destroy(uindata);
#line 2415
  js_destroy(outdata);
#line 2416
  return (-4);
}
}
#line 2428 "recursive.c"
int cmp_ips(js_string *compare , int offset , uint32_t ip ) 
{ int ip_compare ;
  int len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2435
  tmp = js_has_sanity(compare);
#line 2435
  if (tmp == -1) {
#line 2436
    return (-1);
  }
#line 2437
  if (compare->unit_size != 1U) {
#line 2438
    return (-1);
  }
#line 2439
  if ((unsigned int )offset > compare->unit_count) {
#line 2440
    return (-1);
  }
#line 2443
  len = dlabel_length(compare, (unsigned int )offset);
#line 2444
  if (len == -1) {
#line 2445
    return (-1);
  }
#line 2446
  offset += len;
#line 2448
  tmp___0 = js_readuint16(compare, (unsigned int )offset);
#line 2448
  if (tmp___0 != 1) {
#line 2449
    return (0);
  }
#line 2451
  offset += 8;
#line 2453
  tmp___1 = js_readuint16(compare, (unsigned int )offset);
#line 2453
  if (tmp___1 != 4) {
#line 2454
    return (0);
  }
#line 2456
  offset += 2;
#line 2458
  if (compare->unit_count < (unsigned int )(offset + 3)) {
#line 2459
    return (-1);
  }
#line 2460
  ip_compare = (int )(((((unsigned int )((int )*(compare->string + offset) << 24) & 4278190080U) | (unsigned int )(((int )*((compare->string + offset) + 1) << 16) & 16711680)) | (unsigned int )(((int )*((compare->string + offset) + 2) << 8) & 65280)) | (unsigned int )((int )*((compare->string + offset) + 3) & 255));
#line 2465
  if ((uint32_t )ip_compare == ip) {
#line 2466
    return (1);
  }
#line 2468
  return (0);
}
}
#line 2486 "recursive.c"
int give_answer(void *value___0 , int datatype , void **rotate_point , uint32_t *ipret ,
                js_string *ptrret , js_string *query , js_string *hash_pointer , int id ,
                int sock , struct sockaddr_in client , int queries_sent , int glueless_level ,
                int cname_answer ) 
{ rr *lookatrr ;
  void *tmp ;
  int tmp___0 ;
  int64_t tmp___1 ;
  int64_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 2497
  lookatrr = (rr *)value___0;
#line 2498
  move_to_top(lookatrr->zap);
#line 2503
  if (lookatrr->expire != 0LL) {
#line 2503
    tmp___1 = qual_get_time();
#line 2503
    if (lookatrr->expire < tmp___1) {
#line 2503
      goto _L;
    } else
#line 2503
    if ((int )lookatrr->rr_type == 5) {
#line 2503
      if ((unsigned long )lookatrr->ip == (unsigned long )((void *)0)) {
#line 2503
        tmp___2 = qual_get_time();
#line 2503
        if (lookatrr->expire - (int64_t )lookatrr->ttl < tmp___2 - (int64_t )(timeout_seconds * 15)) {
          _L: /* CIL Label */ 
#line 2509
          tmp = mhash_undef(dnscache, hash_pointer);
#line 2509
          lookatrr = (rr *)tmp;
#line 2510
          unlink_rr(lookatrr, 0);
#line 2512
          tmp___0 = recurse_call(id, sock, client, query, queries_sent + 1, glueless_level,
                                 ipret, ptrret);
#line 2512
          if (tmp___0 == -1) {
#line 2514
            goto cleanup;
          }
#line 2515
          goto success;
        }
      }
    }
  }
#line 2521
  if ((unsigned long )ipret == (unsigned long )((void *)0)) {
#line 2521
    if ((unsigned long )ptrret == (unsigned long )((void *)0)) {
#line 2523
      if (datatype == 5) {
#line 2524
        udpnotfound(lookatrr, id, sock, & client, query, 0, 1, (conn *)0, 1);
      } else {
#line 2527
        udpsuccess((rr *)value___0, id, sock, & client, query, rotate_point, cname_answer,
                   1, (conn *)0, 0, 1);
      }
    } else {
#line 2521
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 2531
  if ((unsigned long )ipret != (unsigned long )((void *)0)) {
#line 2533
    lookatrr = (rr *)value___0;
#line 2536
    if (datatype == 5) {
#line 2537
      *ipret = 4294967295U;
#line 2538
      goto success;
    }
#line 2541
    if ((int )lookatrr->rr_type != 1) {
#line 2541
      if (cname_answer != 1) {
#line 2542
        *ipret = (uint32_t )0;
#line 2543
        goto success;
      }
    }
#line 2547
    if (cname_answer == 1) {
#line 2549
      tmp___3 = js_copy(lookatrr->data, hash_pointer);
#line 2549
      if (tmp___3 == -1) {
#line 2550
        goto cleanup;
      }
#line 2551
      tmp___4 = js_adduint16(hash_pointer, 1);
#line 2551
      if (tmp___4 == -1) {
#line 2552
        goto cleanup;
      }
#line 2553
      tmp___5 = recurse_call(id, sock, client, hash_pointer, queries_sent + 1, glueless_level + 1,
                             ipret, ptrret);
#line 2553
      if (tmp___5 == -1) {
#line 2555
        goto cleanup;
      }
#line 2558
      goto success;
    }
#line 2561
    *ipret = ((((unsigned int )((int )*((lookatrr->data)->string) << 24) & 4278190080U) | (unsigned int )(((int )*((lookatrr->data)->string + 1) << 16) & 16711680)) | (unsigned int )(((int )*((lookatrr->data)->string + 2) << 8) & 65280)) | (unsigned int )((int )*((lookatrr->data)->string + 3) & 255);
#line 2565
    return (1);
  } else
#line 2567
  if ((unsigned long )ptrret != (unsigned long )((void *)0)) {
#line 2568
    lookatrr = (rr *)value___0;
#line 2571
    if (datatype == 5) {
#line 2572
      tmp___6 = js_qstr2js(ptrret, (char *)"NotQual");
#line 2572
      if (tmp___6 == -1) {
#line 2573
        return (-1);
      }
#line 2575
      return (1);
    }
#line 2578
    if ((int )lookatrr->rr_type != 12) {
#line 2578
      if (cname_answer != 1) {
#line 2579
        tmp___7 = js_qstr2js(ptrret, (char *)"NotQual");
#line 2579
        if (tmp___7 == -1) {
#line 2580
          return (-1);
        }
#line 2582
        goto success;
      }
    }
#line 2586
    if (cname_answer == 1) {
#line 2588
      tmp___8 = js_copy(lookatrr->data, hash_pointer);
#line 2588
      if (tmp___8 == -1) {
#line 2589
        goto cleanup;
      }
#line 2590
      tmp___9 = js_adduint16(hash_pointer, 12);
#line 2590
      if (tmp___9 == -1) {
#line 2591
        goto cleanup;
      }
#line 2592
      tmp___10 = recurse_call(id, sock, client, hash_pointer, queries_sent + 1, glueless_level + 1,
                              ipret, ptrret);
#line 2592
      if (tmp___10 == -1) {
#line 2594
        goto cleanup;
      }
#line 2597
      goto success;
    }
#line 2600
    tmp___11 = js_copy(lookatrr->data, ptrret);
#line 2600
    if (tmp___11 == -1) {
#line 2601
      return (-1);
    }
#line 2603
    return (1);
  }
  success: 
#line 2607
  return (1);
  cleanup: 
#line 2609
  return (-1);
}
}
#line 2617 "recursive.c"
int recurse_thread(dnsreq *req ) 
{ int ret ;

  {
#line 2622
  tcount_lock();
#line 2623
  num_of_threads_running ++;
#line 2624
  tcount_unlock();
#line 2626
  if (rlog_level >= 4) {
#line 2627
    log_lock();
#line 2628
    show_timestamp();
#line 2629
    tcount_lock();
#line 2630
    printf("In thread; ready to begin recursion; Threads in use: %d\n", num_of_threads_running);
#line 2632
    tcount_unlock();
#line 2633
    log_unlock();
  }
#line 2636
  do_big_lock();
#line 2637
  ret = recurse_call(req->id, req->sock, req->client, req->query, 0, 0, (uint32_t *)((void *)0),
                     (js_string *)((void *)0));
#line 2639
  big_unlock();
#line 2641
  if (rlog_level >= 4) {
#line 2642
    log_lock();
#line 2643
    show_timestamp();
#line 2644
    tcount_lock();
#line 2645
    printf("Ready to terminate thread; threads in use %d\n", num_of_threads_running);
#line 2647
    tcount_unlock();
#line 2648
    log_unlock();
  }
#line 2651
  js_destroy(req->query);
#line 2652
  js_dealloc((void *)req);
#line 2655
  tcount_lock();
#line 2656
  num_of_threads_running --;
#line 2657
  tcount_unlock();
#line 2659
  return (ret);
}
}
#line 2676 "recursive.c"
int recurse_call(int id , int sock , struct sockaddr_in client , js_string *query ,
                 int queries_sent , int glueless_level , uint32_t *ipret , js_string *ptrret ) 
{ mhash_e spot_data ;
  js_string *copy ;
  closer *cpoint ;
  uint32_t nsip ;
  int result ;
  int qtype ;
  int case_folded ;
  int case_folded_found ;
  closer *local_c ;
  closer *local_c_head ;
  closer *local_c_save ;
  uint32_t *i32_copy ;
  js_string *jstr_copy ;
  js_string *glueless_query ;
  js_string *lower ;
  rr *lookatrr ;
  int current_retry_cycle ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  int tmp___18 ;
  int64_t tmp___19 ;
  void *tmp___20 ;
  void *tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  void *tmp___24 ;
  long tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  js_string *synthesized_header ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  js_string *synthesized_header___0 ;
  int tmp___35 ;

  {
#line 2684
  case_folded = 0;
#line 2685
  case_folded_found = 0;
#line 2687
  local_c_head = (closer *)((void *)0);
#line 2691
  current_retry_cycle = 0;
#line 2695
  if (queries_sent > max_queries_total) {
#line 2695
    goto _L;
  } else
#line 2695
  if (glueless_level > max_glueless_level) {
    _L: /* CIL Label */ 
#line 2697
    if (rlog_level >= 4) {
#line 2698
      log_lock();
#line 2699
      show_timestamp();
#line 2700
      show_esc_stdout(query);
#line 2701
      printf(" queries_total/glueless_level exceeded\n");
#line 2702
      log_unlock();
    }
#line 2704
    return (-1);
  }
#line 2707
  if ((unsigned long )ipret != (unsigned long )((void *)0)) {
#line 2708
    *ipret = (uint32_t )0;
  }
#line 2711
  lower = js_create(query->unit_count + 3U, 1U);
#line 2711
  if ((unsigned long )lower == (unsigned long )((js_string *)0)) {
#line 2712
    return (-1);
  }
#line 2713
  tmp = js_copy(query, lower);
#line 2713
  if (tmp == -1) {
#line 2714
    goto cleanup_nojs;
  }
#line 2716
  if (case_folded == -1) {
#line 2717
    goto cleanup_nojs;
  }
#line 2723
  qtype = get_rtype(query);
#line 2724
  if (qtype == 255) {
#line 2725
    if (rlog_level >= 4) {
#line 2726
      log_lock();
#line 2727
      show_timestamp();
#line 2728
      show_esc_stdout(query);
#line 2729
      printf(" is an ANY query\n");
#line 2730
      log_unlock();
    }
#line 2733
    change_rtype(query, 1);
#line 2734
    tmp___0 = recurse_call(id, sock, client, query, queries_sent + 1, glueless_level,
                           & nsip, (js_string *)0);
#line 2734
    if (tmp___0 == -1) {
#line 2736
      goto cleanup_nojs;
    }
#line 2738
    change_rtype(query, 15);
#line 2739
    tmp___1 = recurse_call(id, sock, client, query, queries_sent + 1, glueless_level,
                           & nsip, (js_string *)0);
#line 2739
    if (tmp___1 == -1) {
#line 2741
      goto cleanup_nojs;
    }
#line 2743
    change_rtype(query, 255);
#line 2745
    tmp___2 = udpany(id, sock, & client, query, 3, dnscache, 1, (conn *)0, 1, (js_string *)0);
#line 2745
    if (tmp___2 == 1) {
#line 2746
      js_destroy(lower);
#line 2747
      return (1);
    }
#line 2750
    lookatrr = (rr *)0;
#line 2751
    change_rtype(query, 1);
#line 2752
    spot_data = mhash_get(dnscache, query);
#line 2753
    if ((unsigned long )spot_data.value != (unsigned long )((void *)0)) {
#line 2753
      if (spot_data.datatype == 5) {
#line 2754
        lookatrr = (rr *)spot_data.value;
      } else {
#line 2753
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 2756
      change_rtype(query, 15);
#line 2757
      spot_data = mhash_get(dnscache, query);
#line 2758
      if ((unsigned long )spot_data.value != (unsigned long )((void *)0)) {
#line 2758
        if (spot_data.datatype == 5) {
#line 2759
          lookatrr = (rr *)spot_data.value;
        }
      }
    }
#line 2761
    if ((unsigned long )lookatrr != (unsigned long )((rr *)0)) {
#line 2762
      move_to_top(lookatrr->zap);
#line 2763
      udpnotfound(lookatrr, id, sock, & client, query, 255, 1, (conn *)0, 1);
    }
#line 2765
    js_destroy(lower);
#line 2766
    return (1);
  }
#line 2770
  copy = js_create(257U, 1U);
#line 2770
  if ((unsigned long )copy == (unsigned long )((js_string *)0)) {
#line 2771
    goto cleanup_nojs;
  }
#line 2774
  if (rlog_level >= 4) {
#line 2775
    log_lock();
#line 2776
    show_timestamp();
#line 2777
    printf("Looking for ");
#line 2778
    show_esc_stdout(lower);
#line 2779
    printf(" in cache\n");
#line 2780
    log_unlock();
  }
#line 2782
  spot_data = mhash_get(dnscache, lower);
#line 2786
  if ((unsigned long )spot_data.value != (unsigned long )((void *)0)) {
#line 2786
    if (spot_data.datatype == 5) {
#line 2787
      if (rlog_level >= 4) {
#line 2788
        log_lock();
#line 2789
        show_timestamp();
#line 2790
        show_esc_stdout(lower);
#line 2791
        printf(" found in cache (psudo-NXDOMAIN) at %p\n", spot_data.value);
#line 2792
        log_unlock();
      }
#line 2794
      tmp___3 = give_answer(spot_data.value, spot_data.datatype, spot_data.point,
                            ipret, ptrret, query, lower, id, sock, client, queries_sent,
                            glueless_level, 0);
#line 2794
      if (tmp___3 == 1) {
#line 2797
        goto success;
      }
#line 2798
      goto cleanup;
    }
  }
#line 2802
  if ((unsigned long )spot_data.value != (unsigned long )((void *)0)) {
#line 2802
    if (spot_data.datatype == 3) {
#line 2803
      if (rlog_level >= 4) {
#line 2804
        log_lock();
#line 2805
        show_timestamp();
#line 2806
        show_esc_stdout(lower);
#line 2807
        printf(" found in cache (RR) at %p\n", spot_data.value);
#line 2808
        log_unlock();
      }
#line 2810
      tmp___4 = give_answer(spot_data.value, spot_data.datatype, spot_data.point,
                            ipret, ptrret, query, lower, id, sock, client, queries_sent,
                            glueless_level, 0);
#line 2810
      if (tmp___4 == 1) {
#line 2813
        goto success;
      }
#line 2814
      goto cleanup;
    }
  }
#line 2818
  tmp___5 = js_copy(lower, copy);
#line 2818
  if (tmp___5 == -1) {
#line 2819
    goto cleanup;
  }
#line 2820
  tmp___6 = change_rtype(copy, 5);
#line 2820
  if (tmp___6 == -1) {
#line 2821
    goto cleanup;
  }
#line 2822
  spot_data = mhash_get(dnscache, copy);
#line 2823
  if ((unsigned long )spot_data.value != (unsigned long )((void *)0)) {
#line 2823
    if (spot_data.datatype == 3) {
#line 2824
      if (rlog_level >= 4) {
#line 2825
        log_lock();
#line 2826
        show_timestamp();
#line 2827
        show_esc_stdout(lower);
#line 2828
        printf(" found in cache (CNAME RR) at %p\n", spot_data.value);
#line 2829
        log_unlock();
      }
#line 2831
      tmp___7 = give_answer(spot_data.value, spot_data.datatype, spot_data.point,
                            ipret, ptrret, query, copy, id, sock, client, queries_sent,
                            glueless_level, qtype);
#line 2831
      if (tmp___7 == 1) {
#line 2835
        goto success;
      }
#line 2836
      goto cleanup;
    }
  }
#line 2840
  if (rlog_level >= 4) {
#line 2841
    log_lock();
#line 2842
    show_timestamp();
#line 2843
    show_esc_stdout(lower);
#line 2844
    printf(" not found in cache\n");
#line 2845
    log_unlock();
  }
#line 2850
  case_folded = fold_case(lower);
#line 2852
  if (case_folded == 1) {
#line 2853
    if (rlog_level >= 4) {
#line 2854
      log_lock();
#line 2855
      show_timestamp();
#line 2856
      printf("Looking for ");
#line 2857
      show_esc_stdout(lower);
#line 2858
      printf(" (lowercase)\n");
#line 2859
      log_unlock();
    }
#line 2861
    spot_data = mhash_get(dnscache, lower);
#line 2865
    if ((unsigned long )spot_data.value != (unsigned long )((void *)0)) {
#line 2865
      if (spot_data.datatype == 5) {
#line 2866
        if (rlog_level >= 4) {
#line 2867
          log_lock();
#line 2868
          show_timestamp();
#line 2869
          show_esc_stdout(lower);
#line 2870
          printf(" found (lowercase psudo-NXDOMAIN) at %p\n", spot_data.value);
#line 2872
          log_unlock();
        }
#line 2874
        tmp___8 = give_answer(spot_data.value, spot_data.datatype, spot_data.point,
                              ipret, ptrret, query, lower, id, sock, client, queries_sent,
                              glueless_level, 0);
#line 2874
        if (tmp___8 == 1) {
#line 2878
          goto success;
        }
#line 2879
        goto cleanup;
      }
    }
#line 2883
    if ((unsigned long )spot_data.value != (unsigned long )((void *)0)) {
#line 2883
      if (spot_data.datatype == 3) {
#line 2884
        if (rlog_level >= 4) {
#line 2885
          log_lock();
#line 2886
          show_timestamp();
#line 2887
          show_esc_stdout(lower);
#line 2888
          printf(" found (lowercase RR) at %p\n", spot_data.value);
#line 2889
          log_unlock();
        }
#line 2891
        tmp___9 = give_answer(spot_data.value, spot_data.datatype, spot_data.point,
                              ipret, ptrret, query, lower, id, sock, client, queries_sent,
                              glueless_level, 0);
#line 2891
        if (tmp___9 == 1) {
#line 2895
          goto success;
        }
#line 2896
        goto cleanup;
      }
    }
#line 2901
    tmp___10 = js_copy(lower, copy);
#line 2901
    if (tmp___10 == -1) {
#line 2902
      goto cleanup;
    }
#line 2903
    tmp___11 = change_rtype(copy, 5);
#line 2903
    if (tmp___11 == -1) {
#line 2904
      goto cleanup;
    }
#line 2905
    spot_data = mhash_get(dnscache, copy);
#line 2906
    if ((unsigned long )spot_data.value != (unsigned long )((void *)0)) {
#line 2906
      if (spot_data.datatype == 3) {
#line 2907
        if (rlog_level >= 4) {
#line 2908
          log_lock();
#line 2909
          show_timestamp();
#line 2910
          show_esc_stdout(lower);
#line 2911
          printf(" found (CNAME lowercase RR) at %p\n", spot_data.value);
#line 2912
          log_unlock();
        }
#line 2914
        tmp___12 = give_answer(spot_data.value, spot_data.datatype, spot_data.point,
                               ipret, ptrret, query, copy, id, sock, client, queries_sent,
                               glueless_level, qtype);
#line 2914
        if (tmp___12 == 1) {
#line 2917
          goto success;
        }
#line 2918
        goto cleanup;
      }
    }
#line 2921
    if (rlog_level >= 4) {
#line 2922
      log_lock();
#line 2923
      show_timestamp();
#line 2924
      show_esc_stdout(lower);
#line 2925
      printf(" not found in cache either\n");
#line 2926
      log_unlock();
    }
  }
#line 2933
  tmp___13 = js_copy(query, copy);
#line 2933
  if (tmp___13 == -1) {
#line 2934
    goto cleanup;
  }
#line 2938
  tmp___14 = change_rtype(copy, 252);
#line 2938
  if (tmp___14 == -1) {
#line 2939
    goto cleanup;
  }
#line 2942
  while (1) {
#line 2943
    if (rlog_level >= 4) {
#line 2944
      log_lock();
#line 2945
      show_timestamp();
#line 2946
      printf("Looking for ");
#line 2947
      show_esc_stdout(copy);
#line 2948
      printf(" in cache (NS referral)\n");
#line 2949
      log_unlock();
    }
#line 2952
    spot_data = mhash_get(dnscache, copy);
#line 2955
    case_folded_found = 0;
#line 2957
    if ((unsigned long )spot_data.value == (unsigned long )((void *)0)) {
#line 2957
      goto _L___1;
    } else
#line 2957
    if (spot_data.datatype != 4) {
      _L___1: /* CIL Label */ 
#line 2958
      js_copy(copy, lower);
#line 2959
      tmp___15 = fold_case(lower);
#line 2959
      if (tmp___15 == 1) {
#line 2960
        if (rlog_level >= 4) {
#line 2961
          log_lock();
#line 2962
          show_timestamp();
#line 2963
          printf("Looking for ");
#line 2964
          show_esc_stdout(lower);
#line 2965
          printf(" in cache (lowercase NS ref)\n");
#line 2966
          log_unlock();
        }
#line 2968
        spot_data = mhash_get(dnscache, lower);
#line 2969
        if ((unsigned long )spot_data.value != (unsigned long )((void *)0)) {
#line 2969
          if (spot_data.datatype == 4) {
#line 2970
            case_folded_found = 1;
          }
        }
      }
    }
#line 2975
    if ((unsigned long )spot_data.value != (unsigned long )((void *)0)) {
#line 2975
      if (spot_data.datatype == 4) {
#line 2976
        cpoint = (closer *)spot_data.value;
#line 2977
        if (rlog_level >= 4) {
#line 2978
          log_lock();
#line 2979
          show_timestamp();
#line 2980
          if (case_folded_found == 1) {
#line 2981
            show_esc_stdout(lower);
          } else {
#line 2983
            show_esc_stdout(copy);
          }
#line 2984
          printf(" found at %p\n", spot_data.value);
#line 2985
          log_unlock();
        }
#line 2987
        move_to_top(cpoint->zap);
#line 2989
        if (cpoint->ttd != 0LL) {
#line 2989
          tmp___19 = qual_get_time();
#line 2989
          if (cpoint->ttd < tmp___19) {
#line 2993
            if (rlog_level >= 4) {
#line 2994
              log_lock();
#line 2995
              show_timestamp();
#line 2996
              if (case_folded_found == 1) {
#line 2997
                show_esc_stdout(lower);
              } else {
#line 2999
                show_esc_stdout(copy);
              }
#line 3000
              printf(" at %p has expired, zapping\n", spot_data.value);
#line 3001
              log_unlock();
            }
#line 3004
            if (case_folded_found == 0) {
#line 3005
              tmp___16 = mhash_undef(dnscache, copy);
#line 3005
              cpoint = (closer *)tmp___16;
            } else {
#line 3007
              tmp___17 = mhash_undef(dnscache, lower);
#line 3007
              cpoint = (closer *)tmp___17;
            }
#line 3008
            unlink_closer(cpoint);
#line 3010
            tmp___18 = recurse_call(id, sock, client, query, queries_sent + 1, glueless_level,
                                    ipret, ptrret);
#line 3010
            if (tmp___18 == -1) {
#line 3012
              goto cleanup;
            }
#line 3014
            goto success;
          }
        }
#line 3021
        if (rlog_level >= 4) {
#line 3022
          log_lock();
#line 3023
          show_timestamp();
#line 3024
          printf("Making cpoint copy of ");
#line 3025
          if (case_folded_found == 1) {
#line 3026
            show_esc_stdout(lower);
          } else {
#line 3028
            show_esc_stdout(copy);
          }
#line 3029
          printf(" at %p\n", spot_data.value);
#line 3030
          log_unlock();
        }
#line 3033
        tmp___20 = js_alloc(1, (int )sizeof(closer ));
#line 3033
        local_c = (closer *)tmp___20;
#line 3033
        if ((unsigned long )local_c == (unsigned long )((closer *)0)) {
#line 3034
          goto cleanup;
        }
#line 3035
        local_c_head = local_c;
#line 3036
        while ((unsigned long )local_c != (unsigned long )((void *)0)) {
#line 3037
          local_c->num_elements = cpoint->num_elements;
#line 3038
          local_c->ttd = cpoint->ttd;
#line 3039
          local_c->zap = (fila *)((void *)0);
#line 3040
          switch (cpoint->datatype) {
          case 1: 
#line 3042
          tmp___21 = js_alloc(1, (int )sizeof(uint32_t ));
#line 3042
          i32_copy = (uint32_t *)tmp___21;
#line 3042
          if ((unsigned long )i32_copy == (unsigned long )((uint32_t *)0)) {
#line 3043
            goto cleanup;
          }
#line 3044
          *i32_copy = *((uint32_t *)cpoint->data);
#line 3045
          local_c->datatype = 1;
#line 3046
          local_c->data = (void *)i32_copy;
#line 3047
          break;
          case 2: 
#line 3049
          tmp___22 = js_has_sanity((js_string *)cpoint->data);
#line 3049
          if (tmp___22 == -1) {
#line 3050
            goto cleanup;
          }
#line 3051
          jstr_copy = (js_string *)cpoint->data;
#line 3052
          jstr_copy = js_create(jstr_copy->unit_count + 1U, 1U);
#line 3052
          if ((unsigned long )jstr_copy == (unsigned long )((js_string *)0)) {
#line 3054
            goto cleanup;
          }
#line 3055
          tmp___23 = js_copy((js_string *)cpoint->data, jstr_copy);
#line 3055
          if (tmp___23 == -1) {
#line 3056
            js_destroy(jstr_copy);
#line 3057
            goto cleanup;
          }
#line 3059
          local_c->datatype = 2;
#line 3060
          local_c->data = (void *)jstr_copy;
#line 3061
          break;
          default: 
#line 3063
          local_c->datatype = 10;
#line 3070
          local_c->data = (void *)0;
          }
#line 3072
          if ((unsigned long )cpoint->next != (unsigned long )((void *)0)) {
#line 3073
            local_c_save = local_c;
#line 3074
            tmp___24 = js_alloc(1, (int )sizeof(closer ));
#line 3074
            local_c = (closer *)tmp___24;
#line 3074
            if ((unsigned long )local_c == (unsigned long )((closer *)0)) {
#line 3075
              goto cleanup;
            }
#line 3076
            local_c_save->next = local_c;
#line 3077
            cpoint = cpoint->next;
          } else {
#line 3080
            local_c->next = (struct closer *)((void *)0);
#line 3081
            break;
          }
        }
#line 3085
        local_c = local_c_head;
#line 3089
        tmp___25 = random();
#line 3089
        result = (int )(tmp___25 % (long )local_c->num_elements);
#line 3097
        while (result > 0) {
#line 3098
          local_c = local_c->next;
#line 3099
          if ((unsigned long )local_c == (unsigned long )((void *)0)) {
#line 3100
            local_c = local_c_head;
          }
#line 3101
          result --;
        }
#line 3103
        local_c_save = local_c;
#line 3104
        result = 0;
#line 3108
        current_retry_cycle = 0;
#line 3109
        while (1) {
#line 3110
          while (1) {
#line 3111
            if (local_c->datatype == 1) {
#line 3112
              nsip = *((uint32_t *)local_c->data);
#line 3114
              if (case_folded_found == 0) {
#line 3115
                result = query_nameserver((int )nsip, query, copy);
              } else {
#line 3117
                result = query_nameserver((int )nsip, query, lower);
              }
            }
#line 3120
            local_c = local_c->next;
#line 3121
            if ((unsigned long )local_c == (unsigned long )((void *)0)) {
#line 3122
              local_c = local_c_head;
            }
#line 3110
            if (result <= 0) {
#line 3110
              if (! ((unsigned long )local_c != (unsigned long )local_c_save)) {
#line 3110
                break;
              }
            } else {
#line 3110
              break;
            }
          }
#line 3126
          if (result <= 0) {
#line 3128
            local_c = local_c_save;
#line 3131
            while (1) {
#line 3132
              if (local_c->datatype == 2) {
#line 3135
                glueless_query = (js_string *)local_c->data;
#line 3136
                tmp___26 = js_has_sanity(glueless_query);
#line 3136
                if (tmp___26 == -1) {
#line 3137
                  goto cleanup;
                }
#line 3138
                glueless_query = js_create(glueless_query->unit_count + 2U, 1U);
#line 3138
                if ((unsigned long )glueless_query == (unsigned long )((js_string *)0)) {
#line 3140
                  goto cleanup;
                }
#line 3141
                tmp___27 = js_copy((js_string *)local_c->data, glueless_query);
#line 3141
                if (tmp___27 == -1) {
#line 3142
                  js_destroy(glueless_query);
#line 3143
                  goto cleanup;
                }
#line 3148
                nsip = (uint32_t )0;
#line 3149
                if (case_folded_found == 0) {
#line 3149
                  tmp___30 = q_bailiwick(glueless_query, copy);
#line 3149
                  if (tmp___30 == 1) {
#line 3151
                    nsip = (uint32_t )0;
                  } else {
#line 3149
                    goto _L___3;
                  }
                } else
                _L___3: /* CIL Label */ 
#line 3153
                if (case_folded_found == 1) {
#line 3153
                  tmp___29 = q_bailiwick(glueless_query, lower);
#line 3153
                  if (tmp___29 == 1) {
#line 3155
                    nsip = (uint32_t )0;
                  } else {
#line 3153
                    goto _L___2;
                  }
                } else {
                  _L___2: /* CIL Label */ 
#line 3158
                  tmp___28 = recurse_call(id, sock, client, glueless_query, queries_sent + 1,
                                          glueless_level + 1, & nsip, (js_string *)0);
#line 3158
                  if (tmp___28 == -1) {
#line 3161
                    js_destroy(glueless_query);
#line 3162
                    goto cleanup;
                  }
                }
#line 3164
                js_destroy(glueless_query);
#line 3167
                if (nsip != 0U) {
#line 3168
                  if (case_folded_found == 0) {
#line 3169
                    result = query_nameserver((int )nsip, query, copy);
                  } else {
#line 3171
                    result = query_nameserver((int )nsip, query, lower);
                  }
                }
              }
#line 3175
              local_c = local_c->next;
#line 3176
              if ((unsigned long )local_c == (unsigned long )((void *)0)) {
#line 3177
                local_c = local_c_head;
              }
#line 3131
              if (result <= 0) {
#line 3131
                if (! ((unsigned long )local_c != (unsigned long )local_c_save)) {
#line 3131
                  break;
                }
              } else {
#line 3131
                break;
              }
            }
          }
#line 3180
          current_retry_cycle ++;
#line 3109
          if (result <= 0) {
#line 3109
            if (! (current_retry_cycle < retry_cycles)) {
#line 3109
              break;
            }
          } else {
#line 3109
            break;
          }
        }
#line 3182
        js_destroy(copy);
#line 3183
        js_destroy(lower);
#line 3186
        if ((unsigned long )local_c_head != (unsigned long )((void *)0)) {
#line 3187
          unlink_closer(local_c_head);
        }
#line 3188
        if (result > 0) {
#line 3191
          tmp___31 = recurse_call(id, sock, client, query, queries_sent + 1, glueless_level,
                                  ipret, ptrret);
#line 3191
          if (tmp___31 == -1) {
#line 3193
            return (-1);
          }
#line 3195
          return (1);
        }
#line 3202
        if ((unsigned long )ipret == (unsigned long )((void *)0)) {
#line 3202
          if ((unsigned long )ptrret == (unsigned long )((void *)0)) {
#line 3204
            if (handle_noreply == 2) {
#line 3205
              udpnotfound(rra_data, id, sock, & client, query, 0, 1, (conn *)0, 3);
            } else
#line 3207
            if (handle_noreply == 1) {
#line 3211
              synthesized_header = js_create(24U, 1U);
#line 3211
              if ((unsigned long )synthesized_header == (unsigned long )((js_string *)0)) {
#line 3212
                return (-1);
              }
#line 3214
              tmp___32 = js_adduint16(synthesized_header, id);
#line 3214
              if (tmp___32 == -1) {
#line 3215
                js_destroy(synthesized_header);
#line 3216
                return (-1);
              }
#line 3218
              udperror(sock, synthesized_header, & client, query, 2, (char *)"No reply from remote servers",
                       2, 1, (conn *)0, 0);
#line 3220
              js_destroy(synthesized_header);
            }
          } else {
#line 3202
            goto _L___4;
          }
        } else
        _L___4: /* CIL Label */ 
#line 3223
        if ((unsigned long )ptrret != (unsigned long )((void *)0)) {
#line 3224
          tmp___33 = js_qstr2js(ptrret, (char *)"NotQual");
#line 3224
          if (tmp___33 == -1) {
#line 3225
            return (-1);
          }
        }
#line 3228
        return (1);
      }
    }
#line 2942
    tmp___34 = bobbit_label(copy);
#line 2942
    if (! (tmp___34 > 0)) {
#line 2942
      break;
    }
  }
#line 3237
  if ((unsigned long )ipret == (unsigned long )((void *)0)) {
#line 3237
    if ((unsigned long )ptrret == (unsigned long )((void *)0)) {
#line 3239
      if (handle_noreply == 2) {
#line 3240
        udpnotfound(rra_data, id, sock, & client, query, 0, 1, (conn *)0, 3);
      } else
#line 3242
      if (handle_noreply == 1) {
#line 3245
        synthesized_header___0 = js_create(24U, 1U);
#line 3245
        if ((unsigned long )synthesized_header___0 == (unsigned long )((js_string *)0)) {
#line 3246
          return (-1);
        }
#line 3248
        tmp___35 = js_adduint16(synthesized_header___0, id);
#line 3248
        if (tmp___35 == -1) {
#line 3249
          js_destroy(synthesized_header___0);
#line 3250
          return (-1);
        }
#line 3252
        udperror(sock, synthesized_header___0, & client, query, 2, (char *)"No reply from remote servers",
                 2, 1, (conn *)0, 0);
#line 3254
        js_destroy(synthesized_header___0);
      }
    }
  }
  success: 
#line 3259
  js_destroy(copy);
#line 3260
  js_destroy(lower);
#line 3261
  return (1);
  cleanup: 
#line 3264
  if ((unsigned long )local_c_head != (unsigned long )((void *)0)) {
#line 3265
    unlink_closer(local_c_head);
  }
#line 3266
  js_destroy(copy);
  cleanup_nojs: 
#line 3268
  js_destroy(lower);
#line 3269
  return (-1);
}
}
#line 3279 "recursive.c"
int launch_thread(int id , int sock , struct sockaddr_in client , js_string *query ) 
{ js_string *copy ;
  js_string *synthesized_header ;
  dnsreq *req ;
  uint16_t original_rtype ;
  pthread_t thread ;
  pthread_attr_t attr ;
  mhash_e spot_data ;
  rr *lookatrr ;
  time_t tmp ;
  int64_t tmp___0 ;
  int64_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int64_t tmp___5 ;
  int64_t tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 3291
  if (verbose_query > 0) {
#line 3293
    tmp = time((time_t *)0);
#line 3293
    printf("%d:", (int )tmp);
#line 3294
    human_readable_dns_query(query, 0);
#line 3295
    printf("\n");
#line 3296
    fflush(__stdoutp);
  }
#line 3302
  do_big_lock();
#line 3303
  if (rlog_level >= 4) {
#line 3304
    log_lock();
#line 3305
    show_timestamp();
#line 3306
    printf("Looking for ");
#line 3307
    show_esc_stdout(query);
#line 3308
    printf(" in DNS cache\n");
#line 3309
    log_unlock();
  }
#line 3311
  spot_data = mhash_get(dnscache, query);
#line 3312
  if ((unsigned long )spot_data.value != (unsigned long )((void *)0)) {
#line 3312
    if (spot_data.datatype == 3) {
#line 3312
      goto _L___2;
    } else
#line 3312
    if (spot_data.datatype == 5) {
      _L___2: /* CIL Label */ 
#line 3314
      if (rlog_level >= 4) {
#line 3315
        log_lock();
#line 3316
        show_timestamp();
#line 3317
        show_esc_stdout(query);
#line 3318
        printf(" found at %p\n", spot_data.value);
#line 3319
        log_unlock();
      }
#line 3321
      lookatrr = (rr *)spot_data.value;
#line 3322
      move_to_top(lookatrr->zap);
#line 3325
      if (lookatrr->expire != 0LL) {
#line 3325
        tmp___0 = qual_get_time();
#line 3325
        if (lookatrr->expire < tmp___0) {
#line 3325
          goto _L___0;
        } else
#line 3325
        if ((int )lookatrr->rr_type == 5) {
#line 3325
          if ((unsigned long )lookatrr->ip == (unsigned long )((void *)0)) {
#line 3325
            tmp___1 = qual_get_time();
#line 3325
            if (lookatrr->expire - (int64_t )lookatrr->ttl < tmp___1 - (int64_t )(timeout_seconds * 15)) {
              _L___0: /* CIL Label */ 
#line 3330
              if (rlog_level >= 4) {
#line 3331
                log_lock();
#line 3332
                show_timestamp();
#line 3333
                show_esc_stdout(query);
#line 3334
                printf(" has expired at %p\n", spot_data.value);
#line 3335
                log_unlock();
              }
            } else {
#line 3325
              goto _L;
            }
          } else {
#line 3325
            goto _L;
          }
        } else {
#line 3325
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 3338
      if (spot_data.datatype == 5) {
#line 3341
        if (rlog_level >= 4) {
#line 3342
          log_lock();
#line 3343
          show_timestamp();
#line 3344
          show_esc_stdout(query);
#line 3345
          printf(" is a psudo-NXDOMAIN at %p\n", spot_data.value);
#line 3346
          log_unlock();
        }
#line 3348
        udpnotfound(lookatrr, id, sock, & client, query, 0, 1, (conn *)0, 1);
#line 3349
        big_unlock();
#line 3350
        return (1);
      } else {
#line 3353
        if (rlog_level >= 4) {
#line 3354
          log_lock();
#line 3355
          show_timestamp();
#line 3356
          show_esc_stdout(query);
#line 3357
          printf(" is an RR at %p\n", spot_data.value);
#line 3358
          log_unlock();
        }
#line 3360
        udpsuccess((rr *)spot_data.value, id, sock, & client, query, spot_data.point,
                   0, 1, (conn *)0, 0, 1);
#line 3362
        big_unlock();
#line 3363
        return (1);
      }
    } else {
#line 3312
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 3367
  if (rlog_level >= 4) {
#line 3368
    log_lock();
#line 3369
    show_timestamp();
#line 3370
    show_esc_stdout(query);
#line 3371
    printf(" not found in cache\n");
#line 3372
    log_unlock();
  }
#line 3380
  tmp___2 = get_rtype(query);
#line 3380
  original_rtype = (uint16_t )tmp___2;
#line 3384
  if ((int )original_rtype != 5) {
#line 3385
    tmp___3 = change_rtype(query, 5);
#line 3385
    if (tmp___3 == -1) {
#line 3386
      big_unlock();
#line 3387
      return (-1);
    }
#line 3389
    if (rlog_level >= 4) {
#line 3390
      log_lock();
#line 3391
      show_timestamp();
#line 3392
      printf("Looking for ");
#line 3393
      show_esc_stdout(query);
#line 3394
      printf(" in DNS cache (CNAME lookup)\n");
#line 3395
      log_unlock();
    }
#line 3397
    spot_data = mhash_get(dnscache, query);
#line 3398
    if ((unsigned long )spot_data.value != (unsigned long )((void *)0)) {
#line 3398
      if (spot_data.datatype == 3) {
#line 3398
        goto _L___6;
      } else
#line 3398
      if (spot_data.datatype == 5) {
        _L___6: /* CIL Label */ 
#line 3400
        lookatrr = (rr *)spot_data.value;
#line 3401
        move_to_top(lookatrr->zap);
#line 3404
        if (lookatrr->expire != 0LL) {
#line 3404
          tmp___5 = qual_get_time();
#line 3404
          if (lookatrr->expire < tmp___5) {
#line 3404
            goto _L___4;
          } else
#line 3404
          if ((int )lookatrr->rr_type == 5) {
#line 3404
            if ((unsigned long )lookatrr->ip == (unsigned long )((void *)0)) {
#line 3404
              tmp___6 = qual_get_time();
#line 3404
              if (lookatrr->expire - (int64_t )lookatrr->ttl < tmp___6 - (int64_t )(timeout_seconds * 15)) {
                _L___4: /* CIL Label */ 
#line 3409
                if (rlog_level >= 4) {
#line 3410
                  log_lock();
#line 3411
                  show_timestamp();
#line 3412
                  show_esc_stdout(query);
#line 3413
                  printf(" has expired (CNAME) at %p\n", spot_data.value);
#line 3414
                  log_unlock();
                }
              } else {
#line 3404
                goto _L___3;
              }
            } else {
#line 3404
              goto _L___3;
            }
          } else {
#line 3404
            goto _L___3;
          }
        } else
        _L___3: /* CIL Label */ 
#line 3417
        if (spot_data.datatype == 5) {
#line 3418
          if (rlog_level >= 4) {
#line 3419
            log_lock();
#line 3420
            show_timestamp();
#line 3421
            show_esc_stdout(query);
#line 3422
            printf(" is a psudo-NXDOMAIN (CNAME) at %p\n", spot_data.value);
#line 3424
            log_unlock();
          }
#line 3426
          udpnotfound(lookatrr, id, sock, & client, query, 0, 1, (conn *)0, 1);
#line 3427
          big_unlock();
#line 3428
          return (1);
        } else {
#line 3431
          if (rlog_level >= 4) {
#line 3432
            log_lock();
#line 3433
            show_timestamp();
#line 3434
            show_esc_stdout(query);
#line 3435
            printf(" is an RR (CNAME) at %p\n", spot_data.value);
#line 3436
            log_unlock();
          }
#line 3438
          tmp___4 = change_rtype(query, (int )original_rtype);
#line 3438
          if (tmp___4 == -1) {
#line 3439
            big_unlock();
#line 3440
            return (-1);
          }
#line 3442
          if ((int )original_rtype > 0) {
#line 3443
            udpsuccess((rr *)spot_data.value, id, sock, & client, query, spot_data.point,
                       (int )original_rtype, 1, (conn *)0, 0, 1);
          } else {
#line 3446
            udpsuccess((rr *)spot_data.value, id, sock, & client, query, spot_data.point,
                       0, 1, (conn *)0, 0, 1);
          }
#line 3448
          big_unlock();
#line 3449
          return (1);
        }
      } else {
#line 3398
        goto _L___5;
      }
    } else
    _L___5: /* CIL Label */ 
#line 3453
    if (rlog_level >= 4) {
#line 3454
      log_lock();
#line 3455
      show_timestamp();
#line 3456
      show_esc_stdout(query);
#line 3457
      printf(" not found in cache (CNAME)\n");
#line 3458
      log_unlock();
    }
  }
#line 3463
  big_unlock();
#line 3464
  tmp___7 = change_rtype(query, (int )original_rtype);
#line 3464
  if (tmp___7 == -1) {
#line 3465
    return (-1);
  }
#line 3467
  if (rlog_level >= 4) {
#line 3468
    log_lock();
#line 3469
    show_timestamp();
#line 3470
    printf("initializing thread\n");
#line 3471
    log_unlock();
  }
#line 3480
  tmp___8 = js_alloc(1, (int )sizeof(dnsreq ));
#line 3480
  req = (dnsreq *)tmp___8;
#line 3480
  if ((unsigned long )req == (unsigned long )((dnsreq *)0)) {
#line 3481
    return (-1);
  }
#line 3484
  copy = js_create(query->unit_count + 3U, 1U);
#line 3484
  if ((unsigned long )copy == (unsigned long )((js_string *)0)) {
#line 3485
    js_dealloc((void *)req);
#line 3486
    return (-1);
  }
#line 3490
  tmp___9 = js_copy(query, copy);
#line 3490
  if (tmp___9 == -1) {
#line 3491
    js_dealloc((void *)req);
#line 3491
    js_destroy(copy);
#line 3492
    return (-1);
  }
#line 3496
  req->id = id;
#line 3497
  req->sock = sock;
#line 3498
  req->client = client;
#line 3499
  req->query = copy;
#line 3502
  tcount_lock();
#line 3503
  if (num_of_threads_running > maximum_num_of_threads) {
#line 3504
    tcount_unlock();
#line 3505
    js_dealloc((void *)req);
#line 3505
    js_destroy(copy);
#line 3506
    if (rlog_level >= 4) {
#line 3507
      log_lock();
#line 3508
      show_timestamp();
#line 3509
      printf("too many threads running\n");
#line 3510
      log_unlock();
    }
#line 3514
    synthesized_header = js_create(24U, 1U);
#line 3514
    if ((unsigned long )synthesized_header == (unsigned long )((js_string *)0)) {
#line 3515
      return (-1);
    }
#line 3517
    tmp___10 = js_adduint16(synthesized_header, id);
#line 3517
    if (tmp___10 == -1) {
#line 3518
      js_destroy(synthesized_header);
#line 3519
      return (-1);
    }
#line 3521
    udperror(sock, synthesized_header, & client, query, 1, (char *)"Didn\'t spawn thread",
             2, 1, (conn *)0, 0);
#line 3523
    js_destroy(synthesized_header);
#line 3524
    return (-1);
  }
#line 3526
  tcount_unlock();
#line 3532
  if (rlog_level >= 4) {
#line 3533
    log_lock();
#line 3534
    show_timestamp();
#line 3535
    printf("About to launch thread...\n");
#line 3536
    log_unlock();
  }
#line 3541
  pthread_attr_init(& attr);
#line 3542
  pthread_attr_setdetachstate(& attr, 2);
#line 3544
  tmp___11 = pthread_create(& thread, (pthread_attr_t const   *)(& attr), (void *(*)(void * ))((void *)(& recurse_thread)),
                            (void *)req);
#line 3544
  if (tmp___11 != 0) {
#line 3546
    js_dealloc((void *)req);
#line 3546
    js_destroy(copy);
#line 3547
    return (-1);
  }
#line 3554
  pthread_attr_destroy(& attr);
#line 3559
  return (1);
}
}
#line 3572 "recursive.c"
int add_closer_jsddip(js_string *zone , js_string *ddip , int if_exists ) 
{ closer *close___0 ;
  js_string *ipjs ;
  uint32_t ip ;
  uint32_t *ipp ;
  closer *point ;
  closer *point_save ;
  mhash_e spot_data ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int64_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 3575
  ipp = (uint32_t *)0;
#line 3580
  tmp = js_alloc(1, (int )sizeof(closer ));
#line 3580
  close___0 = (closer *)tmp;
#line 3580
  if ((unsigned long )close___0 == (unsigned long )((closer *)0)) {
#line 3581
    return (-1);
  }
#line 3584
  ipjs = js_create(6U, 1U);
#line 3584
  if ((unsigned long )ipjs == (unsigned long )((js_string *)0)) {
#line 3585
    js_dealloc((void *)close___0);
#line 3586
    return (-1);
  }
#line 3590
  ddip->encoding = 3;
#line 3593
  tmp___0 = ddip_2_ip(ddip, ipjs, 0);
#line 3593
  if (tmp___0 == -1) {
#line 3594
    goto cleanup;
  }
#line 3597
  tmp___1 = change_rtype(zone, 252);
#line 3597
  if (tmp___1 == -1) {
#line 3598
    goto cleanup;
  }
#line 3601
  if (ipjs->unit_count < 4U) {
#line 3602
    goto cleanup;
  }
#line 3603
  ip = (uint32_t )(((((int )*(ipjs->string) << 24) | ((int )*(ipjs->string + 1) << 16)) | ((int )*(ipjs->string + 2) << 8)) | (int )*(ipjs->string + 3));
#line 3605
  js_destroy(ipjs);
#line 3608
  close___0->num_elements = 1U;
#line 3609
  close___0->datatype = 1;
#line 3610
  tmp___2 = js_alloc(1, (int )sizeof(uint32_t ));
#line 3610
  ipp = (uint32_t *)tmp___2;
#line 3610
  if ((unsigned long )ipp == (unsigned long )((uint32_t *)0)) {
#line 3611
    goto cleanup_noipjs;
  }
#line 3612
  *ipp = ip;
#line 3613
  close___0->data = (void *)ipp;
#line 3614
  close___0->next = (struct closer *)((void *)0);
#line 3615
  tmp___3 = qual_get_time();
#line 3615
  close___0->ttd = tmp___3 + 86400LL;
#line 3617
  close___0->ttd = (int64_t )0;
#line 3618
  close___0->zap = (fila *)((void *)0);
#line 3623
  if (rlog_level >= 4) {
#line 3624
    log_lock();
#line 3625
    show_timestamp();
#line 3626
    printf("Adding ");
#line 3627
    show_esc_stdout(zone);
#line 3628
    printf(" to cache at %p (jsddip)\n", close___0);
#line 3629
    log_unlock();
  }
#line 3634
  spot_data = mhash_get(dnscache, zone);
#line 3635
  if ((unsigned long )spot_data.value != (unsigned long )((void *)0)) {
#line 3635
    if (spot_data.datatype == 4) {
#line 3636
      point = (closer *)spot_data.value;
#line 3637
      switch (if_exists) {
      case 1: 
#line 3640
      mhash_undef(dnscache, zone);
#line 3644
      while ((unsigned long )point != (unsigned long )((closer *)0)) {
#line 3645
        point_save = point->next;
#line 3646
        if (point->datatype == 1) {
#line 3646
          if ((unsigned long )point->data != (unsigned long )((void *)0)) {
#line 3647
            js_dealloc(point->data);
          } else {
#line 3646
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 3648
        if (point->datatype == 2) {
#line 3648
          if ((unsigned long )point->data != (unsigned long )((void *)0)) {
#line 3649
            js_destroy((js_string *)point->data);
          } else {
#line 3648
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 3650
        if ((unsigned long )point->data != (unsigned long )((void *)0)) {
#line 3651
          js_dealloc(point->data);
        }
#line 3652
        js_dealloc((void *)point);
#line 3653
        point = point_save;
      }
#line 3657
      tmp___4 = mhash_put(dnscache, zone, (void *)close___0, 4);
#line 3657
      if (tmp___4 == -1) {
#line 3658
        goto cleanup_noipjs;
      }
#line 3659
      break;
      case 2: 
#line 3661
      while ((unsigned long )point->next != (unsigned long )((struct closer *)0)) {
#line 3662
        point = point->next;
      }
#line 3663
      point->next = close___0;
#line 3664
      if (rlog_level >= 4) {
#line 3665
        log_lock();
#line 3666
        show_timestamp();
#line 3667
        printf("That\'s an append\n");
#line 3668
        log_unlock();
      }
#line 3670
      return (1);
      }
    } else {
#line 3635
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 3676
  if ((unsigned long )spot_data.value != (unsigned long )((void *)0)) {
#line 3677
    goto cleanup_noipjs;
  } else {
#line 3680
    tmp___5 = mhash_put(dnscache, zone, (void *)close___0, 4);
#line 3680
    if (tmp___5 == -1) {
#line 3681
      goto cleanup_noipjs;
    }
  }
#line 3683
  custodian();
#line 3685
  return (1);
  cleanup: 
#line 3687
  js_destroy(ipjs);
  cleanup_noipjs: 
#line 3689
  if ((unsigned long )ipp != (unsigned long )((uint32_t *)0)) {
#line 3690
    js_dealloc((void *)ipp);
  }
#line 3692
  js_dealloc((void *)close___0);
#line 3693
  return (-1);
}
}
#line 3706 "recursive.c"
int add_closer_ipv4pair(js_string *zone , ipv4pair *pair , int if_exists ) 
{ closer *close___0 ;
  uint32_t ip ;
  uint32_t *ipp ;
  closer *point ;
  closer *point_save ;
  mhash_e spot_data ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int64_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 3707
  close___0 = (closer *)0;
#line 3708
  ipp = (uint32_t *)0;
#line 3713
  tmp = js_alloc(1, (int )sizeof(closer ));
#line 3713
  close___0 = (closer *)tmp;
#line 3713
  if ((unsigned long )close___0 == (unsigned long )((closer *)0)) {
#line 3714
    return (-1);
  }
#line 3717
  tmp___0 = change_rtype(zone, 252);
#line 3717
  if (tmp___0 == -1) {
#line 3718
    goto cleanup;
  }
#line 3721
  ip = pair->ip;
#line 3724
  close___0->num_elements = 1U;
#line 3725
  close___0->datatype = 1;
#line 3726
  tmp___1 = js_alloc(1, (int )sizeof(uint32_t ));
#line 3726
  ipp = (uint32_t *)tmp___1;
#line 3726
  if ((unsigned long )ipp == (unsigned long )((uint32_t *)0)) {
#line 3727
    goto cleanup;
  }
#line 3728
  *ipp = ip;
#line 3729
  close___0->data = (void *)ipp;
#line 3730
  close___0->next = (struct closer *)((void *)0);
#line 3731
  tmp___2 = qual_get_time();
#line 3731
  close___0->ttd = tmp___2 + 86400LL;
#line 3733
  close___0->ttd = (int64_t )0;
#line 3735
  close___0->zap = (fila *)((void *)0);
#line 3739
  if (rlog_level >= 4) {
#line 3740
    log_lock();
#line 3741
    show_timestamp();
#line 3742
    printf("Adding ");
#line 3743
    show_esc_stdout(zone);
#line 3744
    printf(" to cache at %p (ipv4pair)\n", close___0);
#line 3745
    log_unlock();
  }
#line 3750
  spot_data = mhash_get(dnscache, zone);
#line 3751
  if ((unsigned long )spot_data.value != (unsigned long )((void *)0)) {
#line 3751
    if (spot_data.datatype == 4) {
#line 3752
      point = (closer *)spot_data.value;
#line 3753
      switch (if_exists) {
      case 1: 
#line 3756
      mhash_undef(dnscache, zone);
#line 3760
      while ((unsigned long )point != (unsigned long )((closer *)0)) {
#line 3761
        point_save = point->next;
#line 3762
        if (point->datatype == 1) {
#line 3762
          if ((unsigned long )point->data != (unsigned long )((void *)0)) {
#line 3763
            js_dealloc(point->data);
          } else {
#line 3762
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 3764
        if (point->datatype == 2) {
#line 3764
          if ((unsigned long )point->data != (unsigned long )((void *)0)) {
#line 3765
            js_destroy((js_string *)point->data);
          } else {
#line 3764
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 3766
        if ((unsigned long )point->data != (unsigned long )((void *)0)) {
#line 3767
          js_dealloc(point->data);
        }
#line 3768
        js_dealloc((void *)point);
#line 3769
        point = point_save;
      }
#line 3773
      tmp___3 = mhash_put(dnscache, zone, (void *)close___0, 4);
#line 3773
      if (tmp___3 == -1) {
#line 3774
        goto cleanup;
      }
#line 3775
      break;
      case 2: 
#line 3777
      while ((unsigned long )point->next != (unsigned long )((struct closer *)0)) {
#line 3778
        point = point->next;
      }
#line 3779
      point->next = close___0;
#line 3780
      if (rlog_level >= 4) {
#line 3781
        log_lock();
#line 3782
        show_timestamp();
#line 3783
        printf("That\'s an append\n");
#line 3784
        log_unlock();
      }
#line 3786
      return (1);
      }
    } else {
#line 3751
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 3791
  if ((unsigned long )spot_data.value != (unsigned long )((void *)0)) {
#line 3792
    goto cleanup;
  } else {
#line 3795
    tmp___4 = mhash_put(dnscache, zone, (void *)close___0, 4);
#line 3795
    if (tmp___4 == -1) {
#line 3796
      goto cleanup;
    }
  }
#line 3798
  custodian();
#line 3800
  return (1);
  cleanup: 
#line 3802
  if ((unsigned long )ipp != (unsigned long )((uint32_t *)0)) {
#line 3803
    js_dealloc((void *)ipp);
  }
#line 3805
  js_dealloc((void *)close___0);
#line 3806
  return (-1);
}
}
#line 3819 "recursive.c"
int add_closer_js(js_string *zone , js_string *name , int if_exists ) 
{ closer *close___0 ;
  mhash_e spot_data ;
  closer *point ;
  js_string *new ;
  js_string *zone_copy ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int64_t tmp___3 ;
  int tmp___4 ;

  {
#line 3820
  close___0 = (closer *)0;
#line 3823
  new = (js_string *)0;
#line 3823
  zone_copy = (js_string *)0;
#line 3826
  tmp = js_alloc(1, (int )sizeof(closer ));
#line 3826
  close___0 = (closer *)tmp;
#line 3826
  if ((unsigned long )close___0 == (unsigned long )((closer *)0)) {
#line 3827
    return (-1);
  }
#line 3828
  new = js_create(name->unit_count + 1U, 1U);
#line 3828
  if ((unsigned long )new == (unsigned long )((js_string *)0)) {
#line 3829
    js_dealloc((void *)close___0);
#line 3830
    return (-1);
  }
#line 3832
  zone_copy = js_create(zone->unit_count + 1U, 1U);
#line 3832
  if ((unsigned long )zone_copy == (unsigned long )((js_string *)0)) {
#line 3833
    js_dealloc((void *)close___0);
#line 3834
    js_destroy(new);
#line 3835
    return (-1);
  }
#line 3838
  tmp___0 = js_copy(name, new);
#line 3838
  if (tmp___0 == -1) {
#line 3839
    js_dealloc((void *)close___0);
#line 3839
    js_destroy(new);
#line 3839
    js_destroy(zone_copy);
#line 3840
    return (-1);
  }
#line 3842
  tmp___1 = js_copy(zone, zone_copy);
#line 3842
  if (tmp___1 == -1) {
#line 3843
    js_dealloc((void *)close___0);
#line 3843
    js_destroy(new);
#line 3843
    js_destroy(zone_copy);
#line 3844
    return (-1);
  }
#line 3848
  tmp___2 = change_rtype(zone, 252);
#line 3848
  if (tmp___2 == -1) {
#line 3849
    goto cleanup;
  }
#line 3852
  close___0->num_elements = 1U;
#line 3853
  close___0->datatype = 2;
#line 3854
  close___0->data = (void *)new;
#line 3855
  close___0->next = (struct closer *)((void *)0);
#line 3856
  tmp___3 = qual_get_time();
#line 3856
  close___0->ttd = tmp___3 + 86400LL;
#line 3858
  close___0->zap = (fila *)0;
#line 3860
  if (rlog_level >= 4) {
#line 3861
    log_lock();
#line 3862
    show_timestamp();
#line 3863
    printf("Adding ");
#line 3864
    show_esc_stdout(zone);
#line 3865
    printf(" to cache at %p (js)\n", close___0);
#line 3866
    log_unlock();
  }
#line 3872
  spot_data = mhash_get(dnscache, zone);
#line 3874
  if ((unsigned long )spot_data.value != (unsigned long )((void *)0)) {
#line 3874
    if (spot_data.datatype == 4) {
#line 3875
      point = (closer *)spot_data.value;
#line 3876
      switch (if_exists) {
      case 1: 
#line 3879
      mhash_undef(dnscache, zone);
#line 3881
      unlink_closer(point);
#line 3884
      close___0->zap = new_fila((void *)close___0, (unsigned char)1, zone_copy, (char)1);
#line 3885
      break;
      case 2: 
#line 3887
      (point->num_elements) ++;
#line 3888
      close___0->zap = (fila *)((void *)0);
#line 3890
      while ((unsigned long )point->next != (unsigned long )((struct closer *)0)) {
#line 3891
        point = point->next;
      }
#line 3892
      point->next = close___0;
#line 3893
      if (rlog_level >= 4) {
#line 3894
        log_lock();
#line 3895
        show_timestamp();
#line 3896
        printf("That\'s an append\n");
#line 3897
        log_unlock();
      }
#line 3899
      js_destroy(zone_copy);
#line 3900
      return (1);
      }
    } else {
#line 3874
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 3905
  if ((unsigned long )spot_data.value != (unsigned long )((void *)0)) {
#line 3906
    goto cleanup;
  } else {
#line 3910
    close___0->zap = new_fila((void *)close___0, (unsigned char)1, zone_copy, (char)1);
  }
#line 3914
  tmp___4 = mhash_put(dnscache, zone, (void *)close___0, 4);
#line 3914
  if (tmp___4 == -1) {
#line 3915
    if ((unsigned long )close___0->zap != (unsigned long )((fila *)0)) {
#line 3916
      remove_fila(close___0->zap);
    }
#line 3917
    js_dealloc((void *)close___0);
#line 3917
    js_destroy(new);
#line 3918
    return (-1);
  }
#line 3921
  custodian();
#line 3923
  return (1);
  cleanup: 
#line 3925
  js_dealloc((void *)close___0);
#line 3925
  js_destroy(new);
#line 3925
  js_destroy(zone_copy);
#line 3926
  return (-1);
}
}
#line 3939 "recursive.c"
int add_closer_jsip_offset(js_string *js , int offset , js_string *ipjs , int if_exists ) 
{ js_string *sub ;
  int len ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
#line 3946
  len = dlabel_length(js, (unsigned int )offset);
#line 3947
  if (len == -1) {
#line 3948
    return (-1);
  }
#line 3951
  sub = js_create((unsigned int )(len + 4), 1U);
#line 3951
  if ((unsigned long )sub == (unsigned long )((js_string *)0)) {
#line 3952
    return (-1);
  }
#line 3953
  tmp = js_substr(js, sub, offset, len);
#line 3953
  if (tmp == -1) {
#line 3954
    js_destroy(sub);
#line 3955
    return (-1);
  }
#line 3957
  tmp___0 = js_adduint16(sub, 252);
#line 3957
  if (tmp___0 == -1) {
#line 3958
    js_destroy(sub);
#line 3959
    return (-1);
  }
#line 3963
  ret = add_closer_jsip(sub, ipjs, if_exists);
#line 3964
  js_destroy(sub);
#line 3965
  return (ret);
}
}
#line 3977 "recursive.c"
int add_closer_js_offset(js_string *js , int offset1 , int offset2 , int if_exists ) 
{ js_string *sub1 ;
  js_string *sub2 ;
  int len1 ;
  int len2 ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 3984
  len1 = dlabel_length(js, (unsigned int )offset1);
#line 3985
  if (len1 == -1) {
#line 3986
    return (-1);
  }
#line 3987
  len2 = dlabel_length(js, (unsigned int )offset2);
#line 3988
  if (len2 == -1) {
#line 3989
    return (-1);
  }
#line 3992
  sub1 = js_create((unsigned int )(len1 + 4), 1U);
#line 3992
  if ((unsigned long )sub1 == (unsigned long )((js_string *)0)) {
#line 3993
    return (-1);
  }
#line 3994
  tmp = js_substr(js, sub1, offset1, len1);
#line 3994
  if (tmp == -1) {
#line 3995
    js_destroy(sub1);
#line 3996
    return (-1);
  }
#line 3998
  tmp___0 = js_adduint16(sub1, 252);
#line 3998
  if (tmp___0 == -1) {
#line 3999
    js_destroy(sub1);
#line 4000
    return (-1);
  }
#line 4004
  sub2 = js_create((unsigned int )(len2 + 4), 1U);
#line 4004
  if ((unsigned long )sub2 == (unsigned long )((js_string *)0)) {
#line 4005
    js_destroy(sub1);
#line 4006
    return (-1);
  }
#line 4008
  tmp___1 = js_substr(js, sub2, offset2, len2);
#line 4008
  if (tmp___1 == -1) {
#line 4009
    js_destroy(sub1);
#line 4010
    js_destroy(sub2);
#line 4011
    return (-1);
  }
#line 4013
  tmp___2 = js_adduint16(sub2, 1);
#line 4013
  if (tmp___2 == -1) {
#line 4014
    js_destroy(sub1);
#line 4015
    js_destroy(sub2);
#line 4016
    return (-1);
  }
#line 4020
  ret = add_closer_js(sub1, sub2, if_exists);
#line 4021
  js_destroy(sub1);
#line 4022
  js_destroy(sub2);
#line 4023
  return (ret);
}
}
#line 4035 "recursive.c"
int add_closer_jsip(js_string *zone , js_string *ipjs , int if_exists ) 
{ closer *close___0 ;
  uint32_t ip ;
  uint32_t *ipp ;
  closer *point ;
  mhash_e spot_data ;
  js_string *zone_copy ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int64_t tmp___3 ;
  int tmp___4 ;

  {
#line 4036
  close___0 = (closer *)0;
#line 4037
  ipp = (uint32_t *)0;
#line 4040
  zone_copy = (js_string *)0;
#line 4043
  tmp = js_alloc(1, (int )sizeof(closer ));
#line 4043
  close___0 = (closer *)tmp;
#line 4043
  if ((unsigned long )close___0 == (unsigned long )((closer *)0)) {
#line 4044
    return (-1);
  }
#line 4045
  zone_copy = js_create(zone->unit_count + 1U, 1U);
#line 4045
  if ((unsigned long )zone_copy == (unsigned long )((js_string *)0)) {
#line 4046
    js_dealloc((void *)close___0);
#line 4047
    return (-1);
  }
#line 4051
  tmp___0 = change_rtype(zone, 252);
#line 4051
  if (tmp___0 == -1) {
#line 4052
    js_dealloc((void *)close___0);
#line 4052
    js_destroy(zone_copy);
#line 4053
    return (-1);
  }
#line 4058
  tmp___1 = js_copy(zone, zone_copy);
#line 4058
  if (tmp___1 == -1) {
#line 4059
    js_dealloc((void *)close___0);
#line 4059
    js_destroy(zone_copy);
#line 4060
    return (-1);
  }
#line 4064
  if (ipjs->unit_count < 4U) {
#line 4065
    js_dealloc((void *)close___0);
#line 4065
    js_destroy(zone_copy);
#line 4066
    return (-1);
  }
#line 4068
  ip = (uint32_t )(((((int )*(ipjs->string) << 24) | ((int )*(ipjs->string + 1) << 16)) | ((int )*(ipjs->string + 2) << 8)) | (int )*(ipjs->string + 3));
#line 4072
  close___0->num_elements = 1U;
#line 4073
  close___0->datatype = 1;
#line 4074
  tmp___2 = js_alloc(1, (int )sizeof(uint32_t ));
#line 4074
  ipp = (uint32_t *)tmp___2;
#line 4074
  if ((unsigned long )ipp == (unsigned long )((uint32_t *)0)) {
#line 4075
    goto cleanup;
  }
#line 4077
  *ipp = ip;
#line 4078
  close___0->data = (void *)ipp;
#line 4079
  close___0->next = (struct closer *)((void *)0);
#line 4080
  tmp___3 = qual_get_time();
#line 4080
  close___0->ttd = tmp___3 + 86400LL;
#line 4082
  close___0->zap = (fila *)0;
#line 4084
  if (rlog_level >= 4) {
#line 4085
    log_lock();
#line 4086
    show_timestamp();
#line 4087
    printf("Adding ");
#line 4088
    show_esc_stdout(zone);
#line 4089
    printf(" to cache at %p (jsip)\n", close___0);
#line 4090
    log_unlock();
  }
#line 4096
  spot_data = mhash_get(dnscache, zone);
#line 4098
  if ((unsigned long )spot_data.value != (unsigned long )((void *)0)) {
#line 4098
    if (spot_data.datatype == 4) {
#line 4099
      point = (closer *)spot_data.value;
#line 4100
      switch (if_exists) {
      case 1: 
#line 4103
      mhash_undef(dnscache, zone);
#line 4105
      unlink_closer(point);
#line 4108
      close___0->zap = new_fila((void *)close___0, (unsigned char)1, zone_copy, (char)1);
#line 4109
      break;
      case 2: 
#line 4111
      (point->num_elements) ++;
#line 4112
      close___0->zap = (fila *)((void *)0);
#line 4114
      while ((unsigned long )point->next != (unsigned long )((struct closer *)0)) {
#line 4115
        point = point->next;
      }
#line 4116
      point->next = close___0;
#line 4117
      js_destroy(zone_copy);
#line 4118
      return (1);
      }
    } else {
#line 4098
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 4123
  if ((unsigned long )spot_data.value != (unsigned long )((void *)0)) {
#line 4124
    goto cleanup;
  } else {
#line 4128
    close___0->zap = new_fila((void *)close___0, (unsigned char)1, zone_copy, (char)1);
  }
#line 4132
  tmp___4 = mhash_put(dnscache, zone, (void *)close___0, 4);
#line 4132
  if (tmp___4 == -1) {
#line 4135
    if ((unsigned long )close___0->zap != (unsigned long )((fila *)0)) {
#line 4136
      remove_fila(close___0->zap);
    }
#line 4137
    js_dealloc((void *)ipp);
#line 4137
    js_dealloc((void *)close___0);
#line 4138
    return (-1);
  }
#line 4141
  custodian();
#line 4143
  return (1);
  cleanup: 
#line 4145
  js_dealloc((void *)close___0);
#line 4146
  if ((unsigned long )ipp != (unsigned long )((uint32_t *)0)) {
#line 4147
    js_dealloc((void *)ipp);
  }
#line 4149
  js_destroy(zone_copy);
#line 4150
  return (-1);
}
}
#line 4160 "recursive.c"
int add_closer_ip(char *zone , char *ddip ) 
{ js_string *zone_js ;
  js_string *ddip_js ;
  int zone_len ;
  int ddip_len ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 4165
  if ((unsigned long )zone == (unsigned long )((char *)0)) {
#line 4166
    return (-1);
  } else
#line 4165
  if ((int )*zone == 0) {
#line 4166
    return (-1);
  }
#line 4167
  if ((unsigned long )ddip == (unsigned long )((char *)0)) {
#line 4168
    return (-1);
  } else
#line 4167
  if ((int )*ddip == 0) {
#line 4168
    return (-1);
  }
#line 4170
  zone_len = js_strnlen(zone, (uint32_t )1000000);
#line 4171
  ddip_len = js_strnlen(ddip, (uint32_t )1000000);
#line 4174
  zone_js = js_create((unsigned int )(zone_len + 3), 1U);
#line 4174
  if ((unsigned long )zone_js == (unsigned long )((js_string *)0)) {
#line 4175
    return (-1);
  }
#line 4177
  ddip_js = js_create((unsigned int )(ddip_len + 1), 1U);
#line 4177
  if ((unsigned long )ddip_js == (unsigned long )((js_string *)0)) {
#line 4178
    js_destroy(zone_js);
#line 4179
    return (-1);
  }
#line 4183
  tmp = js_str2js(zone_js, zone, zone_len, 1);
#line 4183
  if (tmp == -1) {
#line 4184
    goto cleanup;
  }
#line 4185
  tmp___0 = js_str2js(ddip_js, ddip, ddip_len, 1);
#line 4185
  if (tmp___0 == -1) {
#line 4186
    goto cleanup;
  }
#line 4189
  tmp___1 = hname_2rfc1035(zone_js);
#line 4189
  if (tmp___1 <= 0) {
#line 4190
    goto cleanup;
  }
#line 4192
  tmp___2 = js_adduint16(zone_js, 252);
#line 4192
  if (tmp___2 == -1) {
#line 4193
    goto cleanup;
  }
#line 4196
  ret = add_closer_jsddip(zone_js, ddip_js, 1);
#line 4197
  js_destroy(zone_js);
#line 4198
  js_destroy(ddip_js);
#line 4199
  return (ret);
  cleanup: 
#line 4202
  js_destroy(ddip_js);
#line 4203
  js_destroy(zone_js);
#line 4204
  return (-1);
}
}
#line 4216 "recursive.c"
int init_spammers(js_string *spam_list ) 
{ int counter ;
  int tmp ;

  {
#line 4220
  counter = 0;
#line 4220
  while (counter < 511) {
#line 4221
    spammers[counter].ip = 4294967295U;
#line 4220
    counter ++;
  }
#line 4224
  if ((unsigned long )spam_list != (unsigned long )((js_string *)0)) {
#line 4225
    tmp = make_ip_acl(spam_list, spammers, 500, 0);
#line 4225
    return (tmp);
  } else {
#line 4227
    return (1);
  }
}
}
#line 4234 "recursive.c"
int set_port_range(int a , int b ) 
{ 

  {
#line 4235
  recurse_min_bind_port = a;
#line 4236
  recurse_number_ports = b - 1;
#line 4237
  return (1);
}
}
#line 4243 "recursive.c"
int set_upstream_port(int num ) 
{ 

  {
#line 4244
  if (num < 1) {
#line 4245
    printf("Warning: upstream_port out of range; using default value of 53\n");
#line 4247
    upstream_port = 53;
#line 4248
    return (0);
  } else
#line 4244
  if (num > 65530) {
#line 4245
    printf("Warning: upstream_port out of range; using default value of 53\n");
#line 4247
    upstream_port = 53;
#line 4248
    return (0);
  }
#line 4250
  upstream_port = num;
#line 4251
  return (1);
}
}
#line 4260 "recursive.c"
int set_min_ttl(int norm , int cname ) 
{ 

  {
#line 4263
  if (norm < 0) {
#line 4264
    norm = 300;
  }
#line 4265
  if (norm < 180) {
#line 4266
    norm = 180;
  }
#line 4267
  if (cname < 0) {
#line 4268
    cname = norm;
  }
#line 4269
  if (cname < 180) {
#line 4270
    cname = 180;
  }
#line 4272
  min_ttl_cname = cname;
#line 4273
  min_ttl_normal = norm;
#line 4274
  return (1);
}
}
#line 4283 "recursive.c"
int add_hardcoded_ns(js_string *rootns , js_string *rootns_zone ) 
{ int ret ;
  int counter ;
  ipv4pair root_servers[512] ;
  js_string *zone ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 4285
  ret = 0;
#line 4286
  counter = 0;
#line 4291
  counter = 0;
#line 4291
  while (counter < 511) {
#line 4292
    root_servers[counter].ip = 4294967295U;
#line 4291
    counter ++;
  }
#line 4295
  zone = js_create(256U, 1U);
#line 4296
  if ((unsigned long )zone == (unsigned long )((js_string *)0)) {
#line 4297
    return (0);
  }
#line 4301
  js_set_encode(rootns, 1);
#line 4302
  js_set_encode(rootns_zone, 1);
#line 4303
  js_set_encode(zone, 1);
#line 4306
  ret = -8;
#line 4307
  tmp = js_qstr2js(zone, (char *)"A");
#line 4307
  if (tmp == -1) {
#line 4308
    goto cleanup;
  }
#line 4309
  tmp___0 = js_append(rootns_zone, zone);
#line 4309
  if (tmp___0 == -1) {
#line 4310
    goto cleanup;
  }
#line 4311
  ret = -9;
#line 4312
  tmp___1 = hname_2rfc1035(zone);
#line 4312
  if (tmp___1 <= 0) {
#line 4313
    printf("\n***************************************\n");
#line 4314
    printf("WARNING: Invalid zone name ");
#line 4315
    show_esc_stdout(rootns_zone);
#line 4316
    printf("\n(Perhaps you forgot the final dot)\n");
#line 4317
    printf("Please remove or edit the line from your mararc that looks like this:\n\n");
#line 4319
    if (root_or_upstream == 1) {
#line 4320
      printf("upstream");
    } else {
#line 4322
      printf("root");
    }
#line 4324
    printf("_servers[\"");
#line 4325
    show_esc_stdout(rootns_zone);
#line 4326
    printf("\"] = \"");
#line 4327
    show_esc_stdout(rootns);
#line 4328
    printf("\"\n\n");
#line 4329
    js_destroy(zone);
#line 4330
    printf("This line is being ignored by MaraDNS\n");
#line 4331
    printf("***************************************\n\n");
#line 4332
    return (1);
  }
#line 4334
  ret = -10;
#line 4335
  tmp___2 = js_adduint16(zone, 252);
#line 4335
  if (tmp___2 == -1) {
#line 4336
    goto cleanup;
  }
#line 4338
  ret = -11;
#line 4339
  tmp___3 = make_ip_acl(rootns, root_servers, 500, 0);
#line 4339
  if (tmp___3 == -1) {
#line 4340
    printf("\n***************************************\n");
#line 4341
    printf("WARNING: Invalid IP list for zone ");
#line 4342
    show_esc_stdout(rootns_zone);
#line 4343
    printf("\nPlease remove or edit the line from your mararc that looks like this:\n\n");
#line 4345
    if (root_or_upstream == 1) {
#line 4346
      printf("upstream");
    } else {
#line 4348
      printf("root");
    }
#line 4350
    printf("_servers[\"");
#line 4351
    show_esc_stdout(rootns_zone);
#line 4352
    printf("\"] = \"");
#line 4353
    show_esc_stdout(rootns);
#line 4354
    printf("\"\n\n");
#line 4355
    js_destroy(zone);
#line 4356
    printf("This line is being ignored by MaraDNS\n");
#line 4357
    printf("***************************************\n\n");
#line 4358
    js_destroy(zone);
#line 4359
    return (1);
  }
#line 4361
  counter = 0;
#line 4362
  while (root_servers[counter].ip != 4294967295U) {
#line 4363
    ret = -12;
#line 4364
    if (counter > 502) {
#line 4365
      goto cleanup;
    }
#line 4366
    ret = -13;
#line 4367
    tmp___4 = add_closer_ipv4pair(zone, & root_servers[counter], 2);
#line 4367
    if (tmp___4 == -1) {
#line 4369
      goto cleanup;
    }
#line 4370
    counter ++;
  }
#line 4373
  js_destroy(zone);
#line 4374
  return (1);
  cleanup: 
#line 4377
  js_destroy(zone);
#line 4378
  return (ret);
}
}
#line 4406 "recursive.c"
int init_cache(int max_cache_elements , int max_threads , int max_glueless , int max_q_total ,
               int timeout , int verbose_query_value ) 
{ js_string *rootns ;
  js_string *rootns_zone ;
  js_string *rzone ;
  int bits ;
  int exp_counter ;
  int ret ;
  mhash *root_serv ;
  mhash *upstream_serv ;
  int root_seen ;
  mhash *tmp ;
  int tmp___0 ;
  mhash *tmp___1 ;
  int tmp___2 ;
  mhash *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  js_string *nslist ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 4411
  bits = 1;
#line 4412
  exp_counter = 1;
#line 4413
  ret = 0;
#line 4416
  root_seen = 0;
#line 4419
  if ((unsigned long )rra_data == (unsigned long )((rr *)0)) {
#line 4420
    rra_data = init_ra_data();
  }
#line 4424
  verbose_query = verbose_query_value;
#line 4427
  max_glueless_level = 10;
#line 4428
  if (max_glueless > 0) {
#line 4429
    max_glueless_level = max_glueless;
  }
#line 4432
  max_queries_total = 32;
#line 4433
  if (max_q_total > 0) {
#line 4434
    max_queries_total = max_q_total;
  }
#line 4437
  timeout_seconds = 2;
#line 4438
  if (timeout > 0) {
#line 4439
    timeout_seconds = timeout;
  }
#line 4442
  if (max_threads > 0) {
#line 4443
    maximum_num_of_threads = max_threads;
  }
#line 4446
  while (exp_counter <= max_cache_elements) {
#line 4450
    if (bits > 30) {
#line 4451
      return (-1);
    }
#line 4452
    bits ++;
#line 4453
    exp_counter *= 2;
  }
#line 4473
  if ((unsigned long )dnscache != (unsigned long )((mhash *)0)) {
#line 4474
    return (-2);
  }
#line 4477
  tmp = mhash_create(bits);
#line 4477
  dnscache = tmp;
#line 4481
  cache_max = max_cache_elements;
#line 4485
  rootns = js_create(256U, 1U);
#line 4485
  if ((unsigned long )rootns == (unsigned long )((js_string *)0)) {
#line 4486
    return (-3);
  }
#line 4488
  rootns_zone = js_create(256U, 1U);
#line 4488
  if ((unsigned long )rootns_zone == (unsigned long )((js_string *)0)) {
#line 4489
    js_destroy(rootns);
#line 4490
    return (-4);
  }
#line 4492
  rzone = js_create(256U, 1U);
#line 4492
  if ((unsigned long )rzone == (unsigned long )((js_string *)0)) {
#line 4493
    js_destroy(rootns);
#line 4494
    js_destroy(rzone);
#line 4495
    return (-4);
  }
#line 4498
  tmp___0 = dq_keyword2n((char *)"root_servers");
#line 4498
  tmp___1 = dvar_raw(tmp___0);
#line 4498
  root_serv = tmp___1;
#line 4499
  tmp___2 = dq_keyword2n((char *)"upstream_servers");
#line 4499
  tmp___3 = dvar_raw(tmp___2);
#line 4499
  upstream_serv = tmp___3;
#line 4502
  js_set_encode(rootns, 3);
#line 4503
  js_set_encode(rootns_zone, 3);
#line 4506
  if ((unsigned long )root_serv == (unsigned long )((mhash *)0)) {
#line 4506
    if ((unsigned long )upstream_serv == (unsigned long )((mhash *)0)) {
#line 4508
      printf("Using default ICANN root servers\n");
#line 4509
      tmp___4 = js_qstr2js(rootns, (char *)"198.41.0.4,192.228.79.201,192.33.4.12,128.8.10.90,192.203.230.10,192.5.5.241,192.112.36.4,128.63.2.53,192.36.148.17,192.58.128.30,193.0.14.129,199.7.83.42,202.12.27.33");
#line 4509
      if (tmp___4 == -1) {
#line 4510
        goto cleanup;
      }
#line 4512
      tmp___5 = js_qstr2js(rootns_zone, (char *)".");
#line 4512
      if (tmp___5 == -1) {
#line 4513
        goto cleanup;
      }
#line 4516
      ret = add_hardcoded_ns(rootns, rootns_zone);
#line 4517
      goto cleanup;
    } else {
#line 4506
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 4520
  if ((unsigned long )root_serv != (unsigned long )((mhash *)0)) {
#line 4520
    if ((unsigned long )upstream_serv != (unsigned long )((mhash *)0)) {
#line 4521
      ret = -14;
#line 4522
      goto cleanup;
    }
  }
#line 4530
  root_or_upstream = 0;
#line 4531
  if ((unsigned long )upstream_serv != (unsigned long )((mhash *)0)) {
#line 4532
    root_or_upstream = 1;
#line 4533
    root_serv = upstream_serv;
  }
#line 4536
  root_seen = 0;
#line 4539
  tmp___6 = mhash_firstkey(root_serv, rzone);
#line 4539
  if (tmp___6 == -1) {
#line 4540
    ret = -1;
#line 4541
    goto cleanup;
  }
#line 4543
  while (1) {
#line 4545
    nslist = mhash_get_js(root_serv, rzone);
#line 4546
    if ((unsigned long )nslist == (unsigned long )((js_string *)0)) {
#line 4548
      break;
    }
#line 4550
    printf("Adding root nameserver ");
#line 4551
    show_esc_stdout(nslist);
#line 4552
    printf(" for zone ");
#line 4553
    show_esc_stdout(rzone);
#line 4554
    printf("\n");
#line 4555
    tmp___7 = js_qissame((char *)".", rzone);
#line 4555
    if (tmp___7) {
#line 4556
      root_seen = 1;
    }
#line 4558
    ret = add_hardcoded_ns(nslist, rzone);
#line 4559
    js_destroy(nslist);
#line 4560
    if (ret != 1) {
#line 4561
      goto cleanup;
    }
#line 4543
    tmp___8 = mhash_nextkey(root_serv, rzone);
#line 4543
    if (! (tmp___8 != 0)) {
#line 4543
      break;
    }
  }
#line 4565
  if (root_seen == 0) {
#line 4566
    if (root_or_upstream == 1) {
#line 4567
      printf("FATAL ERROR: upstream_servers[\".\"] must be set when");
#line 4568
      printf("\nUsing upstream_servers\n");
#line 4569
      exit(1);
    }
#line 4571
    printf("Using ICANN nameservers for root_servers[\".\"]\n");
#line 4572
    tmp___9 = js_qstr2js(rootns, (char *)"198.41.0.4,192.228.79.201,192.33.4.12,128.8.10.90,192.203.230.10,192.5.5.241,192.112.36.4,128.63.2.53,192.36.148.17,192.58.128.30,193.0.14.129,199.7.83.42,202.12.27.33");
#line 4572
    if (tmp___9 == -1) {
#line 4573
      goto cleanup;
    }
#line 4575
    tmp___10 = js_qstr2js(rootns_zone, (char *)".");
#line 4575
    if (tmp___10 == -1) {
#line 4576
      goto cleanup;
    }
#line 4578
    ret = add_hardcoded_ns(rootns, rootns_zone);
#line 4579
    goto cleanup;
  }
#line 4583
  ret = 1;
  cleanup: 
#line 4585
  js_destroy(rootns);
#line 4586
  js_destroy(rootns_zone);
#line 4587
  js_destroy(rzone);
#line 4588
  return (ret);
}
}
#line 4603 "recursive.c"
static int desc  ;
#line 4601 "recursive.c"
int init_rng(js_string *seedfile , int rekey ) 
{ unsigned char prng_seed[34] ;
  int counter ;
  int max ;
  pid_t process_id ;
  char path[1026] ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;
  ssize_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 4609
  tmp___0 = __builtin_object_size((void *)(r_inBlock), 0);
#line 4609
  if (tmp___0 != 0xffffffffffffffffUL) {
#line 4609
    tmp = __builtin_object_size((void *)(r_inBlock), 0);
#line 4609
    __builtin___memset_chk((void *)(r_inBlock), 0, 16UL, tmp);
  } else {
#line 4609
    __inline_memset_chk((void *)(r_inBlock), 0, (size_t )16);
  }
#line 4610
  time((time_t *)(& r_inBlock[0]));
#line 4611
  tmp___2 = __builtin_object_size((void *)(r_binSeed), 0);
#line 4611
  if (tmp___2 != 0xffffffffffffffffUL) {
#line 4611
    tmp___1 = __builtin_object_size((void *)(r_binSeed), 0);
#line 4611
    __builtin___memset_chk((void *)(r_binSeed), 0, 16UL, tmp___1);
  } else {
#line 4611
    __inline_memset_chk((void *)(r_binSeed), 0, (size_t )16);
  }
#line 4613
  if (rekey == 0) {
#line 4615
    tmp___3 = js_js2str(seedfile, path, 1024);
#line 4615
    if (tmp___3 == -1) {
#line 4616
      return (-1);
    }
#line 4618
    desc = open((char const   *)(path), 0);
#line 4619
    if (desc == -1) {
#line 4620
      return (-2);
    }
  } else {
#line 4622
    lseek(desc, (off_t )0, 0);
  }
#line 4626
  tmp___4 = read(desc, (void *)(prng_seed), (size_t )16);
#line 4626
  if (tmp___4 != 16L) {
#line 4627
    return (-3);
  }
#line 4633
  process_id = getpid();
#line 4634
  max = (int )sizeof(pid_t );
#line 4635
  if (max > 15) {
#line 4636
    max = 15;
  }
#line 4637
  counter = 0;
#line 4637
  while (counter < max) {
#line 4638
    prng_seed[15 - counter] = (unsigned char )((int )prng_seed[15 - counter] ^ (process_id & 255));
#line 4639
    process_id >>= 8;
#line 4637
    counter ++;
  }
#line 4645
  if (rekey == 1) {
#line 4646
    blockEncrypt(& r_cipherInst, & r_seedInst, r_inBlock, 128, r_outBlock);
#line 4647
    counter = 0;
#line 4647
    while (counter < 15) {
#line 4648
      prng_seed[counter] = (unsigned char )((int )prng_seed[counter] ^ ((int )r_outBlock[counter] & 255));
#line 4647
      counter ++;
    }
  }
#line 4653
  tmp___5 = makeKey(& r_seedInst, (MARA_BYTE )0, 128, (char *)(prng_seed));
#line 4653
  if (tmp___5 != 1) {
#line 4654
    return (-1);
  }
#line 4655
  tmp___6 = cipherInit(& r_cipherInst, (MARA_BYTE )1, (char *)((void *)0));
#line 4655
  if (tmp___6 != 1) {
#line 4656
    return (-1);
  }
#line 4657
  tmp___7 = blockEncrypt(& r_cipherInst, & r_seedInst, r_inBlock, 128, r_outBlock);
#line 4657
  if (tmp___7 != 128) {
#line 4658
    return (-1);
  }
#line 4660
  return (1);
}
}
#line 4670 "recursive.c"
int init_rlog_level(int verbose_level ) 
{ 

  {
#line 4671
  rlog_level = verbose_level;
#line 4672
  return (1);
}
}
#line 4677 "recursive.c"
int init_retry_cycles(int in ) 
{ 

  {
#line 4678
  if (in >= 1) {
#line 4678
    if (in <= 31) {
#line 4679
      retry_cycles = in;
    }
  }
#line 4681
  return (1);
}
}
#line 1 "timestamp.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-xVFckVQO.i","")
#line 123 "/usr/include/time.h"
extern char *asctime(struct tm  const  * ) ;
#line 128
extern struct tm *gmtime(time_t const   * ) ;
#line 129
extern struct tm *localtime(time_t const   * ) ;
#line 29 "timestamp.c"
int timestamp_type  =    0;
#line 44 "timestamp.c"
int set_timestamp(int type ) 
{ 

  {
#line 45
  if (type >= 0) {
#line 45
    if (type <= 128) {
#line 46
      timestamp_type = type;
#line 47
      return (1);
    }
  }
#line 49
  return (-1);
}
}
#line 58 "timestamp.c"
int show_timestamp(void) 
{ time_t tmp ;
  time_t tmp___0 ;
  struct tm *htime ;
  time_t now ;
  char *dow[7] ;
  char *moy[12] ;
  char ct[256] ;
  int count ;
  time_t now___0 ;
  struct tm *tmp___1 ;
  char *tmp___2 ;
  unsigned long tmp___3 ;
  struct tm *tmp___4 ;
  char *tmp___5 ;
  unsigned long tmp___6 ;
  struct tm *htime___0 ;
  time_t now___1 ;
  time_t tmp___7 ;

  {
#line 59
  fflush(__stdoutp);
#line 60
  if (timestamp_type == 0) {
#line 61
    tmp = time((time_t *)0);
#line 61
    printf("%s%d ", "Timestamp: ", (int )tmp);
  } else
#line 63
  if (timestamp_type == 1) {
#line 64
    tmp___0 = time((time_t *)0);
#line 64
    printf("%d ", (int )tmp___0);
  } else
#line 66
  if (timestamp_type == 2) {
#line 66
    goto _L___0;
  } else
#line 66
  if (timestamp_type == 3) {
    _L___0: /* CIL Label */ 
#line 70
    dow[0] = (char *)"Domingo";
#line 70
    dow[1] = (char *)"Lunes";
#line 70
    dow[2] = (char *)"Martes";
#line 70
    dow[3] = (char *)"Miercoles";
#line 70
    dow[4] = (char *)"Jueves";
#line 70
    dow[5] = (char *)"Viernes";
#line 70
    dow[6] = (char *)"Sabado";
#line 78
    moy[0] = (char *)"Enero";
#line 78
    moy[1] = (char *)"Febrero";
#line 78
    moy[2] = (char *)"Marzo";
#line 78
    moy[3] = (char *)"Abril";
#line 78
    moy[4] = (char *)"Mayo";
#line 78
    moy[5] = (char *)"Junio";
#line 78
    moy[6] = (char *)"Julio";
#line 78
    moy[7] = (char *)"Agosto";
#line 78
    moy[8] = (char *)"Septiembre";
#line 78
    moy[9] = (char *)"Octubre";
#line 78
    moy[10] = (char *)"Noviembre";
#line 78
    moy[11] = (char *)"Diciembre";
#line 91
    now = time((time_t *)0);
#line 92
    if (timestamp_type == 2) {
#line 93
      htime = gmtime((time_t const   *)(& now));
    } else {
#line 95
      htime = localtime((time_t const   *)(& now));
    }
#line 98
    if (htime->tm_mon < 0) {
#line 99
      return (-1);
    } else
#line 98
    if (htime->tm_mon > 11) {
#line 99
      return (-1);
    }
#line 100
    if (htime->tm_wday < 0) {
#line 101
      return (-1);
    } else
#line 100
    if (htime->tm_wday > 6) {
#line 101
      return (-1);
    }
#line 103
    printf("%s, %d de %s, a %02d:%02d:%02d ", dow[htime->tm_wday], htime->tm_mday,
           moy[htime->tm_mon], htime->tm_hour, htime->tm_min, htime->tm_sec);
#line 106
    if (timestamp_type == 2) {
#line 107
      printf("(UTC) ");
    }
  } else
#line 109
  if (timestamp_type == 4) {
#line 113
    now___0 = time((time_t *)0);
#line 114
    tmp___6 = __builtin_object_size((void *)(ct), 0);
#line 114
    if (tmp___6 != 0xffffffffffffffffUL) {
#line 114
      tmp___3 = __builtin_object_size((void *)(ct), 1);
#line 114
      tmp___4 = gmtime((time_t const   *)(& now___0));
#line 114
      tmp___5 = asctime((struct tm  const  *)tmp___4);
#line 114
      __builtin___strncpy_chk(ct, (char const   *)tmp___5, 100UL, tmp___3);
    } else {
#line 114
      tmp___1 = gmtime((time_t const   *)(& now___0));
#line 114
      tmp___2 = asctime((struct tm  const  *)tmp___1);
#line 114
      __inline_strncpy_chk(ct, (char const   *)tmp___2, (size_t )100);
    }
#line 115
    count = 0;
#line 115
    while (count < 100) {
#line 116
      if ((int )ct[count] < 32) {
#line 117
        ct[count] = (char)0;
#line 118
        break;
      }
#line 115
      count ++;
    }
#line 121
    printf("%s GMT ", ct);
  } else
#line 123
  if (! (timestamp_type == 5)) {
#line 125
    if (timestamp_type == 6) {
#line 125
      goto _L;
    } else
#line 125
    if (timestamp_type == 7) {
      _L: /* CIL Label */ 
#line 128
      now___1 = time((time_t *)0);
#line 129
      if (timestamp_type == 6) {
#line 130
        htime___0 = gmtime((time_t const   *)(& now___1));
      } else {
#line 132
        htime___0 = localtime((time_t const   *)(& now___1));
      }
#line 134
      printf("%d-%02d-%02d %02d:%02d:%02d ", htime___0->tm_year + 1900, htime___0->tm_mon + 1,
             htime___0->tm_mday, htime___0->tm_hour, htime___0->tm_min, htime___0->tm_sec);
    } else {
#line 143
      tmp___7 = time((time_t *)0);
#line 143
      printf("%s%d ", "Timestamp: ", (int )tmp___7);
    }
  }
#line 145
  return (1);
}
}
#line 1 "read_kvars.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-SzuCc8j0.i","")
#line 123 "../libs/JsStr.h"
unsigned int js_atoi(js_string *js , int offset ) ;
#line 24 "../parse/functions_parse.h"
int read_kvar(js_string *name , js_string *value___0 ) ;
#line 45 "read_kvars.c"
int read_numeric_kvar(char *name , int default_value ) 
{ js_string *kvar_name ;
  js_string *kvar_value ;
  int ret ;
  int status ;
  int tmp ;
  unsigned int tmp___0 ;

  {
#line 50
  kvar_name = js_create(64U, 1U);
#line 50
  if ((unsigned long )kvar_name == (unsigned long )((js_string *)0)) {
#line 51
    printf("Aieeeeeee!\n");
#line 52
    exit(1);
#line 53
    return (-1);
  }
#line 56
  kvar_value = js_create(256U, 1U);
#line 56
  if ((unsigned long )kvar_value == (unsigned long )((js_string *)0)) {
#line 57
    printf("Aieeeeeeee!\n");
#line 58
    exit(1);
#line 59
    js_destroy(kvar_name);
#line 60
    return (-1);
  }
#line 63
  js_set_encode(kvar_name, 3);
#line 64
  js_set_encode(kvar_value, 3);
#line 66
  tmp = js_qstr2js(kvar_name, name);
#line 66
  if (tmp == -1) {
#line 67
    js_destroy(kvar_name);
#line 68
    js_destroy(kvar_value);
#line 69
    harderror((char *)"Could not create kvar_query");
  }
#line 72
  status = read_kvar(kvar_name, kvar_value);
#line 74
  if (status == -1) {
#line 75
    js_destroy(kvar_name);
#line 76
    js_destroy(kvar_value);
#line 77
    show_timestamp();
#line 78
    printf("%s%s\n", "Error processing value for ", name);
#line 79
    return (default_value);
  }
#line 82
  if (status == 0) {
#line 83
    js_destroy(kvar_name);
#line 84
    js_destroy(kvar_value);
#line 85
    return (default_value);
  }
#line 88
  tmp___0 = js_atoi(kvar_value, 0);
#line 88
  ret = (int )tmp___0;
#line 90
  js_destroy(kvar_name);
#line 91
  js_destroy(kvar_value);
#line 92
  return (ret);
}
}
#line 107 "read_kvars.c"
js_string *read_string_kvar(char *name ) 
{ js_string *kvar_name ;
  js_string *kvar_value ;
  int status ;
  int tmp ;

  {
#line 112
  kvar_name = js_create(64U, 1U);
#line 112
  if ((unsigned long )kvar_name == (unsigned long )((js_string *)0)) {
#line 113
    printf("Aiiieeeeeee!\n");
#line 114
    exit(1);
#line 115
    return ((js_string *)0);
  }
#line 118
  kvar_value = js_create(256U, 1U);
#line 118
  if ((unsigned long )kvar_value == (unsigned long )((js_string *)0)) {
#line 119
    printf("Aiiieeeeeeeeee!\n");
#line 120
    exit(1);
#line 121
    js_destroy(kvar_name);
#line 122
    return ((js_string *)0);
  }
#line 125
  js_set_encode(kvar_name, 3);
#line 126
  js_set_encode(kvar_value, 3);
#line 128
  tmp = js_qstr2js(kvar_name, name);
#line 128
  if (tmp == -1) {
#line 129
    js_destroy(kvar_name);
#line 130
    js_destroy(kvar_value);
#line 131
    harderror((char *)"Could not create kvar_query");
  }
#line 134
  status = read_kvar(kvar_name, kvar_value);
#line 136
  if (status == -1) {
#line 137
    js_destroy(kvar_name);
#line 138
    js_destroy(kvar_value);
#line 139
    show_timestamp();
#line 140
    printf("%s%s\n", "Error processing value for ", name);
#line 141
    return ((js_string *)0);
  }
#line 144
  if (status == 0) {
#line 145
    js_destroy(kvar_name);
#line 146
    js_destroy(kvar_value);
#line 147
    return ((js_string *)0);
  }
#line 150
  js_destroy(kvar_name);
#line 151
  return (kvar_value);
}
}
#line 1 "MaraAnyChain.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-lUPIa7A1.i","")
#line 35 "MaraAnyChain.c"
int any_add_rr(mhash *hash , js_string *query , rr *data ) 
{ int rrtype ;
  int a ;
  js_string *copy ;
  rr_list *point ;
  rr_list *new ;
  mhash_e get ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 43
  rrtype = get_rtype(query);
#line 45
  if (rrtype == -1) {
#line 46
    return (-1);
  }
#line 48
  if (rrtype < 0) {
#line 49
    return (-1);
  } else
#line 48
  if (rrtype > 65535) {
#line 49
    return (-1);
  }
#line 54
  copy = js_create(256U, 1U);
#line 54
  if ((unsigned long )copy == (unsigned long )((js_string *)0)) {
#line 55
    return (-1);
  }
#line 57
  tmp = js_copy(query, copy);
#line 57
  if (tmp == -1) {
#line 58
    js_destroy(copy);
#line 59
    return (-1);
  }
#line 61
  tmp___0 = change_rtype(copy, 255);
#line 61
  if (tmp___0 == -1) {
#line 62
    js_destroy(copy);
#line 63
    return (-1);
  }
#line 67
  tmp___1 = js_alloc(1, (int )sizeof(rr_list ));
#line 67
  new = (rr_list *)tmp___1;
#line 68
  if ((unsigned long )new == (unsigned long )((rr_list *)0)) {
#line 69
    js_destroy(copy);
#line 70
    return (-1);
  }
#line 73
  new->rr_type = (uint16_t )rrtype;
#line 74
  new->data = data;
#line 75
  new->next = (struct rr_list *)0;
#line 78
  get = mhash_get(hash, copy);
#line 82
  if ((unsigned long )get.value == (unsigned long )((void *)0)) {
#line 82
    if (get.datatype == 0) {
#line 83
      mhash_put(hash, copy, (void *)new, 6);
#line 84
      js_destroy(copy);
#line 85
      return (1);
    }
  }
#line 88
  js_destroy(copy);
#line 92
  if (get.datatype != 6) {
#line 93
    harderror((char *)"Data not MARA_DNS_LIST in ANY query in bighash");
  }
#line 96
  point = (rr_list *)get.value;
#line 97
  if ((unsigned long )point == (unsigned long )((rr_list *)0)) {
#line 98
    return (-1);
  }
#line 102
  a = 0;
#line 102
  while (a < 65000) {
#line 104
    if ((unsigned long )point->next == (unsigned long )((struct rr_list *)0)) {
#line 105
      break;
    }
#line 107
    point = point->next;
#line 102
    a ++;
  }
#line 110
  if ((unsigned long )point->next != (unsigned long )((struct rr_list *)0)) {
#line 111
    return (-1);
  }
#line 115
  point->next = new;
#line 116
  new->next = (struct rr_list *)0;
#line 117
  new->data = data;
#line 118
  return (1);
}
}
#line 123 "MaraAnyChain.c"
int any_add_c_rr(mhash *hash , js_string *query , rr *data ) 
{ int rrtype ;
  int tmp ;

  {
#line 125
  rrtype = get_rtype(query);
#line 126
  if (rrtype == 5) {
#line 127
    return (-1);
  }
#line 129
  tmp = any_add_rr(hash, query, data);
#line 129
  return (tmp);
}
}
#line 138 "MaraAnyChain.c"
int any_zap_rr(mhash *hash , js_string *query , rr *data ) 
{ int a ;
  js_string *copy ;
  mhash_e get ;
  rr_list *point ;
  rr_list *last ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 147
  copy = js_create(256U, 1U);
#line 147
  if ((unsigned long )copy == (unsigned long )((js_string *)0)) {
#line 148
    return (-1);
  }
#line 150
  tmp = js_copy(query, copy);
#line 150
  if (tmp == -1) {
#line 151
    js_destroy(copy);
#line 152
    return (-1);
  }
#line 154
  tmp___0 = change_rtype(copy, 255);
#line 154
  if (tmp___0 == -1) {
#line 155
    js_destroy(copy);
#line 156
    return (-1);
  }
#line 160
  get = mhash_get(hash, copy);
#line 162
  if ((unsigned long )get.value == (unsigned long )((void *)0)) {
#line 163
    js_destroy(copy);
#line 164
    return (1);
  } else
#line 162
  if (get.datatype == 0) {
#line 163
    js_destroy(copy);
#line 164
    return (1);
  }
#line 167
  point = (rr_list *)get.value;
#line 168
  last = (rr_list *)0;
#line 171
  if ((unsigned long )point->data == (unsigned long )data) {
#line 171
    if ((unsigned long )point->next == (unsigned long )((struct rr_list *)0)) {
#line 172
      tmp___1 = mhash_undef(hash, copy);
#line 172
      last = (rr_list *)tmp___1;
#line 173
      if ((unsigned long )last != (unsigned long )point) {
#line 174
        harderror((char *)"Line 166; mail the mailing list");
      }
#line 176
      js_dealloc((void *)last);
#line 177
      js_destroy(copy);
#line 178
      return (1);
    }
  }
#line 182
  if ((unsigned long )point->data == (unsigned long )data) {
#line 182
    if ((unsigned long )point->next != (unsigned long )((struct rr_list *)0)) {
#line 183
      tmp___2 = mhash_undef(hash, copy);
#line 183
      last = (rr_list *)tmp___2;
#line 184
      if ((unsigned long )last != (unsigned long )point) {
#line 185
        harderror((char *)"Line 177; mail the mailing list");
      }
#line 187
      point = point->next;
#line 188
      js_dealloc((void *)last);
#line 189
      mhash_put(hash, copy, (void *)point, 6);
#line 190
      js_destroy(copy);
#line 191
      return (1);
    }
  }
#line 194
  js_destroy(copy);
#line 197
  a = 0;
#line 197
  while (a < 65000) {
#line 198
    if ((unsigned long )point->next == (unsigned long )((struct rr_list *)0)) {
#line 199
      return (-2);
    }
#line 201
    last = point;
#line 202
    point = point->next;
#line 204
    if ((unsigned long )point->data == (unsigned long )data) {
#line 205
      last->next = point->next;
#line 206
      js_dealloc((void *)point);
#line 207
      return (1);
    }
#line 197
    a ++;
  }
#line 211
  return (-1);
}
}
#line 1 "udpsuccess.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-uBGmWHzw.i","")
#line 201 "../dns/functions_dns.h"
js_string *squeeze_to_fit(js_string *packet ) ;
#line 61 "udpsuccess.c"
int udpsuccess(rr *where , int id , int sock , struct sockaddr_in *client , js_string *query ,
               void **rotate_point , int show_cname_a , int rd_val , conn *ect , int force_authoritative ,
               int ra_value ) 
{ js_string *most ;
  js_string *ar ;
  uint16_t first_rr_type ;
  int in_ns ;
  int ns_delegation ;
  int length_save ;
  int len_inet ;
  rr *ipwhere ;
  rr *rotate_1st ;
  rr *rotate_2nd ;
  rr *rotate_last ;
  int a_count ;
  int an_count ;
  fila *zap_point ;
  int seen_ptr_record ;
  rr *top___0 ;
  int is_auth ;
  int compress_error_happened ;
  q_header header ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  uint32_t tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  uint32_t tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  uint32_t tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  uint32_t tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  struct rr_list *any_list ;
  uint16_t this_rr_type ;
  int counter ;
  rr *answer ;
  int counter___0 ;
  int tmp___31 ;
  int tmp___32 ;
  uint32_t tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int x ;
  js_string *tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;

  {
#line 64
  most = (js_string *)0;
#line 65
  ar = (js_string *)0;
#line 68
  in_ns = 0;
#line 69
  ns_delegation = 0;
#line 71
  len_inet = (int )sizeof(struct sockaddr );
#line 72
  ipwhere = (rr *)0;
#line 74
  rotate_1st = (rr *)0;
#line 74
  rotate_2nd = (rr *)0;
#line 74
  rotate_last = (rr *)0;
#line 77
  a_count = 0;
#line 77
  an_count = 0;
#line 80
  seen_ptr_record = 0;
#line 81
  top___0 = where;
#line 82
  is_auth = 0;
#line 83
  compress_error_happened = 0;
#line 88
  total_count = 0;
#line 90
  most = js_create(1024U, 1U);
#line 90
  if ((unsigned long )most == (unsigned long )((js_string *)0)) {
#line 91
    return (-1);
  }
#line 98
  ar = js_create(600U, 1U);
#line 98
  if ((unsigned long )ar == (unsigned long )((js_string *)0)) {
#line 99
    js_destroy(most);
#line 100
    return (-1);
  }
#line 105
  init_header(& header);
#line 106
  header.id = (uint16_t )id;
#line 107
  tmp = make_hdr(& header, most);
#line 107
  if (tmp == -1) {
#line 108
    goto giveerror;
  }
#line 111
  if ((unsigned long )where == (unsigned long )((rr *)0)) {
#line 112
    goto giveerror;
  }
#line 114
  if ((unsigned long )where->query == (unsigned long )((js_string *)0)) {
#line 115
    goto giveerror;
  }
#line 117
  tmp___0 = js_has_sanity(where->query);
#line 117
  if (tmp___0 == -1) {
#line 118
    goto giveerror;
  }
#line 120
  if ((unsigned long )where->data == (unsigned long )((js_string *)0)) {
#line 121
    goto giveerror;
  }
#line 123
  tmp___1 = js_has_sanity(where->data);
#line 123
  if (tmp___1 == -1) {
#line 124
    goto giveerror;
  }
#line 126
  tmp___2 = js_has_sanity(query);
#line 126
  if (tmp___2 == -1) {
#line 127
    goto giveerror;
  }
#line 129
  tmp___3 = get_rtype(query);
#line 129
  first_rr_type = (uint16_t )tmp___3;
#line 132
  ns_delegation = 0;
#line 133
  if ((int )first_rr_type != 2) {
#line 133
    if ((int )where->rr_type == 2) {
#line 134
      ns_delegation = 1;
    }
  }
#line 142
  if (force_authoritative != 1) {
#line 143
    header.aa = (int )where->authoritative;
  } else {
#line 146
    header.aa = 1;
  }
#line 148
  is_auth = (int )where->authoritative;
#line 152
  if ((where->data)->unit_count < 0U) {
#line 153
    goto giveerror;
  } else
#line 152
  if ((where->data)->unit_count > 65535U) {
#line 153
    goto giveerror;
  }
#line 157
  tmp___4 = js_append(query, most);
#line 157
  if (tmp___4 == -1) {
#line 158
    goto giveerror;
  }
#line 162
  tmp___5 = js_adduint16(most, 1);
#line 162
  if (tmp___5 == -1) {
#line 163
    goto giveerror;
  }
#line 167
  header.ancount = (uint16_t )0;
#line 168
  header.nscount = (uint16_t )0;
#line 169
  header.arcount = (uint16_t )0;
#line 172
  rotate_1st = where;
#line 173
  rotate_2nd = where->next;
#line 175
  if ((unsigned long )rotate_2nd != (unsigned long )((rr *)0)) {
#line 175
    if ((int )first_rr_type != 2) {
#line 175
      if ((int )rotate_2nd->rr_type == 2) {
#line 177
        rotate_2nd = (rr *)0;
      }
    }
  }
#line 180
  while ((unsigned long )where != (unsigned long )((rr *)0)) {
#line 182
    if ((int )first_rr_type != 2) {
#line 182
      if ((int )where->rr_type == 2) {
#line 182
        if (in_ns == 0) {
#line 187
          if ((unsigned long )rotate_2nd != (unsigned long )((rr *)0)) {
#line 187
            if (max_ar_chain == 1) {
#line 187
              if ((unsigned long )rotate_last != (unsigned long )((rr *)0)) {
#line 187
                if ((int )first_rr_type != 2) {
#line 195
                  rotate_1st->next = where;
#line 196
                  rotate_last->next = rotate_1st;
#line 197
                  *rotate_point = (void *)rotate_2nd;
#line 198
                  rotate_2nd = (rr *)0;
                }
              }
            }
          }
#line 200
          in_ns = 1;
#line 201
          a_count = 0;
        }
      }
    }
#line 207
    if (a_count < max_chain) {
#line 207
      if (total_count < max_total) {
#line 207
        if (in_ns == 0) {
#line 207
          goto _L___6;
        } else
#line 207
        if (is_auth == 1) {
#line 207
          goto _L___6;
        } else
#line 207
        if (ns_delegation == 1) {
          _L___6: /* CIL Label */ 
#line 209
          a_count ++;
#line 210
          total_count ++;
#line 211
          if (! in_ns) {
#line 212
            header.ancount = (uint16_t )((int )header.ancount + 1);
          } else {
#line 215
            header.nscount = (uint16_t )((int )header.nscount + 1);
          }
#line 218
          tmp___6 = js_append(where->query, most);
#line 218
          if (tmp___6 == -1) {
#line 219
            goto giveerror;
          }
#line 221
          tmp___7 = js_adduint16(most, 1);
#line 221
          if (tmp___7 == -1) {
#line 222
            goto giveerror;
          }
#line 224
          tmp___8 = determine_ttl(where->expire, where->ttl);
#line 224
          tmp___9 = js_adduint32(most, tmp___8);
#line 224
          if (tmp___9 == -1) {
#line 226
            goto giveerror;
          }
#line 228
          tmp___10 = js_adduint16(most, (int )(where->data)->unit_count);
#line 228
          if (tmp___10 == -1) {
#line 229
            goto giveerror;
          }
#line 231
          tmp___11 = js_append(where->data, most);
#line 231
          if (tmp___11 == -1) {
#line 232
            goto giveerror;
          }
#line 235
          if ((unsigned long )where->ip != (unsigned long )((struct rr *)0)) {
#line 235
            if ((int )where->rr_type != 5) {
#line 237
              an_count = 0;
#line 238
              ipwhere = where->ip;
#line 239
              while (1) {
#line 239
                if ((unsigned long )ipwhere != (unsigned long )((rr *)0)) {
#line 239
                  if (! ((int )ipwhere->rr_type != 2)) {
#line 239
                    break;
                  }
                } else {
#line 239
                  break;
                }
#line 241
                if ((int )ipwhere->seen == 1) {
#line 244
                  ipwhere = ipwhere->next;
#line 245
                  continue;
                }
#line 248
                if (an_count >= max_ar_chain) {
#line 249
                  break;
                } else
#line 248
                if (total_count >= max_total) {
#line 249
                  break;
                }
#line 250
                an_count ++;
#line 251
                total_count ++;
#line 253
                header.arcount = (uint16_t )((int )header.arcount + 1);
#line 255
                tmp___12 = js_append(ipwhere->query, ar);
#line 255
                if (tmp___12 == -1) {
#line 256
                  goto giveerror;
                }
#line 258
                tmp___13 = js_adduint16(ar, 1);
#line 258
                if (tmp___13 == -1) {
#line 259
                  goto giveerror;
                }
#line 261
                tmp___14 = determine_ttl(ipwhere->expire, ipwhere->ttl);
#line 261
                tmp___15 = js_adduint32(ar, tmp___14);
#line 261
                if (tmp___15 == -1) {
#line 263
                  goto giveerror;
                }
#line 265
                tmp___16 = js_adduint16(ar, (int )(ipwhere->data)->unit_count);
#line 265
                if (tmp___16 == -1) {
#line 266
                  goto giveerror;
                }
#line 268
                tmp___17 = js_append(ipwhere->data, ar);
#line 268
                if (tmp___17 == -1) {
#line 269
                  goto giveerror;
                }
#line 271
                if (seenlist_where < 250) {
#line 272
                  ipwhere->seen = (char)1;
#line 273
                  seenlist[seenlist_where] = ipwhere;
#line 274
                  seenlist_where ++;
                }
#line 277
                ipwhere = ipwhere->next;
              }
            }
          }
#line 286
          if ((unsigned long )where->ip != (unsigned long )((struct rr *)0)) {
#line 286
            if ((int )where->rr_type == 5) {
#line 286
              if (show_cname_a == 1) {
#line 286
                if ((unsigned long )where->list == (unsigned long )((struct rr_list *)0)) {
#line 289
                  an_count = 0;
#line 290
                  ipwhere = where->ip;
#line 291
                  while (1) {
#line 291
                    if ((unsigned long )ipwhere != (unsigned long )((rr *)0)) {
#line 291
                      if (! ((int )ipwhere->rr_type != 2)) {
#line 291
                        break;
                      }
                    } else {
#line 291
                      break;
                    }
#line 293
                    if ((int )ipwhere->seen == 1) {
#line 296
                      ipwhere = ipwhere->next;
#line 297
                      continue;
                    }
#line 301
                    if ((int )ipwhere->rr_type == 1) {
#line 301
                      if ((ipwhere->data)->unit_count == 4U) {
#line 301
                        if ((int )*((ipwhere->data)->string) == 255) {
#line 301
                          if ((int )*((ipwhere->data)->string + 1) == 255) {
#line 301
                            if ((int )*((ipwhere->data)->string + 2) == 255) {
#line 301
                              if ((int )*((ipwhere->data)->string + 3) == 255) {
#line 307
                                ipwhere = ipwhere->next;
#line 308
                                continue;
                              }
                            }
                          }
                        }
                      }
                    }
#line 311
                    if (an_count >= max_ar_chain) {
#line 312
                      break;
                    } else
#line 311
                    if (total_count >= max_total) {
#line 312
                      break;
                    }
#line 313
                    an_count ++;
#line 314
                    total_count ++;
#line 316
                    header.ancount = (uint16_t )((int )header.ancount + 1);
#line 318
                    tmp___18 = js_append(ipwhere->query, most);
#line 318
                    if (tmp___18 == -1) {
#line 319
                      goto giveerror;
                    }
#line 321
                    tmp___19 = js_adduint16(most, 1);
#line 321
                    if (tmp___19 == -1) {
#line 322
                      goto giveerror;
                    }
#line 324
                    tmp___20 = determine_ttl(ipwhere->expire, ipwhere->ttl);
#line 324
                    tmp___21 = js_adduint32(most, tmp___20);
#line 324
                    if (tmp___21 == -1) {
#line 326
                      goto giveerror;
                    }
#line 328
                    tmp___22 = js_adduint16(most, (int )(ipwhere->data)->unit_count);
#line 328
                    if (tmp___22 == -1) {
#line 330
                      goto giveerror;
                    }
#line 332
                    tmp___23 = js_append(ipwhere->data, most);
#line 332
                    if (tmp___23 == -1) {
#line 333
                      goto giveerror;
                    }
#line 335
                    if (seenlist_where < 250) {
#line 336
                      ipwhere->seen = (char)1;
#line 337
                      seenlist[seenlist_where] = ipwhere;
#line 338
                      seenlist_where ++;
                    }
#line 341
                    ipwhere = ipwhere->next;
                  }
                } else {
#line 286
                  goto _L___5;
                }
              } else {
#line 286
                goto _L___5;
              }
            } else {
#line 286
              goto _L___5;
            }
          } else
          _L___5: /* CIL Label */ 
#line 351
          if ((unsigned long )top___0->ptr != (unsigned long )((js_string *)0)) {
#line 351
            if ((int )top___0->rr_type == 5) {
#line 351
              if (show_cname_a == 12) {
#line 351
                if (seen_ptr_record == 0) {
#line 351
                  if ((unsigned long )where->list == (unsigned long )((struct rr_list *)0)) {
#line 355
                    seen_ptr_record = 1;
#line 357
                    total_count ++;
#line 359
                    header.ancount = (uint16_t )((int )header.ancount + 1);
#line 361
                    tmp___24 = js_append(top___0->data, most);
#line 361
                    if (tmp___24 == -1) {
#line 362
                      goto giveerror;
                    }
#line 364
                    tmp___25 = js_adduint16(most, 12);
#line 364
                    if (tmp___25 == -1) {
#line 365
                      goto giveerror;
                    }
#line 367
                    tmp___26 = js_adduint16(most, 1);
#line 367
                    if (tmp___26 == -1) {
#line 368
                      goto giveerror;
                    }
#line 370
                    tmp___27 = determine_ttl(top___0->expire, top___0->ttl);
#line 370
                    tmp___28 = js_adduint32(most, tmp___27);
#line 370
                    if (tmp___28 == -1) {
#line 372
                      goto giveerror;
                    }
#line 374
                    tmp___29 = js_adduint16(most, (int )(top___0->ptr)->unit_count);
#line 374
                    if (tmp___29 == -1) {
#line 376
                      goto giveerror;
                    }
#line 378
                    tmp___30 = js_append(top___0->ptr, most);
#line 378
                    if (tmp___30 == -1) {
#line 379
                      goto giveerror;
                    }
                  } else {
#line 351
                    goto _L___2;
                  }
                } else {
#line 351
                  goto _L___2;
                }
              } else {
#line 351
                goto _L___2;
              }
            } else {
#line 351
              goto _L___2;
            }
          } else
          _L___2: /* CIL Label */ 
#line 386
          if ((int )where->rr_type == 5) {
#line 386
            if ((unsigned long )where->list != (unsigned long )((struct rr_list *)0)) {
#line 387
              any_list = (struct rr_list *)0;
#line 388
              this_rr_type = (uint16_t )0;
#line 389
              counter = 0;
#line 391
              any_list = where->list;
#line 392
              this_rr_type = first_rr_type;
#line 394
              counter = 0;
#line 394
              while (counter < 1000) {
#line 395
                if ((int )any_list->rr_type == (int )this_rr_type) {
#line 396
                  break;
                }
#line 398
                if ((unsigned long )any_list->next == (unsigned long )((struct rr_list *)0)) {
#line 399
                  break;
                }
#line 401
                any_list = any_list->next;
#line 394
                counter ++;
              }
#line 404
              if ((int )any_list->rr_type == (int )this_rr_type) {
#line 404
                if ((unsigned long )any_list->data != (unsigned long )((rr *)0)) {
#line 406
                  counter___0 = 0;
#line 407
                  answer = any_list->data;
#line 408
                  while (1) {
#line 408
                    if ((unsigned long )answer != (unsigned long )((rr *)0)) {
#line 408
                      if ((int )answer->rr_type == (int )this_rr_type) {
#line 408
                        if (! (counter___0 < 100)) {
#line 408
                          break;
                        }
                      } else {
#line 408
                        break;
                      }
                    } else {
#line 408
                      break;
                    }
#line 413
                    header.ancount = (uint16_t )((int )header.ancount + 1);
#line 416
                    tmp___31 = js_append(answer->query, most);
#line 416
                    if (tmp___31 == -1) {
#line 417
                      goto giveerror;
                    }
#line 419
                    tmp___32 = js_adduint16(most, 1);
#line 419
                    if (tmp___32 == -1) {
#line 420
                      goto giveerror;
                    }
#line 427
                    tmp___33 = determine_ttl(answer->expire, answer->ttl);
#line 427
                    tmp___34 = js_adduint32(most, tmp___33);
#line 427
                    if (tmp___34 == -1) {
#line 429
                      goto giveerror;
                    }
#line 431
                    if ((unsigned long )answer->data == (unsigned long )((js_string *)0)) {
#line 432
                      goto giveerror;
                    }
#line 433
                    if ((answer->data)->unit_count < 0U) {
#line 435
                      goto giveerror;
                    } else
#line 433
                    if ((answer->data)->unit_count > 65535U) {
#line 435
                      goto giveerror;
                    }
#line 436
                    tmp___35 = js_adduint16(most, (int )(answer->data)->unit_count);
#line 436
                    if (tmp___35 == -1) {
#line 438
                      goto giveerror;
                    }
#line 440
                    tmp___36 = js_append(answer->data, most);
#line 440
                    if (tmp___36 == -1) {
#line 441
                      goto giveerror;
                    }
#line 442
                    counter___0 ++;
#line 443
                    answer = answer->next;
                  }
                }
              }
            }
          }
        }
      }
    }
#line 449
    rotate_last = where;
#line 450
    where = where->next;
#line 452
    if ((unsigned long )where == (unsigned long )((rr *)0)) {
#line 452
      if ((unsigned long )rotate_2nd != (unsigned long )((rr *)0)) {
#line 452
        if (max_ar_chain == 1) {
#line 452
          if ((int )first_rr_type != 2) {
#line 457
            if ((unsigned long )rotate_1st->zap != (unsigned long )((fila *)0)) {
#line 458
              zap_point = rotate_1st->zap;
#line 459
              rotate_1st->zap = (fila *)0;
#line 460
              rotate_2nd->zap = zap_point;
#line 461
              zap_point->record = (void *)rotate_2nd;
            }
#line 463
            rotate_1st->next = (struct rr *)0;
#line 464
            rotate_last->next = rotate_1st;
#line 465
            *rotate_point = (void *)rotate_2nd;
#line 466
            rotate_2nd = (rr *)0;
          }
        }
      }
    }
  }
#line 472
  header.qr = 1;
#line 473
  header.opcode = 0;
#line 474
  header.tc = 0;
#line 475
  header.rd = rd_val;
#line 476
  header.ra = calc_ra_value(ra_value);
#line 477
  header.z = 0;
#line 478
  header.rcode = 0;
#line 479
  header.qdcount = (uint16_t )1;
#line 483
  length_save = (int )most->unit_count;
#line 484
  make_hdr(& header, most);
#line 485
  most->unit_count = (unsigned int )length_save;
#line 488
  tmp___37 = js_append(ar, most);
#line 488
  if (tmp___37 == -1) {
#line 489
    goto giveerror;
  }
#line 492
  compress_error_happened = 0;
#line 493
  tmp___38 = compress_data(most, ar);
#line 493
  if (tmp___38 == -1) {
#line 494
    compress_error_happened = 1;
  }
#line 499
  if (ar->unit_count > 512U) {
#line 499
    goto _L___7;
  } else
#line 499
  if (compress_error_happened == 1) {
    _L___7: /* CIL Label */ 
#line 519
    x = 0;
#line 519
    while (x < 20) {
#line 520
      compress_error_happened = 0;
#line 522
      tmp___39 = squeeze_to_fit(most);
#line 522
      if ((unsigned long )tmp___39 == (unsigned long )((js_string *)0)) {
#line 523
        goto giveerror;
      }
#line 525
      if (most->unit_count > 12U) {
#line 526
        tmp___40 = compress_data(most, ar);
#line 526
        if (tmp___40 == -1) {
#line 527
          compress_error_happened = 1;
        }
#line 529
        if (ar->unit_count <= 512U) {
#line 529
          if (compress_error_happened == 0) {
#line 531
            break;
          }
        }
      } else
#line 533
      if (most->unit_count == 12U) {
#line 534
        tmp___41 = js_copy(most, ar);
#line 534
        if (tmp___41 == -1) {
#line 535
          goto giveerror;
        }
      } else {
#line 538
        goto giveerror;
      }
#line 519
      x ++;
    }
  }
#line 547
  if (compress_error_happened == 1) {
#line 548
    goto giveerror;
  }
#line 552
  if ((unsigned long )ect == (unsigned long )((conn *)0)) {
#line 553
    sendto(sock, (void const   *)ar->string, (size_t )ar->unit_count, 0, (struct sockaddr  const  *)((struct sockaddr *)client),
           (socklen_t )len_inet);
  } else {
#line 556
    mara_send(ect, sock, ar);
  }
#line 559
  js_destroy(most);
#line 560
  js_destroy(ar);
#line 563
  while (seenlist_where > 0) {
#line 564
    seenlist_where --;
#line 565
    if ((unsigned long )seenlist[seenlist_where] != (unsigned long )((rr *)0)) {
#line 566
      (seenlist[seenlist_where])->seen = (char)0;
    }
  }
#line 569
  return (1);
  giveerror: 
#line 573
  js_destroy(ar);
#line 574
  udperror(sock, most, client, (js_string *)0, 2, (char *)"giveerror in udpsuccess",
           2, rd_val, ect, 1);
#line 576
  js_destroy(most);
#line 579
  while (seenlist_where > 0) {
#line 580
    seenlist_where --;
#line 581
    if ((unsigned long )seenlist[seenlist_where] != (unsigned long )((rr *)0)) {
#line 582
      (seenlist[seenlist_where])->seen = (char)0;
    }
  }
#line 584
  return (-1);
}
}
#line 1 "JsStr.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-cmEiAY1c.i","")
#line 65 "JsStr.h"
int js_octets(js_string *js ) ;
#line 68
int js_get_encode(js_string *js ) ;
#line 69
int js_set_chsize(js_string *js , int size ) ;
#line 71
int js_destroy_force(js_string *object ) ;
#line 78
int js_match(js_string *exp , js_string *js ) ;
#line 79
int js_match_offset(js_string *exp , js_string *js , int offset ) ;
#line 80
int js_insert(js_string *toinsert , js_string *target , int where ) ;
#line 84
int js_notmatch_offset(js_string *exp , js_string *js , int offset ) ;
#line 85
int js_notmatch(js_string *exp , js_string *js ) ;
#line 87
int js_qprepend(char *toprepend , js_string *target ) ;
#line 88
int js_qfgrep(char *expression , js_string *target ) ;
#line 89
int js_val(js_string *js , int offset ) ;
#line 94
int js_changebyte(js_string *js , unsigned char byte , int offset ) ;
#line 112
int js_substr_append(js_string *source , js_string *dest , int offset , int length ) ;
#line 12 "JsStr.c"
int js_octets(js_string *js ) 
{ 

  {
#line 13
  return ((int )(js->max_count * js->unit_size));
}
}
#line 20 "JsStr.c"
js_string *js_create(unsigned int max_count , unsigned int unit_size ) 
{ js_string *new ;
  void *tmp ;
  unsigned char *tmp___0 ;
  void *tmp___1 ;

  {
#line 23
  tmp = js_alloc(1, (int )sizeof(js_string ));
#line 23
  new = (js_string *)tmp;
#line 23
  if ((unsigned long )new == (unsigned long )((js_string *)0)) {
#line 24
    return ((js_string *)0);
  }
#line 27
  new->unit_size = unit_size;
#line 28
  new->unit_count = 0U;
#line 29
  new->max_count = max_count;
#line 30
  new->is_good = 3124;
#line 31
  new->encoding = 1;
#line 34
  tmp___1 = js_alloc((int )(max_count + 3U), (int )unit_size);
#line 34
  tmp___0 = (unsigned char *)tmp___1;
#line 34
  new->string = tmp___0;
#line 34
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 35
    js_dealloc((void *)new);
#line 36
    return ((js_string *)0);
  }
#line 39
  return (new);
}
}
#line 80 "JsStr.c"
int js_set_encode(js_string *js , int encoding ) 
{ int tmp ;

  {
#line 82
  tmp = js_has_sanity(js);
#line 82
  if (tmp == -1) {
#line 83
    return (-1);
  }
#line 86
  if (encoding < 1) {
#line 87
    return (-1);
  } else
#line 86
  if (encoding > 3) {
#line 87
    return (-1);
  }
#line 89
  js->encoding = encoding;
#line 91
  return (0);
}
}
#line 98 "JsStr.c"
int js_get_encode(js_string *js ) 
{ int tmp ;

  {
#line 100
  tmp = js_has_sanity(js);
#line 100
  if (tmp == -1) {
#line 101
    return (-1);
  }
#line 104
  if (js->encoding < 1) {
#line 105
    return (-1);
  } else
#line 104
  if (js->encoding > 3) {
#line 105
    return (-1);
  }
#line 107
  return (js->encoding);
#line 109
  return (0);
}
}
#line 115 "JsStr.c"
int js_length(js_string *js ) 
{ int tmp ;

  {
#line 117
  tmp = js_has_sanity(js);
#line 117
  if (tmp == -1) {
#line 118
    return (-1);
  }
#line 120
  return ((int )js->unit_count);
}
}
#line 129 "JsStr.c"
int js_set_chsize(js_string *js , int size ) 
{ int tmp ;

  {
#line 131
  tmp = js_has_sanity(js);
#line 131
  if (tmp == -1) {
#line 132
    return (-1);
  }
#line 135
  if (size < 1) {
#line 136
    return (-1);
  }
#line 140
  if (js->unit_count != 0U) {
#line 141
    return (-1);
  }
#line 164
  if ((js->max_count * js->unit_size) % (unsigned int )size != 0U) {
#line 165
    return (-1);
  }
#line 166
  js->max_count *= js->unit_size;
#line 167
  js->max_count /= (unsigned int )size;
#line 170
  js->unit_size = (unsigned int )size;
#line 172
  return (0);
}
}
#line 178 "JsStr.c"
int js_destroy(js_string *object ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 179
  tmp___0 = js_has_sanity(object);
#line 179
  if (tmp___0 != -1) {
#line 180
    tmp = js_destroy_force(object);
#line 180
    return (tmp);
  } else {
#line 182
    return (-1);
  }
}
}
#line 188 "JsStr.c"
int js_destroy_force(js_string *object ) 
{ 

  {
#line 190
  js_dealloc((void *)object->string);
#line 192
  js_dealloc((void *)object);
#line 194
  return (1);
}
}
#line 201 "JsStr.c"
int js_has_sanity(js_string *object ) 
{ 

  {
#line 204
  if ((unsigned long )object == (unsigned long )((js_string *)0)) {
#line 205
    return (-1);
  }
#line 208
  if (object->is_good != 3124) {
#line 209
    return (-1);
  }
#line 212
  if (object->unit_count > object->max_count) {
#line 213
    return (-1);
  }
#line 216
  if (object->encoding == 2) {
#line 216
    if (object->unit_size != 1U) {
#line 217
      return (-1);
    }
  }
#line 219
  return (1);
}
}
#line 226 "JsStr.c"
int js_str2js(js_string *js , char *string , int count , int size ) 
{ int counter ;
  int max ;
  int tmp ;

  {
#line 227
  counter = 0;
#line 229
  max = count;
#line 232
  if ((unsigned int )count > js->max_count) {
#line 233
    return (-1);
  }
#line 236
  tmp = js_has_sanity(js);
#line 236
  if (tmp == -1) {
#line 237
    return (-1);
  }
#line 238
  if ((unsigned int )size != js->unit_size) {
#line 239
    return (-1);
  }
#line 240
  if ((unsigned long )string == (unsigned long )((char *)0)) {
#line 241
    return (-1);
  }
#line 243
  while (counter < max * size) {
#line 244
    *(js->string + counter) = (unsigned char )*(string + counter);
#line 245
    counter ++;
  }
#line 249
  js->unit_count = (unsigned int )count;
#line 251
  return (1);
}
}
#line 258 "JsStr.c"
int js_js2str(js_string *js , char *string , int max ) 
{ int counter ;
  int tmp ;

  {
#line 259
  counter = 0;
#line 262
  tmp = js_has_sanity(js);
#line 262
  if (tmp == -1) {
#line 263
    return (-1);
  }
#line 264
  if (js->unit_size * js->unit_count >= (unsigned int )max) {
#line 265
    return (-1);
  }
#line 267
  while ((unsigned int )counter < js->unit_size * js->unit_count) {
#line 268
    *(string + counter) = (char )*(js->string + counter);
#line 269
    counter ++;
  }
#line 272
  *(string + counter) = (char)0;
#line 274
  return (1);
}
}
#line 280 "JsStr.c"
int js_issame(js_string *js1 , js_string *js2 ) 
{ int counter ;
  int max ;
  int tmp ;
  int tmp___0 ;

  {
#line 281
  counter = 0;
#line 285
  tmp = js_has_sanity(js1);
#line 285
  if (tmp == -1) {
#line 286
    return (-1);
  }
#line 287
  tmp___0 = js_has_sanity(js2);
#line 287
  if (tmp___0 == -1) {
#line 288
    return (-1);
  }
#line 291
  if (js1->unit_size != js2->unit_size) {
#line 292
    return (0);
  }
#line 294
  if (js1->unit_count != js2->unit_count) {
#line 295
    return (0);
  }
#line 301
  max = (int )js1->unit_count;
#line 304
  while ((unsigned int )counter < (unsigned int )max * js1->unit_size) {
#line 305
    if ((int )*(js1->string + counter) != (int )*(js2->string + counter)) {
#line 306
      return (0);
    }
#line 307
    counter ++;
  }
#line 311
  return (1);
}
}
#line 319 "JsStr.c"
int js_fgrep(js_string *exp , js_string *js ) 
{ int tmp ;

  {
#line 320
  tmp = js_fgrep_offset(exp, js, 0);
#line 320
  return (tmp);
}
}
#line 330 "JsStr.c"
int js_fgrep_offset(js_string *exp , js_string *js , int offset ) 
{ int counter ;
  int place ;
  int match ;
  int max ;
  int tmp ;
  int tmp___0 ;

  {
#line 331
  counter = 0;
#line 332
  place = 0;
#line 333
  match = -2;
#line 337
  tmp = js_has_sanity(exp);
#line 337
  if (tmp == -1) {
#line 338
    return (-1);
  }
#line 339
  tmp___0 = js_has_sanity(js);
#line 339
  if (tmp___0 == -1) {
#line 340
    return (-1);
  }
#line 343
  if ((unsigned int )offset > js->unit_count) {
#line 344
    return (-1);
  }
#line 347
  if (offset < 0) {
#line 348
    offset = (int )(js->unit_count + (unsigned int )offset);
  }
#line 351
  if (offset < 0) {
#line 352
    return (-1);
  }
#line 355
  if (exp->unit_size != js->unit_size) {
#line 356
    return (-2);
  }
#line 360
  if (exp->unit_count > js->unit_count) {
#line 361
    return (-2);
  }
#line 364
  if (exp->unit_count <= 0U) {
#line 365
    return (0);
  }
#line 369
  max = (int )(js->unit_count - exp->unit_count);
#line 371
  match = -2;
#line 374
  while (1) {
#line 374
    if ((unsigned int )counter <= (unsigned int )max * js->unit_size) {
#line 374
      if (! (match == -2)) {
#line 374
        break;
      }
    } else {
#line 374
      break;
    }
#line 376
    if ((int )*(exp->string) == (int )*(js->string + counter)) {
#line 376
      if ((unsigned int )counter % js->unit_size == 0U) {
#line 376
        if ((unsigned int )counter >= (unsigned int )offset * js->unit_size) {
#line 379
          match = (int )((unsigned int )counter / js->unit_size);
#line 380
          place = 0;
#line 381
          while (1) {
#line 381
            if ((unsigned int )place < exp->unit_count * exp->unit_size) {
#line 381
              if (! ((unsigned int )(place + counter) < js->unit_count * js->unit_size)) {
#line 381
                break;
              }
            } else {
#line 381
              break;
            }
#line 383
            if ((int )*(exp->string + place) != (int )*((js->string + place) + counter)) {
#line 385
              match = -2;
            }
#line 386
            place ++;
          }
        }
      }
    }
#line 389
    counter ++;
  }
#line 393
  return (match);
}
}
#line 402 "JsStr.c"
int js_match(js_string *exp , js_string *js ) 
{ int tmp ;

  {
#line 403
  tmp = js_match_offset(exp, js, 0);
#line 403
  return (tmp);
}
}
#line 412 "JsStr.c"
int js_match_offset(js_string *exp , js_string *js , int offset ) 
{ int counter ;
  int place ;
  int pexp ;
  int match ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 413
  counter = 0;
#line 414
  place = 0;
#line 415
  pexp = 0;
#line 416
  match = -2;
#line 419
  tmp = js_has_sanity(exp);
#line 419
  if (tmp == -1) {
#line 420
    return (-1);
  }
#line 421
  tmp___0 = js_has_sanity(js);
#line 421
  if (tmp___0 == -1) {
#line 422
    return (-1);
  }
#line 425
  if (offset < 0) {
#line 426
    offset = (int )(js->unit_count + (unsigned int )offset);
  }
#line 429
  if (offset < 0) {
#line 430
    return (-1);
  }
#line 433
  if (exp->unit_size != js->unit_size) {
#line 434
    return (-2);
  }
#line 437
  if (exp->unit_count <= 0U) {
#line 438
    return (-2);
  }
#line 441
  while (1) {
#line 441
    if ((unsigned int )counter < js->unit_count * js->unit_size) {
#line 441
      if (! (match == -2)) {
#line 441
        break;
      }
    } else {
#line 441
      break;
    }
#line 443
    pexp = 0;
#line 447
    while (1) {
#line 447
      if (counter >= offset) {
#line 447
        if ((unsigned int )pexp < exp->unit_count * exp->unit_size) {
#line 447
          if (! (match == -2)) {
#line 447
            break;
          }
        } else {
#line 447
          break;
        }
      } else {
#line 447
        break;
      }
#line 453
      if ((int )*(exp->string + pexp) == (int )*(js->string + counter)) {
#line 453
        if ((unsigned int )pexp % exp->unit_size == 0U) {
#line 453
          tmp___3 = js_octets(exp);
#line 453
          if (pexp < tmp___3) {
#line 456
            match = (int )((unsigned int )counter / exp->unit_size);
#line 457
            place = 1;
#line 460
            while ((unsigned int )place < exp->unit_size) {
#line 463
              if ((int )*((exp->string + pexp) + place) != (int )*((js->string + counter) + place)) {
#line 463
                tmp___1 = js_octets(exp);
#line 463
                if (pexp + place < tmp___1) {
#line 463
                  tmp___2 = js_octets(js);
#line 463
                  if (counter + place < tmp___2) {
#line 468
                    match = -2;
                  }
                }
              }
#line 469
              place ++;
            }
          }
        }
      }
#line 473
      pexp ++;
    }
#line 477
    counter ++;
  }
#line 481
  return (match);
}
}
#line 490 "JsStr.c"
int js_notmatch(js_string *exp , js_string *js ) 
{ int tmp ;

  {
#line 491
  tmp = js_notmatch_offset(exp, js, 0);
#line 491
  return (tmp);
}
}
#line 500 "JsStr.c"
int js_notmatch_offset(js_string *exp , js_string *js , int offset ) 
{ int counter ;
  int place ;
  int pexp ;
  int match ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 501
  counter = 0;
#line 502
  place = 0;
#line 503
  pexp = 0;
#line 504
  match = -2;
#line 507
  tmp = js_has_sanity(exp);
#line 507
  if (tmp == -1) {
#line 508
    return (-1);
  }
#line 509
  tmp___0 = js_has_sanity(js);
#line 509
  if (tmp___0 == -1) {
#line 510
    return (-1);
  }
#line 513
  if (offset < 0) {
#line 514
    offset = (int )(js->unit_count + (unsigned int )offset);
  }
#line 517
  if (offset < 0) {
#line 518
    return (-1);
  }
#line 521
  if (exp->unit_size != js->unit_size) {
#line 522
    return (-2);
  }
#line 525
  if (exp->unit_count <= 0U) {
#line 526
    return (-2);
  }
#line 529
  while (1) {
#line 529
    if ((unsigned int )counter < js->unit_count * js->unit_size) {
#line 529
      if (! (match == -2)) {
#line 529
        break;
      }
    } else {
#line 529
      break;
    }
#line 531
    pexp = 0;
#line 535
    while (1) {
#line 535
      if (counter >= offset) {
#line 535
        if (! ((unsigned int )pexp < exp->unit_count * exp->unit_size)) {
#line 535
          break;
        }
      } else {
#line 535
        break;
      }
#line 536
      if ((unsigned int )pexp % exp->unit_size == 0U) {
#line 537
        match = (int )((unsigned int )counter / exp->unit_size);
      }
#line 542
      if ((int )*(exp->string + pexp) == (int )*(js->string + counter)) {
#line 542
        if ((unsigned int )pexp % exp->unit_size == 0U) {
#line 542
          tmp___3 = js_octets(exp);
#line 542
          if (pexp < tmp___3) {
#line 545
            match = -2;
#line 546
            place = 1;
#line 549
            while ((unsigned int )place < exp->unit_size) {
#line 552
              if ((int )*((exp->string + pexp) + place) != (int )*((js->string + counter) + place)) {
#line 552
                tmp___1 = js_octets(exp);
#line 552
                if (pexp + place < tmp___1) {
#line 552
                  tmp___2 = js_octets(js);
#line 552
                  if (counter + place < tmp___2) {
#line 557
                    match = (int )((unsigned int )counter / exp->unit_size);
                  }
                }
              }
#line 558
              place ++;
            }
#line 560
            if (match == -2) {
#line 561
              break;
            }
          }
        }
      }
#line 564
      pexp ++;
    }
#line 568
    counter ++;
  }
#line 572
  return (match);
}
}
#line 584 "JsStr.c"
int js_insert(js_string *toinsert , js_string *target , int where ) 
{ int place ;
  int counter ;
  char *temp_str ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
#line 585
  place = 0;
#line 590
  tmp = js_has_sanity(toinsert);
#line 590
  if (tmp == -1) {
#line 591
    return (-1);
  }
#line 592
  tmp___0 = js_has_sanity(target);
#line 592
  if (tmp___0 == -1) {
#line 593
    return (-1);
  }
#line 595
  if (toinsert->unit_size != target->unit_size) {
#line 596
    return (-1);
  }
#line 598
  if ((unsigned int )where > target->unit_count) {
#line 599
    return (-1);
  }
#line 602
  if ((unsigned int )where == target->unit_count) {
#line 603
    tmp___1 = js_append(toinsert, target);
#line 603
    return (tmp___1);
  }
#line 607
  if (toinsert->unit_count + target->unit_count > target->max_count) {
#line 608
    return (-1);
  }
#line 611
  tmp___2 = js_alloc((int )target->unit_size, (int )target->unit_count);
#line 611
  temp_str = (char *)tmp___2;
#line 611
  if ((unsigned long )temp_str == (unsigned long )((void *)-1)) {
#line 613
    return (-1);
  }
#line 616
  while ((unsigned int )place < target->unit_size * target->unit_count) {
#line 617
    *(temp_str + place) = (char )*(target->string + place);
#line 618
    place ++;
  }
#line 622
  if (where < 0) {
#line 623
    where = (int )(target->unit_count + (unsigned int )where);
  }
#line 626
  if (where < 0) {
#line 627
    js_dealloc((void *)temp_str);
#line 628
    return (-1);
  }
#line 632
  place = 0;
#line 633
  counter = 0;
#line 634
  while ((unsigned int )place < target->unit_size * target->unit_count) {
#line 636
    if ((unsigned int )place == (unsigned int )where * target->unit_size) {
#line 637
      while ((unsigned int )counter < toinsert->unit_size * toinsert->unit_count) {
#line 639
        if ((unsigned int )(place + counter) < target->unit_size * target->max_count) {
#line 641
          *((target->string + place) + counter) = *(toinsert->string + counter);
        }
#line 643
        counter ++;
      }
    }
#line 646
    if ((unsigned int )(place + counter) < target->unit_size * target->max_count) {
#line 648
      *((target->string + place) + counter) = (unsigned char )*(temp_str + place);
    }
#line 649
    place ++;
  }
#line 653
  target->unit_count += toinsert->unit_count;
#line 656
  js_dealloc((void *)temp_str);
#line 658
  return (0);
}
}
#line 667 "JsStr.c"
int js_append(js_string *toappend , js_string *target ) 
{ int counter ;
  int tmp ;
  int tmp___0 ;

  {
#line 668
  counter = 0;
#line 671
  tmp = js_has_sanity(toappend);
#line 671
  if (tmp == -1) {
#line 672
    return (-1);
  }
#line 673
  tmp___0 = js_has_sanity(target);
#line 673
  if (tmp___0 == -1) {
#line 674
    return (-1);
  }
#line 676
  if (toappend->unit_size != target->unit_size) {
#line 677
    return (-1);
  }
#line 681
  if (toappend->unit_count + target->unit_count >= target->max_count) {
#line 682
    return (-1);
  }
#line 685
  while ((unsigned int )counter < toappend->unit_size * toappend->unit_count) {
#line 686
    *((target->string + target->unit_size * target->unit_count) + counter) = *(toappend->string + counter);
#line 688
    counter ++;
  }
#line 692
  target->unit_count += toappend->unit_count;
#line 694
  return (0);
}
}
#line 702 "JsStr.c"
int js_substr(js_string *source , js_string *dest , int start , int count ) 
{ int counter ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 707
  tmp = js_has_sanity(source);
#line 707
  if (tmp == -1) {
#line 708
    return (-1);
  }
#line 709
  tmp___0 = js_has_sanity(dest);
#line 709
  if (tmp___0 == -1) {
#line 710
    return (-1);
  }
#line 711
  if (source->unit_size != dest->unit_size) {
#line 712
    return (-1);
  }
#line 715
  if (count < 0) {
#line 716
    return (-1);
  }
#line 717
  if ((unsigned int )start >= source->unit_count) {
#line 718
    return (-1);
  } else
#line 717
  if ((unsigned int )start >= source->max_count) {
#line 718
    return (-1);
  }
#line 719
  if ((unsigned int )(start + count) > source->unit_count) {
#line 720
    return (-1);
  }
#line 721
  if ((unsigned int )(start + count) > source->max_count) {
#line 722
    return (-1);
  }
#line 723
  if ((unsigned int )count >= dest->max_count) {
#line 724
    return (-1);
  }
#line 727
  counter = 0;
#line 728
  while (1) {
#line 728
    if ((unsigned int )counter < (unsigned int )count * source->unit_size) {
#line 728
      tmp___1 = js_octets(dest);
#line 728
      if (counter < tmp___1) {
#line 728
        tmp___2 = js_octets(source);
#line 728
        if (! ((unsigned int )counter + (unsigned int )start * source->unit_size < (unsigned int )tmp___2)) {
#line 728
          break;
        }
      } else {
#line 728
        break;
      }
    } else {
#line 728
      break;
    }
#line 730
    *(dest->string + counter) = *((source->string + counter) + (unsigned int )start * source->unit_size);
#line 732
    counter ++;
  }
#line 735
  dest->unit_count = (unsigned int )count;
#line 737
  return (1);
}
}
#line 743 "JsStr.c"
int js_copy(js_string *src , js_string *dest ) 
{ int counter ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 744
  counter = 0;
#line 747
  tmp = js_has_sanity(src);
#line 747
  if (tmp == -1) {
#line 748
    return (-1);
  } else {
#line 747
    tmp___0 = js_has_sanity(dest);
#line 747
    if (tmp___0 == -1) {
#line 748
      return (-1);
    }
  }
#line 750
  if (src->unit_size != dest->unit_size) {
#line 751
    return (-1);
  }
#line 753
  tmp___1 = js_octets(dest);
#line 753
  if (src->unit_size * src->unit_count >= (unsigned int )tmp___1) {
#line 754
    return (-1);
  }
#line 757
  while (1) {
#line 757
    if ((unsigned int )counter < src->unit_size * src->unit_count) {
#line 757
      tmp___2 = js_octets(dest);
#line 757
      if (counter < tmp___2) {
#line 757
        tmp___3 = js_octets(src);
#line 757
        if (! (counter < tmp___3)) {
#line 757
          break;
        }
      } else {
#line 757
        break;
      }
    } else {
#line 757
      break;
    }
#line 759
    *(dest->string + counter) = *(src->string + counter);
#line 760
    counter ++;
  }
#line 764
  dest->unit_count = src->unit_count;
#line 765
  dest->encoding = src->encoding;
#line 767
  return (1);
}
}
#line 777 "JsStr.c"
int js_val(js_string *js , int offset ) 
{ int value___0 ;
  int point ;
  int tmp ;

  {
#line 782
  tmp = js_has_sanity(js);
#line 782
  if (tmp == -1) {
#line 783
    return (-1);
  }
#line 784
  if ((unsigned int )offset >= js->unit_count) {
#line 785
    return (-1);
  }
#line 788
  if ((unsigned long )js->unit_size >= sizeof(int )) {
#line 789
    return (-1);
  }
#line 791
  point = 0;
#line 791
  value___0 = point;
#line 793
  while ((unsigned int )point < js->unit_size) {
#line 794
    value___0 *= 256;
#line 795
    value___0 += (int )*((js->string + (unsigned int )offset * js->unit_size) + point);
#line 796
    point ++;
  }
#line 799
  return (value___0);
}
}
#line 808 "JsStr.c"
int js_qappend(char *toappend , js_string *target ) 
{ js_string *temp ;
  int return_value ;
  int tmp ;
  int tmp___0 ;

  {
#line 810
  temp = (js_string *)0;
#line 814
  tmp = js_has_sanity(target);
#line 814
  if (tmp == -1) {
#line 815
    return (-1);
  }
#line 818
  if ((unsigned long )temp == (unsigned long )((js_string *)0)) {
#line 821
    temp = js_create(1024U, target->unit_size);
#line 821
    if ((unsigned long )temp == (unsigned long )((js_string *)0)) {
#line 822
      return (-1);
    }
  }
#line 824
  tmp___0 = js_qstr2js(temp, toappend);
#line 824
  if (tmp___0 == -1) {
#line 825
    js_destroy(temp);
#line 826
    return (-1);
  }
#line 829
  return_value = js_append(temp, target);
#line 831
  js_destroy(temp);
#line 833
  return (return_value);
}
}
#line 843 "JsStr.c"
int js_qprepend(char *toprepend , js_string *target ) 
{ js_string *temp ;
  int return_value ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 845
  temp = (js_string *)0;
#line 849
  tmp = js_has_sanity(target);
#line 849
  if (tmp == -1) {
#line 850
    return (-1);
  }
#line 853
  if ((unsigned long )temp == (unsigned long )((js_string *)0)) {
#line 857
    temp = js_create(1024U, target->unit_size);
#line 857
    if ((unsigned long )temp == (unsigned long )((js_string *)0)) {
#line 858
      return (-1);
    }
  }
#line 860
  tmp___0 = js_qstr2js(temp, toprepend);
#line 860
  if (tmp___0 == -1) {
#line 861
    js_destroy(temp);
#line 862
    return (-1);
  }
#line 866
  temp->encoding = target->encoding;
#line 868
  tmp___1 = js_append(target, temp);
#line 868
  if (tmp___1 == -1) {
#line 869
    js_destroy(temp);
#line 870
    return (-1);
  }
#line 873
  return_value = js_copy(temp, target);
#line 875
  js_destroy(temp);
#line 877
  return (return_value);
}
}
#line 886 "JsStr.c"
int js_qissame(char *expression , js_string *target ) 
{ js_string *temp ;
  int return_value ;
  int tmp ;
  int tmp___0 ;

  {
#line 888
  temp = (js_string *)0;
#line 892
  tmp = js_has_sanity(target);
#line 892
  if (tmp == -1) {
#line 893
    return (-1);
  }
#line 896
  if ((unsigned long )temp == (unsigned long )((js_string *)0)) {
#line 899
    temp = js_create(1024U, target->unit_size);
#line 899
    if ((unsigned long )temp == (unsigned long )((js_string *)0)) {
#line 900
      return (-1);
    }
  }
#line 902
  tmp___0 = js_qstr2js(temp, expression);
#line 902
  if (tmp___0 == -1) {
#line 903
    js_destroy(temp);
#line 904
    return (-1);
  }
#line 907
  temp->unit_size = target->unit_size;
#line 908
  temp->encoding = target->encoding;
#line 909
  return_value = js_issame(temp, target);
#line 911
  js_destroy(temp);
#line 913
  return (return_value);
}
}
#line 922 "JsStr.c"
int js_qfgrep(char *expression , js_string *target ) 
{ js_string *temp ;
  int return_value ;
  int tmp ;
  int tmp___0 ;

  {
#line 924
  temp = (js_string *)0;
#line 928
  tmp = js_has_sanity(target);
#line 928
  if (tmp == -1) {
#line 929
    return (-1);
  }
#line 932
  if ((unsigned long )temp == (unsigned long )((js_string *)0)) {
#line 935
    temp = js_create(1024U, target->unit_size);
#line 935
    if ((unsigned long )temp == (unsigned long )((js_string *)0)) {
#line 936
      return (-1);
    }
  }
#line 938
  tmp___0 = js_qstr2js(temp, expression);
#line 938
  if (tmp___0 == -1) {
#line 939
    js_destroy(temp);
#line 940
    return (-1);
  }
#line 943
  return_value = js_fgrep(temp, target);
#line 945
  js_destroy(temp);
#line 947
  return (return_value);
}
}
#line 957 "JsStr.c"
int js_addbyte(js_string *js , unsigned char byte ) 
{ int tmp ;

  {
#line 960
  tmp = js_has_sanity(js);
#line 960
  if (tmp == -1) {
#line 961
    return (-1);
  }
#line 962
  if (js->unit_size != 1U) {
#line 963
    return (-1);
  }
#line 965
  if (js->unit_count + 1U >= js->max_count) {
#line 966
    return (-1);
  }
#line 969
  *(js->string + js->unit_count) = byte;
#line 970
  (js->unit_count) ++;
#line 972
  return (1);
}
}
#line 981 "JsStr.c"
int js_changebyte(js_string *js , unsigned char byte , int offset ) 
{ int tmp ;

  {
#line 984
  tmp = js_has_sanity(js);
#line 984
  if (tmp == -1) {
#line 985
    return (-1);
  }
#line 986
  if (js->unit_size != 1U) {
#line 987
    return (-1);
  }
#line 989
  if ((unsigned int )offset >= js->unit_count) {
#line 990
    return (-1);
  }
#line 993
  *(js->string + offset) = byte;
#line 995
  return (1);
}
}
#line 1004 "JsStr.c"
int js_adduint16(js_string *js , int number ) 
{ int tmp ;

  {
#line 1007
  tmp = js_has_sanity(js);
#line 1007
  if (tmp == -1) {
#line 1008
    return (-1);
  }
#line 1009
  if (js->unit_size != 1U) {
#line 1010
    return (-1);
  }
#line 1011
  if (number < 0) {
#line 1012
    return (-1);
  } else
#line 1011
  if (number > 65535) {
#line 1012
    return (-1);
  }
#line 1014
  if (js->unit_count + 2U >= js->max_count) {
#line 1015
    return (-1);
  }
#line 1018
  *(js->string + js->unit_count) = (unsigned char )((number >> 8) & 255);
#line 1019
  *((js->string + js->unit_count) + 1) = (unsigned char )(number & 255);
#line 1020
  js->unit_count += 2U;
#line 1022
  return (1);
}
}
#line 1031 "JsStr.c"
int js_readbyte(js_string *js , unsigned int offset ) 
{ int tmp ;

  {
#line 1034
  tmp = js_has_sanity(js);
#line 1034
  if (tmp == -1) {
#line 1035
    return (-1);
  }
#line 1036
  if (js->unit_size != 1U) {
#line 1037
    return (-1);
  }
#line 1038
  if (offset > js->unit_count - 1U) {
#line 1039
    return (-1);
  } else
#line 1038
  if (offset < 0U) {
#line 1039
    return (-1);
  }
#line 1041
  return ((int )*(js->string + offset));
}
}
#line 1052 "JsStr.c"
int js_readuint16(js_string *js , unsigned int offset ) 
{ int ret ;
  int tmp ;

  {
#line 1056
  tmp = js_has_sanity(js);
#line 1056
  if (tmp == -1) {
#line 1057
    return (-1);
  }
#line 1058
  if (js->unit_size != 1U) {
#line 1059
    return (-1);
  }
#line 1060
  if (offset > js->unit_count - 2U) {
#line 1061
    return (-1);
  } else
#line 1060
  if (offset < 0U) {
#line 1061
    return (-1);
  }
#line 1063
  ret = (((int )*(js->string + offset) << 8) & 65280) | ((int )*((js->string + offset) + 1) & 255);
#line 1066
  return (ret);
}
}
#line 1081 "JsStr.c"
int js_substr_append(js_string *source , js_string *dest , int offset , int length ) 
{ js_string *temp ;
  int tmp ;
  int tmp___0 ;

  {
#line 1085
  temp = js_create((unsigned int )(length + 2), 1U);
#line 1085
  if ((unsigned long )temp == (unsigned long )((js_string *)0)) {
#line 1086
    return (-1);
  }
#line 1089
  if (source->unit_count < (unsigned int )(offset + length)) {
#line 1090
    js_destroy(temp);
#line 1091
    return (-1);
  }
#line 1094
  tmp = js_substr(source, temp, offset, length);
#line 1094
  if (tmp != 1) {
#line 1095
    js_destroy(temp);
#line 1096
    return (-1);
  }
#line 1099
  tmp___0 = js_append(temp, dest);
#line 1099
  if (tmp___0 == -1) {
#line 1100
    js_destroy(temp);
#line 1101
    return (-1);
  }
#line 1104
  js_destroy(temp);
#line 1105
  return (1);
}
}
#line 1 "JsStrOS.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-gt2wMBbw.i","")
#line 160 "/usr/include/stdlib.h"
extern void free(void * ) ;
#line 169
extern void *malloc(size_t  ) ;
#line 164 "/usr/include/stdio.h"
extern FILE *__stdinp ;
#line 241
extern int feof(FILE * ) ;
#line 263
extern int getc(FILE * ) ;
#line 268
extern int putc(int  , FILE * ) ;
#line 92 "/usr/include/string.h"
extern size_t strlen(char const   * ) ;
#line 470 "/usr/include/sys/fcntl.h"
extern int flock(int  , int  ) ;
#line 535 "/usr/include/unistd.h"
extern ssize_t write(int  , void const   * , size_t  )  __asm__("_write")  ;
#line 101 "JsStr.h"
void js_open(js_string *filename , js_file *desc___0 , int flags ) ;
#line 102
int js_open_write(js_string *filename , js_file *desc___0 ) ;
#line 104
int js_read(js_file *desc___0 , js_string *js , int count ) ;
#line 105
int js_write(js_file *desc___0 , js_string *js ) ;
#line 108
int js_buf_read(js_file *desc___0 ) ;
#line 118
int safe_esc_stdout(js_string *js ) ;
#line 121
int js_newline_chars(js_string *js ) ;
#line 57 "JsStrOS.c"
void *js_alloc(int unit_count , int unit_size ) 
{ void *data ;
  void *tmp ;

  {
#line 64
  if (unit_size == 0) {
#line 65
    return ((void *)0);
  } else
#line 64
  if (unit_count == 0) {
#line 65
    return ((void *)0);
  }
#line 66
  tmp = malloc((size_t )(unit_count * unit_size));
#line 66
  data = tmp;
#line 118
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 122
    printf("Aieeeeee, can not allocate memory!");
#line 123
    exit(64);
#line 124
    return ((void *)0);
  }
#line 126
  return (data);
}
}
#line 134 "JsStrOS.c"
void *js_alloc_DEBUG(int unit_count , int unit_size , char *whence ) 
{ void *data ;
  void *tmp ;

  {
#line 141
  tmp = malloc((size_t )(unit_count * unit_size));
#line 141
  data = tmp;
#line 200
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 204
    printf("Aieeeeee, can not allocate memory!");
#line 205
    exit(64);
#line 206
    return ((void *)0);
  }
#line 208
  return (data);
}
}
#line 215 "JsStrOS.c"
int js_dealloc(void *pointer ) 
{ 

  {
#line 220
  if ((unsigned long )pointer == (unsigned long )((void *)0)) {
#line 221
    return (1);
  }
#line 284
  free(pointer);
#line 285
  return (1);
}
}
#line 323 "JsStrOS.c"
int js_tell_memory_allocated(void) 
{ 

  {
#line 327
  return (0);
}
}
#line 335 "JsStrOS.c"
int js_show_stdout(js_string *js ) 
{ int counter ;
  int tmp ;

  {
#line 336
  counter = 0;
#line 338
  tmp = js_has_sanity(js);
#line 338
  if (tmp < 0) {
#line 339
    return (-1);
  }
#line 341
  while ((unsigned int )counter < js->unit_size * js->unit_count) {
#line 342
    putc((int )*(js->string + counter), __stdoutp);
#line 343
    counter ++;
  }
#line 346
  return (1);
}
}
#line 353 "JsStrOS.c"
int show_esc_stdout(js_string *js ) 
{ int counter ;
  unsigned char this ;
  int tmp ;

  {
#line 354
  counter = 0;
#line 357
  tmp = js_has_sanity(js);
#line 357
  if (tmp < 0) {
#line 358
    return (-1);
  }
#line 360
  if (js->unit_size != 1U) {
#line 362
    return (-1);
  }
#line 363
  while ((unsigned int )counter < js->unit_size * js->unit_count) {
#line 364
    this = *(js->string + counter);
#line 365
    if ((int )this < 32) {
#line 366
      printf("\\%03o", (int )this);
    } else
#line 365
    if ((int )this > 126) {
#line 366
      printf("\\%03o", (int )this);
    } else
#line 368
    if ((int )this == 92) {
#line 369
      printf("\\%c", (int )this);
    } else
#line 368
    if ((int )this == 37) {
#line 369
      printf("\\%c", (int )this);
    } else {
#line 372
      putc((int )*(js->string + counter), __stdoutp);
    }
#line 374
    counter ++;
  }
#line 377
  return (1);
}
}
#line 386 "JsStrOS.c"
int safe_esc_stdout(js_string *js ) 
{ int counter ;
  unsigned char this ;
  int tmp ;

  {
#line 387
  counter = 0;
#line 390
  tmp = js_has_sanity(js);
#line 390
  if (tmp < 0) {
#line 391
    return (-1);
  }
#line 393
  if (js->unit_size != 1U) {
#line 395
    return (-1);
  }
#line 396
  while ((unsigned int )counter < js->unit_size * js->unit_count) {
#line 397
    this = *(js->string + counter);
#line 400
    if ((int )this == 32) {
#line 400
      if (counter == 0) {
#line 401
        printf(" ");
      } else {
#line 400
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 403
    if ((int )this >= 65) {
#line 403
      if ((int )this <= 90) {
#line 406
        printf("%c", (int )this);
      } else {
#line 403
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 403
    if ((int )this >= 97) {
#line 403
      if ((int )this <= 122) {
#line 406
        printf("%c", (int )this);
      } else {
#line 403
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 403
    if ((int )this == 45) {
#line 406
      printf("%c", (int )this);
    } else
#line 403
    if ((int )this == 95) {
#line 406
      printf("%c", (int )this);
    } else
#line 403
    if ((int )this > 127) {
#line 406
      printf("%c", (int )this);
    } else
#line 403
    if ((int )this == 46) {
#line 406
      printf("%c", (int )this);
    } else
#line 403
    if ((int )this == 64) {
#line 406
      printf("%c", (int )this);
    } else
#line 403
    if ((int )this >= 48) {
#line 403
      if ((int )this <= 57) {
#line 406
        printf("%c", (int )this);
      } else {
#line 403
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 410
    if ((int )this == 42) {
#line 410
      if (counter == 0) {
#line 410
        if (js->unit_count > 2U) {
#line 410
          if ((int )*(js->string + 1) == 46) {
#line 412
            printf("%c", (int )this);
          } else {
#line 415
            printf("\\x%02x", (int )this);
          }
        } else {
#line 415
          printf("\\x%02x", (int )this);
        }
      } else {
#line 415
        printf("\\x%02x", (int )this);
      }
    } else {
#line 415
      printf("\\x%02x", (int )this);
    }
#line 417
    counter ++;
  }
#line 420
  return (1);
}
}
#line 427 "JsStrOS.c"
int js_getline_stdin(js_string *js ) 
{ char *temp ;
  js_string *newlines ;
  js_string *append ;
  int counter ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 431
  counter = 0;
#line 432
  tmp = js_alloc((int )js->unit_size, 1);
#line 432
  temp = (char *)tmp;
#line 433
  newlines = js_create(256U, js->unit_size);
#line 434
  if ((unsigned long )newlines == (unsigned long )((js_string *)0)) {
#line 435
    return (-1);
  }
#line 436
  newlines->encoding = js->encoding;
#line 437
  append = js_create(256U, js->unit_size);
#line 438
  if ((unsigned long )append == (unsigned long )((js_string *)0)) {
#line 439
    js_destroy(newlines);
#line 440
    js_dealloc((void *)temp);
#line 441
    return (-1);
  }
#line 443
  js_newline_chars(newlines);
#line 444
  tmp___0 = js_has_sanity(js);
#line 444
  if (tmp___0 == -1) {
#line 445
    goto error;
  }
#line 446
  if ((unsigned long )temp == (unsigned long )((char *)0)) {
#line 447
    js_destroy(newlines);
#line 448
    js_destroy(append);
#line 449
    js_dealloc((void *)temp);
#line 450
    return (-1);
  }
#line 453
  js->unit_count = 0U;
#line 454
  while (1) {
#line 454
    tmp___3 = feof(__stdinp);
#line 454
    if (tmp___3) {
#line 454
      break;
    } else {
#line 454
      tmp___4 = js_match(newlines, js);
#line 454
      if (! (tmp___4 == -2)) {
#line 454
        break;
      }
    }
#line 455
    tmp___1 = getc(__stdinp);
#line 455
    *(temp + counter) = (char )tmp___1;
#line 456
    counter ++;
#line 457
    if ((unsigned int )counter >= js->unit_size) {
#line 458
      counter = 0;
#line 459
      js_str2js(append, temp, 1, (int )js->unit_size);
#line 460
      tmp___2 = js_append(append, js);
#line 460
      if (tmp___2 == -1) {
#line 461
        goto error;
      }
    }
  }
#line 466
  js_destroy(append);
#line 467
  js_destroy(newlines);
#line 468
  js_dealloc((void *)temp);
#line 469
  return (1);
  error: 
#line 472
  js_destroy(append);
#line 473
  js_destroy(newlines);
#line 474
  js_dealloc((void *)temp);
#line 475
  return (-1);
}
}
#line 481 "JsStrOS.c"
void js_open(js_string *filename , js_file *desc___0 , int flags ) 
{ char temp[256] ;

  {
#line 486
  if (filename->unit_count * filename->unit_size > 255U) {
#line 487
    desc___0->filetype = -1;
#line 488
    return;
  }
#line 494
  js_js2str(filename, temp, 255);
#line 496
  desc___0->filetype = 1;
#line 497
  desc___0->file_desc = open((char const   *)(temp), flags, 384);
#line 498
  desc___0->number = -1;
#line 499
  desc___0->eof = 0;
#line 500
  desc___0->buffer = (js_string *)0;
#line 502
  if (desc___0->file_desc == -1) {
#line 503
    desc___0->filetype = -1;
#line 504
    return;
  }
#line 507
  return;
}
}
#line 514 "JsStrOS.c"
int js_open_append(js_string *filename , js_file *desc___0 ) 
{ 

  {
#line 515
  js_open(filename, desc___0, 521);
#line 516
  if (desc___0->filetype == -1) {
#line 517
    return (-1);
  } else {
#line 519
    return (1);
  }
}
}
#line 525 "JsStrOS.c"
int js_open_write(js_string *filename , js_file *desc___0 ) 
{ 

  {
#line 526
  js_open(filename, desc___0, 513);
#line 527
  if (desc___0->filetype == -1) {
#line 528
    return (-1);
  } else {
#line 530
    return (1);
  }
}
}
#line 536 "JsStrOS.c"
int js_open_read(js_string *filename , js_file *desc___0 ) 
{ 

  {
#line 537
  js_open(filename, desc___0, 0);
#line 538
  if (desc___0->filetype == -1) {
#line 539
    return (-1);
  } else {
#line 541
    return (1);
  }
}
}
#line 547 "JsStrOS.c"
int js_rewind(js_file *desc___0 ) 
{ off_t tmp ;

  {
#line 549
  if ((unsigned long )desc___0 == (unsigned long )((js_file *)0)) {
#line 550
    return (-1);
  }
#line 551
  if (desc___0->filetype != 1) {
#line 552
    return (-1);
  }
#line 555
  if ((unsigned long )desc___0->buffer != (unsigned long )((js_string *)0)) {
#line 556
    js_destroy(desc___0->buffer);
  }
#line 557
  desc___0->number = -1;
#line 559
  tmp = lseek(desc___0->file_desc, (off_t )0, 0);
#line 559
  if (tmp == -1LL) {
#line 560
    return (-1);
  }
#line 562
  return (1);
}
}
#line 570 "JsStrOS.c"
int js_read(js_file *desc___0 , js_string *js , int count ) 
{ ssize_t value___0 ;
  int ret ;
  int tmp ;

  {
#line 576
  tmp = js_has_sanity(js);
#line 576
  if (tmp == -1) {
#line 577
    return (-1);
  }
#line 578
  if (desc___0->filetype != 1) {
#line 579
    return (-1);
  }
#line 580
  if ((unsigned int )count % js->unit_size != 0U) {
#line 581
    return (-1);
  }
#line 583
  if (count < 0) {
#line 584
    return (-1);
  } else
#line 583
  if (count > 1048576) {
#line 584
    return (-1);
  }
#line 594
  if ((unsigned int )count > js->unit_size * js->max_count) {
#line 595
    return (-1);
  }
#line 597
  value___0 = read(desc___0->file_desc, (void *)js->string, (size_t )count);
#line 599
  if (value___0 == -1L) {
#line 600
    return (-1);
  }
#line 602
  ret = (int )value___0;
#line 604
  if ((unsigned int )ret % js->unit_size != 0U) {
#line 605
    js->unit_count = 0U;
#line 606
    return (-1);
  }
#line 609
  js->unit_count = (unsigned int )ret / js->unit_size;
#line 611
  return (ret);
}
}
#line 618 "JsStrOS.c"
int js_write(js_file *desc___0 , js_string *js ) 
{ ssize_t value___0 ;
  int to_write ;
  int written ;
  int tmp ;

  {
#line 624
  tmp = js_has_sanity(js);
#line 624
  if (tmp == -1) {
#line 625
    return (-1);
  }
#line 626
  if (desc___0->filetype != 1) {
#line 627
    return (-1);
  }
#line 629
  to_write = (int )(js->unit_size * js->unit_count);
#line 631
  if (to_write < 0) {
#line 632
    return (-1);
  } else
#line 631
  if (to_write > 1048576) {
#line 632
    return (-1);
  }
#line 642
  value___0 = write(desc___0->file_desc, (void const   *)js->string, (size_t )to_write);
#line 644
  written = (int )value___0;
#line 646
  if (written != to_write) {
#line 647
    return (-1);
  }
#line 649
  return (1);
}
}
#line 656 "JsStrOS.c"
int js_close(js_file *desc___0 ) 
{ int ret ;

  {
#line 660
  ret = close(desc___0->file_desc);
#line 663
  if ((unsigned long )desc___0->buffer != (unsigned long )((js_string *)0)) {
#line 664
    js_destroy(desc___0->buffer);
  }
#line 665
  desc___0->number = -1;
#line 667
  if (ret == -1) {
#line 668
    return (-1);
  }
#line 671
  desc___0->filetype = -1;
#line 673
  return (1);
}
}
#line 687 "JsStrOS.c"
int js_lock(js_file *desc___0 ) 
{ 

  {
#line 690
  flock(desc___0->file_desc, 2);
#line 692
  return (1);
}
}
#line 699 "JsStrOS.c"
int js_unlock(js_file *desc___0 ) 
{ 

  {
#line 702
  flock(desc___0->file_desc, 8);
#line 704
  return (1);
}
}
#line 713 "JsStrOS.c"
int js_buf_eof(js_file *desc___0 ) 
{ 

  {
#line 714
  if (desc___0->eof) {
#line 714
    if ((unsigned int )desc___0->number >= (desc___0->buffer)->unit_count) {
#line 715
      return (1);
    }
  }
#line 716
  return (0);
}
}
#line 722 "JsStrOS.c"
int js_buf_read(js_file *desc___0 ) 
{ int bytes_read ;
  int tmp ;

  {
#line 726
  tmp = js_has_sanity(desc___0->buffer);
#line 726
  if (tmp == -1) {
#line 727
    return (-1);
  }
#line 728
  bytes_read = js_read(desc___0, desc___0->buffer, (int )(1024U * (desc___0->buffer)->unit_size));
#line 730
  if ((unsigned int )bytes_read != 1024U * (desc___0->buffer)->unit_size) {
#line 731
    desc___0->eof = 1;
  }
#line 732
  desc___0->number = 0;
#line 734
  return (1);
}
}
#line 744 "JsStrOS.c"
int js_buf_getline(js_file *desc___0 , js_string *js ) 
{ js_string *newlines ;
  js_string *temp ;
  int next_newln ;
  int overflowed ;
  int tmp ;
  int tmp___0 ;

  {
#line 747
  overflowed = 0;
#line 750
  tmp = js_has_sanity(js);
#line 750
  if (tmp == -1) {
#line 751
    return (-1);
  }
#line 755
  if (desc___0->number == -1) {
#line 756
    if ((unsigned long )desc___0->buffer == (unsigned long )((js_string *)0)) {
#line 757
      desc___0->buffer = js_create(1034U, js->unit_size);
    }
#line 758
    js_buf_read(desc___0);
  }
#line 762
  if (js->unit_size != (desc___0->buffer)->unit_size) {
#line 763
    return (-1);
  }
#line 767
  newlines = js_create(js->max_count, js->unit_size);
#line 768
  js_copy(js, newlines);
#line 769
  js_newline_chars(newlines);
#line 772
  next_newln = js_match_offset(newlines, desc___0->buffer, desc___0->number);
#line 775
  if (next_newln == -2) {
#line 775
    if (desc___0->eof == 0) {
#line 779
      if ((unsigned int )(1025 - desc___0->number) < js->max_count) {
#line 779
        if (overflowed == 0) {
#line 780
          js_substr(desc___0->buffer, js, desc___0->number, 1024 - desc___0->number);
        } else {
#line 783
          js_str2js(js, (char *)"", 0, (int )js->unit_size);
#line 784
          overflowed = 1;
        }
      } else {
#line 783
        js_str2js(js, (char *)"", 0, (int )js->unit_size);
#line 784
        overflowed = 1;
      }
#line 787
      js_buf_read(desc___0);
#line 790
      while (1) {
#line 790
        tmp___0 = js_match(newlines, desc___0->buffer);
#line 790
        if (tmp___0 == -2) {
#line 790
          if (! (desc___0->eof == 0)) {
#line 790
            break;
          }
        } else {
#line 790
          break;
        }
#line 791
        if (js->unit_count + 1024U < js->max_count) {
#line 791
          if (overflowed == 0) {
#line 792
            js_append(desc___0->buffer, js);
          } else {
#line 794
            js_str2js(js, (char *)"", 0, (int )js->unit_size);
#line 795
            overflowed = 1;
          }
        } else {
#line 794
          js_str2js(js, (char *)"", 0, (int )js->unit_size);
#line 795
          overflowed = 1;
        }
#line 797
        js_buf_read(desc___0);
      }
#line 799
      next_newln = js_match(newlines, desc___0->buffer);
#line 800
      temp = js_create(js->max_count, js->unit_size);
#line 801
      js_substr(desc___0->buffer, temp, 0, next_newln + 1);
#line 802
      js_append(temp, js);
#line 803
      js_destroy(temp);
#line 804
      if (next_newln != -2) {
#line 805
        desc___0->number = next_newln + 1;
      }
#line 806
      if (desc___0->number >= 1024) {
#line 807
        js_buf_read(desc___0);
      }
#line 808
      js_destroy(newlines);
#line 809
      if (overflowed == 1) {
#line 810
        return (-2);
      }
#line 811
      return (1);
    } else {
#line 775
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 813
  if (next_newln == -2) {
#line 816
    if ((desc___0->buffer)->unit_count - (unsigned int )desc___0->number < js->max_count) {
#line 816
      if (overflowed == 0) {
#line 818
        js_substr(desc___0->buffer, js, desc___0->number, (int )((desc___0->buffer)->unit_count - (unsigned int )desc___0->number));
      } else {
#line 821
        js_str2js(js, (char *)"", 0, (int )js->unit_size);
#line 822
        overflowed = 1;
      }
    } else {
#line 821
      js_str2js(js, (char *)"", 0, (int )js->unit_size);
#line 822
      overflowed = 1;
    }
#line 826
    desc___0->number = (int )((desc___0->buffer)->unit_count + 1U);
#line 828
    js_destroy(newlines);
#line 829
    if (overflowed == 1) {
#line 830
      return (-2);
    }
#line 831
    return (1);
  }
#line 835
  if ((unsigned int )((next_newln + 1) - desc___0->number) < js->max_count) {
#line 836
    js_substr(desc___0->buffer, js, desc___0->number, (next_newln + 1) - desc___0->number);
#line 837
    desc___0->number = next_newln + 1;
#line 838
    if (desc___0->number >= 1024) {
#line 839
      js_buf_read(desc___0);
    }
  } else {
#line 842
    js_str2js(js, (char *)"", 0, (int )js->unit_size);
  }
#line 844
  js_destroy(newlines);
#line 846
  if (overflowed == 1) {
#line 847
    return (-2);
  }
#line 849
  return (1);
}
}
#line 857 "JsStrOS.c"
int js_qstr2js(js_string *js , char *string ) 
{ size_t tmp ;
  int tmp___0 ;

  {
#line 858
  if ((unsigned long )js == (unsigned long )((js_string *)0)) {
#line 859
    return (-1);
  }
#line 861
  tmp = strlen((char const   *)string);
#line 861
  tmp___0 = js_str2js(js, string, (int )tmp, (int )js->unit_size);
#line 861
  return (tmp___0);
}
}
#line 871 "JsStrOS.c"
int js_adduint32(js_string *js , uint32_t number ) 
{ int tmp ;

  {
#line 874
  tmp = js_has_sanity(js);
#line 874
  if (tmp == -1) {
#line 875
    return (-1);
  }
#line 876
  if (js->unit_size != 1U) {
#line 877
    return (-1);
  }
#line 879
  if (js->unit_count + 4U >= js->max_count) {
#line 880
    return (-1);
  }
#line 883
  *(js->string + js->unit_count) = (unsigned char )((number >> 24) & 255U);
#line 884
  *((js->string + js->unit_count) + 1) = (unsigned char )((number >> 16) & 255U);
#line 885
  *((js->string + js->unit_count) + 2) = (unsigned char )((number >> 8) & 255U);
#line 886
  *((js->string + js->unit_count) + 3) = (unsigned char )(number & 255U);
#line 887
  js->unit_count += 4U;
#line 889
  return (1);
}
}
#line 901 "JsStrOS.c"
uint32_t js_readuint32(js_string *js , unsigned int offset ) 
{ uint32_t ret ;
  int tmp ;

  {
#line 905
  tmp = js_has_sanity(js);
#line 905
  if (tmp == -1) {
#line 906
    return (4294967295U);
  }
#line 907
  if (js->unit_size != 1U) {
#line 908
    return (4294967295U);
  }
#line 909
  if (offset > js->unit_count - 4U) {
#line 910
    return (4294967295U);
  } else
#line 909
  if (offset < 0U) {
#line 910
    return (4294967295U);
  }
#line 912
  ret = ((((unsigned int )((int )*(js->string + offset) << 24) & 4278190080U) | (unsigned int )(((int )*((js->string + offset) + 1) << 16) & 16711680)) | (unsigned int )(((int )*((js->string + offset) + 2) << 8) & 65280)) | (unsigned int )((int )*((js->string + offset) + 3) & 255);
#line 918
  if (ret == 4294967295U) {
#line 919
    ret = 4294967294U;
  }
#line 921
  return (ret);
}
}
#line 929 "JsStrOS.c"
int js_strnlen(char *s , uint32_t limit ) 
{ uint32_t len ;
  char *tmp ;

  {
#line 931
  if (limit > 2147483600U) {
#line 932
    return (-1);
  } else
#line 931
  if (limit < 0U) {
#line 932
    return (-1);
  }
#line 934
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 935
    return (-1);
  }
#line 937
  len = (uint32_t )0;
#line 938
  while (1) {
#line 938
    if (len < limit) {
#line 938
      tmp = s;
#line 938
      s ++;
#line 938
      if (! *tmp) {
#line 938
        break;
      }
    } else {
#line 938
      break;
    }
#line 939
    len ++;
  }
#line 941
  return ((int )len);
}
}
#line 1 "JsStrCP.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-6c9w5MTV.i","")
#line 124 "JsStr.h"
int js_space_chars(js_string *js ) ;
#line 125
js_string *js_an_chars(js_string *js ) ;
#line 126
js_string *js_numbers(js_string *js ) ;
#line 12 "JsStrCP.c"
int js_newline_chars(js_string *js ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 15
  tmp = js_has_sanity(js);
#line 15
  if (tmp == -1) {
#line 16
    return (-1);
  }
#line 19
  switch (js->encoding) {
  case 1: 
#line 21
  js->unit_count = 0U;
#line 22
  return (1);
  case 2: 
  case 3: 
#line 25
  if (js->unit_size != 1U) {
#line 26
    return (-1);
  }
#line 27
  tmp___0 = js_octets(js);
#line 27
  if (tmp___0 < 2) {
#line 28
    return (-1);
  }
#line 29
  *(js->string) = (unsigned char )'\r';
#line 30
  *(js->string + 1) = (unsigned char )'\n';
#line 31
  js->unit_count = 2U;
#line 32
  return (1);
  }
#line 36
  return (-1);
}
}
#line 45 "JsStrCP.c"
int js_space_chars(js_string *js ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 48
  tmp = js_has_sanity(js);
#line 48
  if (tmp == -1) {
#line 49
    return (-1);
  }
#line 52
  switch (js->encoding) {
  case 1: 
#line 54
  js->unit_count = 0U;
#line 55
  return (1);
  case 2: 
  case 3: 
#line 58
  if (js->unit_size != 1U) {
#line 59
    return (-1);
  }
#line 60
  tmp___0 = js_octets(js);
#line 60
  if (tmp___0 < 3) {
#line 61
    return (-1);
  }
#line 62
  *(js->string) = (unsigned char )' ';
#line 63
  *(js->string + 1) = (unsigned char )'\t';
#line 64
  if (js->encoding != 2) {
#line 65
    *(js->string + 2) = (unsigned char)160;
#line 66
    js->unit_count = 3U;
  } else {
#line 69
    js->unit_count = 2U;
  }
#line 70
  return (1);
  }
#line 74
  return (-1);
}
}
#line 81 "JsStrCP.c"
unsigned int js_atoi(js_string *js , int offset ) 
{ int value___0 ;
  int sign ;
  int tmp ;

  {
#line 85
  tmp = js_has_sanity(js);
#line 85
  if (tmp == -1) {
#line 86
    return (0U);
  }
#line 89
  if (js->encoding != 2) {
#line 89
    if (js->encoding != 3) {
#line 90
      return (0U);
    } else {
#line 89
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 93
    if ((unsigned int )offset >= js->unit_count) {
#line 94
      return (0U);
    }
#line 95
    value___0 = 0;
#line 96
    sign = 1;
#line 97
    while (1) {
#line 97
      if ((unsigned int )offset < js->unit_count) {
#line 97
        if ((int )*(js->string + offset) >= 48) {
#line 97
          if (! ((int )*(js->string + offset) <= 57)) {
#line 97
            break;
          }
        } else {
#line 97
          break;
        }
      } else {
#line 97
        break;
      }
#line 99
      value___0 *= 10;
#line 100
      value___0 += (int )*(js->string + offset) - 48;
#line 101
      offset ++;
    }
#line 103
    value___0 *= sign;
#line 104
    return ((unsigned int )value___0);
  }
#line 107
  return (0U);
}
}
#line 113 "JsStrCP.c"
int js_tolower(js_string *js ) 
{ int counter ;
  int tmp ;

  {
#line 116
  tmp = js_has_sanity(js);
#line 116
  if (tmp == -1) {
#line 117
    return (-1);
  }
#line 119
  if (js->unit_size != 1U) {
#line 121
    return (-1);
  }
#line 123
  if (js->encoding == 2) {
#line 124
    counter = 0;
#line 124
    while ((unsigned int )counter < js->unit_count) {
#line 125
      if ((int )*(js->string + counter) >= 65) {
#line 125
        if ((int )*(js->string + counter) <= 90) {
#line 127
          *(js->string + counter) = (unsigned char )((int )*(js->string + counter) + 32);
        }
      }
#line 124
      counter ++;
    }
  } else
#line 129
  if (js->encoding == 3) {
#line 130
    counter = 0;
#line 130
    while ((unsigned int )counter < js->unit_count) {
#line 131
      if ((int )*(js->string + counter) >= 65) {
#line 131
        if ((int )*(js->string + counter) <= 90) {
#line 133
          *(js->string + counter) = (unsigned char )((int )*(js->string + counter) + 32);
        }
      }
#line 134
      if ((int )*(js->string + counter) >= 192) {
#line 134
        if ((int )*(js->string + counter) <= 214) {
#line 136
          *(js->string + counter) = (unsigned char )((int )*(js->string + counter) + 32);
        }
      }
#line 139
      if ((int )*(js->string + counter) >= 216) {
#line 139
        if ((int )*(js->string + counter) <= 222) {
#line 141
          *(js->string + counter) = (unsigned char )((int )*(js->string + counter) + 32);
        }
      }
#line 130
      counter ++;
    }
  } else {
#line 146
    return (0);
  }
#line 148
  return (1);
}
}
#line 159 "JsStrCP.c"
js_string *js_anq_chars(js_string *js , int do_nums ) 
{ int place ;
  int do_lets ;
  unsigned char counter ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 160
  place = 0;
#line 160
  do_lets = 1;
#line 164
  tmp = js_has_sanity(js);
#line 164
  if (tmp == -1) {
#line 165
    return ((js_string *)0);
  }
#line 168
  if (do_nums == 2) {
#line 169
    do_lets = 0;
  }
#line 172
  switch (js->encoding) {
  case 3: 
#line 174
  tmp___0 = js_octets(js);
#line 174
  if (tmp___0 < 192) {
#line 175
    return ((js_string *)0);
  }
#line 176
  if (do_lets == 1) {
#line 178
    counter = (unsigned char)192;
#line 178
    while ((int )counter <= 214) {
#line 179
      *(js->string + place) = counter;
#line 180
      place ++;
#line 178
      counter = (unsigned char )((int )counter + 1);
    }
#line 183
    counter = (unsigned char)216;
#line 183
    while ((int )counter <= 246) {
#line 184
      *(js->string + place) = counter;
#line 185
      place ++;
#line 183
      counter = (unsigned char )((int )counter + 1);
    }
#line 188
    counter = (unsigned char)248;
#line 188
    while ((int )counter < 255) {
#line 189
      *(js->string + place) = counter;
#line 190
      place ++;
#line 188
      counter = (unsigned char )((int )counter + 1);
    }
#line 193
    *(js->string + place) = (unsigned char)255;
#line 194
    place ++;
  }
  case 2: 
#line 197
  tmp___1 = js_octets(js);
#line 197
  if (tmp___1 < 96) {
#line 198
    return ((js_string *)0);
  }
#line 199
  if (do_lets == 1) {
#line 201
    counter = (unsigned char )'A';
#line 201
    while ((int )counter <= 90) {
#line 202
      *(js->string + place) = counter;
#line 203
      place ++;
#line 201
      counter = (unsigned char )((int )counter + 1);
    }
#line 206
    counter = (unsigned char )'a';
#line 206
    while ((int )counter <= 122) {
#line 207
      *(js->string + place) = counter;
#line 208
      place ++;
#line 206
      counter = (unsigned char )((int )counter + 1);
    }
  }
#line 211
  if (do_nums == 1) {
#line 211
    goto _L;
  } else
#line 211
  if (do_nums == 2) {
    _L: /* CIL Label */ 
#line 213
    counter = (unsigned char )'0';
#line 213
    while ((int )counter <= 57) {
#line 214
      *(js->string + place) = counter;
#line 215
      place ++;
#line 213
      counter = (unsigned char )((int )counter + 1);
    }
#line 218
    if (do_nums != 2) {
#line 219
      *(js->string + place) = (unsigned char )'_';
#line 220
      place ++;
    }
  }
#line 223
  js->unit_count = (unsigned int )place;
#line 224
  break;
  default: 
#line 226
  return ((js_string *)0);
  }
#line 229
  return (js);
}
}
#line 239 "JsStrCP.c"
js_string *js_alpha_chars(js_string *js ) 
{ js_string *tmp ;

  {
#line 240
  tmp = js_anq_chars(js, 0);
#line 240
  return (tmp);
}
}
#line 249 "JsStrCP.c"
js_string *js_an_chars(js_string *js ) 
{ js_string *tmp ;

  {
#line 250
  tmp = js_anq_chars(js, 1);
#line 250
  return (tmp);
}
}
#line 259 "JsStrCP.c"
js_string *js_numbers(js_string *js ) 
{ js_string *tmp ;

  {
#line 260
  tmp = js_anq_chars(js, 2);
#line 260
  return (tmp);
}
}
#line 1 "MaraHash.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-VU6Jvmcg.i","")
#line 59 "MaraHash.h"
unsigned int mhash_js(js_string *tohash , int hash_bits ) ;
#line 63
int mhash_put_js(mhash *hash , js_string *key___0 , js_string *value___0 ) ;
#line 69
mara_tuple *mtuple_new(int elements ) ;
#line 70
int mtuple_put(mara_tuple *tuple , js_string *js , int element ) ;
#line 71
js_string *mtuple_get(mara_tuple *tuple , int element ) ;
#line 5 "functions_MaraHash.h"
int mhash_undef_js(mhash *hash , js_string *key___0 ) ;
#line 13
int mhash_resize(mhash *hash , int new_bits ) ;
#line 38 "MaraHash.c"
unsigned int mhash_mask[31]  = 
#line 38 "MaraHash.c"
  {      1U,      1U,      3U,      7U, 
        15U,      31U,      63U,      127U, 
        255U,      511U,      1023U,      2047U, 
        4095U,      8191U,      16383U,      32767U, 
        65535U,      131071U,      262143U,      524287U, 
        1048575U,      2097151U,      4194303U,      8388607U, 
        16777215U,      33554431U,      67108863U,      134217727U, 
        268435455U,      536870911U,      1073741823U};
#line 50 "MaraHash.c"
mhash *mhash_create(int hash_bits ) 
{ mhash *new ;
  int counter ;
  void *tmp ;
  mhash_spot **tmp___0 ;
  void *tmp___1 ;

  {
#line 55
  tmp = js_alloc(1, (int )sizeof(mhash ));
#line 55
  new = (mhash *)tmp;
#line 55
  if ((unsigned long )new == (unsigned long )((mhash *)0)) {
#line 56
    return ((mhash *)0);
  }
#line 58
  new->hash_bits = hash_bits;
#line 62
  tmp___1 = js_alloc((int )(mhash_mask[hash_bits] + 1U), (int )sizeof(mhash_spot *));
#line 62
  tmp___0 = (mhash_spot **)tmp___1;
#line 62
  new->hash_table = tmp___0;
#line 62
  if ((unsigned long )tmp___0 == (unsigned long )((mhash_spot **)0)) {
#line 64
    js_dealloc((void *)new);
#line 65
    return ((mhash *)0);
  }
#line 69
  counter = 0;
#line 69
  while ((unsigned int )counter <= mhash_mask[hash_bits]) {
#line 70
    *(new->hash_table + counter) = (mhash_spot *)0;
#line 69
    counter ++;
  }
#line 73
  new->spots = 0U;
#line 76
  return (new);
}
}
#line 86 "MaraHash.c"
unsigned int mhash_js(js_string *tohash , int hash_bits ) 
{ unsigned int ret ;
  unsigned char *point ;
  unsigned char *max ;
  int shift ;
  int tmp ;
  int tmp___0 ;

  {
#line 88
  ret = 0U;
#line 91
  shift = 0;
#line 93
  tmp = js_has_sanity(tohash);
#line 93
  if (tmp == -1) {
#line 94
    return (0U);
  }
#line 95
  point = tohash->string;
#line 96
  max = point + tohash->unit_count * tohash->unit_size;
#line 97
  tmp___0 = js_octets(tohash);
#line 97
  if ((unsigned long )max > (unsigned long )(point + tmp___0)) {
#line 98
    return (0U);
  }
#line 101
  while ((unsigned long )point < (unsigned long )max) {
#line 102
    ret += (unsigned int )((int )*point << shift);
#line 103
    shift += 7;
#line 104
    shift %= hash_bits;
#line 105
    point ++;
  }
#line 109
  ret ^= ret >> 7;
#line 112
  ret &= mhash_mask[hash_bits];
#line 115
  if (ret == 0U) {
#line 116
    ret ++;
  }
#line 118
  return (ret);
}
}
#line 128 "MaraHash.c"
int mhash_put(mhash *hash , js_string *key___0 , void *value___0 , int datatype ) 
{ unsigned int first_found ;
  js_string *new_key ;
  mhash_spot *point ;
  mhash_spot *new ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 136
  tmp = js_has_sanity(key___0);
#line 136
  if (tmp == -1) {
#line 137
    return (-1);
  }
#line 140
  first_found = mhash_js(key___0, hash->hash_bits);
#line 141
  if (first_found == 0U) {
#line 142
    return (-1);
  }
#line 146
  new_key = js_create(key___0->unit_count + 1U, key___0->unit_size);
#line 146
  if ((unsigned long )new_key == (unsigned long )((js_string *)0)) {
#line 147
    js_dealloc((void *)*(hash->hash_table + first_found));
#line 148
    return (-1);
  }
#line 150
  tmp___0 = js_copy(key___0, new_key);
#line 150
  if (tmp___0 == -1) {
#line 151
    js_dealloc((void *)*(hash->hash_table + first_found));
#line 152
    js_destroy(new_key);
#line 153
    return (-1);
  }
#line 157
  tmp___1 = js_alloc(1, (int )sizeof(mhash_spot ));
#line 157
  new = (mhash_spot *)tmp___1;
#line 157
  if ((unsigned long )new == (unsigned long )((mhash_spot *)0)) {
#line 158
    return (-1);
  }
#line 161
  new->key = new_key;
#line 162
  new->value = value___0;
#line 163
  new->datatype = datatype;
#line 164
  new->next = (struct mhash_spot *)0;
#line 167
  point = *(hash->hash_table + first_found);
#line 169
  if ((unsigned long )point == (unsigned long )((mhash_spot *)0)) {
#line 170
    *(hash->hash_table + first_found) = new;
  } else {
#line 175
    tmp___2 = js_issame(point->key, new_key);
#line 175
    if (tmp___2) {
#line 176
      goto cleanup;
    }
#line 177
    while ((unsigned long )point->next != (unsigned long )((struct mhash_spot *)0)) {
#line 179
      tmp___3 = js_issame(point->key, new_key);
#line 179
      if (tmp___3) {
#line 180
        goto cleanup;
      }
#line 181
      point = point->next;
    }
#line 184
    tmp___4 = js_issame(point->key, new_key);
#line 184
    if (tmp___4) {
#line 185
      goto cleanup;
    }
#line 186
    point->next = new;
  }
#line 190
  (hash->spots) ++;
#line 192
  return (1);
  cleanup: 
#line 195
  js_destroy(new_key);
#line 196
  js_dealloc((void *)new);
#line 197
  return (-1);
}
}
#line 207 "MaraHash.c"
mhash_e mhash_get(mhash *hash , js_string *key___0 ) 
{ unsigned int first_found ;
  mhash_spot *point ;
  mhash_e ret ;
  int tmp ;
  int tmp___0 ;

  {
#line 213
  ret.point = (void **)0;
#line 214
  ret.value = (void *)0;
#line 215
  ret.datatype = -1;
#line 218
  tmp = js_has_sanity(key___0);
#line 218
  if (tmp == -1) {
#line 219
    return (ret);
  }
#line 222
  first_found = mhash_js(key___0, hash->hash_bits);
#line 225
  if ((unsigned long )*(hash->hash_table + first_found) == (unsigned long )((mhash_spot *)0)) {
#line 226
    ret.value = (void *)0;
#line 227
    ret.datatype = 0;
#line 228
    ret.point = (void **)0;
#line 229
    return (ret);
  }
#line 232
  point = *(hash->hash_table + first_found);
#line 235
  while (1) {
#line 235
    tmp___0 = js_issame(key___0, point->key);
#line 235
    if (tmp___0) {
#line 235
      break;
    }
#line 237
    if ((unsigned long )point->next == (unsigned long )((struct mhash_spot *)0)) {
#line 238
      ret.value = (void *)0;
#line 239
      ret.datatype = 0;
#line 240
      ret.point = (void **)0;
#line 241
      return (ret);
    }
#line 243
    point = point->next;
  }
#line 247
  ret.point = & point->value;
#line 248
  ret.value = point->value;
#line 249
  ret.datatype = point->datatype;
#line 251
  return (ret);
}
}
#line 261 "MaraHash.c"
js_string *mhash_get_immutable_key(mhash *hash , js_string *key___0 ) 
{ unsigned int first_found ;
  mhash_spot *point ;
  int tmp ;
  int tmp___0 ;

  {
#line 267
  tmp = js_has_sanity(key___0);
#line 267
  if (tmp == -1) {
#line 268
    return ((js_string *)0);
  }
#line 271
  first_found = mhash_js(key___0, hash->hash_bits);
#line 274
  if ((unsigned long )*(hash->hash_table + first_found) == (unsigned long )((mhash_spot *)0)) {
#line 275
    return ((js_string *)0);
  }
#line 277
  point = *(hash->hash_table + first_found);
#line 280
  while (1) {
#line 280
    tmp___0 = js_issame(key___0, point->key);
#line 280
    if (tmp___0) {
#line 280
      break;
    }
#line 282
    if ((unsigned long )point->next == (unsigned long )((struct mhash_spot *)0)) {
#line 283
      return ((js_string *)0);
    }
#line 284
    point = point->next;
  }
#line 289
  return (point->key);
}
}
#line 298 "MaraHash.c"
void *mhash_undef(mhash *hash , js_string *key___0 ) 
{ unsigned int first_found ;
  mhash_spot *point ;
  mhash_spot *last ;
  void *ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 304
  first_found = mhash_js(key___0, hash->hash_bits);
#line 305
  if (first_found == 0U) {
#line 306
    return ((void *)0);
  }
#line 310
  if ((unsigned long )*(hash->hash_table + first_found) == (unsigned long )((mhash_spot *)0)) {
#line 311
    return ((void *)0);
  }
#line 314
  point = *(hash->hash_table + first_found);
#line 315
  last = (mhash_spot *)0;
#line 318
  while ((unsigned long )point != (unsigned long )((mhash_spot *)0)) {
#line 320
    tmp = js_issame(key___0, point->key);
#line 320
    if (tmp) {
#line 321
      break;
    }
#line 322
    last = point;
#line 323
    point = point->next;
  }
#line 327
  if ((unsigned long )point == (unsigned long )((mhash_spot *)0)) {
#line 328
    return ((void *)0);
  }
#line 331
  if ((unsigned long )last == (unsigned long )((mhash_spot *)0)) {
#line 332
    *(hash->hash_table + first_found) = point->next;
  } else {
#line 334
    last->next = point->next;
  }
#line 337
  (hash->spots) --;
#line 340
  tmp___0 = js_destroy(point->key);
#line 340
  if (tmp___0 == -1) {
#line 341
    return ((void *)0);
  }
#line 345
  ret = point->value;
#line 348
  tmp___1 = js_dealloc((void *)point);
#line 348
  if (tmp___1 == -1) {
#line 349
    return ((void *)0);
  }
#line 354
  return (ret);
}
}
#line 362 "MaraHash.c"
int mhash_put_js(mhash *hash , js_string *key___0 , js_string *value___0 ) 
{ js_string *new ;
  int ret ;
  int tmp ;

  {
#line 371
  new = js_create(value___0->unit_count + 1U, value___0->unit_size);
#line 371
  if ((unsigned long )new == (unsigned long )((js_string *)0)) {
#line 372
    return (-1);
  }
#line 373
  tmp = js_copy(value___0, new);
#line 373
  if (tmp == -1) {
#line 374
    js_destroy(new);
#line 375
    return (-1);
  }
#line 378
  ret = mhash_put(hash, key___0, (void *)new, 1);
#line 380
  if (ret == -1) {
#line 381
    js_destroy(new);
  }
#line 383
  return (ret);
}
}
#line 390 "MaraHash.c"
js_string *mhash_get_js(mhash *hash , js_string *key___0 ) 
{ mhash_e info ;
  int tmp ;

  {
#line 392
  info = mhash_get(hash, key___0);
#line 393
  if ((unsigned long )info.value == (unsigned long )((void *)0)) {
#line 394
    return ((js_string *)0);
  }
#line 395
  if (info.datatype != 1) {
#line 396
    return ((js_string *)0);
  }
#line 397
  tmp = js_has_sanity((js_string *)info.value);
#line 397
  if (tmp == -1) {
#line 398
    return ((js_string *)0);
  }
#line 399
  return ((js_string *)info.value);
}
}
#line 406 "MaraHash.c"
int mhash_undef_js(mhash *hash , js_string *key___0 ) 
{ js_string *tonuke ;
  void *tmp ;
  int tmp___0 ;

  {
#line 408
  tmp = mhash_undef(hash, key___0);
#line 408
  tonuke = (js_string *)tmp;
#line 409
  if ((unsigned long )tonuke == (unsigned long )((js_string *)0)) {
#line 410
    js_destroy(tonuke);
#line 411
    return (-1);
  }
#line 413
  tmp___0 = js_destroy(tonuke);
#line 413
  return (tmp___0);
}
}
#line 422 "MaraHash.c"
int mhash_resize(mhash *hash , int new_bits ) 
{ unsigned int counter ;
  unsigned int old_tablesize ;
  mhash_spot **new_hash_table ;
  mhash_spot **old_hash_table ;
  mhash_spot *point ;
  mhash_spot *save ;
  void *tmp ;
  int tmp___0 ;

  {
#line 429
  if (new_bits < 1) {
#line 430
    return (-1);
  } else
#line 429
  if (new_bits > 29) {
#line 430
    return (-1);
  }
#line 433
  tmp = js_alloc((int )(mhash_mask[new_bits] + 1U), (int )sizeof(mhash_spot *));
#line 433
  new_hash_table = (mhash_spot **)tmp;
#line 433
  if ((unsigned long )new_hash_table == (unsigned long )((mhash_spot **)0)) {
#line 435
    return (-1);
  }
#line 438
  counter = 0U;
#line 438
  while (counter <= mhash_mask[new_bits]) {
#line 439
    *(new_hash_table + counter) = (mhash_spot *)0;
#line 438
    counter ++;
  }
#line 442
  old_hash_table = hash->hash_table;
#line 446
  old_tablesize = mhash_mask[hash->hash_bits];
#line 450
  hash->hash_table = new_hash_table;
#line 451
  hash->hash_bits = new_bits;
#line 454
  counter = 1U;
#line 454
  while (counter <= old_tablesize) {
#line 457
    if ((unsigned long )*(old_hash_table + counter) != (unsigned long )((mhash_spot *)0)) {
#line 458
      point = *(old_hash_table + counter);
#line 461
      while ((unsigned long )point != (unsigned long )((mhash_spot *)0)) {
#line 463
        if ((unsigned long )point->key == (unsigned long )((js_string *)0)) {
#line 464
          continue;
        }
#line 465
        tmp___0 = js_has_sanity(point->key);
#line 465
        if (tmp___0 == -1) {
#line 466
          continue;
        }
#line 469
        mhash_put(hash, point->key, point->value, point->datatype);
#line 473
        save = point->next;
#line 474
        js_dealloc((void *)point);
#line 475
        point = save;
      }
    }
#line 454
    counter ++;
  }
#line 481
  js_dealloc((void *)old_hash_table);
#line 483
  return (1);
}
}
#line 492 "MaraHash.c"
int mhash_autogrow(mhash *hash ) 
{ int bits ;
  int tmp ;
  int tmp___0 ;

  {
#line 496
  bits = hash->hash_bits;
#line 497
  if (bits < 1) {
#line 498
    return (-1);
  } else
#line 497
  if (bits > 29) {
#line 498
    return (-1);
  }
#line 501
  if (bits < 4) {
#line 502
    tmp = mhash_resize(hash, bits + 1);
#line 502
    if (tmp == -1) {
#line 503
      return (-1);
    }
#line 504
    return (2);
  }
#line 511
  if (hash->spots >= mhash_mask[bits - 1]) {
#line 512
    tmp___0 = mhash_resize(hash, bits + 1);
#line 512
    if (tmp___0 == -1) {
#line 513
      return (-1);
    }
#line 514
    return (2);
  }
#line 518
  return (1);
}
}
#line 530 "MaraHash.c"
int mhash_firstkey(mhash *hash , js_string *key___0 ) 
{ unsigned int offset ;
  mhash_spot *point ;
  int tmp ;

  {
#line 531
  offset = 0U;
#line 534
  while (offset < mhash_mask[hash->hash_bits] + 1U) {
#line 537
    if ((unsigned long )*(hash->hash_table + offset) != (unsigned long )((mhash_spot *)0)) {
#line 538
      point = *(hash->hash_table + offset);
#line 539
      tmp = js_copy(point->key, key___0);
#line 539
      return (tmp);
    } else {
#line 542
      offset ++;
    }
  }
#line 547
  return (0);
}
}
#line 560 "MaraHash.c"
int mhash_nextkey(mhash *hash , js_string *key___0 ) 
{ mhash_spot *point ;
  unsigned int offset ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 565
  offset = mhash_js(key___0, hash->hash_bits);
#line 568
  if (offset > mhash_mask[hash->hash_bits]) {
#line 569
    return (-1);
  } else
#line 568
  if (offset < 0U) {
#line 569
    return (-1);
  }
#line 573
  point = *(hash->hash_table + offset);
#line 576
  if ((unsigned long )point == (unsigned long )((mhash_spot *)0)) {
#line 577
    return (-1);
  }
#line 580
  while (1) {
#line 580
    tmp = js_issame(key___0, point->key);
#line 580
    if (tmp) {
#line 580
      break;
    }
#line 582
    if ((unsigned long )point->next == (unsigned long )((struct mhash_spot *)0)) {
#line 583
      return (-1);
    }
#line 585
    point = point->next;
  }
#line 593
  if ((unsigned long )point->next != (unsigned long )((struct mhash_spot *)0)) {
#line 594
    tmp___0 = js_copy((point->next)->key, key___0);
#line 594
    return (tmp___0);
  }
#line 599
  offset ++;
#line 601
  while (offset < mhash_mask[hash->hash_bits] + 1U) {
#line 604
    if ((unsigned long )*(hash->hash_table + offset) != (unsigned long )((mhash_spot *)0)) {
#line 605
      point = *(hash->hash_table + offset);
#line 606
      tmp___1 = js_copy(point->key, key___0);
#line 606
      return (tmp___1);
    } else {
#line 609
      offset ++;
    }
  }
#line 614
  return (0);
}
}
#line 621 "MaraHash.c"
mara_tuple *mtuple_new(int elements ) 
{ mara_tuple *ret ;
  int counter ;
  void *tmp ;
  js_string **tmp___0 ;
  void *tmp___1 ;

  {
#line 625
  tmp = js_alloc(1, (int )sizeof(mara_tuple ));
#line 625
  ret = (mara_tuple *)tmp;
#line 625
  if ((unsigned long )ret == (unsigned long )((mara_tuple *)0)) {
#line 626
    return ((mara_tuple *)0);
  }
#line 628
  ret->elements = elements;
#line 629
  tmp___1 = js_alloc(elements, (int )sizeof(js_string *));
#line 629
  tmp___0 = (js_string **)tmp___1;
#line 629
  ret->tuple_list = tmp___0;
#line 629
  if ((unsigned long )tmp___0 == (unsigned long )((js_string **)0)) {
#line 630
    js_dealloc((void *)ret);
#line 631
    return ((mara_tuple *)0);
  }
#line 635
  counter = 0;
#line 635
  while (counter < elements) {
#line 636
    *(ret->tuple_list + counter) = (js_string *)0;
#line 635
    counter ++;
  }
#line 638
  return (ret);
}
}
#line 648 "MaraHash.c"
int mtuple_put(mara_tuple *tuple , js_string *js , int element ) 
{ js_string *copy ;
  int tmp ;

  {
#line 654
  if (element >= tuple->elements) {
#line 655
    return (-1);
  } else
#line 654
  if (element < 0) {
#line 655
    return (-1);
  }
#line 656
  if ((unsigned long )*(tuple->tuple_list + element) != (unsigned long )((js_string *)0)) {
#line 657
    return (-1);
  }
#line 662
  copy = js_create(js->unit_count + 1U, js->unit_size);
#line 662
  if ((unsigned long )copy == (unsigned long )((js_string *)0)) {
#line 663
    return (-1);
  }
#line 664
  tmp = js_copy(js, copy);
#line 664
  if (tmp == -1) {
#line 665
    return (-1);
  }
#line 667
  *(tuple->tuple_list + element) = copy;
#line 669
  return (1);
}
}
#line 678 "MaraHash.c"
js_string *mtuple_get(mara_tuple *tuple , int element ) 
{ 

  {
#line 681
  if (element >= tuple->elements) {
#line 682
    return ((js_string *)0);
  } else
#line 681
  if (element < 0) {
#line 682
    return ((js_string *)0);
  }
#line 684
  return (*(tuple->tuple_list + element));
}
}
#line 1 "qual_timestamp.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-8DlZwyFA.i","")
#line 33 "qual_timestamp.c"
int64_t the_time  ;
#line 34 "qual_timestamp.c"
int num_tries  =    0;
#line 41 "qual_timestamp.c"
pthread_mutex_t qtime_lock  =    {850045863L, {(char)0}};
#line 47 "qual_timestamp.c"
int64_t qual_get_time(void) 
{ int64_t ttime ;

  {
#line 50
  pthread_mutex_lock(& qtime_lock);
#line 52
  ttime = the_time;
#line 54
  pthread_mutex_unlock(& qtime_lock);
#line 56
  return (ttime);
}
}
#line 64 "qual_timestamp.c"
int qual_set_time(void) 
{ time_t sys_time ;
  int64_t ttime ;

  {
#line 68
  sys_time = time((time_t *)0);
#line 70
  if (sizeof(sys_time) > 4UL) {
#line 71
    if (sys_time == -1L) {
#line 72
      return (-1);
    }
#line 74
    ttime = (int64_t )(sys_time - 290805600L);
  } else
#line 82
  if (sys_time == -1L) {
#line 82
    if (num_tries < 3) {
#line 83
      num_tries ++;
#line 84
      return (1);
    } else {
#line 82
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 86
  if (sys_time == -1L) {
#line 87
    return (-1);
  } else
#line 99
  if (sys_time < 290805600L) {
#line 101
    ttime = (int64_t )(sys_time + 4004161696L);
#line 102
    num_tries = 0;
  } else {
#line 105
    ttime = (int64_t )(sys_time - 290805600L);
#line 106
    num_tries = 0;
  }
#line 110
  pthread_mutex_lock(& qtime_lock);
#line 112
  the_time = ttime;
#line 114
  pthread_mutex_unlock(& qtime_lock);
#line 116
  return (1);
}
}
#line 1 "Queries.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-oAH5mgHU.i","")
#line 56 "functions_dns.h"
int hname_2rfc1035_starwhitis(js_string *hostname , int starwhitis ) ;
#line 64
int email_2rfc1035(js_string *hostname ) ;
#line 127
int read_rr_h(js_string *js , q_rr *hdr , int offset ) ;
#line 133
int read_soa(js_string *js , rr_soa *soa , int offset ) ;
#line 148
int email_translate(js_string *hostname ) ;
#line 165
int make_question(q_question *question , js_string *js ) ;
#line 173
int read_question(js_string *js , q_question *question , int offset ) ;
#line 180
int read_ns(js_string *in , js_string *out , int offset ) ;
#line 187
int read_txt(js_string *in , js_string *out , int offset ) ;
#line 33 "Queries.c"
int dlabel_length(js_string *raw , unsigned int offset ) 
{ int length ;
  unsigned char toread ;
  int tmp ;

  {
#line 39
  tmp = js_has_sanity(raw);
#line 39
  if (tmp == -1) {
#line 40
    return (-1);
  }
#line 41
  if (raw->unit_size != 1U) {
#line 42
    return (-1);
  }
#line 44
  length = 0;
#line 45
  if (offset > raw->unit_count) {
#line 46
    return (-1);
  }
#line 47
  toread = *(raw->string + offset);
#line 48
  while (1) {
#line 48
    if (length < 256) {
#line 48
      if ((int )toread > 0) {
#line 48
        if (! ((int )toread != 95)) {
#line 48
          break;
        }
      } else {
#line 48
        break;
      }
    } else {
#line 48
      break;
    }
#line 49
    if ((int )toread >= 192) {
#line 50
      if ((unsigned int )(length + 2) + offset <= raw->unit_count) {
#line 51
        return (length + 2);
      } else {
#line 53
        return (-1);
      }
    }
#line 55
    if ((int )toread > 63) {
#line 56
      return (-1);
    }
#line 57
    length += (int )toread + 1;
#line 59
    if ((unsigned int )length + offset > raw->unit_count) {
#line 60
      return (-1);
    }
#line 61
    toread = *((raw->string + length) + offset);
  }
#line 64
  if ((unsigned int )(length + 1) + offset <= raw->unit_count) {
#line 65
    return (length + 1);
  }
#line 67
  return (-1);
}
}
#line 74 "Queries.c"
void init_header(q_header *header ) 
{ 

  {
#line 75
  header->id = (uint16_t )0;
#line 76
  header->qr = 0;
#line 77
  header->opcode = 0;
#line 78
  header->aa = 0;
#line 79
  header->tc = 0;
#line 80
  header->rd = 0;
#line 81
  header->ra = 0;
#line 82
  header->z = 0;
#line 83
  header->rcode = 0;
#line 84
  header->qdcount = (uint16_t )0;
#line 85
  header->ancount = (uint16_t )0;
#line 86
  header->nscount = (uint16_t )0;
#line 87
  header->arcount = (uint16_t )0;
#line 88
  return;
}
}
#line 96 "Queries.c"
int make_hdr(q_header *header , js_string *js ) 
{ unsigned char *raw ;
  int tmp ;
  unsigned char tmp___0 ;

  {
#line 100
  tmp = js_has_sanity(js);
#line 100
  if (tmp == -1) {
#line 101
    return (-1);
  }
#line 102
  if (js->unit_size != 1U) {
#line 103
    return (-1);
  }
#line 104
  if (js->max_count < 14U) {
#line 105
    return (-1);
  }
#line 108
  raw = js->string;
#line 111
  *(raw + 0) = (unsigned char )(((int )header->id & 65280) >> 8);
#line 112
  *(raw + 1) = (unsigned char )((int )header->id & 255);
#line 114
  tmp___0 = (unsigned char)0;
#line 114
  *(raw + 3) = tmp___0;
#line 114
  *(raw + 2) = tmp___0;
#line 115
  if (header->qr == 1) {
#line 116
    *(raw + 2) = (unsigned char )((int )*(raw + 2) | 128);
  }
#line 117
  *(raw + 2) = (unsigned char )((int )*(raw + 2) | ((header->opcode & 15) << 3));
#line 118
  if (header->aa == 1) {
#line 119
    *(raw + 2) = (unsigned char )((int )*(raw + 2) | 4);
  }
#line 120
  if (header->tc == 1) {
#line 121
    *(raw + 2) = (unsigned char )((int )*(raw + 2) | 2);
  }
#line 122
  if (header->rd == 1) {
#line 123
    *(raw + 2) = (unsigned char )((int )*(raw + 2) | 1);
  }
#line 124
  if (header->ra == 1) {
#line 125
    *(raw + 3) = (unsigned char )((int )*(raw + 3) | 128);
  }
#line 126
  *(raw + 3) = (unsigned char )((int )*(raw + 3) | ((header->z & 7) << 4));
#line 127
  *(raw + 3) = (unsigned char )((int )*(raw + 3) | (header->rcode & 15));
#line 129
  *(raw + 4) = (unsigned char )(((int )header->qdcount & 65280) >> 8);
#line 130
  *(raw + 5) = (unsigned char )((int )header->qdcount & 255);
#line 131
  *(raw + 6) = (unsigned char )(((int )header->ancount & 65280) >> 8);
#line 132
  *(raw + 7) = (unsigned char )((int )header->ancount & 255);
#line 133
  *(raw + 8) = (unsigned char )(((int )header->nscount & 65280) >> 8);
#line 134
  *(raw + 9) = (unsigned char )((int )header->nscount & 255);
#line 135
  *(raw + 10) = (unsigned char )(((int )header->arcount & 65280) >> 8);
#line 136
  *(raw + 11) = (unsigned char )((int )header->arcount & 255);
#line 139
  if (js->max_count >= 12U) {
#line 140
    js->unit_count = 12U;
  }
#line 142
  return (1);
}
}
#line 152 "Queries.c"
int read_hdr(js_string *js , q_header *header ) 
{ unsigned char *raw ;
  int tmp ;

  {
#line 156
  tmp = js_has_sanity(js);
#line 156
  if (tmp == -1) {
#line 157
    return (-1);
  }
#line 158
  if (js->unit_size != 1U) {
#line 159
    return (-1);
  }
#line 160
  if (js->max_count < 14U) {
#line 161
    return (-1);
  }
#line 163
  raw = js->string;
#line 166
  header->id = (uint16_t )(((int )*(raw + 0) << 8) | (int )*(raw + 1));
#line 168
  if ((int )*(raw + 2) & 128) {
#line 169
    header->qr = 1;
  } else {
#line 171
    header->qr = 0;
  }
#line 172
  header->opcode = ((int )*(raw + 2) & 120) >> 3;
#line 173
  if ((int )*(raw + 2) & 4) {
#line 174
    header->aa = 1;
  } else {
#line 176
    header->aa = 0;
  }
#line 177
  if ((int )*(raw + 2) & 2) {
#line 178
    header->tc = 1;
  } else {
#line 180
    header->tc = 0;
  }
#line 181
  if ((int )*(raw + 2) & 1) {
#line 182
    header->rd = 1;
  } else {
#line 184
    header->rd = 0;
  }
#line 185
  if ((int )*(raw + 3) & 128) {
#line 186
    header->ra = 1;
  } else {
#line 188
    header->ra = 0;
  }
#line 189
  header->z = ((int )*(raw + 3) & 112) >> 4;
#line 190
  header->rcode = (int )*(raw + 3) & 15;
#line 192
  header->qdcount = (uint16_t )(((int )*(raw + 4) << 8) | (int )*(raw + 5));
#line 193
  header->ancount = (uint16_t )(((int )*(raw + 6) << 8) | (int )*(raw + 7));
#line 194
  header->nscount = (uint16_t )(((int )*(raw + 8) << 8) | (int )*(raw + 9));
#line 195
  header->arcount = (uint16_t )(((int )*(raw + 10) << 8) | (int )*(raw + 11));
#line 197
  return (1);
}
}
#line 206 "Queries.c"
int make_question(q_question *question , js_string *js ) 
{ int counter ;
  unsigned char toread ;
  unsigned char read___0 ;
  int offset ;
  unsigned char *raw ;
  int tmp ;
  int tmp___0 ;

  {
#line 211
  offset = (int )js->unit_count;
#line 215
  toread = (unsigned char)0;
#line 215
  counter = (int )toread;
#line 218
  tmp = js_has_sanity(js);
#line 218
  if (tmp == -1) {
#line 219
    return (-1);
  }
#line 220
  if (js->unit_size != 1U) {
#line 221
    return (-1);
  }
#line 222
  tmp___0 = js_has_sanity(question->qname);
#line 222
  if (tmp___0 == -1) {
#line 223
    return (-1);
  }
#line 224
  if ((question->qname)->unit_size != 1U) {
#line 225
    return (-1);
  }
#line 226
  if ((unsigned int )offset >= js->max_count) {
#line 227
    return (-1);
  }
#line 229
  raw = (question->qname)->string;
#line 232
  while (counter < 256) {
#line 233
    toread = *(raw + counter);
#line 234
    if ((int )toread > 63) {
#line 235
      return (-1);
    }
#line 236
    read___0 = (unsigned char)0;
#line 237
    if ((int )toread == 0) {
#line 238
      break;
    }
#line 239
    while ((int )read___0 <= (int )toread) {
#line 241
      if ((unsigned int )counter < (question->qname)->max_count) {
#line 241
        if ((unsigned int )(counter + offset) < js->max_count) {
#line 244
          *((js->string + offset) + counter) = *(raw + counter);
        } else {
#line 246
          return (-1);
        }
      } else {
#line 246
        return (-1);
      }
#line 247
      read___0 = (unsigned char )((int )read___0 + 1);
#line 248
      counter ++;
    }
  }
#line 253
  *((js->string + offset) + counter) = (unsigned char)0;
#line 254
  counter ++;
#line 257
  if ((unsigned int )((counter + offset) + 4) < js->max_count) {
#line 258
    raw = (js->string + counter) + offset;
#line 259
    *(raw + 0) = (unsigned char )(((int )question->qtype & 65280) >> 8);
#line 260
    *(raw + 1) = (unsigned char )((int )question->qtype & 255);
#line 261
    *(raw + 2) = (unsigned char )(((int )question->qclass & 65280) >> 8);
#line 262
    *(raw + 3) = (unsigned char )((int )question->qclass & 255);
  } else {
#line 265
    return (-1);
  }
#line 268
  if (js->max_count > (unsigned int )((counter + offset) + 4)) {
#line 269
    js->unit_count = (unsigned int )((counter + offset) + 4);
  }
#line 271
  return (1);
}
}
#line 281 "Queries.c"
int read_question(js_string *js , q_question *question , int offset ) 
{ int counter ;
  unsigned char toread ;
  unsigned char read___0 ;
  unsigned char *raw ;
  int tmp ;
  int tmp___0 ;

  {
#line 288
  toread = (unsigned char)0;
#line 288
  counter = (int )toread;
#line 291
  tmp = js_has_sanity(js);
#line 291
  if (tmp == -1) {
#line 292
    return (-1);
  }
#line 293
  if (js->unit_size != 1U) {
#line 294
    return (-1);
  }
#line 295
  tmp___0 = js_has_sanity(question->qname);
#line 295
  if (tmp___0 == -1) {
#line 296
    return (-1);
  }
#line 297
  if ((question->qname)->unit_size != 1U) {
#line 298
    return (-1);
  }
#line 299
  if ((unsigned int )offset >= js->unit_count) {
#line 300
    return (-1);
  }
#line 302
  raw = js->string + offset;
#line 305
  while (counter < 256) {
#line 306
    toread = *(raw + counter);
#line 307
    if ((int )toread > 63) {
#line 308
      return (-1);
    }
#line 309
    read___0 = (unsigned char)0;
#line 310
    if ((int )toread == 0) {
#line 311
      break;
    }
#line 312
    while ((int )read___0 <= (int )toread) {
#line 314
      if ((unsigned int )counter < (question->qname)->max_count) {
#line 314
        if ((unsigned int )(counter + offset) < js->unit_count) {
#line 317
          *((question->qname)->string + counter) = *(raw + counter);
        } else {
#line 319
          return (-1);
        }
      } else {
#line 319
        return (-1);
      }
#line 320
      read___0 = (unsigned char )((int )read___0 + 1);
#line 321
      counter ++;
    }
  }
#line 327
  *((question->qname)->string + counter) = (unsigned char)0;
#line 328
  counter ++;
#line 331
  if ((unsigned int )((counter + offset) + 4) <= js->unit_count) {
#line 332
    raw = (js->string + counter) + offset;
#line 333
    question->qtype = (uint16_t )((((int )*(raw + 0) << 8) & 65280) | ((int )*(raw + 1) & 255));
#line 334
    question->qclass = (uint16_t )((((int )*(raw + 2) << 8) & 65280) | ((int )*(raw + 3) & 255));
  } else {
#line 337
    return (-1);
  }
#line 340
  if ((unsigned int )counter < (question->qname)->max_count) {
#line 341
    (question->qname)->unit_count = (unsigned int )counter;
  } else {
#line 343
    return (-1);
  }
#line 345
  return (counter + 4);
}
}
#line 356 "Queries.c"
int hname_translate(js_string *hostname , int qtype ) 
{ int counter ;
  int special_root_case ;
  unsigned char toread ;
  unsigned char *raw ;
  int dotseen ;
  int tmp ;

  {
#line 357
  counter = 0;
#line 357
  special_root_case = 0;
#line 358
  toread = (unsigned char)0;
#line 359
  raw = (unsigned char *)0;
#line 360
  dotseen = 0;
#line 363
  tmp = js_has_sanity(hostname);
#line 363
  if (tmp == -1) {
#line 364
    return (-1);
  }
#line 365
  if (hostname->unit_size != 1U) {
#line 366
    return (-1);
  }
#line 367
  if (hostname->unit_count < 1U) {
#line 368
    return (-1);
  }
#line 371
  toread = *(hostname->string);
#line 374
  if (hostname->unit_count == 1U) {
#line 374
    if ((int )toread == 0) {
#line 375
      special_root_case = 1;
    }
  }
#line 378
  raw = hostname->string;
#line 379
  switch (qtype) {
  case 1: 
#line 381
  *raw = (unsigned char )'A';
#line 382
  break;
  case 2: 
#line 384
  *raw = (unsigned char )'N';
#line 385
  break;
  case 5: 
#line 387
  *raw = (unsigned char )'C';
#line 388
  break;
  case 6: 
#line 390
  *raw = (unsigned char )'S';
#line 391
  break;
  case 12: 
#line 393
  *raw = (unsigned char )'P';
#line 394
  break;
  case 15: 
#line 396
  *raw = (unsigned char )'@';
#line 397
  break;
  case 16: 
#line 399
  *raw = (unsigned char )'T';
#line 400
  break;
  case 255: 
#line 402
  *raw = (unsigned char )'Z';
#line 403
  break;
  case -2: 
#line 405
  *raw = (unsigned char )'|';
#line 406
  break;
  case -300: 
  case -301: 
#line 410
  *raw = (unsigned char )' ';
#line 411
  break;
  default: 
#line 413
  *raw = (unsigned char )'U';
  }
#line 418
  if (special_root_case == 1) {
#line 419
    if (hostname->max_count < 2U) {
#line 420
      return (-1);
    }
#line 421
    hostname->unit_count = 2U;
#line 422
    raw ++;
#line 423
    *raw = (unsigned char )'.';
#line 424
    return (1);
  }
#line 428
  counter = 0;
#line 429
  dotseen = 0;
#line 430
  while (1) {
#line 430
    if (counter < 256) {
#line 430
      if (! ((int )toread > 0)) {
#line 430
        break;
      }
    } else {
#line 430
      break;
    }
#line 431
    if ((int )toread > 63) {
#line 432
      return (-1);
    }
#line 433
    counter += (int )toread + 1;
#line 435
    if ((unsigned int )counter > hostname->unit_count) {
#line 436
      return (-1);
    }
#line 437
    toread = *(raw + counter);
#line 439
    if ((unsigned int )counter <= hostname->unit_count) {
#line 440
      if (qtype != -301) {
#line 441
        *(raw + counter) = (unsigned char )'.';
      } else
#line 440
      if (dotseen > 0) {
#line 441
        *(raw + counter) = (unsigned char )'.';
      } else {
#line 443
        *(raw + counter) = (unsigned char )'@';
#line 444
        dotseen = 1;
      }
    } else {
#line 447
      return (-1);
    }
  }
#line 451
  return (1);
}
}
#line 460 "Queries.c"
int email_translate(js_string *hostname ) 
{ int counter ;
  unsigned char toread ;
  int first ;
  unsigned char *raw ;
  int tmp ;

  {
#line 463
  first = 1;
#line 467
  tmp = js_has_sanity(hostname);
#line 467
  if (tmp == -1) {
#line 468
    return (-1);
  }
#line 469
  if (hostname->unit_size != 1U) {
#line 470
    return (-1);
  }
#line 471
  if (hostname->unit_count < 1U) {
#line 472
    return (-1);
  }
#line 475
  toread = *(hostname->string);
#line 478
  raw = hostname->string;
#line 479
  *raw = (unsigned char )'|';
#line 482
  counter = 0;
#line 483
  while (1) {
#line 483
    if (counter < 256) {
#line 483
      if (! ((int )toread > 0)) {
#line 483
        break;
      }
    } else {
#line 483
      break;
    }
#line 484
    if ((int )toread > 63) {
#line 485
      return (-1);
    }
#line 486
    counter += (int )toread + 1;
#line 488
    if ((unsigned int )counter > hostname->unit_count) {
#line 489
      return (-1);
    }
#line 490
    toread = *(raw + counter);
#line 492
    if ((unsigned int )counter <= hostname->unit_count) {
#line 493
      if (first) {
#line 494
        *(raw + counter) = (unsigned char )'@';
#line 495
        first = 0;
      } else {
#line 498
        *(raw + counter) = (unsigned char )'.';
      }
    } else {
#line 502
      return (-1);
    }
  }
#line 505
  return (1);
}
}
#line 516 "Queries.c"
int hname_2rfc1035(js_string *hostname ) 
{ int tmp ;

  {
#line 517
  tmp = hname_2rfc1035_starwhitis(hostname, 0);
#line 517
  return (tmp);
}
}
#line 523 "Queries.c"
int hname_2rfc1035_starwhitis(js_string *hostname , int starwhitis ) 
{ int counter ;
  int seen ;
  unsigned char *raw ;
  unsigned char *towrite ;
  int ret ;
  int tmp ;

  {
#line 526
  ret = -2;
#line 529
  tmp = js_has_sanity(hostname);
#line 529
  if (tmp == -1) {
#line 530
    return (-1);
  }
#line 531
  if (hostname->unit_size != 1U) {
#line 532
    return (-1);
  }
#line 533
  if (hostname->unit_count < 1U) {
#line 534
    return (-1);
  }
#line 537
  towrite = hostname->string;
#line 537
  raw = towrite;
#line 540
  switch ((int )*raw) {
  case 65: 
#line 542
  ret = 1;
#line 543
  break;
  case 78: 
#line 545
  ret = 2;
#line 546
  break;
  case 67: 
#line 548
  ret = 5;
#line 549
  break;
  case 83: 
#line 551
  ret = 6;
#line 552
  break;
  case 80: 
#line 554
  ret = 12;
#line 555
  break;
  case 64: 
#line 557
  ret = 15;
#line 558
  break;
  case 84: 
#line 560
  ret = 16;
#line 561
  break;
  case 85: 
#line 563
  ret = -3;
#line 564
  break;
  case 90: 
#line 566
  ret = 255;
#line 567
  break;
  default: 
#line 569
  return (-2);
  }
#line 573
  if ((int )*(raw + 1) == 46) {
#line 573
    if (hostname->unit_count == 2U) {
#line 574
      *raw = (unsigned char)0;
#line 575
      hostname->unit_count = 1U;
#line 576
      return (ret);
    }
  }
#line 580
  if ((int )*(raw + 1) == 42) {
#line 580
    if (hostname->unit_count == 2U) {
#line 580
      if (starwhitis == 1) {
#line 582
        *raw = (unsigned char )'_';
#line 583
        hostname->unit_count = 1U;
#line 584
        return (ret);
      }
    }
  }
#line 588
  counter = 0;
#line 588
  seen = counter;
#line 589
  while (1) {
#line 589
    if (counter < 256) {
#line 589
      if (! ((unsigned int )counter < hostname->unit_count)) {
#line 589
        break;
      }
    } else {
#line 589
      break;
    }
#line 590
    counter ++;
#line 591
    if ((unsigned int )counter > hostname->unit_count) {
#line 592
      return (-1);
    }
#line 593
    if ((int )*(raw + counter) == 46) {
#line 594
      if (seen < 1) {
#line 595
        return (-1);
      } else
#line 594
      if (seen > 63) {
#line 595
        return (-1);
      }
#line 596
      *towrite = (unsigned char )seen;
#line 597
      towrite = raw + counter;
#line 598
      seen = 0;
    } else {
#line 601
      seen ++;
    }
#line 602
    if ((unsigned int )counter == hostname->unit_count - 1U) {
#line 603
      break;
    }
  }
#line 607
  if (counter < 256) {
#line 607
    if ((int )*(raw + counter) == 46) {
#line 608
      *(raw + counter) = (unsigned char)0;
    } else {
#line 607
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 610
  if (counter < 256) {
#line 610
    if (counter > 1) {
#line 610
      if ((int )*(raw + counter) == 42) {
#line 610
        if (hostname->unit_count > 1U) {
#line 610
          if (starwhitis == 1) {
#line 612
            *((raw + counter) - 1) = (unsigned char )'_';
#line 613
            (hostname->unit_count) --;
          } else {
#line 616
            return (-1);
          }
        } else {
#line 616
          return (-1);
        }
      } else {
#line 616
        return (-1);
      }
    } else {
#line 616
      return (-1);
    }
  } else {
#line 616
    return (-1);
  }
#line 619
  return (ret);
}
}
#line 629 "Queries.c"
int email_2rfc1035(js_string *hostname ) 
{ int counter ;
  int seen ;
  unsigned char *raw ;
  unsigned char *towrite ;
  int firstat ;
  int tmp ;
  int tmp___0 ;

  {
#line 633
  firstat = 1;
#line 636
  tmp = js_has_sanity(hostname);
#line 636
  if (tmp == -1) {
#line 637
    return (-1);
  }
#line 638
  if (hostname->unit_size != 1U) {
#line 639
    return (-1);
  }
#line 640
  if (hostname->unit_count < 1U) {
#line 641
    return (-1);
  }
#line 644
  towrite = hostname->string;
#line 644
  raw = towrite;
#line 647
  counter = 0;
#line 647
  seen = counter;
#line 649
  if (hostname->unit_count == 2U) {
#line 649
    if ((int )*(raw + 1) == 46) {
#line 650
      hostname->unit_count = 1U;
#line 651
      *(hostname->string) = (unsigned char )'\000';
#line 652
      return (1);
    }
  }
#line 655
  while (1) {
#line 655
    if (counter < 256) {
#line 655
      if (! ((unsigned int )counter < hostname->unit_count)) {
#line 655
        break;
      }
    } else {
#line 655
      break;
    }
#line 656
    counter ++;
#line 657
    if ((unsigned int )counter > hostname->unit_count) {
#line 658
      return (-1);
    }
#line 659
    if (! firstat) {
#line 659
      if ((int )*(raw + counter) == 46) {
#line 659
        goto _L;
      } else {
#line 659
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 659
    if (firstat) {
#line 659
      if ((int )*(raw + counter) == 64) {
        _L: /* CIL Label */ 
#line 661
        firstat = 0;
#line 662
        if (seen < 1) {
#line 663
          return (-1);
        } else
#line 662
        if (seen > 63) {
#line 663
          return (-1);
        }
#line 664
        *towrite = (unsigned char )seen;
#line 665
        towrite = raw + counter;
#line 666
        seen = 0;
      } else {
#line 669
        seen ++;
      }
    } else {
#line 669
      seen ++;
    }
#line 670
    if ((unsigned int )counter == hostname->unit_count - 1U) {
#line 671
      break;
    }
  }
#line 676
  if (firstat) {
#line 677
    tmp___0 = hname_2rfc1035_starwhitis(hostname, 0);
#line 677
    return (tmp___0);
  }
#line 681
  if (counter < 256) {
#line 681
    if ((int )*(raw + counter) == 46) {
#line 682
      *(raw + counter) = (unsigned char)0;
    } else {
#line 684
      return (-1);
    }
  } else {
#line 684
    return (-1);
  }
#line 686
  return (1);
}
}
#line 697 "Queries.c"
int read_rr_h(js_string *js , q_rr *hdr , int offset ) 
{ int counter ;
  unsigned char toread ;
  unsigned char read___0 ;
  unsigned char *raw ;
  int tmp ;
  int tmp___0 ;

  {
#line 703
  toread = (unsigned char)0;
#line 703
  counter = (int )toread;
#line 706
  tmp = js_has_sanity(js);
#line 706
  if (tmp == -1) {
#line 707
    return (-1);
  }
#line 708
  if (js->unit_size != 1U) {
#line 709
    return (-1);
  }
#line 710
  tmp___0 = js_has_sanity(hdr->name);
#line 710
  if (tmp___0 == -1) {
#line 711
    return (-1);
  }
#line 712
  if ((hdr->name)->unit_size != 1U) {
#line 713
    return (-1);
  }
#line 714
  if ((unsigned int )offset >= js->max_count) {
#line 715
    return (-1);
  }
#line 717
  raw = js->string + offset;
#line 720
  while (counter < 256) {
#line 721
    if ((unsigned int )(offset + counter) > js->unit_count) {
#line 722
      return (-1);
    }
#line 723
    toread = *(raw + counter);
#line 724
    if ((int )toread > 63) {
#line 725
      return (-1);
    }
#line 726
    read___0 = (unsigned char)0;
#line 727
    if ((int )toread == 0) {
#line 728
      break;
    }
#line 729
    while ((int )read___0 <= (int )toread) {
#line 731
      if ((unsigned int )counter < (hdr->name)->max_count) {
#line 731
        if ((unsigned int )(counter + offset) < js->unit_count) {
#line 734
          *((hdr->name)->string + counter) = *(raw + counter);
        } else {
#line 736
          return (-1);
        }
      } else {
#line 736
        return (-1);
      }
#line 737
      read___0 = (unsigned char )((int )read___0 + 1);
#line 738
      counter ++;
    }
  }
#line 744
  *((hdr->name)->string + counter) = *(raw + counter);
#line 746
  counter ++;
#line 749
  if ((unsigned int )((counter + offset) + 10) <= js->unit_count) {
#line 750
    raw = (js->string + counter) + offset;
#line 751
    hdr->type = (uint16_t )(((int )*(raw + 0) << 8) | (int )*(raw + 1));
#line 752
    hdr->class = (uint16_t )(((int )*(raw + 2) << 8) | (int )*(raw + 3));
#line 753
    hdr->ttl = (uint32_t )(((((int )*(raw + 4) << 24) | ((int )*(raw + 5) << 16)) | ((int )*(raw + 6) << 8)) | (int )*(raw + 7));
#line 754
    hdr->rdlength = (uint16_t )(((int )*(raw + 8) << 8) | (int )*(raw + 9));
  } else {
#line 757
    return (-1);
  }
#line 759
  if ((unsigned int )counter < (hdr->name)->max_count) {
#line 760
    (hdr->name)->unit_count = (unsigned int )counter;
  } else {
#line 762
    return (-1);
  }
#line 764
  return (counter + 10);
}
}
#line 773 "Queries.c"
int read_soa(js_string *js , rr_soa *soa , int offset ) 
{ int counter ;
  unsigned char read___0 ;
  unsigned char toread ;
  unsigned char *raw ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 780
  tmp = js_has_sanity(js);
#line 780
  if (tmp == -1) {
#line 781
    return (-1);
  }
#line 782
  tmp___0 = js_has_sanity(soa->mname);
#line 782
  if (tmp___0 == -1) {
#line 783
    return (-1);
  }
#line 784
  tmp___1 = js_has_sanity(soa->rname);
#line 784
  if (tmp___1 == -1) {
#line 785
    return (-1);
  }
#line 786
  if (js->unit_size != 1U) {
#line 787
    return (-1);
  }
#line 788
  if ((soa->mname)->unit_size != 1U) {
#line 789
    return (-1);
  }
#line 790
  if ((soa->rname)->unit_size != 1U) {
#line 791
    return (-1);
  }
#line 792
  if (js->unit_count < (unsigned int )offset) {
#line 793
    return (-1);
  }
#line 795
  raw = js->string + offset;
#line 798
  counter = 0;
#line 799
  while (counter < 256) {
#line 800
    toread = *(raw + counter);
#line 801
    if ((int )toread > 63) {
#line 802
      return (-1);
    }
#line 803
    read___0 = (unsigned char)0;
#line 804
    if ((int )toread == 0) {
#line 805
      break;
    }
#line 806
    while ((int )read___0 <= (int )toread) {
#line 808
      if ((unsigned int )counter < (soa->mname)->max_count) {
#line 808
        if ((unsigned int )(counter + offset) < js->unit_count) {
#line 811
          *((soa->mname)->string + counter) = *(raw + counter);
        } else {
#line 813
          return (-1);
        }
      } else {
#line 813
        return (-1);
      }
#line 814
      read___0 = (unsigned char )((int )read___0 + 1);
#line 815
      counter ++;
    }
  }
#line 820
  *((soa->mname)->string + counter) = (unsigned char)0;
#line 821
  counter ++;
#line 822
  offset += counter;
#line 823
  if ((soa->mname)->max_count < (unsigned int )counter) {
#line 824
    return (-1);
  }
#line 825
  (soa->mname)->unit_count = (unsigned int )counter;
#line 827
  raw = js->string + offset;
#line 830
  counter = 0;
#line 831
  while (counter < 256) {
#line 832
    toread = *(raw + counter);
#line 833
    if ((int )toread > 63) {
#line 834
      return (-1);
    }
#line 835
    read___0 = (unsigned char)0;
#line 836
    if ((int )toread == 0) {
#line 837
      break;
    }
#line 838
    while ((int )read___0 <= (int )toread) {
#line 840
      if ((unsigned int )counter < (soa->rname)->max_count) {
#line 840
        if ((unsigned int )(counter + offset) < js->unit_count) {
#line 843
          *((soa->rname)->string + counter) = *(raw + counter);
        } else {
#line 845
          return (-1);
        }
      } else {
#line 845
        return (-1);
      }
#line 846
      read___0 = (unsigned char )((int )read___0 + 1);
#line 847
      counter ++;
    }
  }
#line 852
  *((soa->rname)->string + counter) = (unsigned char)0;
#line 853
  counter ++;
#line 854
  if ((soa->rname)->max_count < (unsigned int )counter) {
#line 855
    return (-1);
  }
#line 856
  (soa->rname)->unit_count = (unsigned int )counter;
#line 858
  if ((unsigned int )((counter + offset) + 20) > js->unit_count) {
#line 859
    return (-1);
  }
#line 861
  raw = (js->string + counter) + offset;
#line 862
  soa->serial = (uint32_t )(((((int )*(raw + 0) << 24) | ((int )*(raw + 1) << 16)) | ((int )*(raw + 2) << 8)) | (int )*(raw + 3));
#line 863
  soa->refresh = ((((int )*(raw + 4) << 24) | ((int )*(raw + 5) << 16)) | ((int )*(raw + 6) << 8)) | (int )*(raw + 7);
#line 864
  soa->retry = ((((int )*(raw + 8) << 24) | ((int )*(raw + 9) << 16)) | ((int )*(raw + 10) << 8)) | (int )*(raw + 11);
#line 865
  soa->expire = ((((int )*(raw + 12) << 24) | ((int )*(raw + 13) << 16)) | ((int )*(raw + 14) << 8)) | (int )*(raw + 15);
#line 866
  soa->minimum = (uint32_t )(((((int )*(raw + 16) << 24) | ((int )*(raw + 17) << 16)) | ((int )*(raw + 18) << 8)) | (int )*(raw + 19));
#line 869
  return (counter + 20);
}
}
#line 879 "Queries.c"
int read_ns(js_string *in , js_string *out , int offset ) 
{ uint16_t toread ;
  uint16_t read___0 ;
  int counter ;
  unsigned char *raw ;
  int tmp ;
  int tmp___0 ;

  {
#line 885
  tmp = js_has_sanity(in);
#line 885
  if (tmp == -1) {
#line 886
    return (-1);
  }
#line 887
  tmp___0 = js_has_sanity(out);
#line 887
  if (tmp___0 == -1) {
#line 888
    return (-1);
  }
#line 889
  if (in->unit_size != 1U) {
#line 890
    return (-1);
  }
#line 891
  if (out->unit_size != 1U) {
#line 892
    return (-1);
  }
#line 893
  if (in->unit_count < (unsigned int )offset) {
#line 894
    return (-1);
  }
#line 896
  raw = in->string + offset;
#line 898
  counter = 0;
#line 899
  while (counter < 256) {
#line 900
    toread = (uint16_t )*(raw + counter);
#line 901
    if ((int )toread > 63) {
#line 902
      return (-1);
    }
#line 903
    read___0 = (uint16_t )0;
#line 904
    if ((int )toread == 0) {
#line 905
      break;
    }
#line 906
    while ((int )read___0 <= (int )toread) {
#line 908
      if ((unsigned int )counter < out->max_count) {
#line 908
        if ((unsigned int )(counter + offset) < in->unit_count) {
#line 911
          *(out->string + counter) = *(raw + counter);
        } else {
#line 913
          return (-1);
        }
      } else {
#line 913
        return (-1);
      }
#line 914
      read___0 = (uint16_t )((int )read___0 + 1);
#line 915
      counter ++;
    }
  }
#line 920
  *(out->string + counter) = (unsigned char)0;
#line 921
  counter ++;
#line 922
  offset += counter;
#line 923
  if (out->max_count < (unsigned int )counter) {
#line 924
    return (-1);
  }
#line 925
  out->unit_count = (unsigned int )counter;
#line 927
  return (counter);
}
}
#line 936 "Queries.c"
int read_txt(js_string *in , js_string *out , int offset ) 
{ int counter ;
  unsigned char toread ;
  int tmp ;
  int tmp___0 ;

  {
#line 940
  counter = 0;
#line 943
  tmp = js_has_sanity(in);
#line 943
  if (tmp == -1) {
#line 944
    return (-1);
  }
#line 945
  tmp___0 = js_has_sanity(out);
#line 945
  if (tmp___0 == -1) {
#line 946
    return (-1);
  }
#line 947
  if (in->unit_size != 1U) {
#line 948
    return (-1);
  }
#line 949
  if (out->unit_size != 1U) {
#line 950
    return (-1);
  }
#line 951
  if (in->unit_count < (unsigned int )offset) {
#line 952
    return (-1);
  }
#line 955
  toread = *(in->string + offset);
#line 958
  if ((unsigned int )toread >= out->max_count) {
#line 959
    return (-1);
  } else
#line 958
  if ((unsigned int )(offset + (int )toread) >= in->unit_count) {
#line 959
    return (-1);
  }
#line 962
  offset ++;
#line 963
  counter = 0;
#line 963
  while (counter < (int )toread) {
#line 964
    *(out->string + counter) = *((in->string + offset) + counter);
#line 963
    counter ++;
  }
#line 966
  out->unit_count = (unsigned int )toread;
#line 967
  return ((int )out->unit_count);
}
}
#line 982 "Queries.c"
js_string *squeeze_to_fit(js_string *packet ) 
{ q_header hdr ;
  int qd ;
  int an ;
  int ns ;
  int ar ;
  int qc ;
  int count ;
  int offset ;
  int tmp ;
  int len ;
  int len___0 ;

  {
#line 988
  tmp = read_hdr(packet, & hdr);
#line 988
  if (tmp == -1) {
#line 989
    return ((js_string *)0);
  }
#line 992
  qd = (int )hdr.qdcount;
#line 993
  an = (int )hdr.ancount;
#line 994
  ns = (int )hdr.nscount;
#line 995
  ar = (int )hdr.arcount;
#line 1002
  if (hdr.tc == 1) {
#line 1002
    goto _L;
  } else
#line 1002
  if (ns == 0) {
#line 1002
    if (ar == 0) {
      _L: /* CIL Label */ 
#line 1003
      hdr.tc = 1;
#line 1004
      hdr.arcount = (uint16_t )0;
#line 1004
      hdr.nscount = hdr.arcount;
#line 1004
      hdr.ancount = hdr.nscount;
#line 1004
      hdr.qdcount = hdr.ancount;
#line 1005
      make_hdr(& hdr, packet);
#line 1006
      return (packet);
    }
  }
#line 1009
  qc = qd;
#line 1010
  count = (an + ns) + ar;
#line 1011
  offset = 12;
#line 1013
  while (qc > 0) {
#line 1015
    len = dlabel_length(packet, (unsigned int )offset);
#line 1016
    if (len == -1) {
#line 1017
      hdr.tc = 1;
#line 1018
      hdr.arcount = (uint16_t )0;
#line 1018
      hdr.nscount = hdr.arcount;
#line 1018
      hdr.ancount = hdr.nscount;
#line 1018
      hdr.qdcount = hdr.ancount;
#line 1020
      make_hdr(& hdr, packet);
#line 1021
      return (packet);
    }
#line 1023
    len += 4;
#line 1024
    offset += len;
#line 1025
    if ((unsigned int )offset >= packet->unit_count) {
#line 1026
      hdr.tc = 1;
#line 1027
      hdr.arcount = (uint16_t )0;
#line 1027
      hdr.nscount = hdr.arcount;
#line 1027
      hdr.ancount = hdr.nscount;
#line 1027
      hdr.qdcount = hdr.ancount;
#line 1029
      make_hdr(& hdr, packet);
#line 1030
      return (packet);
    }
#line 1032
    qc --;
  }
#line 1036
  while (count > 1) {
#line 1038
    len___0 = dlabel_length(packet, (unsigned int )offset);
#line 1039
    if (len___0 == -1) {
#line 1040
      hdr.tc = 1;
#line 1041
      hdr.arcount = (uint16_t )0;
#line 1041
      hdr.nscount = hdr.arcount;
#line 1041
      hdr.ancount = hdr.nscount;
#line 1041
      hdr.qdcount = hdr.ancount;
#line 1043
      make_hdr(& hdr, packet);
#line 1044
      return (packet);
    }
#line 1046
    len___0 += 8;
#line 1047
    offset += len___0;
#line 1048
    if ((unsigned int )(offset + 2) >= packet->unit_count) {
#line 1049
      hdr.tc = 1;
#line 1050
      hdr.arcount = (uint16_t )0;
#line 1050
      hdr.nscount = hdr.arcount;
#line 1050
      hdr.ancount = hdr.nscount;
#line 1050
      hdr.qdcount = hdr.ancount;
#line 1052
      make_hdr(& hdr, packet);
#line 1053
      return (packet);
    }
#line 1057
    len___0 = (((int )*(packet->string + offset) & 255) << 8) + (int )*((packet->string + offset) + 1);
#line 1059
    offset += len___0 + 2;
#line 1060
    if ((unsigned int )offset >= packet->unit_count) {
#line 1061
      hdr.tc = 1;
#line 1062
      hdr.arcount = (uint16_t )0;
#line 1062
      hdr.nscount = hdr.arcount;
#line 1062
      hdr.ancount = hdr.nscount;
#line 1062
      hdr.qdcount = hdr.ancount;
#line 1064
      make_hdr(& hdr, packet);
#line 1065
      return (packet);
    }
#line 1067
    count --;
  }
#line 1072
  if (ar > 0) {
#line 1073
    ar --;
#line 1074
    hdr.arcount = (uint16_t )ar;
  } else
#line 1075
  if (ns > 0) {
#line 1076
    ns --;
#line 1077
    hdr.nscount = (uint16_t )ns;
  } else {
#line 1079
    hdr.tc = 1;
#line 1080
    hdr.arcount = (uint16_t )0;
#line 1080
    hdr.nscount = hdr.arcount;
#line 1080
    hdr.ancount = hdr.nscount;
#line 1080
    hdr.qdcount = hdr.ancount;
#line 1081
    make_hdr(& hdr, packet);
#line 1082
    return (packet);
  }
#line 1085
  hdr.tc = 0;
#line 1086
  make_hdr(& hdr, packet);
#line 1087
  packet->unit_count = (unsigned int )offset;
#line 1088
  return (packet);
}
}
#line 1 "Compress.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-gmCdH9BA.i","")
#line 37 "Compress.c"
js_string *decomp_get_label(js_string *compressed , unsigned int compressed_offset ) ;
#line 39
rrdesc **decomp_export_rrformats(void) ;
#line 40
char *decomp_get_rrdesc(int rr_num ) ;
#line 64 "Compress.c"
compress_state *compress_init_state(js_string *uncompressed ) 
{ compress_state *new ;
  int tmp ;
  void *tmp___0 ;
  js_string *tmp___1 ;
  int *tmp___2 ;
  void *tmp___3 ;

  {
#line 68
  tmp = js_has_sanity(uncompressed);
#line 68
  if (tmp != 1) {
#line 69
    return ((compress_state *)0);
  }
#line 72
  tmp___0 = js_alloc(1, (int )sizeof(compress_state ));
#line 72
  new = (compress_state *)tmp___0;
#line 72
  if ((unsigned long )new == (unsigned long )((compress_state *)0)) {
#line 73
    return ((compress_state *)0);
  }
#line 76
  new->uncompressed_offset = 0U;
#line 77
  new->this_dlabel_begin = 0U;
#line 78
  new->this_rdlength_begin = 0U;
#line 79
  new->this_rr_type = 0;
#line 80
  new->current_rdlength = 0;
#line 81
  new->valid_state = 1;
#line 82
  new->number_answers = 0;
#line 83
  new->uncompressed = uncompressed;
#line 86
  tmp___1 = js_create(516U, 1U);
#line 86
  new->compressed = tmp___1;
#line 86
  if ((unsigned long )tmp___1 == (unsigned long )((js_string *)0)) {
#line 87
    js_dealloc((void *)new);
#line 88
    return ((compress_state *)0);
  }
#line 90
  tmp___3 = js_alloc(163, (int )sizeof(int ));
#line 90
  tmp___2 = (int *)tmp___3;
#line 90
  new->dlabel_points = tmp___2;
#line 90
  if ((unsigned long )tmp___2 == (unsigned long )((int *)0)) {
#line 92
    js_destroy(new->compressed);
#line 93
    js_dealloc((void *)new);
#line 94
    return ((compress_state *)0);
  }
#line 96
  *(new->dlabel_points + 0) = 0;
#line 99
  return (new);
}
}
#line 110 "Compress.c"
js_string *compress_get_dlabel(js_string *packet , int offset ) 
{ js_string *tmp ;

  {
#line 111
  tmp = decomp_get_label(packet, (unsigned int )offset);
#line 111
  return (tmp);
}
}
#line 122 "Compress.c"
int compress_compare_dlabels(js_string *packet1 , js_string *packet2 , int offset1 ,
                             int offset2 ) 
{ js_string *a ;
  js_string *b ;
  int ret ;

  {
#line 127
  a = compress_get_dlabel(packet1, offset1);
#line 128
  if ((unsigned long )a == (unsigned long )((js_string *)0)) {
#line 129
    return (-1);
  }
#line 130
  b = compress_get_dlabel(packet2, offset2);
#line 131
  if ((unsigned long )b == (unsigned long )((js_string *)0)) {
#line 132
    js_destroy(a);
#line 133
    return (-1);
  }
#line 135
  ret = js_issame(a, b);
#line 136
  js_destroy(a);
#line 137
  js_destroy(b);
#line 138
  return (ret);
}
}
#line 157 "Compress.c"
int compress_add_dlabel_points(compress_state *state , int offset ) 
{ int counter ;
  int limit ;
  unsigned int len ;

  {
#line 161
  if ((unsigned long )state == (unsigned long )((compress_state *)0)) {
#line 162
    return (-1);
  }
#line 163
  if (state->valid_state != 1) {
#line 164
    return (-1);
  }
#line 167
  counter = 0;
#line 168
  while (1) {
#line 168
    if (*(state->dlabel_points + counter) != 0) {
#line 168
      if (! (counter < 150)) {
#line 168
        break;
      }
    } else {
#line 168
      break;
    }
#line 170
    counter ++;
  }
#line 174
  limit = 0;
#line 175
  while (limit < 257) {
#line 179
    if ((unsigned int )offset >= (state->compressed)->unit_count) {
#line 180
      state->valid_state = 0;
#line 181
      return (-1);
    }
#line 185
    len = (unsigned int )*((state->compressed)->string + offset);
#line 186
    if (len >= 192U) {
#line 187
      break;
    }
#line 190
    if ((unsigned int )offset + len >= (state->compressed)->unit_count) {
#line 191
      state->valid_state = 0;
#line 192
      return (-1);
    }
#line 194
    if (counter >= 150) {
#line 195
      state->valid_state = 0;
#line 196
      return (-1);
    }
#line 200
    *(state->dlabel_points + counter) = offset;
#line 201
    *(state->dlabel_points + (counter + 1)) = 0;
#line 202
    counter ++;
#line 203
    if (len == 0U) {
#line 204
      break;
    } else
#line 203
    if (len > 63U) {
#line 204
      break;
    }
#line 206
    offset = (int )((unsigned int )offset + len);
#line 207
    offset ++;
#line 210
    limit ++;
  }
#line 214
  if (limit >= 257) {
#line 215
    state->valid_state = 0;
#line 216
    return (-1);
  }
#line 219
  return (1);
}
}
#line 236 "Compress.c"
int compress_sub_dlabel(compress_state *state ) 
{ unsigned int len ;
  unsigned int counter ;
  int tmp ;
  uint16_t compress_pointer ;
  int length ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 241
  if ((unsigned long )state == (unsigned long )((compress_state *)0)) {
#line 242
    return (-1);
  }
#line 244
  if (state->valid_state != 1) {
#line 245
    return (-1);
  }
#line 247
  if (state->uncompressed_offset >= (state->uncompressed)->unit_count) {
#line 248
    state->valid_state = 0;
#line 249
    return (-1);
  }
#line 253
  len = (unsigned int )*((state->uncompressed)->string + state->uncompressed_offset);
#line 254
  if (len == 0U) {
#line 256
    tmp = js_substr_append(state->uncompressed, state->compressed, (int )state->uncompressed_offset,
                           1);
#line 256
    if (tmp != 1) {
#line 258
      state->valid_state = 0;
#line 259
      return (-1);
    }
#line 261
    if (state->uncompressed_offset + 1U > (state->uncompressed)->unit_count) {
#line 264
      state->valid_state = 0;
#line 265
      return (-1);
    } else
#line 261
    if (state->uncompressed_offset + 1U >= (state->uncompressed)->max_count) {
#line 264
      state->valid_state = 0;
#line 265
      return (-1);
    }
#line 267
    if (state->uncompressed_offset == (state->uncompressed)->unit_count) {
#line 268
      return (3);
    }
#line 270
    (state->uncompressed_offset) ++;
#line 271
    return (0);
  }
#line 273
  if (len > 63U) {
#line 274
    state->valid_state = 0;
#line 275
    return (-1);
  } else
#line 273
  if (len < 0U) {
#line 274
    state->valid_state = 0;
#line 275
    return (-1);
  }
#line 277
  if ((state->uncompressed_offset + len) + 1U >= (state->uncompressed)->unit_count) {
#line 280
    state->valid_state = 0;
#line 281
    return (-1);
  } else
#line 277
  if ((state->uncompressed_offset + len) + 1U >= (state->uncompressed)->max_count) {
#line 280
    state->valid_state = 0;
#line 281
    return (-1);
  }
#line 286
  counter = 0U;
#line 287
  while (counter < 155U) {
#line 290
    if (*(state->dlabel_points + counter) == 0) {
#line 291
      break;
    }
#line 295
    if ((unsigned int )*(state->dlabel_points + counter) >= state->this_dlabel_begin) {
#line 296
      break;
    }
#line 300
    tmp___1 = compress_compare_dlabels(state->uncompressed, state->compressed, (int )state->uncompressed_offset,
                                       *(state->dlabel_points + counter));
#line 300
    if (tmp___1 == 1) {
#line 305
      if (*(state->dlabel_points + counter) < 12) {
#line 307
        state->valid_state = 0;
#line 308
        return (-1);
      } else
#line 305
      if (*(state->dlabel_points + counter) >= 16384) {
#line 307
        state->valid_state = 0;
#line 308
        return (-1);
      }
#line 310
      compress_pointer = (uint16_t )*(state->dlabel_points + counter);
#line 311
      compress_pointer = (uint16_t )((int )compress_pointer | 49152);
#line 312
      tmp___0 = js_adduint16(state->compressed, (int )compress_pointer);
#line 312
      if (tmp___0 != 1) {
#line 313
        state->valid_state = 0;
#line 314
        return (-1);
      }
#line 318
      length = dlabel_length(state->uncompressed, state->uncompressed_offset);
#line 320
      if (length == -1) {
#line 321
        state->valid_state = 0;
#line 322
        return (-1);
      }
#line 324
      if (state->uncompressed_offset + (unsigned int )length > (state->uncompressed)->unit_count) {
#line 328
        state->valid_state = 0;
#line 329
        return (-1);
      } else
#line 324
      if (state->uncompressed_offset + (unsigned int )length >= (state->uncompressed)->max_count) {
#line 328
        state->valid_state = 0;
#line 329
        return (-1);
      }
#line 331
      state->uncompressed_offset += (unsigned int )length;
#line 332
      if (state->uncompressed_offset == (state->uncompressed)->unit_count) {
#line 333
        return (3);
      }
#line 335
      return (2);
    }
#line 337
    counter ++;
  }
#line 341
  if (counter >= 155U) {
#line 342
    state->valid_state = 0;
#line 343
    return (-1);
  }
#line 347
  tmp___2 = js_substr_append(state->uncompressed, state->compressed, (int )state->uncompressed_offset,
                             (int )(len + 1U));
#line 347
  if (tmp___2 != 1) {
#line 349
    state->valid_state = 0;
#line 350
    return (-1);
  }
#line 352
  state->uncompressed_offset += len;
#line 353
  (state->uncompressed_offset) ++;
#line 354
  return (1);
}
}
#line 370 "Compress.c"
int compress_dlabel(compress_state *state ) 
{ int offset ;
  int ret ;
  int tmp ;

  {
#line 374
  if (state->valid_state != 1) {
#line 375
    return (-1);
  }
#line 378
  offset = (int )(state->compressed)->unit_count;
#line 379
  state->this_dlabel_begin = state->uncompressed_offset;
#line 381
  ret = 1;
#line 382
  while (ret == 1) {
#line 383
    ret = compress_sub_dlabel(state);
  }
#line 387
  if (ret == 3) {
#line 388
    return (1);
  }
#line 391
  tmp = compress_add_dlabel_points(state, offset);
#line 391
  if (tmp != 1) {
#line 392
    state->valid_state = 0;
#line 393
    return (-1);
  }
#line 396
  return (1);
}
}
#line 411 "Compress.c"
char compress_get_tocomp(int rr_num ) 
{ rrdesc *point ;
  rrdesc **hash ;

  {
#line 414
  hash = decomp_export_rrformats();
#line 415
  if ((unsigned long )hash == (unsigned long )((rrdesc **)0)) {
#line 416
    return ((char)0);
  }
#line 419
  point = *(hash + rr_num % 7);
#line 421
  if ((unsigned long )point == (unsigned long )((rrdesc *)0)) {
#line 422
    return ((char)0);
  }
#line 424
  while (point->rr_num != rr_num) {
#line 425
    point = point->next;
#line 426
    if ((unsigned long )point == (unsigned long )((rrdesc *)0)) {
#line 427
      return ((char)0);
    }
  }
#line 430
  return (point->tocompress);
}
}
#line 446 "Compress.c"
int compress_rddata(compress_state *state ) 
{ char *desc___0 ;
  char to_compress ;
  int subtype ;
  int total ;
  int ctotal ;
  int tmp ;
  int tmp___0 ;
  int len ;
  int point ;
  int tmp___1 ;
  int tmp___2 ;
  int len___0 ;
  int clen ;
  int coffset ;
  int tmp___3 ;
  int len___1 ;
  int tmp___4 ;
  int len___2 ;
  int tmp___5 ;
  unsigned char left ;
  unsigned char right ;
  unsigned int off ;

  {
#line 452
  if (state->valid_state != 1) {
#line 453
    return (-1);
  }
#line 456
  desc___0 = decomp_get_rrdesc(state->this_rr_type);
#line 457
  to_compress = compress_get_tocomp(state->this_rr_type);
#line 459
  if ((unsigned long )desc___0 == (unsigned long )((char *)0)) {
#line 460
    if (state->current_rdlength == 0) {
#line 461
      return (1);
    }
#line 463
    tmp = js_substr_append(state->uncompressed, state->compressed, (int )state->uncompressed_offset,
                           state->current_rdlength);
#line 463
    if (tmp != 1) {
#line 466
      state->valid_state = 0;
#line 467
      return (-1);
    } else {
#line 470
      state->uncompressed_offset += (unsigned int )state->current_rdlength;
#line 471
      return (1);
    }
  } else {
#line 475
    subtype = (int )*desc___0;
#line 476
    total = 0;
#line 477
    ctotal = 0;
#line 478
    while (subtype != 0) {
#line 480
      if (subtype > 0) {
#line 480
        if (subtype < 64) {
#line 481
          tmp___0 = js_substr_append(state->uncompressed, state->compressed, (int )state->uncompressed_offset,
                                     subtype);
#line 481
          if (tmp___0 != 1) {
#line 485
            state->valid_state = 0;
#line 486
            return (-1);
          }
#line 488
          total += subtype;
#line 489
          ctotal += subtype;
#line 490
          state->uncompressed_offset += (unsigned int )subtype;
        } else {
#line 480
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 493
      if (subtype == 64) {
#line 495
        if ((int )to_compress == 0) {
#line 497
          len = dlabel_length(state->uncompressed, state->uncompressed_offset);
#line 499
          if (len < 1) {
#line 500
            state->valid_state = 0;
#line 501
            return (-1);
          }
#line 503
          point = (int )(state->compressed)->unit_count;
#line 504
          tmp___1 = js_substr_append(state->uncompressed, state->compressed, (int )state->uncompressed_offset,
                                     len);
#line 504
          if (tmp___1 != 1) {
#line 508
            state->valid_state = 0;
#line 509
            return (-1);
          }
#line 511
          tmp___2 = compress_add_dlabel_points(state, point);
#line 511
          if (tmp___2 != 1) {
#line 512
            state->valid_state = 0;
#line 513
            return (-1);
          }
#line 515
          state->uncompressed_offset += (unsigned int )len;
#line 516
          total += len;
#line 517
          ctotal += len;
        } else {
#line 521
          len___0 = dlabel_length(state->uncompressed, state->uncompressed_offset);
#line 523
          if (len___0 < 1) {
#line 524
            state->valid_state = 0;
#line 525
            return (-1);
          }
#line 527
          coffset = (int )(state->compressed)->unit_count;
#line 528
          tmp___3 = compress_dlabel(state);
#line 528
          if (tmp___3 != 1) {
#line 529
            state->valid_state = 0;
#line 530
            return (-1);
          }
#line 532
          total += len___0;
#line 533
          clen = dlabel_length(state->compressed, (unsigned int )coffset);
#line 534
          ctotal += clen;
        }
      } else
#line 538
      if (subtype == 65) {
#line 540
        if (state->uncompressed_offset >= (state->uncompressed)->unit_count) {
#line 542
          state->valid_state = 0;
#line 543
          return (-1);
        }
#line 545
        len___1 = (int )*((state->uncompressed)->string + state->uncompressed_offset);
#line 547
        if (len___1 < 0) {
#line 548
          state->valid_state = 0;
#line 549
          return (-1);
        } else
#line 547
        if (len___1 > 256) {
#line 548
          state->valid_state = 0;
#line 549
          return (-1);
        }
#line 551
        tmp___4 = js_substr_append(state->uncompressed, state->compressed, (int )state->uncompressed_offset,
                                   len___1);
#line 551
        if (tmp___4 != 1) {
#line 555
          state->valid_state = 0;
#line 556
          return (-1);
        }
#line 558
        total += len___1;
#line 559
        ctotal += len___1;
#line 560
        state->uncompressed_offset += (unsigned int )len___1;
      } else
#line 563
      if (subtype == 66) {
#line 565
        len___2 = state->current_rdlength - total;
#line 566
        if (len___2 == 0) {
#line 567
          break;
        }
#line 569
        tmp___5 = js_substr_append(state->uncompressed, state->compressed, (int )state->uncompressed_offset,
                                   len___2);
#line 569
        if (tmp___5 != 1) {
#line 573
          state->valid_state = 0;
#line 574
          return (-1);
        }
#line 576
        total += len___2;
#line 577
        ctotal += len___2;
#line 578
        state->uncompressed_offset += (unsigned int )len___2;
      } else {
#line 582
        state->valid_state = 0;
#line 583
        return (-1);
      }
#line 585
      desc___0 ++;
#line 587
      if (subtype != 66) {
#line 588
        subtype = (int )*desc___0;
      } else {
#line 590
        subtype = 0;
      }
    }
#line 593
    if (state->current_rdlength != total) {
#line 594
      state->valid_state = 0;
#line 595
      return (-1);
    }
  }
#line 600
  if (ctotal != total) {
#line 603
    off = state->this_rdlength_begin;
#line 604
    if (ctotal > 65535) {
#line 605
      state->valid_state = 0;
#line 606
      return (-1);
    } else
#line 604
    if (ctotal < 2) {
#line 605
      state->valid_state = 0;
#line 606
      return (-1);
    }
#line 608
    left = (unsigned char )((ctotal >> 8) & 255);
#line 609
    right = (unsigned char )(ctotal & 255);
#line 610
    if (off < 12U) {
#line 611
      state->valid_state = 0;
#line 612
      return (-1);
    } else
#line 610
    if (off >= (state->compressed)->unit_count - 1U) {
#line 611
      state->valid_state = 0;
#line 612
      return (-1);
    }
#line 614
    *((state->compressed)->string + off) = left;
#line 615
    *(((state->compressed)->string + off) + 1) = right;
  }
#line 619
  return (1);
}
}
#line 635 "Compress.c"
int compress_get_uint16(compress_state *state ) 
{ int number ;
  int tmp ;

  {
#line 638
  if (state->valid_state != 1) {
#line 639
    return (-1);
  }
#line 642
  number = js_readuint16(state->uncompressed, state->uncompressed_offset);
#line 643
  if (number == -1) {
#line 644
    state->valid_state = 0;
#line 645
    return (-1);
  }
#line 647
  if (number < 0) {
#line 648
    state->valid_state = 0;
#line 649
    return (-1);
  } else
#line 647
  if (number > 65535) {
#line 648
    state->valid_state = 0;
#line 649
    return (-1);
  }
#line 651
  tmp = js_adduint16(state->compressed, number);
#line 651
  if (tmp != 1) {
#line 652
    state->valid_state = 0;
#line 653
    return (-1);
  }
#line 655
  state->uncompressed_offset += 2U;
#line 656
  if (state->uncompressed_offset > (state->uncompressed)->unit_count) {
#line 657
    state->valid_state = 0;
#line 658
    return (-1);
  }
#line 662
  return (number);
}
}
#line 680 "Compress.c"
int compress_get_type_etc(compress_state *state ) 
{ int number ;
  uint32_t tmp ;
  int tmp___0 ;

  {
#line 683
  if (state->valid_state != 1) {
#line 684
    return (-1);
  }
#line 688
  number = compress_get_uint16(state);
#line 689
  if (number == -1) {
#line 690
    state->valid_state = 0;
#line 691
    return (-1);
  }
#line 693
  state->this_rr_type = number;
#line 696
  number = compress_get_uint16(state);
#line 697
  if (number == -1) {
#line 698
    state->valid_state = 0;
#line 699
    return (-1);
  }
#line 703
  tmp = js_readuint32(state->uncompressed, state->uncompressed_offset);
#line 703
  number = (int )tmp;
#line 704
  if ((unsigned int )number == 4294967295U) {
#line 705
    state->valid_state = 0;
#line 706
    return (-1);
  }
#line 708
  tmp___0 = js_adduint32(state->compressed, (uint32_t )number);
#line 708
  if (tmp___0 != 1) {
#line 709
    state->valid_state = 0;
#line 710
    return (-1);
  }
#line 712
  state->uncompressed_offset += 4U;
#line 713
  if (state->uncompressed_offset >= (state->uncompressed)->unit_count) {
#line 714
    state->valid_state = 0;
#line 715
    return (-1);
  }
#line 719
  return (1);
}
}
#line 730 "Compress.c"
int compress_get_header(compress_state *state ) 
{ int qdcount ;
  int ancount ;
  int nscount ;
  int arcount ;
  int total ;
  int tmp ;

  {
#line 737
  if (state->valid_state != 1) {
#line 738
    return (-1);
  }
#line 741
  if (state->uncompressed_offset != 0U) {
#line 742
    state->valid_state = 0;
#line 743
    return (-1);
  }
#line 747
  tmp = js_substr_append(state->uncompressed, state->compressed, 0, 4);
#line 747
  if (tmp != 1) {
#line 749
    state->valid_state = 0;
#line 750
    return (-1);
  }
#line 754
  state->uncompressed_offset += 4U;
#line 755
  if (state->uncompressed_offset >= (state->uncompressed)->unit_count) {
#line 756
    state->valid_state = 0;
#line 757
    return (-1);
  }
#line 761
  qdcount = compress_get_uint16(state);
#line 762
  if (qdcount == -1) {
#line 763
    state->valid_state = 0;
#line 764
    return (-1);
  }
#line 768
  ancount = compress_get_uint16(state);
#line 769
  if (ancount == -1) {
#line 770
    state->valid_state = 0;
#line 771
    return (-1);
  }
#line 775
  nscount = compress_get_uint16(state);
#line 776
  if (nscount == -1) {
#line 777
    state->valid_state = 0;
#line 778
    return (-1);
  }
#line 782
  arcount = compress_get_uint16(state);
#line 783
  if (arcount == -1) {
#line 784
    state->valid_state = 0;
#line 785
    return (-1);
  }
#line 790
  if (qdcount < 0) {
#line 791
    state->valid_state = 0;
#line 792
    return (-1);
  } else
#line 790
  if (qdcount > 1) {
#line 791
    state->valid_state = 0;
#line 792
    return (-1);
  }
#line 794
  total = (ancount + nscount) + arcount;
#line 797
  if (total != 0) {
#line 797
    if (qdcount != 1) {
#line 798
      state->valid_state = 0;
#line 799
      return (-1);
    }
  }
#line 802
  if (qdcount == 0) {
#line 803
    state->number_answers = -2;
#line 804
    return (1);
  }
#line 807
  state->number_answers = total;
#line 808
  return (1);
}
}
#line 820 "Compress.c"
int compress_get_question(compress_state *state ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 823
  if (state->valid_state != 1) {
#line 824
    return (-1);
  }
#line 826
  if (state->uncompressed_offset != 12U) {
#line 827
    state->valid_state = 0;
#line 828
    return (-1);
  }
#line 831
  if (state->number_answers == -2) {
#line 832
    return (1);
  }
#line 836
  tmp = compress_dlabel(state);
#line 836
  if (tmp != 1) {
#line 837
    state->valid_state = 0;
#line 838
    return (-1);
  }
#line 841
  tmp___0 = compress_get_uint16(state);
#line 841
  if (tmp___0 == -1) {
#line 842
    state->valid_state = 0;
#line 843
    return (-1);
  }
#line 846
  tmp___1 = compress_get_uint16(state);
#line 846
  if (tmp___1 == -1) {
#line 847
    state->valid_state = 0;
#line 848
    return (-1);
  }
#line 851
  return (1);
}
}
#line 858 "Compress.c"
int compress_get_rdlength(compress_state *state ) 
{ int number ;

  {
#line 862
  state->this_rdlength_begin = (state->compressed)->unit_count;
#line 864
  number = compress_get_uint16(state);
#line 865
  if (number == -1) {
#line 866
    state->valid_state = 0;
#line 867
    return (-1);
  }
#line 869
  state->current_rdlength = number;
#line 871
  return (1);
}
}
#line 880 "Compress.c"
int compress_answers(compress_state *state ) 
{ int counter ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 883
  if (state->valid_state != 1) {
#line 884
    return (-1);
  }
#line 887
  counter = 0;
#line 887
  while (counter < state->number_answers) {
#line 888
    tmp = compress_dlabel(state);
#line 888
    if (tmp == -1) {
#line 889
      state->valid_state = 0;
#line 890
      return (-1);
    }
#line 892
    tmp___0 = compress_get_type_etc(state);
#line 892
    if (tmp___0 == -1) {
#line 893
      state->valid_state = 0;
#line 894
      return (-1);
    }
#line 896
    tmp___1 = compress_get_rdlength(state);
#line 896
    if (tmp___1 == -1) {
#line 897
      state->valid_state = 0;
#line 898
      return (-1);
    }
#line 900
    tmp___2 = compress_rddata(state);
#line 900
    if (tmp___2 == -1) {
#line 901
      state->valid_state = 0;
#line 902
      return (-1);
    }
#line 887
    counter ++;
  }
#line 905
  return (1);
}
}
#line 916 "Compress.c"
js_string *compress_destroy_state(compress_state *state ) 
{ js_string *ret ;

  {
#line 918
  js_dealloc((void *)state->dlabel_points);
#line 919
  ret = state->compressed;
#line 920
  js_dealloc((void *)state);
#line 921
  return (ret);
}
}
#line 937 "Compress.c"
int compress_data(js_string *in , js_string *out ) 
{ js_string *compressed ;
  compress_state *state ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 941
  state = compress_init_state(in);
#line 942
  if ((unsigned long )state == (unsigned long )((compress_state *)0)) {
#line 943
    return (-1);
  }
#line 949
  tmp = compress_get_header(state);
#line 949
  if (tmp == -1) {
#line 950
    compressed = compress_destroy_state(state);
#line 951
    js_destroy(compressed);
#line 952
    return (-1);
  }
#line 955
  tmp___0 = compress_get_question(state);
#line 955
  if (tmp___0 == -1) {
#line 956
    compressed = compress_destroy_state(state);
#line 957
    js_destroy(compressed);
#line 958
    return (-1);
  }
#line 961
  tmp___1 = compress_answers(state);
#line 961
  if (tmp___1 == -1) {
#line 962
    compressed = compress_destroy_state(state);
#line 963
    js_destroy(compressed);
#line 964
    return (-1);
  }
#line 967
  compressed = compress_destroy_state(state);
#line 973
  tmp___2 = js_copy(compressed, out);
#line 973
  if (tmp___2 == -1) {
#line 974
    js_destroy(compressed);
#line 975
    return (-1);
  }
#line 978
  js_destroy(compressed);
#line 979
  return (1);
}
}
#line 1 "bobbit.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-YxyacqW1.i","")
#line 30 "bobbit.c"
int bobbit_label(js_string *js ) 
{ int counter ;
  unsigned char length ;

  {
#line 31
  counter = 0;
#line 34
  if (js->unit_size != 1U) {
#line 35
    return (-1);
  }
#line 36
  if (js->unit_count >= js->max_count) {
#line 37
    return (-1);
  }
#line 38
  if (js->unit_count < 1U) {
#line 39
    return (-1);
  }
#line 41
  length = *(js->string);
#line 43
  if ((int )length == 95) {
#line 44
    length = (unsigned char)0;
  } else
#line 45
  if ((unsigned int )((int )length + 1) > js->unit_count) {
#line 46
    return (-1);
  } else
#line 45
  if ((int )length > 63) {
#line 46
    return (-1);
  } else
#line 47
  if ((int )length == 0) {
#line 48
    return (0);
  }
#line 50
  length = (unsigned char )((int )length + 1);
#line 52
  while ((unsigned int )counter < js->unit_count - (unsigned int )length) {
#line 53
    *(js->string + counter) = *((js->string + counter) + (int )length);
#line 54
    counter ++;
  }
#line 57
  js->unit_count -= (unsigned int )length;
#line 59
  return (1);
}
}
#line 1 "Decompress.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-oZq7FCpO.i","")
#line 40 "Compress_rrdescs.h"
char *rr_descs[17]  = 
#line 40 "Compress_rrdescs.h"
  {      (char *)":1|A|4|N|en;IPv4 Addresses [RFC 1035];",      (char *)":15|MX|2;D|C|en;Mail exchanger records [RFC 1035];",      (char *)":2|NS|D|C|en;NS (name server) records [RFC 1035];",      (char *)":6|SOA|D;D;4;4;4;4;4|C|en;SOA records [RFC 1035];", 
        (char *)":12|PTR|D|C|en;Reverse DNS lookup records [RFC 1035];",      (char *)":16|TXT|T;V|N|en;Text data [RFC 1035];",      (char *)":5|CNAME|D|C|en;CNAME records [RFC 1035];",      (char *)":3|MD|D|N|en;[RFC 1035];", 
        (char *)":4|MF|D|N|en;[RFC 1035];",      (char *)":7|MB|D|N|en;[RFC 1035];",      (char *)":8|MG|D|N|en;[RFC 1035];",      (char *)":9|MR|D|N|en;[RFC 1035];", 
        (char *)":14|MINFO|D;D|N|en;[RFC 1035];",      (char *)":17|RP|D;D|N|en;[RFC 1183];",      (char *)":18|AFSDB|2;D|N|en;[RFC 1183];",      (char *)":21|RT|2;D|N|en;[RFC 1183];", 
        (char *)":33|SRV|2;2;2;D|N|en;Service [RFC 2052];"};
#line 31 "Decompress.c"
rrdesc **rr_formats  ;
#line 34 "Decompress.c"
int dlog_level  =    -1;
#line 45 "Decompress.c"
int decomp_message(char *message , int min_log_level ) 
{ 

  {
#line 46
  if (dlog_level >= min_log_level) {
#line 47
    show_timestamp();
#line 48
    printf("%s\n", message);
  }
#line 50
  return (1);
}
}
#line 68 "Decompress.c"
js_string *decomp_get_label(js_string *compressed , unsigned int compressed_offset ) 
{ js_string *ret ;
  int counter ;
  int cplace ;
  int cplace_save ;
  int dplace ;
  int limit ;

  {
#line 73
  decomp_message((char *)"Performing sanity checks on compressed string...", 5);
#line 76
  if ((unsigned long )compressed == (unsigned long )((js_string *)0)) {
#line 77
    return ((js_string *)0);
  }
#line 78
  if (compressed->unit_size != 1U) {
#line 79
    return ((js_string *)0);
  }
#line 80
  if (compressed->unit_count > compressed->max_count) {
#line 81
    return ((js_string *)0);
  }
#line 82
  if (compressed_offset > compressed->unit_count) {
#line 83
    return ((js_string *)0);
  }
#line 85
  decomp_message((char *)"Compressed string is sane.  Initializing variables...",
                 5);
#line 88
  cplace = (int )compressed_offset;
#line 89
  cplace_save = cplace;
#line 90
  dplace = 0;
#line 91
  counter = 0;
#line 92
  limit = 0;
#line 93
  ret = js_create(259U, 1U);
#line 93
  if ((unsigned long )ret == (unsigned long )((js_string *)0)) {
#line 94
    return ((js_string *)0);
  }
#line 96
  decomp_message((char *)"Variables initalized.", 5);
#line 99
  while (1) {
#line 100
    if ((unsigned int )cplace >= compressed->unit_count) {
#line 101
      js_destroy(ret);
#line 102
      return ((js_string *)0);
    }
#line 104
    limit ++;
#line 105
    counter = (int )*(compressed->string + cplace);
#line 107
    if (counter > 63) {
#line 107
      if (counter < 192) {
#line 108
        decomp_message((char *)"Invalid length value in compressed string", 4);
#line 109
        js_destroy(ret);
#line 110
        return ((js_string *)0);
      } else {
#line 107
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 112
    if (counter >= 192) {
#line 114
      if ((unsigned int )(cplace + 1) >= compressed->unit_count) {
#line 115
        decomp_message((char *)"Compression pointer isn\'t fitting", 4);
#line 116
        js_destroy(ret);
#line 117
        return ((js_string *)0);
      }
#line 120
      cplace_save = cplace;
#line 121
      cplace = (counter & 63) << 8;
#line 122
      cplace |= (int )*((compressed->string + cplace_save) + 1);
#line 124
      if (cplace >= cplace_save) {
#line 125
        decomp_message((char *)"Compressed pointer goes forward", 4);
#line 126
        js_destroy(ret);
#line 127
        return ((js_string *)0);
      }
#line 130
      if (cplace < 12) {
#line 131
        decomp_message((char *)"Compressed pointer points to header", 4);
#line 132
        js_destroy(ret);
#line 133
        return ((js_string *)0);
      }
    } else
#line 137
    if (counter > 0) {
#line 137
      if (counter <= 63) {
#line 138
        counter ++;
#line 139
        if ((unsigned int )(dplace + counter) >= ret->max_count) {
#line 140
          decomp_message((char *)"Pointing past end of ret string", 4);
#line 141
          js_destroy(ret);
#line 142
          return ((js_string *)0);
        }
#line 144
        if ((unsigned int )(cplace + counter) >= compressed->unit_count) {
#line 145
          decomp_message((char *)"Pointing past end of compressed string", 4);
#line 146
          js_destroy(ret);
#line 147
          return ((js_string *)0);
        }
#line 149
        while (counter > 0) {
#line 150
          *(ret->string + dplace) = *(compressed->string + cplace);
#line 151
          (ret->unit_count) ++;
#line 152
          dplace ++;
#line 153
          cplace ++;
#line 154
          counter --;
        }
#line 156
        counter = 100;
      } else {
#line 137
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 158
    if (counter == 0) {
#line 159
      if ((unsigned int )(dplace + counter) >= ret->max_count) {
#line 160
        decomp_message((char *)"Pointing past end of the compressed string", 4);
#line 161
        js_destroy(ret);
#line 162
        return ((js_string *)0);
      }
#line 164
      *(ret->string + dplace) = (unsigned char)0;
#line 165
      (ret->unit_count) ++;
    } else {
#line 168
      decomp_message((char *)"This, folks, should never happen", 4);
#line 169
      js_destroy(ret);
#line 170
      return ((js_string *)0);
    }
#line 99
    if (counter > 0) {
#line 99
      if (! (limit < 256)) {
#line 99
        break;
      }
    } else {
#line 99
      break;
    }
  }
#line 174
  if (limit >= 256) {
#line 175
    decomp_message((char *)"Limit exceeded when decompressing dlabel", 4);
#line 176
    js_destroy(ret);
#line 177
    return ((js_string *)0);
  }
#line 182
  return (ret);
}
}
#line 202 "Decompress.c"
int decomp_append_dlabel(js_string *compressed , js_string *uncompressed , unsigned int compressed_offset ) 
{ js_string *dlabel ;
  int length ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 206
  length = 0;
#line 209
  tmp = js_has_sanity(compressed);
#line 209
  if (tmp != 1) {
#line 210
    return (-1);
  }
#line 212
  tmp___0 = js_has_sanity(uncompressed);
#line 212
  if (tmp___0 != 1) {
#line 213
    return (-1);
  }
#line 215
  if (compressed->unit_size != 1U) {
#line 216
    return (-1);
  }
#line 218
  if (uncompressed->unit_size != 1U) {
#line 219
    return (-1);
  }
#line 221
  if (compressed_offset >= compressed->unit_count) {
#line 222
    return (-1);
  }
#line 226
  dlabel = decomp_get_label(compressed, compressed_offset);
#line 227
  if ((unsigned long )dlabel == (unsigned long )((js_string *)0)) {
#line 228
    return (-1);
  }
#line 230
  length = dlabel_length(compressed, compressed_offset);
#line 231
  if (length == -1) {
#line 232
    js_destroy(dlabel);
#line 233
    return (-1);
  }
#line 237
  tmp___1 = js_append(dlabel, uncompressed);
#line 237
  if (tmp___1 == -1) {
#line 238
    js_destroy(dlabel);
#line 239
    return (-1);
  }
#line 243
  js_destroy(dlabel);
#line 244
  return (length);
}
}
#line 271 "Decompress.c"
int decomp_append_bytes(js_string *compressed , js_string *uncompressed , unsigned int compressed_offset ,
                        int length ) 
{ js_string *temp ;
  int tmp ;
  int tmp___0 ;

  {
#line 275
  temp = js_create((unsigned int )(length + 2), 1U);
#line 275
  if ((unsigned long )temp == (unsigned long )((js_string *)0)) {
#line 276
    return (-1);
  }
#line 279
  if (compressed->unit_count < compressed_offset + (unsigned int )length) {
#line 280
    js_destroy(temp);
#line 281
    return (-1);
  }
#line 284
  tmp = js_substr(compressed, temp, (int )compressed_offset, length);
#line 284
  if (tmp != 1) {
#line 285
    js_destroy(temp);
#line 286
    return (-1);
  }
#line 289
  tmp___0 = js_append(temp, uncompressed);
#line 289
  if (tmp___0 == -1) {
#line 290
    js_destroy(temp);
#line 291
    return (-1);
  }
#line 294
  js_destroy(temp);
#line 295
  return (1);
}
}
#line 319 "Decompress.c"
int decomp_get_type_etc(js_string *compressed , js_string *uncompressed , unsigned int compressed_offset ) 
{ int type ;
  int tmp ;

  {
#line 324
  type = js_readuint16(compressed, compressed_offset);
#line 326
  tmp = decomp_append_bytes(compressed, uncompressed, compressed_offset, 8);
#line 326
  if (tmp != 1) {
#line 328
    return (-1);
  }
#line 331
  return (type);
}
}
#line 354 "Decompress.c"
int decomp_get_rdlength(js_string *compressed , unsigned int compressed_offset ) 
{ int rdlength ;

  {
#line 359
  rdlength = js_readuint16(compressed, compressed_offset);
#line 361
  return (rdlength);
}
}
#line 385 "Decompress.c"
int decomp_get_header(js_string *compressed , js_string *uncompressed ) 
{ int qdcount ;
  int ancount ;
  int nscount ;
  int arcount ;
  int total ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 389
  tmp = js_has_sanity(compressed);
#line 389
  if (tmp == -1) {
#line 390
    return (-1);
  }
#line 392
  tmp___0 = js_has_sanity(uncompressed);
#line 392
  if (tmp___0 == -1) {
#line 393
    return (-1);
  }
#line 395
  if (compressed->unit_count < 12U) {
#line 396
    return (-1);
  }
#line 398
  if (uncompressed->unit_count != 0U) {
#line 399
    return (-1);
  }
#line 403
  qdcount = js_readuint16(compressed, 4U);
#line 404
  if (qdcount < 0) {
#line 405
    return (-1);
  } else
#line 404
  if (qdcount > 1) {
#line 405
    return (-1);
  }
#line 408
  ancount = js_readuint16(compressed, 6U);
#line 409
  if (ancount < 0) {
#line 410
    return (-1);
  } else
#line 409
  if (ancount > 65535) {
#line 410
    return (-1);
  }
#line 411
  nscount = js_readuint16(compressed, 8U);
#line 412
  if (nscount < 0) {
#line 413
    return (-1);
  } else
#line 412
  if (nscount > 65535) {
#line 413
    return (-1);
  }
#line 414
  arcount = js_readuint16(compressed, 10U);
#line 415
  if (arcount < 0) {
#line 416
    return (-1);
  } else
#line 415
  if (arcount > 65535) {
#line 416
    return (-1);
  }
#line 418
  total = (ancount + nscount) + arcount;
#line 421
  tmp___1 = decomp_append_bytes(compressed, uncompressed, 0U, 12);
#line 421
  if (tmp___1 != 1) {
#line 422
    return (-1);
  }
#line 425
  if (qdcount == 0) {
#line 425
    if (total >= 1) {
#line 426
      return (-2 - total);
    }
  }
#line 429
  if (qdcount == 0) {
#line 430
    return (-2);
  }
#line 432
  return (total);
}
}
#line 453 "Decompress.c"
int decomp_get_question(js_string *compressed , js_string *uncompressed ) 
{ int length ;
  int tmp ;

  {
#line 457
  if (compressed->unit_count < 12U) {
#line 458
    return (-1);
  }
#line 461
  if (uncompressed->unit_count != 12U) {
#line 462
    return (-1);
  }
#line 466
  length = decomp_append_dlabel(compressed, uncompressed, 12U);
#line 467
  if (length < 1) {
#line 468
    return (-1);
  }
#line 472
  tmp = decomp_append_bytes(compressed, uncompressed, (unsigned int )(12 + length),
                            4);
#line 472
  if (tmp != 1) {
#line 474
    return (-1);
  }
#line 477
  length += 4;
#line 479
  return (length);
}
}
#line 502 "Decompress.c"
int decomp_init_rrdesc(void) 
{ int counter ;
  void *tmp ;

  {
#line 505
  tmp = js_alloc(7, (int )sizeof(rrdesc *));
#line 505
  rr_formats = (rrdesc **)tmp;
#line 505
  if ((unsigned long )rr_formats == (unsigned long )((rrdesc **)0)) {
#line 506
    return (-1);
  }
#line 509
  counter = 0;
#line 509
  while (counter < 7) {
#line 510
    *(rr_formats + counter) = (rrdesc *)0;
#line 509
    counter ++;
  }
#line 512
  return (1);
}
}
#line 537 "Decompress.c"
int decomp_add_rrdesc(js_string *desc___0 ) 
{ int rtype ;
  int place ;
  int counter ;
  int fieldnum ;
  int subfieldnum ;
  unsigned char c ;
  rrdesc *new ;
  rrdesc *point ;
  int tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  unsigned int tmp___3 ;

  {
#line 543
  tmp = js_has_sanity(desc___0);
#line 543
  if (tmp != 1) {
#line 544
    return (-1);
  }
#line 545
  js_set_encode(desc___0, 2);
#line 548
  tmp___0 = js_alloc(1, (int )sizeof(rrdesc ));
#line 548
  new = (rrdesc *)tmp___0;
#line 548
  if ((unsigned long )new == (unsigned long )((rrdesc *)0)) {
#line 549
    return (-1);
  }
#line 554
  tmp___2 = js_alloc(16, 1);
#line 554
  tmp___1 = (char *)tmp___2;
#line 554
  new->description = tmp___1;
#line 554
  if ((unsigned long )tmp___1 == (unsigned long )((char *)0)) {
#line 555
    js_dealloc((void *)new);
#line 556
    return (-1);
  }
#line 559
  counter = 0;
#line 559
  while (counter < 15) {
#line 560
    *(new->description + counter) = (char)0;
#line 559
    counter ++;
  }
#line 567
  new->tocompress = (char)79;
#line 570
  subfieldnum = 1;
#line 570
  fieldnum = subfieldnum;
#line 571
  rtype = -1;
#line 572
  counter = 0;
#line 572
  while ((unsigned int )counter < desc___0->unit_count) {
#line 573
    c = *(desc___0->string + counter);
#line 574
    if (fieldnum == 1) {
#line 575
      if (subfieldnum == 1) {
#line 576
        if ((int )c == 58) {
#line 577
          subfieldnum ++;
        }
      } else
#line 580
      if (subfieldnum == 2) {
#line 581
        if (rtype == -1) {
#line 582
          tmp___3 = js_atoi(desc___0, counter);
#line 582
          rtype = (int )tmp___3;
#line 583
          if (rtype <= 0) {
#line 584
            js_dealloc((void *)new->description);
#line 585
            js_dealloc((void *)new);
#line 586
            return (-1);
          } else
#line 583
          if (rtype > 65535) {
#line 584
            js_dealloc((void *)new->description);
#line 585
            js_dealloc((void *)new);
#line 586
            return (-1);
          }
#line 588
          new->rr_num = rtype;
        }
#line 590
        if ((int )c == 124) {
#line 591
          subfieldnum = 1;
#line 592
          fieldnum = 2;
        }
      }
    } else
#line 596
    if (fieldnum == 2) {
#line 597
      if ((int )c == 124) {
#line 598
        subfieldnum = 1;
#line 599
        fieldnum = 3;
      }
    } else
#line 602
    if (fieldnum == 3) {
#line 604
      if (subfieldnum > 14) {
#line 605
        js_dealloc((void *)new->description);
#line 606
        js_dealloc((void *)new);
#line 607
        return (-1);
      }
#line 612
      if ((int )*(new->description + (subfieldnum - 1)) == 0) {
#line 613
        if ((int )c >= 49) {
#line 613
          if ((int )c <= 57) {
#line 614
            *(new->description + (subfieldnum - 1)) = (char )((int )c - 48);
          } else {
#line 613
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 616
        if ((int )c == 68) {
#line 617
          *(new->description + (subfieldnum - 1)) = (char)64;
        } else
#line 619
        if ((int )c == 84) {
#line 620
          *(new->description + (subfieldnum - 1)) = (char)65;
        } else
#line 622
        if ((int )c == 86) {
#line 623
          *(new->description + (subfieldnum - 1)) = (char)66;
        } else {
#line 626
          js_dealloc((void *)new->description);
#line 627
          js_dealloc((void *)new);
#line 628
          return (-1);
        }
      } else
#line 631
      if ((int )c != 59) {
#line 631
        if ((int )c != 124) {
#line 632
          js_dealloc((void *)new->description);
#line 633
          js_dealloc((void *)new);
#line 634
          return (-1);
        } else {
#line 631
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 636
      if ((int )c == 59) {
#line 638
        if ((int )*(new->description + (subfieldnum - 1)) == 66) {
#line 639
          js_dealloc((void *)new->description);
#line 640
          js_dealloc((void *)new);
#line 641
          return (-1);
        }
#line 643
        subfieldnum ++;
      } else
#line 645
      if ((int )c == 124) {
#line 646
        subfieldnum = 1;
#line 647
        fieldnum = 4;
      } else {
#line 650
        js_dealloc((void *)new->description);
#line 651
        js_dealloc((void *)new);
#line 652
        return (-1);
      }
    } else
#line 655
    if (fieldnum == 4) {
#line 657
      if ((int )c == 67) {
#line 657
        if ((int )new->tocompress == 79) {
#line 658
          new->tocompress = (char)1;
        } else {
#line 657
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 660
      if ((int )c == 78) {
#line 660
        if ((int )new->tocompress == 79) {
#line 661
          new->tocompress = (char)0;
        } else {
#line 660
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 663
      if ((int )c == 124) {
#line 663
        if ((int )new->tocompress != 79) {
#line 664
          subfieldnum = 1;
#line 665
          fieldnum = 5;
        } else {
#line 668
          js_dealloc((void *)new->description);
#line 669
          js_dealloc((void *)new);
#line 670
          return (-4);
        }
      } else {
#line 668
        js_dealloc((void *)new->description);
#line 669
        js_dealloc((void *)new);
#line 670
        return (-4);
      }
    } else
#line 673
    if (fieldnum == 5) {
#line 678
      break;
    }
#line 572
    counter ++;
  }
#line 685
  place = rtype % 7;
#line 686
  if ((unsigned long )rr_formats == (unsigned long )((rrdesc **)0)) {
#line 687
    js_dealloc((void *)new->description);
#line 688
    js_dealloc((void *)new);
#line 689
    return (-1);
  }
#line 691
  point = *(rr_formats + place);
#line 692
  if ((unsigned long )point == (unsigned long )((rrdesc *)0)) {
#line 693
    *(rr_formats + place) = new;
  } else {
#line 696
    while ((unsigned long )point->next != (unsigned long )((struct rrdesc *)0)) {
#line 697
      point = point->next;
    }
#line 698
    point->next = new;
  }
#line 701
  new->next = (struct rrdesc *)0;
#line 704
  return (1);
}
}
#line 728 "Decompress.c"
int decomp_init(int alog_level ) 
{ js_string *temp ;
  int counter ;
  int tmp ;
  int tmp___0 ;

  {
#line 733
  temp = js_create(256U, 1U);
#line 733
  if ((unsigned long )temp == (unsigned long )((js_string *)0)) {
#line 734
    return (-1);
  }
#line 738
  decomp_init_rrdesc();
#line 739
  counter = 0;
#line 739
  while (counter < 17) {
#line 740
    tmp = js_qstr2js(temp, rr_descs[counter]);
#line 740
    if (tmp != 1) {
#line 741
      js_destroy(temp);
#line 742
      return (-1);
    }
#line 744
    tmp___0 = decomp_add_rrdesc(temp);
#line 744
    if (tmp___0 != 1) {
#line 745
      js_destroy(temp);
#line 746
      return (-1);
    }
#line 739
    counter ++;
  }
#line 751
  dlog_level = alog_level;
#line 753
  js_destroy(temp);
#line 754
  return (1);
}
}
#line 783 "Decompress.c"
char *decomp_get_rrdesc(int rr_num ) 
{ rrdesc *point ;

  {
#line 786
  if ((unsigned long )rr_formats == (unsigned long )((rrdesc **)0)) {
#line 787
    return ((char *)0);
  }
#line 789
  point = *(rr_formats + rr_num % 7);
#line 790
  if ((unsigned long )point == (unsigned long )((rrdesc *)0)) {
#line 791
    return ((char *)0);
  }
#line 793
  while (point->rr_num != rr_num) {
#line 794
    point = point->next;
#line 795
    if ((unsigned long )point == (unsigned long )((rrdesc *)0)) {
#line 796
      return ((char *)0);
    }
  }
#line 799
  return (point->description);
}
}
#line 823 "Decompress.c"
int decomp_get_rddata(js_string *compressed , js_string *out , unsigned int compressed_offset ,
                      int type , int rdlength ) 
{ char *desc___0 ;
  int subtype ;
  int total ;
  int len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 829
  desc___0 = decomp_get_rrdesc(type);
#line 831
  if ((unsigned long )desc___0 == (unsigned long )((char *)0)) {
#line 832
    if (rdlength == 0) {
#line 833
      return (1);
    }
#line 835
    tmp = decomp_append_bytes(compressed, out, compressed_offset, rdlength);
#line 835
    if (tmp != 1) {
#line 837
      return (-1);
    } else {
#line 840
      return (1);
    }
  } else {
#line 844
    subtype = (int )*desc___0;
#line 845
    total = 0;
#line 847
    while (subtype != 0) {
#line 849
      if (subtype > 0) {
#line 849
        if (subtype < 64) {
#line 850
          tmp___0 = decomp_append_bytes(compressed, out, compressed_offset, subtype);
#line 850
          if (tmp___0 != 1) {
#line 852
            return (-1);
          }
#line 854
          total += subtype;
#line 855
          compressed_offset += (unsigned int )subtype;
        } else {
#line 849
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 858
      if (subtype == 64) {
#line 859
        len = decomp_append_dlabel(compressed, out, compressed_offset);
#line 861
        if (len == -1) {
#line 862
          return (-1);
        }
#line 864
        total += len;
#line 865
        compressed_offset += (unsigned int )len;
      } else
#line 868
      if (subtype == 65) {
#line 870
        len = (int )*(compressed->string + compressed_offset);
#line 871
        len ++;
#line 873
        if (len < 0) {
#line 874
          return (-1);
        } else
#line 873
        if (len > 256) {
#line 874
          return (-1);
        }
#line 876
        tmp___1 = decomp_append_bytes(compressed, out, compressed_offset, len);
#line 876
        if (tmp___1 != 1) {
#line 879
          return (-1);
        }
#line 881
        total += len;
#line 882
        compressed_offset += (unsigned int )len;
      } else
#line 885
      if (subtype == 66) {
#line 886
        len = rdlength - total;
#line 887
        if (len == 0) {
#line 888
          break;
        }
#line 890
        tmp___2 = decomp_append_bytes(compressed, out, compressed_offset, len);
#line 890
        if (tmp___2 != 1) {
#line 892
          return (-1);
        }
#line 894
        total += len;
#line 895
        compressed_offset += (unsigned int )len;
      } else {
#line 898
        return (-1);
      }
#line 900
      desc___0 ++;
#line 902
      if (subtype != 66) {
#line 903
        subtype = (int )*desc___0;
      } else {
#line 905
        subtype = 0;
      }
    }
#line 908
    if (rdlength != total) {
#line 909
      return (-1);
    }
  }
#line 914
  return (1);
}
}
#line 934 "Decompress.c"
int decomp_decompress_packet(js_string *compressed , js_string *uncompressed ) 
{ int answers ;
  int type ;
  int rdlength ;
  int offset ;
  int length ;
  js_string *rddata ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 943
  tmp = js_has_sanity(compressed);
#line 943
  if (tmp == -1) {
#line 944
    return (-1);
  }
#line 945
  tmp___0 = js_has_sanity(uncompressed);
#line 945
  if (tmp___0 == -1) {
#line 946
    return (-1);
  }
#line 947
  if (compressed->unit_size != 1U) {
#line 948
    return (-1);
  } else
#line 947
  if (uncompressed->unit_size != 1U) {
#line 948
    return (-1);
  }
#line 949
  if (uncompressed->unit_count != 0U) {
#line 950
    return (-1);
  }
#line 954
  rddata = js_create(512U, 1U);
#line 954
  if ((unsigned long )rddata == (unsigned long )((js_string *)0)) {
#line 955
    return (-1);
  }
#line 964
  answers = decomp_get_header(compressed, uncompressed);
#line 965
  if (answers == -2) {
#line 966
    js_destroy(rddata);
#line 967
    return (1);
  } else
#line 969
  if (answers == -1) {
#line 970
    js_destroy(rddata);
#line 971
    return (-1);
  }
#line 975
  if (answers <= -3) {
#line 976
    answers = -2 - answers;
#line 978
    length = 0;
  } else {
#line 981
    length = decomp_get_question(compressed, uncompressed);
#line 982
    if (length < 1) {
#line 983
      js_destroy(rddata);
#line 984
      return (-1);
    }
  }
#line 988
  offset = 12 + length;
#line 991
  while (answers > 0) {
#line 992
    length = decomp_append_dlabel(compressed, uncompressed, (unsigned int )offset);
#line 993
    if (length < 1) {
#line 994
      js_destroy(rddata);
#line 995
      return (-1);
    }
#line 997
    offset += length;
#line 998
    type = decomp_get_type_etc(compressed, uncompressed, (unsigned int )offset);
#line 999
    if (type == -1) {
#line 1000
      js_destroy(rddata);
#line 1001
      return (-1);
    }
#line 1003
    offset += 8;
#line 1004
    rdlength = decomp_get_rdlength(compressed, (unsigned int )offset);
#line 1005
    if (rdlength == -1) {
#line 1006
      js_destroy(rddata);
#line 1007
      return (-1);
    }
#line 1009
    offset += 2;
#line 1011
    rddata->unit_count = 0U;
#line 1012
    tmp___1 = decomp_get_rddata(compressed, rddata, (unsigned int )offset, type, rdlength);
#line 1012
    if (tmp___1 != 1) {
#line 1014
      js_destroy(rddata);
#line 1015
      return (-1);
    }
#line 1018
    tmp___2 = js_adduint16(uncompressed, (int )rddata->unit_count);
#line 1018
    if (tmp___2 == -1) {
#line 1019
      js_destroy(rddata);
#line 1020
      return (-1);
    }
#line 1023
    tmp___3 = js_append(rddata, uncompressed);
#line 1023
    if (tmp___3 == -1) {
#line 1024
      js_destroy(rddata);
#line 1025
      return (-1);
    }
#line 1027
    offset += rdlength;
#line 1028
    answers --;
  }
#line 1031
  js_destroy(rddata);
#line 1032
  return (1);
}
}
#line 1050 "Decompress.c"
int decompress_data(js_string *compressed , js_string *uncompressed ) 
{ int tmp ;

  {
#line 1052
  uncompressed->unit_count = 0U;
#line 1054
  if (dlog_level >= 5) {
#line 1055
    printf("About to decompress packet: ");
#line 1056
    show_esc_stdout(compressed);
#line 1057
    printf("\n");
  }
#line 1060
  if (dlog_level == -1) {
#line 1061
    return (-1);
  } else {
#line 1064
    tmp = decomp_decompress_packet(compressed, uncompressed);
#line 1064
    return (tmp);
  }
#line 1068
  return (-1);
}
}
#line 1075 "Decompress.c"
rrdesc **decomp_export_rrformats(void) 
{ 

  {
#line 1076
  return (rr_formats);
}
}
#line 1 "ParseMaraRc.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-Wx8P7S6i.i","")
#line 94 "/usr/include/string.h"
extern int strncmp(char const   * , char const   * , size_t  ) ;
#line 36 "ParseMaraRc.c"
char *keywords[55]  = 
#line 36 "ParseMaraRc.c"
  {      (char *)"bind_address",      (char *)"ipv4_bind_addresses",      (char *)"ipv6_bind_address",      (char *)"csv2_synthip_list", 
        (char *)"chroot_dir",      (char *)"debug_response_delay",      (char *)"debug_msg_level",      (char *)"default_rrany_set", 
        (char *)"hide_disclaimer",      (char *)"maradns_uid",      (char *)"maradns_gid",      (char *)"max_ar_chain", 
        (char *)"max_chain",      (char *)"max_glueless_level",      (char *)"max_queries_total",      (char *)"max_tcp_procs", 
        (char *)"max_total",      (char *)"maximum_cache_elements",      (char *)"maxprocs",      (char *)"min_ttl_cname", 
        (char *)"min_ttl",      (char *)"min_visible_ttl",      (char *)"no_fingerprint",      (char *)"random_seed_file", 
        (char *)"recursive_acl",      (char *)"spammers",      (char *)"timeout_seconds",      (char *)"timestamp_type", 
        (char *)"verbose_level",      (char *)"tcp_convert_acl",      (char *)"tcp_convert_server",      (char *)"tcp_convert_recursion", 
        (char *)"reject_aaaa",      (char *)"reject_ptr",      (char *)"verbose_query",      (char *)"csv2_default_zonefile", 
        (char *)"dos_protection_level",      (char *)"no_cname_warnings",      (char *)"long_packet_ipv4",      (char *)"synth_soa_origin", 
        (char *)"synth_soa_serial",      (char *)"bind_star_handling",      (char *)"admin_acl",      (char *)"remote_admin", 
        (char *)"handle_noreply",      (char *)"retry_cycles",      (char *)"csv2_tilde_handling",      (char *)"dns_port", 
        (char *)"upstream_port",      (char *)"recurse_delegation",      (char *)"recurse_min_bind_port",      (char *)"recurse_number_ports", 
        (char *)"max_mem",      (char *)"notthere_ip",      (char *)"zone_transfer_acl"};
#line 153 "ParseMaraRc.c"
int mara_goodjs(js_string *test ) 
{ int tmp ;

  {
#line 154
  tmp = js_has_sanity(test);
#line 154
  if (tmp == -1) {
#line 155
    return (-1);
  }
#line 157
  if (test->unit_size != 1U) {
#line 158
    return (-1);
  }
#line 159
  return (1);
}
}
#line 165 "ParseMaraRc.c"
int is_numeric_js(js_string *test ) 
{ int counter ;
  int tmp ;

  {
#line 167
  tmp = mara_goodjs(test);
#line 167
  if (! tmp) {
#line 168
    return (-1);
  }
#line 170
  if (test->unit_count > test->max_count) {
#line 171
    return (-1);
  }
#line 173
  if (test->unit_count == 0U) {
#line 174
    return (0);
  }
#line 175
  counter = 0;
#line 175
  while ((unsigned int )counter < test->unit_count) {
#line 176
    if ((int )*(test->string + counter) < 48) {
#line 178
      return (0);
    } else
#line 176
    if ((int )*(test->string + counter) > 57) {
#line 178
      return (0);
    }
#line 175
    counter ++;
  }
#line 180
  return (1);
}
}
#line 183 "ParseMaraRc.c"
js_string *kvar[55]  ;
#line 192 "ParseMaraRc.c"
int keyword2num(js_string *keyword ) 
{ int counter ;
  js_string *name ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 193
  counter = 0;
#line 196
  tmp = mara_goodjs(keyword);
#line 196
  if (tmp == -1) {
#line 197
    return (-1);
  }
#line 199
  name = js_create(256U, 1U);
#line 199
  if ((unsigned long )name == (unsigned long )((js_string *)0)) {
#line 200
    return (-1);
  }
#line 202
  js_set_encode(name, 3);
#line 204
  while (counter < 55) {
#line 205
    tmp___0 = js_qstr2js(name, keywords[counter]);
#line 205
    if (tmp___0 == -1) {
#line 206
      js_destroy(name);
#line 207
      return (-1);
    }
#line 209
    js_set_encode(name, 3);
#line 211
    js_set_encode(keyword, 3);
#line 212
    tmp___1 = js_issame(keyword, name);
#line 212
    if (tmp___1) {
#line 213
      js_destroy(name);
#line 214
      return (counter);
    }
#line 216
    counter ++;
  }
#line 219
  js_destroy(name);
#line 220
  return (-2);
}
}
#line 229 "ParseMaraRc.c"
int num2keyword(int num , js_string *keyword ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 230
  tmp = mara_goodjs(keyword);
#line 230
  if (tmp == -1) {
#line 231
    return (-1);
  }
#line 233
  if (num < 0) {
#line 234
    return (-1);
  } else
#line 233
  if (num >= 55) {
#line 234
    return (-1);
  }
#line 236
  tmp___0 = js_qstr2js(keyword, keywords[num]);
#line 236
  return (tmp___0);
}
}
#line 244 "ParseMaraRc.c"
int init_kvars(void) 
{ int counter ;
  js_string *tmp ;

  {
#line 246
  counter = 0;
#line 246
  while (counter < 55) {
#line 247
    tmp = js_create(256U, 1U);
#line 247
    kvar[counter] = tmp;
#line 247
    if ((unsigned long )tmp == (unsigned long )((js_string *)0)) {
#line 248
      return (-1);
    }
#line 249
    js_set_encode(kvar[counter], 3);
#line 246
    counter ++;
  }
#line 251
  return (1);
}
}
#line 263 "ParseMaraRc.c"
int read_kvar(js_string *name , js_string *value___0 ) 
{ int num ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 268
  tmp = mara_goodjs(name);
#line 268
  if (tmp == -1) {
#line 269
    return (-1);
  }
#line 270
  tmp___0 = mara_goodjs(value___0);
#line 270
  if (tmp___0 == -1) {
#line 271
    return (-1);
  }
#line 274
  num = keyword2num(name);
#line 275
  if (num == -1) {
#line 276
    return (-1);
  }
#line 279
  if (num == -2) {
#line 280
    return (num);
  }
#line 283
  tmp___1 = js_copy(kvar[num], value___0);
#line 283
  if (tmp___1 == -1) {
#line 284
    return (-1);
  }
#line 287
  tmp___2 = js_length(kvar[num]);
#line 287
  if (tmp___2 == 0) {
#line 288
    return (0);
  }
#line 290
  return (1);
}
}
#line 300 "ParseMaraRc.c"
int write_kvar(js_string *name , js_string *value___0 , int is_plus ) 
{ int num ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 303
  num = keyword2num(name);
#line 306
  tmp = mara_goodjs(name);
#line 306
  if (tmp == -1) {
#line 307
    return (-1);
  }
#line 308
  tmp___0 = mara_goodjs(value___0);
#line 308
  if (tmp___0 == -1) {
#line 309
    return (-1);
  }
#line 310
  if (num == -1) {
#line 311
    return (-1);
  }
#line 314
  if (num == -2) {
#line 315
    return (num);
  }
#line 318
  if (is_plus != 1) {
#line 319
    tmp___1 = js_copy(value___0, kvar[num]);
#line 319
    if (tmp___1 == -1) {
#line 320
      return (-1);
    }
  } else {
#line 323
    tmp___2 = is_numeric_js(kvar[num]);
#line 323
    if (tmp___2 == 1) {
#line 324
      return (-5);
    }
#line 326
    tmp___3 = js_length(kvar[num]);
#line 326
    if (tmp___3 == 0) {
#line 327
      return (-4);
    }
#line 329
    tmp___4 = js_append(value___0, kvar[num]);
#line 329
    if (tmp___4 == -1) {
#line 330
      return (-1);
    }
  }
#line 334
  return (1);
}
}
#line 342 "ParseMaraRc.c"
char *dkeywords[6]  = {      (char *)"csv1",      (char *)"csv2",      (char *)"root_servers",      (char *)"upstream_servers", 
        (char *)"ipv4_alias",      (char *)"future"};
#line 349 "ParseMaraRc.c"
mhash *dvar[6]  ;
#line 356 "ParseMaraRc.c"
mhash *dvar_raw(int index___0 ) 
{ 

  {
#line 357
  if (index___0 < 0) {
#line 358
    return ((mhash *)0);
  } else
#line 357
  if (index___0 > 6) {
#line 358
    return ((mhash *)0);
  }
#line 359
  return (dvar[index___0]);
}
}
#line 369 "ParseMaraRc.c"
int dq_keyword2n(char *in ) 
{ int counter ;
  int tmp ;

  {
#line 371
  counter = 0;
#line 371
  while (counter < 6) {
#line 372
    tmp = strncmp((char const   *)in, (char const   *)dkeywords[counter], (size_t )128);
#line 372
    if (! tmp) {
#line 373
      return (counter);
    }
#line 371
    counter ++;
  }
#line 375
  return (-2);
}
}
#line 385 "ParseMaraRc.c"
int dkeyword2num(js_string *keyword ) 
{ int counter ;
  js_string *name ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 386
  counter = 0;
#line 389
  tmp = mara_goodjs(keyword);
#line 389
  if (tmp == -1) {
#line 390
    return (-1);
  }
#line 392
  name = js_create(256U, 1U);
#line 392
  if ((unsigned long )name == (unsigned long )((js_string *)0)) {
#line 393
    return (-1);
  }
#line 395
  js_set_encode(name, 3);
#line 397
  while (counter < 6) {
#line 398
    tmp___0 = js_qstr2js(name, dkeywords[counter]);
#line 398
    if (tmp___0 == -1) {
#line 399
      js_destroy(name);
#line 400
      return (-1);
    }
#line 402
    tmp___1 = js_issame(keyword, name);
#line 402
    if (tmp___1) {
#line 403
      js_destroy(name);
#line 404
      return (counter);
    }
#line 406
    counter ++;
  }
#line 409
  js_destroy(name);
#line 410
  return (-2);
}
}
#line 419 "ParseMaraRc.c"
int num2dkeyword(int num , js_string *keyword ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 420
  tmp = mara_goodjs(keyword);
#line 420
  if (tmp == -1) {
#line 421
    return (-1);
  }
#line 423
  if (num < 0) {
#line 424
    return (-1);
  } else
#line 423
  if (num >= 6) {
#line 424
    return (-1);
  }
#line 426
  tmp___0 = js_qstr2js(keyword, dkeywords[num]);
#line 426
  return (tmp___0);
}
}
#line 434 "ParseMaraRc.c"
int init_dvars(void) 
{ int counter ;

  {
#line 437
  counter = 0;
#line 437
  while (counter < 6) {
#line 438
    dvar[counter] = (mhash *)0;
#line 437
    counter ++;
  }
#line 440
  return (1);
}
}
#line 448 "ParseMaraRc.c"
int new_dvar(js_string *name ) 
{ int num ;
  mhash *tmp ;

  {
#line 450
  num = dkeyword2num(name);
#line 451
  if ((unsigned long )dvar[num] != (unsigned long )((mhash *)0)) {
#line 452
    return (-1);
  } else
#line 451
  if (num < 0) {
#line 452
    return (-1);
  } else
#line 451
  if (num > 6) {
#line 452
    return (-1);
  }
#line 453
  tmp = mhash_create(7);
#line 453
  dvar[num] = tmp;
#line 453
  if ((unsigned long )tmp == (unsigned long )((mhash *)0)) {
#line 454
    return (-1);
  }
#line 456
  return (1);
}
}
#line 465 "ParseMaraRc.c"
int read_dvar(js_string *name , js_string *key___0 , js_string *value___0 ) 
{ int num ;
  js_string *place ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 469
  num = dkeyword2num(name);
#line 472
  tmp = mara_goodjs(name);
#line 472
  if (tmp == -1) {
#line 473
    return (-1);
  }
#line 474
  tmp___0 = mara_goodjs(key___0);
#line 474
  if (tmp___0 == -1) {
#line 475
    return (-1);
  }
#line 476
  tmp___1 = mara_goodjs(value___0);
#line 476
  if (tmp___1 == -1) {
#line 477
    return (-1);
  }
#line 478
  if (num == -1) {
#line 479
    return (-1);
  }
#line 480
  if ((unsigned long )dvar[num] == (unsigned long )((mhash *)0)) {
#line 481
    return (-1);
  } else
#line 480
  if (num < 0) {
#line 481
    return (-1);
  } else
#line 480
  if (num > 6) {
#line 481
    return (-1);
  }
#line 484
  if (num == -2) {
#line 485
    return (num);
  }
#line 488
  place = mhash_get_js(dvar[num], key___0);
#line 493
  if ((unsigned long )place == (unsigned long )((js_string *)0)) {
#line 494
    return (-1);
  }
#line 497
  tmp___2 = js_copy(place, value___0);
#line 497
  if (tmp___2 == -1) {
#line 498
    return (-1);
  }
#line 500
  return (1);
}
}
#line 515 "ParseMaraRc.c"
int write_dvar(js_string *name , js_string *key___0 , js_string *value___0 , int is_plus ) 
{ int num ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int y ;
  int z ;
  js_string *tmp___2 ;
  int tmp___3 ;
  js_string *see ;
  js_string *base ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 520
  num = dkeyword2num(name);
#line 523
  tmp = mara_goodjs(name);
#line 523
  if (tmp == -1) {
#line 524
    return (-1);
  }
#line 525
  tmp___0 = mara_goodjs(key___0);
#line 525
  if (tmp___0 == -1) {
#line 526
    return (-1);
  }
#line 527
  tmp___1 = mara_goodjs(value___0);
#line 527
  if (tmp___1 == -1) {
#line 528
    return (-1);
  }
#line 529
  if (num == -1) {
#line 530
    return (-1);
  }
#line 531
  if ((unsigned long )dvar[num] == (unsigned long )((mhash *)0)) {
#line 532
    return (-6);
  }
#line 533
  if (num < 0) {
#line 534
    return (-1);
  } else
#line 533
  if (num > 6) {
#line 534
    return (-1);
  }
#line 537
  if (num == -2) {
#line 538
    return (num);
  }
#line 542
  if (num <= 3) {
#line 544
    y = 0;
#line 545
    z = 0;
#line 545
    while ((unsigned int )z < key___0->unit_count) {
#line 546
      if ((int )*(key___0->string + z) <= 90) {
#line 546
        if ((int )*(key___0->string + z) >= 65) {
#line 547
          y = 1;
#line 548
          *(key___0->string + z) = (unsigned char )((int )*(key___0->string + z) + 32);
        }
      }
#line 545
      z ++;
    }
#line 551
    if (y == 1) {
#line 552
      if (num <= 1) {
#line 553
        printf("csv%d zone name ", num + 1);
      } else
#line 554
      if (num == 2) {
#line 555
        printf("root_servers name ");
      } else
#line 556
      if (num == 3) {
#line 557
        printf("upstream_servers name ");
      } else {
#line 559
        printf("unknown num %d name ", num);
      }
#line 561
      show_esc_stdout(key___0);
#line 562
      printf(" had upper-case letters.  Converted.\n");
    }
  }
#line 567
  tmp___2 = mhash_get_js(dvar[num], key___0);
#line 567
  if ((unsigned long )tmp___2 != (unsigned long )((js_string *)0)) {
#line 567
    if (is_plus != 1) {
#line 568
      return (-3);
    }
  }
#line 571
  if (is_plus != 1) {
#line 572
    tmp___3 = mhash_put_js(dvar[num], key___0, value___0);
#line 572
    if (tmp___3 == -1) {
#line 573
      return (-1);
    }
  } else {
#line 576
    base = mhash_get_js(dvar[num], key___0);
#line 576
    if ((unsigned long )base == (unsigned long )((js_string *)0)) {
#line 577
      return (-4);
    }
#line 579
    tmp___4 = is_numeric_js(base);
#line 579
    if (tmp___4 == 1) {
#line 580
      return (-5);
    }
#line 582
    see = js_create(256U, 1U);
#line 582
    if ((unsigned long )see == (unsigned long )((js_string *)0)) {
#line 583
      return (-1);
    }
#line 585
    tmp___5 = js_set_encode(see, 3);
#line 585
    if (tmp___5 == -1) {
#line 586
      return (-1);
    }
#line 588
    tmp___6 = js_copy(base, see);
#line 588
    if (tmp___6 == -1) {
#line 589
      return (-1);
    }
#line 591
    tmp___7 = js_append(value___0, see);
#line 591
    if (tmp___7 == -1) {
#line 592
      js_destroy(see);
#line 593
      return (-1);
    }
#line 595
    tmp___8 = js_copy(see, value___0);
#line 595
    if (tmp___8 == -1) {
#line 596
      js_destroy(see);
#line 597
      return (-1);
    }
#line 599
    js_destroy(see);
#line 600
    tmp___9 = mhash_undef(dvar[num], key___0);
#line 600
    see = (js_string *)tmp___9;
#line 600
    if ((unsigned long )see == (unsigned long )((js_string *)0)) {
#line 601
      return (-1);
    }
#line 603
    js_destroy(see);
#line 604
    tmp___10 = mhash_put_js(dvar[num], key___0, value___0);
#line 604
    if (tmp___10 == -1) {
#line 605
      return (-1);
    }
  }
#line 610
  tmp___11 = mhash_autogrow(dvar[num]);
#line 610
  return (tmp___11);
}
}
#line 631
int parseline(js_string *line___0 , js_string *var___0 , js_string *key___0 , js_string *value___0 ,
              int *do_plus ) ;
#line 631 "ParseMaraRc.c"
static js_string *quotes  =    (js_string *)0;
#line 631 "ParseMaraRc.c"
static js_string *alphanumeric  =    (js_string *)0;
#line 631 "ParseMaraRc.c"
static js_string *numbers  =    (js_string *)0;
#line 631 "ParseMaraRc.c"
static js_string *equals  =    (js_string *)0;
#line 631 "ParseMaraRc.c"
static js_string *plusq  =    (js_string *)0;
#line 631 "ParseMaraRc.c"
static js_string *hashq  =    (js_string *)0;
#line 631 "ParseMaraRc.c"
static js_string *bslashq  =    (js_string *)0;
#line 631 "ParseMaraRc.c"
static js_string *allq  =    (js_string *)0;
#line 631 "ParseMaraRc.c"
static js_string *leftq  =    (js_string *)0;
#line 631 "ParseMaraRc.c"
static js_string *rightq  =    (js_string *)0;
#line 631 "ParseMaraRc.c"
static js_string *cleftq  =    (js_string *)0;
#line 631 "ParseMaraRc.c"
static js_string *crightq  =    (js_string *)0;
#line 631 "ParseMaraRc.c"
static js_string *blankq  =    (js_string *)0;
#line 628 "ParseMaraRc.c"
int parseline(js_string *line___0 , js_string *var___0 , js_string *key___0 , js_string *value___0 ,
              int *do_plus ) 
{ int quote1 ;
  int quote2 ;
  int quote3 ;
  int quote4 ;
  int varstart ;
  int varend ;
  int valstart ;
  int valend ;
  int equalp ;
  int hashp ;
  int tempp ;
  int ret ;
  char quote ;
  char plus ;
  char equal ;
  char hash ;
  char left ;
  char right ;
  char cleft ;
  char cright ;
  char bslash ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int q ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 642
  ret = 1;
#line 643
  quote = (char )'\"';
#line 644
  plus = (char )'+';
#line 645
  equal = (char )'=';
#line 646
  hash = (char )'#';
#line 647
  left = (char )'[';
#line 648
  right = (char )']';
#line 649
  cleft = (char )'{';
#line 650
  cright = (char )'}';
#line 651
  bslash = (char )'\\';
#line 653
  if ((unsigned long )do_plus != (unsigned long )((int *)0)) {
#line 654
    *do_plus = 0;
  }
#line 657
  tmp = mara_goodjs(line___0);
#line 657
  if (tmp == -1) {
#line 658
    return (-1);
  }
#line 659
  tmp___0 = mara_goodjs(var___0);
#line 659
  if (tmp___0 == -1) {
#line 660
    return (-1);
  }
#line 661
  tmp___1 = mara_goodjs(key___0);
#line 661
  if (tmp___1 == -1) {
#line 662
    return (-1);
  }
#line 663
  tmp___2 = mara_goodjs(value___0);
#line 663
  if (tmp___2 == -1) {
#line 664
    return (-1);
  }
#line 666
  if ((unsigned long )quotes == (unsigned long )((js_string *)0)) {
#line 667
    quotes = js_create(256U, 1U);
#line 667
    if ((unsigned long )quotes == (unsigned long )((js_string *)0)) {
#line 668
      return (-1);
    }
  }
#line 669
  if ((unsigned long )numbers == (unsigned long )((js_string *)0)) {
#line 670
    numbers = js_create(256U, 1U);
#line 670
    if ((unsigned long )numbers == (unsigned long )((js_string *)0)) {
#line 671
      return (-1);
    }
  }
#line 672
  if ((unsigned long )alphanumeric == (unsigned long )((js_string *)0)) {
#line 673
    alphanumeric = js_create(256U, 1U);
#line 673
    if ((unsigned long )alphanumeric == (unsigned long )((js_string *)0)) {
#line 674
      return (-1);
    }
  }
#line 675
  if ((unsigned long )plusq == (unsigned long )((js_string *)0)) {
#line 676
    plusq = js_create(256U, 1U);
#line 676
    if ((unsigned long )plusq == (unsigned long )((js_string *)0)) {
#line 677
      return (-1);
    }
  }
#line 679
  if ((unsigned long )equals == (unsigned long )((js_string *)0)) {
#line 680
    equals = js_create(256U, 1U);
#line 680
    if ((unsigned long )equals == (unsigned long )((js_string *)0)) {
#line 681
      return (-1);
    }
  }
#line 682
  if ((unsigned long )hashq == (unsigned long )((js_string *)0)) {
#line 683
    hashq = js_create(256U, 1U);
#line 683
    if ((unsigned long )hashq == (unsigned long )((js_string *)0)) {
#line 684
      return (-1);
    }
  }
#line 685
  if ((unsigned long )bslashq == (unsigned long )((js_string *)0)) {
#line 686
    bslashq = js_create(256U, 1U);
#line 686
    if ((unsigned long )bslashq == (unsigned long )((js_string *)0)) {
#line 687
      return (-1);
    }
  }
#line 688
  if ((unsigned long )allq == (unsigned long )((js_string *)0)) {
#line 689
    allq = js_create(256U, 1U);
#line 689
    if ((unsigned long )allq == (unsigned long )((js_string *)0)) {
#line 690
      return (-1);
    }
  }
#line 691
  if ((unsigned long )leftq == (unsigned long )((js_string *)0)) {
#line 692
    leftq = js_create(256U, 1U);
#line 692
    if ((unsigned long )leftq == (unsigned long )((js_string *)0)) {
#line 693
      return (-1);
    }
  }
#line 694
  if ((unsigned long )rightq == (unsigned long )((js_string *)0)) {
#line 695
    rightq = js_create(256U, 1U);
#line 695
    if ((unsigned long )rightq == (unsigned long )((js_string *)0)) {
#line 696
      return (-1);
    }
  }
#line 697
  if ((unsigned long )cleftq == (unsigned long )((js_string *)0)) {
#line 698
    cleftq = js_create(256U, 1U);
#line 698
    if ((unsigned long )cleftq == (unsigned long )((js_string *)0)) {
#line 699
      return (-1);
    }
  }
#line 700
  if ((unsigned long )crightq == (unsigned long )((js_string *)0)) {
#line 701
    crightq = js_create(256U, 1U);
#line 701
    if ((unsigned long )crightq == (unsigned long )((js_string *)0)) {
#line 702
      return (-1);
    }
  }
#line 703
  if ((unsigned long )blankq == (unsigned long )((js_string *)0)) {
#line 704
    blankq = js_create(256U, 1U);
#line 704
    if ((unsigned long )blankq == (unsigned long )((js_string *)0)) {
#line 705
      return (-1);
    }
  }
#line 708
  js_str2js(equals, & equal, 1, 1);
#line 709
  js_str2js(plusq, & plus, 1, 1);
#line 710
  js_str2js(hashq, & hash, 1, 1);
#line 711
  js_str2js(bslashq, & bslash, 1, 1);
#line 712
  js_str2js(leftq, & left, 1, 1);
#line 713
  js_str2js(rightq, & right, 1, 1);
#line 714
  js_str2js(cleftq, & cleft, 1, 1);
#line 715
  js_str2js(crightq, & cright, 1, 1);
#line 716
  js_set_encode(alphanumeric, 3);
#line 717
  js_set_encode(numbers, 3);
#line 718
  js_set_encode(blankq, 3);
#line 719
  js_an_chars(alphanumeric);
#line 720
  js_numbers(numbers);
#line 721
  js_space_chars(blankq);
#line 723
  js_set_encode(allq, 3);
#line 724
  js_set_encode(quotes, 3);
#line 725
  js_space_chars(allq);
#line 727
  js_newline_chars(quotes);
#line 728
  js_append(quotes, allq);
#line 729
  js_append(quotes, blankq);
#line 731
  js_str2js(quotes, & quote, 1, 1);
#line 732
  js_append(quotes, allq);
#line 733
  js_append(equals, allq);
#line 734
  js_append(plusq, allq);
#line 735
  js_append(hashq, allq);
#line 736
  js_append(bslashq, allq);
#line 737
  js_append(alphanumeric, allq);
#line 738
  js_append(leftq, allq);
#line 739
  js_append(rightq, allq);
#line 740
  js_append(cleftq, allq);
#line 741
  js_append(crightq, allq);
#line 744
  js_qstr2js(var___0, (char *)"");
#line 745
  js_qstr2js(value___0, (char *)"");
#line 747
  js_qstr2js(key___0, (char *)"NOTHASH");
#line 750
  quote4 = -2;
#line 750
  quote3 = quote4;
#line 750
  quote2 = quote3;
#line 750
  quote1 = quote2;
#line 756
  hashp = js_match(hashq, line___0);
#line 756
  if (hashp == -1) {
#line 757
    return (-1);
  }
#line 758
  tempp = js_notmatch(blankq, line___0);
#line 759
  if (tempp == -1) {
#line 760
    return (-1);
  }
#line 761
  if (tempp == -2) {
#line 762
    return (1);
  } else
#line 761
  if (tempp == hashp) {
#line 762
    return (1);
  }
#line 765
  quote1 = js_match(quotes, line___0);
#line 765
  if (quote1 == -1) {
#line 766
    return (-1);
  }
#line 767
  if (quote1 != -2) {
#line 768
    quote2 = js_match_offset(quotes, line___0, quote1 + 1);
#line 769
    if (quote2 != -2) {
#line 770
      quote3 = js_match_offset(quotes, line___0, quote2 + 1);
#line 771
      if (quote3 != -2) {
#line 772
        quote4 = js_match_offset(quotes, line___0, quote3 + 1);
#line 772
        if (quote4 == -2) {
#line 773
          js_qstr2js(var___0, (char *)"ERROR");
#line 774
          js_qstr2js(value___0, (char *)"2nd quoted expression needs to be unquoted");
#line 776
          return (1);
        }
      }
    } else {
#line 781
      js_qstr2js(var___0, (char *)"ERROR");
#line 782
      js_qstr2js(value___0, (char *)"Quoted expression needs to be unquoted");
#line 783
      return (1);
    }
  }
#line 788
  hashp = js_match(hashq, line___0);
#line 788
  if (hashp == -1) {
#line 789
    return (-1);
  }
#line 791
  if (hashp > quote1) {
#line 791
    if (hashp < quote2) {
#line 792
      hashp = js_match_offset(hashq, line___0, quote2);
    }
  }
#line 794
  if (hashp > quote3) {
#line 794
    if (hashp < quote4) {
#line 795
      hashp = js_match_offset(hashq, line___0, quote4);
    }
  }
#line 797
  if (hashp == -2) {
#line 798
    tmp___3 = js_length(line___0);
#line 798
    hashp = tmp___3 + 1;
  }
#line 800
  if (quote1 > hashp) {
#line 801
    quote4 = -2;
#line 801
    quote3 = quote4;
#line 801
    quote2 = quote3;
#line 801
    quote1 = quote2;
  }
#line 802
  if (quote3 > hashp) {
#line 803
    quote4 = -2;
#line 803
    quote3 = quote4;
  }
#line 807
  tempp = js_notmatch(allq, line___0);
#line 807
  if (tempp == -1) {
#line 808
    return (-1);
  }
#line 812
  if (tempp != -2) {
#line 812
    if (tempp < hashp) {
#line 812
      if (tempp < quote1) {
#line 812
        goto _L;
      } else
#line 812
      if (tempp > quote2) {
        _L: /* CIL Label */ 
#line 812
        if (tempp < quote3) {
#line 814
          js_qstr2js(var___0, (char *)"ERROR");
#line 815
          js_qstr2js(value___0, (char *)"Unknown character in line");
#line 816
          return (1);
        } else
#line 812
        if (tempp > quote4) {
#line 814
          js_qstr2js(var___0, (char *)"ERROR");
#line 815
          js_qstr2js(value___0, (char *)"Unknown character in line");
#line 816
          return (1);
        }
      }
    }
  }
#line 820
  if (quote4 != -2) {
#line 821
    tempp = js_match_offset(quotes, line___0, quote4 + 1);
#line 821
    if (tempp == -1) {
#line 822
      return (-1);
    }
#line 823
    if (tempp != -2) {
#line 823
      if (tempp < hashp) {
#line 824
        js_qstr2js(var___0, (char *)"ERROR");
#line 825
        js_qstr2js(value___0, (char *)"Maximum allowed quotes on a line is four");
#line 826
        return (1);
      }
    }
  }
#line 831
  equalp = js_match(equals, line___0);
#line 831
  if (equalp == -1) {
#line 832
    return (-1);
  }
#line 834
  tempp = js_match(plusq, line___0);
#line 834
  if (tempp == -1) {
#line 835
    return (-1);
  }
#line 836
  if (tempp != -2) {
#line 836
    if (tempp != equalp - 1) {
#line 837
      js_qstr2js(var___0, (char *)"ERROR");
#line 838
      js_qstr2js(value___0, (char *)"+ only allowed in += form");
#line 839
      return (1);
    }
  }
#line 841
  if (tempp == equalp - 1) {
#line 841
    if ((unsigned long )do_plus != (unsigned long )((int *)0)) {
#line 842
      *do_plus = 1;
    }
  }
#line 843
  tmp___4 = js_match_offset(plusq, line___0, equalp);
#line 843
  if (tmp___4 != -2) {
#line 844
    js_qstr2js(var___0, (char *)"ERROR");
#line 845
    js_qstr2js(value___0, (char *)"+ only allowed once on line");
#line 846
    return (1);
  }
#line 850
  varend = -2;
#line 850
  varstart = varend;
#line 851
  varstart = js_match(alphanumeric, line___0);
#line 851
  if (varstart == -1) {
#line 852
    return (-1);
  }
#line 853
  if (varstart != -2) {
#line 853
    if (varstart < hashp) {
#line 854
      varend = varstart;
#line 855
      while (1) {
#line 855
        tmp___5 = js_match_offset(alphanumeric, line___0, varend + 1);
#line 855
        if (! (tmp___5 == varend + 1)) {
#line 855
          break;
        }
#line 856
        varend ++;
      }
    } else {
#line 853
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 858
  if (varstart >= hashp) {
#line 859
    varstart = -2;
  }
#line 861
  if (varstart > quote1) {
#line 861
    if (varend < quote2) {
#line 863
      js_qstr2js(var___0, (char *)"ERROR");
#line 864
      js_qstr2js(value___0, (char *)"Variable name can not be in quotes");
#line 865
      return (1);
    } else {
#line 861
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 861
  if (varstart > quote3) {
#line 861
    if (varend < quote4) {
#line 863
      js_qstr2js(var___0, (char *)"ERROR");
#line 864
      js_qstr2js(value___0, (char *)"Variable name can not be in quotes");
#line 865
      return (1);
    }
  }
#line 869
  tempp = js_match(leftq, line___0);
#line 870
  if (tempp != -2) {
#line 873
    if (tempp != varend + 1) {
#line 874
      js_qstr2js(var___0, (char *)"ERROR");
#line 875
      js_qstr2js(value___0, (char *)"Left square bracket must be immediately after variable name");
#line 877
      return (1);
    }
#line 879
    if (quote1 != tempp + 1) {
#line 880
      js_qstr2js(var___0, (char *)"ERROR");
#line 881
      js_qstr2js(value___0, (char *)"Dictionary element must be in quotes");
#line 882
      return (1);
    }
#line 884
    tmp___6 = js_match_offset(leftq, line___0, tempp + 1);
#line 884
    if (tmp___6 != -2) {
#line 885
      js_qstr2js(var___0, (char *)"ERROR");
#line 886
      js_qstr2js(value___0, (char *)"Multiple left square brackets forbidden");
#line 887
      return (1);
    }
#line 889
    tmp___7 = js_match(rightq, line___0);
#line 889
    if (tmp___7 != quote2 + 1) {
#line 890
      js_qstr2js(var___0, (char *)"ERROR");
#line 891
      js_qstr2js(value___0, (char *)"Right square bracket must be after quotes");
#line 892
      return (1);
    }
#line 896
    tmp___8 = js_substr(line___0, key___0, quote1 + 1, (quote2 - quote1) - 1);
#line 896
    if (tmp___8 == -1) {
#line 897
      return (-1);
    }
#line 903
    quote1 = quote3;
#line 904
    quote2 = quote4;
#line 905
    quote4 = -2;
#line 905
    quote3 = quote4;
#line 906
    ret = 2;
  }
#line 910
  valend = -2;
#line 910
  valstart = valend;
#line 912
  if (quote1 != -2) {
#line 912
    if (quote2 != -2) {
#line 913
      valstart = quote1 + 1;
#line 914
      valend = quote2 - 1;
#line 917
      if (ret != 2) {
#line 920
        q = js_match_offset(alphanumeric, line___0, varend + 1);
#line 921
        if (q < quote1) {
#line 921
          if (q != -2) {
#line 922
            js_qstr2js(var___0, (char *)"ERROR");
#line 923
            js_qstr2js(value___0, (char *)"Second bare word found before quotes");
#line 924
            return (1);
          }
        }
      }
    } else {
#line 912
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
#line 931
    if (equalp < 0) {
#line 932
      js_qstr2js(var___0, (char *)"ERROR");
#line 933
      js_qstr2js(value___0, (char *)"Statement needs an = sign");
#line 934
      return (1);
    }
#line 936
    valstart = js_match_offset(numbers, line___0, equalp);
#line 936
    if (valstart == -1) {
#line 937
      return (-1);
    }
#line 939
    if (valstart != -2) {
#line 939
      if (valstart < hashp) {
#line 940
        valend = valstart;
#line 941
        while (1) {
#line 941
          tmp___9 = js_match_offset(alphanumeric, line___0, valend + 1);
#line 941
          if (! (tmp___9 == valend + 1)) {
#line 941
            break;
          }
#line 942
          valend ++;
        }
      } else {
#line 939
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
#line 946
      tempp = js_match_offset(cleftq, line___0, equalp);
#line 947
      if (tempp != -2) {
#line 948
        tmp___10 = js_match(crightq, line___0);
#line 948
        if (tmp___10 != tempp + 1) {
#line 949
          js_qstr2js(var___0, (char *)"ERROR");
#line 950
          js_qstr2js(value___0, (char *)"{ must be immediately followed by }");
#line 951
          return (1);
        }
#line 953
        if (ret == 1) {
#line 954
          ret = 3;
        } else {
#line 956
          js_qstr2js(var___0, (char *)"ERROR");
#line 957
          js_qstr2js(value___0, (char *)"Dictionary elements pointing to dictionaries unsupported");
#line 959
          return (1);
        }
      } else {
#line 963
        js_qstr2js(var___0, (char *)"ERROR");
#line 964
        js_qstr2js(value___0, (char *)"Something must follow =");
#line 965
        return (1);
      }
    }
  }
#line 971
  tmp___11 = js_match(bslashq, line___0);
#line 971
  if (tmp___11 != -2) {
#line 972
    js_qstr2js(var___0, (char *)"ERROR");
#line 973
    js_qstr2js(value___0, (char *)"Backslash not supported yet");
#line 974
    return (1);
  }
#line 979
  if (varstart >= 0) {
#line 979
    if (varend >= varstart) {
#line 981
      if (equalp == -2) {
#line 982
        js_qstr2js(var___0, (char *)"ERROR");
#line 983
        js_qstr2js(value___0, (char *)"Variable name needs an = sign");
#line 984
        return (1);
      }
#line 987
      if (varstart > equalp) {
#line 988
        js_qstr2js(var___0, (char *)"ERROR");
#line 989
        js_qstr2js(value___0, (char *)"Equals sign before variable name");
#line 990
        return (1);
      }
#line 992
      tmp___12 = js_substr(line___0, var___0, varstart, (varend - varstart) + 1);
#line 992
      if (tmp___12 == -1) {
#line 993
        return (-1);
      }
    }
  }
#line 996
  if (valstart >= 0) {
#line 996
    if (valend >= valstart) {
#line 998
      if (equalp > quote1) {
#line 998
        if (equalp < quote2) {
#line 999
          js_qstr2js(var___0, (char *)"ERROR");
#line 1000
          js_qstr2js(value___0, (char *)"Quoted string not preceeded by equals sign");
#line 1001
          return (1);
        }
      }
#line 1004
      if (valstart < equalp) {
#line 1005
        js_qstr2js(var___0, (char *)"ERROR");
#line 1006
        js_qstr2js(value___0, (char *)"Equals sign after variable value");
#line 1007
        return (1);
      }
#line 1009
      tmp___13 = js_substr(line___0, value___0, valstart, (valend - valstart) + 1);
#line 1009
      if (tmp___13 == -1) {
#line 1010
        return (-1);
      }
    }
  }
#line 1014
  js_space_chars(allq);
#line 1015
  js_append(quotes, allq);
#line 1016
  js_newline_chars(quotes);
#line 1017
  js_append(quotes, allq);
#line 1018
  tempp = js_notmatch_offset(allq, line___0, valend + 1);
#line 1019
  if (tempp < hashp) {
#line 1019
    if (tempp != -2) {
#line 1020
      js_qstr2js(var___0, (char *)"ERROR");
#line 1021
      js_qstr2js(value___0, (char *)"Unexpected character near end of line");
#line 1022
      return (1);
    }
  }
#line 1025
  return (ret);
}
}
#line 1033 "ParseMaraRc.c"
int find_mararc(js_string *out ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 1036
  tmp = mara_goodjs(out);
#line 1036
  if (tmp == -1) {
#line 1037
    return (-1);
  }
#line 1040
  tmp___0 = js_qstr2js(out, (char *)"/etc/mararc");
#line 1040
  return (tmp___0);
}
}
#line 1053 "ParseMaraRc.c"
static js_string *line  =    (js_string *)0;
#line 1054 "ParseMaraRc.c"
static js_string *var  =    (js_string *)0;
#line 1055 "ParseMaraRc.c"
static js_string *key  =    (js_string *)0;
#line 1056 "ParseMaraRc.c"
static js_string *value  =    (js_string *)0;
#line 1057 "ParseMaraRc.c"
static js_string *tstr  =    (js_string *)0;
#line 1065 "ParseMaraRc.c"
static js_file *file  =    (js_file *)0;
#line 1052 "ParseMaraRc.c"
int read_mararc(js_string *fileloc , js_string *errorstr , int *errorret ) 
{ int error ;
  int linenum ;
  int command ;
  int tnum ;
  int is_plus ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int result ;
  int tmp___3 ;
  int tmp___4 ;
  int result___0 ;
  int tmp___5 ;

  {
#line 1059
  error = 0;
#line 1060
  linenum = 1;
#line 1062
  is_plus = 0;
#line 1067
  *errorret = -1;
#line 1070
  if ((unsigned long )line == (unsigned long )((js_string *)0)) {
#line 1071
    line = js_create(256U, 1U);
#line 1071
    if ((unsigned long )line == (unsigned long )((js_string *)0)) {
#line 1072
      js_qstr2js(errorstr, (char *)"Fatal error creating js_string");
#line 1073
      return (-1);
    }
  }
#line 1075
  if ((unsigned long )var == (unsigned long )((js_string *)0)) {
#line 1076
    var = js_create(256U, 1U);
#line 1076
    if ((unsigned long )var == (unsigned long )((js_string *)0)) {
#line 1077
      js_qstr2js(errorstr, (char *)"Fatal error creating js_string");
#line 1078
      return (-1);
    }
  }
#line 1080
  if ((unsigned long )key == (unsigned long )((js_string *)0)) {
#line 1081
    key = js_create(256U, 1U);
#line 1081
    if ((unsigned long )key == (unsigned long )((js_string *)0)) {
#line 1082
      js_qstr2js(errorstr, (char *)"Fatal error creating js_string");
#line 1083
      return (-1);
    }
  }
#line 1085
  if ((unsigned long )value == (unsigned long )((js_string *)0)) {
#line 1086
    value = js_create(256U, 1U);
#line 1086
    if ((unsigned long )value == (unsigned long )((js_string *)0)) {
#line 1087
      js_qstr2js(errorstr, (char *)"Fatal error creating js_string");
#line 1088
      return (-1);
    }
  }
#line 1090
  if ((unsigned long )tstr == (unsigned long )((js_string *)0)) {
#line 1091
    tstr = js_create(256U, 1U);
#line 1091
    if ((unsigned long )tstr == (unsigned long )((js_string *)0)) {
#line 1092
      js_qstr2js(errorstr, (char *)"Fatal error creating js_string");
#line 1093
      return (-1);
    }
  }
#line 1095
  if ((unsigned long )file == (unsigned long )((js_file *)0)) {
#line 1096
    tmp = js_alloc(1, (int )sizeof(js_file ));
#line 1096
    file = (js_file *)tmp;
#line 1096
    if ((unsigned long )file == (unsigned long )((js_file *)0)) {
#line 1097
      js_qstr2js(errorstr, (char *)"Fatal error creating file");
#line 1098
      return (-1);
    }
  }
#line 1102
  js_qstr2js(errorstr, (char *)"");
#line 1103
  js_set_encode(line, 3);
#line 1104
  js_set_encode(var, 3);
#line 1105
  js_set_encode(key, 3);
#line 1106
  js_set_encode(value, 3);
#line 1107
  js_set_encode(tstr, 3);
#line 1109
  init_dvars();
#line 1110
  init_kvars();
#line 1113
  tmp___0 = js_open_read(fileloc, file);
#line 1113
  if (tmp___0 == -1) {
#line 1114
    *errorret = -1;
#line 1115
    js_qstr2js(errorstr, (char *)"Could not open mararc file at ");
#line 1116
    js_append(fileloc, errorstr);
#line 1117
    return (1);
  }
#line 1119
  while (1) {
#line 1119
    tmp___5 = js_buf_eof(file);
#line 1119
    if (tmp___5) {
#line 1119
      break;
    }
#line 1120
    tmp___1 = js_buf_getline(file, line);
#line 1120
    if (tmp___1 <= -1) {
#line 1121
      js_qstr2js(errorstr, (char *)"Fatal error calling js_buf_getline");
#line 1122
      js_close(file);
#line 1123
      return (-1);
    }
#line 1125
    command = parseline(line, var, key, value, & is_plus);
#line 1125
    if (command == -1) {
#line 1126
      js_qstr2js(errorstr, (char *)"Fatal error calling parseline");
#line 1127
      js_close(file);
#line 1128
      return (-1);
    }
#line 1130
    if (command == 2) {
#line 1130
      if (! error) {
#line 1132
        tnum = dkeyword2num(var);
#line 1133
        if (tnum == -1) {
#line 1134
          js_qstr2js(errorstr, (char *)"Fatal error calling keyword2num");
#line 1135
          js_close(file);
#line 1136
          return (-1);
        }
#line 1138
        if (tnum == -2) {
#line 1140
          js_qstr2js(tstr, (char *)"ERROR");
#line 1141
          tmp___2 = js_issame(tstr, var);
#line 1141
          if (tmp___2) {
#line 1142
            if (! error) {
#line 1143
              error = linenum;
#line 1144
              *errorret = error;
#line 1145
              js_copy(value, errorstr);
            }
          }
        } else
#line 1149
        if (! error) {
#line 1151
          result = write_dvar(var, key, value, is_plus);
#line 1152
          if (result == -3) {
#line 1154
            printf("%s", "Fatal error: ");
#line 1155
            js_show_stdout(var);
#line 1156
            printf("%s", "[\"");
#line 1157
            js_show_stdout(key);
#line 1158
            printf("%s", "\"]");
#line 1159
            printf("%s", " is declared more than once in mararc file.\nPlease remove or comment out this line:\n");
#line 1160
            js_show_stdout(var);
#line 1161
            printf("%s", "[\"");
#line 1162
            js_show_stdout(key);
#line 1163
            printf("%s", "\"] = \"");
#line 1164
            js_show_stdout(value);
#line 1165
            printf("%s", "\"\n");
#line 1166
            printf("Error in line %d\n", linenum);
#line 1167
            exit(1);
          } else
#line 1169
          if (result == -4) {
#line 1170
            printf("+= operator target must be previously ");
#line 1171
            printf("defined with = operator\n");
#line 1172
            printf("Error in line %d\n", linenum);
#line 1173
            exit(1);
          } else
#line 1175
          if (result == -5) {
#line 1176
            printf("+= operator target not supported for ");
#line 1177
            printf("numeric values\n");
#line 1178
            printf("Error in line %d\n", linenum);
#line 1179
            exit(1);
          } else
#line 1181
          if (result == -6) {
#line 1182
            printf("Trying to access unitizalized dictionary var.\n");
#line 1183
            printf("Try adding this line to the beginning of the ");
#line 1184
            printf("mararc file:\n\n");
#line 1185
            js_show_stdout(var);
#line 1186
            printf(" = {}\n");
#line 1187
            printf("Error in line %d\n", linenum);
#line 1188
            exit(1);
          }
        }
      } else {
#line 1130
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1192
    if (command == 1) {
#line 1192
      if (! error) {
#line 1193
        tnum = keyword2num(var);
#line 1194
        if (tnum == -2) {
#line 1196
          js_qstr2js(tstr, (char *)"ERROR");
#line 1197
          tmp___3 = js_issame(tstr, var);
#line 1197
          if (tmp___3) {
#line 1198
            if (! error) {
#line 1199
              error = linenum;
#line 1200
              *errorret = error;
#line 1201
              js_copy(value, errorstr);
            }
          }
        }
#line 1205
        if (tnum == -2) {
#line 1205
          if (var->unit_count > 0U) {
#line 1205
            if (! error) {
#line 1206
              printf("FATAL ERROR: Unknown mararc variable ");
#line 1207
              show_esc_stdout(var);
#line 1208
              printf("\nPlease look for the uncommented string \"");
#line 1209
              show_esc_stdout(var);
#line 1210
              printf("\"\nin your mararc file and remove this line.\n");
#line 1211
              printf("\nThe line this error is on looks like this:\n");
#line 1213
              if ((int )*((line->string + line->unit_count) - 1) == 10) {
#line 1213
                if (line->unit_count > 0U) {
#line 1215
                  (line->unit_count) --;
                }
              }
#line 1217
              show_esc_stdout(line);
#line 1218
              printf("\n");
#line 1219
              exit(10);
            }
          }
        }
#line 1221
        if (tnum == -1) {
#line 1222
          js_qstr2js(errorstr, (char *)"Fatal error calling keyword2num");
#line 1223
          js_close(file);
#line 1224
          return (-1);
        }
#line 1226
        if (tnum == -2) {
#line 1228
          js_qstr2js(tstr, (char *)"ERROR");
#line 1229
          tmp___4 = js_issame(tstr, var);
#line 1229
          if (tmp___4) {
#line 1230
            if (! error) {
#line 1231
              error = linenum;
#line 1232
              *errorret = error;
#line 1233
              js_copy(value, errorstr);
            }
          }
        } else
#line 1237
        if (! error) {
#line 1239
          result___0 = write_kvar(var, value, is_plus);
#line 1240
          if (result___0 == -4) {
#line 1241
            printf("+= operator target must be previously ");
#line 1242
            printf("defined with = operator\n");
#line 1243
            printf("Error in line %d\n", linenum);
#line 1244
            exit(1);
          } else
#line 1246
          if (result___0 == -5) {
#line 1247
            printf("+= operator target not supported for ");
#line 1248
            printf("numeric values\n");
#line 1249
            printf("Error in line %d\n", linenum);
#line 1250
            exit(1);
          }
        }
      } else {
#line 1192
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1254
    if (command == 3) {
#line 1255
      new_dvar(var);
    }
#line 1256
    linenum ++;
  }
#line 1259
  if (! error) {
#line 1260
    *errorret = 0;
  }
#line 1262
  js_close(file);
#line 1298
  return (1);
}
}
#line 1 "ParseCsv1.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-LcJbP9Gq.i","")
#line 44 "ParseCsv1.c"
int parse_csv1_line(js_string *line___0 , js_string *name , js_string *data , uint32_t *ttl ) 
{ js_string *pipeq ;
  js_string *hashq___0 ;
  js_string *starq ;
  js_string *blankq___0 ;
  js_string *field ;
  js_string *tstr___0 ;
  uint16_t type ;
  uint16_t preference ;
  int tempp ;
  int pipep ;
  int opipep ;
  int counter ;
  uint32_t soanum ;
  char pipe ;
  char hash ;
  char star ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  unsigned int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  unsigned int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;

  {
#line 48
  pipeq = (js_string *)0;
#line 48
  hashq___0 = (js_string *)0;
#line 48
  starq = (js_string *)0;
#line 48
  blankq___0 = (js_string *)0;
#line 48
  field = (js_string *)0;
#line 58
  pipe = (char )'|';
#line 59
  hash = (char )'#';
#line 60
  star = (char )'*';
#line 63
  tmp = mara_goodjs(line___0);
#line 63
  if (tmp == -1) {
#line 64
    return (-1);
  }
#line 65
  tmp___0 = js_get_encode(line___0);
#line 65
  if (tmp___0 != 2) {
#line 65
    tmp___1 = js_get_encode(line___0);
#line 65
    if (tmp___1 != 3) {
#line 67
      return (-1);
    }
  }
#line 68
  tmp___2 = mara_goodjs(name);
#line 68
  if (tmp___2 == -1) {
#line 69
    return (-1);
  }
#line 70
  tmp___3 = mara_goodjs(data);
#line 70
  if (tmp___3 == -1) {
#line 71
    return (-1);
  }
#line 72
  if ((unsigned long )ttl == (unsigned long )((uint32_t *)0)) {
#line 73
    return (-1);
  }
#line 76
  pipeq = js_create(7U, 1U);
#line 76
  if ((unsigned long )pipeq == (unsigned long )((js_string *)0)) {
#line 77
    return (-1);
  }
#line 78
  hashq___0 = js_create(7U, 1U);
#line 78
  if ((unsigned long )hashq___0 == (unsigned long )((js_string *)0)) {
#line 79
    js_destroy(pipeq);
#line 80
    return (-1);
  }
#line 82
  starq = js_create(7U, 1U);
#line 82
  if ((unsigned long )starq == (unsigned long )((js_string *)0)) {
#line 83
    js_destroy(pipeq);
#line 83
    js_destroy(hashq___0);
#line 84
    return (-1);
  }
#line 86
  tmp___4 = js_set_encode(starq, 3);
#line 86
  if (tmp___4 == -1) {
#line 87
    js_destroy(pipeq);
#line 87
    js_destroy(hashq___0);
#line 87
    js_destroy(starq);
#line 88
    return (-1);
  }
#line 90
  blankq___0 = js_create(7U, 1U);
#line 90
  if ((unsigned long )blankq___0 == (unsigned long )((js_string *)0)) {
#line 91
    js_destroy(pipeq);
#line 91
    js_destroy(hashq___0);
#line 91
    js_destroy(starq);
#line 92
    return (-1);
  }
#line 94
  tmp___5 = js_set_encode(blankq___0, 3);
#line 94
  if (tmp___5 == -1) {
#line 95
    js_destroy(pipeq);
#line 95
    js_destroy(hashq___0);
#line 95
    js_destroy(starq);
#line 96
    js_destroy(blankq___0);
#line 97
    return (-1);
  }
#line 99
  field = js_create(256U, 1U);
#line 99
  if ((unsigned long )field == (unsigned long )((js_string *)0)) {
#line 100
    js_destroy(pipeq);
#line 100
    js_destroy(hashq___0);
#line 100
    js_destroy(starq);
#line 101
    js_destroy(blankq___0);
#line 102
    return (-1);
  }
#line 106
  tmp___6 = js_str2js(pipeq, & pipe, 1, 1);
#line 106
  if (tmp___6 == -1) {
#line 107
    goto clean;
  }
#line 108
  tmp___7 = js_str2js(hashq___0, & hash, 1, 1);
#line 108
  if (tmp___7 == -1) {
#line 109
    goto clean;
  }
#line 110
  tmp___8 = js_space_chars(blankq___0);
#line 110
  if (tmp___8 == -1) {
#line 111
    goto clean;
  }
#line 114
  tmp___9 = js_newline_chars(starq);
#line 114
  if (tmp___9 == -1) {
#line 115
    goto clean;
  }
#line 116
  tmp___10 = js_append(starq, blankq___0);
#line 116
  if (tmp___10 == -1) {
#line 117
    goto clean;
  }
#line 121
  tempp = js_match(starq, line___0);
#line 122
  if (tempp == -1) {
#line 123
    goto clean;
  }
#line 124
  if (tempp == -2) {
#line 125
    js_qstr2js(name, (char *)"ERROR");
#line 126
    js_qstr2js(data, (char *)"No newline found in line");
#line 127
    goto error;
  }
#line 131
  tmp___11 = js_str2js(starq, & star, 1, 1);
#line 131
  if (tmp___11 == -1) {
#line 132
    goto clean;
  }
#line 134
  tmp___12 = js_qstr2js(name, (char *)"");
#line 134
  if (tmp___12 == -1) {
#line 135
    goto clean;
  }
#line 136
  tmp___13 = js_qstr2js(data, (char *)"");
#line 136
  if (tmp___13 == -1) {
#line 137
    goto clean;
  }
#line 141
  tempp = js_match(hashq___0, line___0);
#line 142
  if (tempp == -1) {
#line 143
    goto clean;
  }
#line 144
  if (tempp == 0) {
#line 145
    goto cero;
  }
#line 149
  tempp = js_notmatch(blankq___0, line___0);
#line 150
  if (tempp == -1) {
#line 151
    goto clean;
  }
#line 152
  if (tempp == -2) {
#line 153
    goto cero;
  }
#line 157
  pipep = js_match(pipeq, line___0);
#line 158
  if (pipep == -1) {
#line 159
    goto clean;
  }
#line 160
  if (tempp == -2) {
#line 161
    js_qstr2js(name, (char *)"ERROR");
#line 162
    js_qstr2js(data, (char *)"No pipe found in line");
#line 163
    goto error;
  }
#line 168
  tmp___14 = js_substr(line___0, name, 0, pipep);
#line 168
  if (tmp___14 == -1) {
#line 169
    goto clean;
  }
#line 171
  tempp = hname_2rfc1035(name);
#line 172
  if (tempp == -1) {
#line 173
    js_qstr2js(name, (char *)"ERROR");
#line 174
    js_qstr2js(data, (char *)"Error in Query syntax.");
#line 175
    goto error;
  }
#line 178
  if (tempp == -2) {
#line 179
    js_qstr2js(name, (char *)"ERROR");
#line 180
    js_qstr2js(data, (char *)"The record type is not supported");
#line 181
    goto error;
  } else
#line 178
  if (tempp > 65535) {
#line 179
    js_qstr2js(name, (char *)"ERROR");
#line 180
    js_qstr2js(data, (char *)"The record type is not supported");
#line 181
    goto error;
  }
#line 184
  type = (uint16_t )tempp;
#line 187
  opipep = pipep;
#line 188
  pipep = js_match_offset(pipeq, line___0, pipep + 1);
#line 189
  if (pipep == -1) {
#line 190
    goto clean;
  }
#line 191
  if (pipep <= opipep) {
#line 192
    js_qstr2js(name, (char *)"ERROR");
#line 193
    js_qstr2js(data, (char *)"You must have at least three fields in the RR");
#line 194
    goto error;
  }
#line 196
  *ttl = js_atoi(line___0, opipep + 1);
#line 197
  if (*ttl == 4294967295U) {
#line 198
    goto clean;
  }
#line 201
  switch (tempp) {
  case 1: 
#line 203
  tmp___15 = ddip_2_ip(line___0, data, pipep + 1);
#line 203
  if (tmp___15 == -1) {
#line 204
    js_qstr2js(name, (char *)"ERROR");
#line 205
    js_qstr2js(data, (char *)"Malformed dotted decimal IP");
#line 206
    goto error;
  }
#line 208
  break;
  case 15: 
#line 211
  tmp___16 = js_atoi(line___0, pipep + 1);
#line 211
  tempp = (int )tmp___16;
#line 212
  if (tempp < 0) {
#line 213
    js_qstr2js(name, (char *)"ERROR");
#line 214
    js_qstr2js(data, (char *)"Bad MX type");
#line 215
    goto error;
  } else
#line 212
  if (tempp > 65535) {
#line 213
    js_qstr2js(name, (char *)"ERROR");
#line 214
    js_qstr2js(data, (char *)"Bad MX type");
#line 215
    goto error;
  }
#line 217
  preference = (uint16_t )tempp;
#line 218
  tmp___17 = js_addbyte(data, (unsigned char )(((int )preference >> 8) & 255));
#line 218
  if (tmp___17 == -1) {
#line 219
    goto clean;
  }
#line 220
  tmp___18 = js_addbyte(data, (unsigned char )((int )preference & 255));
#line 220
  if (tmp___18 == -1) {
#line 221
    goto clean;
  }
#line 222
  tempp = js_match_offset(pipeq, line___0, pipep + 1);
#line 223
  if (tempp <= pipep) {
#line 224
    js_qstr2js(name, (char *)"ERROR");
#line 225
    js_qstr2js(data, (char *)"There must be four fields in the MX");
#line 226
    goto error;
  }
#line 228
  pipep = tempp;
#line 230
  tstr___0 = js_create(512U, 1U);
#line 230
  if ((unsigned long )tstr___0 == (unsigned long )((js_string *)0)) {
#line 231
    goto clean;
  }
#line 232
  tmp___19 = js_length(line___0);
#line 232
  tmp___20 = js_substr(line___0, tstr___0, pipep, (tmp___19 - pipep) - 1);
#line 232
  if (tmp___20 == -1) {
#line 234
    js_destroy(tstr___0);
#line 235
    goto clean;
  }
#line 237
  tmp___21 = js_changebyte(tstr___0, (unsigned char )'A', 0);
#line 237
  if (tmp___21 == -1) {
#line 238
    js_destroy(tstr___0);
#line 239
    goto clean;
  }
#line 241
  tempp = hname_2rfc1035(tstr___0);
#line 242
  if (tempp == -1) {
#line 243
    js_qstr2js(name, (char *)"ERROR");
#line 244
    js_qstr2js(data, (char *)"Malformed domain email");
#line 245
    js_destroy(tstr___0);
#line 246
    goto error;
  }
#line 248
  tmp___22 = js_append(tstr___0, data);
#line 248
  if (tmp___22 == -1) {
#line 249
    js_destroy(tstr___0);
#line 250
    goto clean;
  }
#line 252
  tmp___23 = js_destroy(tstr___0);
#line 252
  if (tmp___23 == -1) {
#line 253
    goto clean;
  }
#line 254
  break;
  case 2: 
#line 258
  if (name->unit_count > 2U) {
#line 258
    if ((int )*(name->string + 1) == 42) {
#line 260
      js_qstr2js(name, (char *)"ERROR");
#line 261
      js_qstr2js(data, (char *)"Star records can not be CNAME nor NS RRs");
#line 262
      goto error;
    }
  }
  case 5: 
  case 12: 
#line 267
  tmp___24 = js_length(line___0);
#line 267
  tmp___25 = js_substr(line___0, data, pipep, (tmp___24 - pipep) - 1);
#line 267
  if (tmp___25 == -1) {
#line 269
    goto clean;
  }
#line 272
  tmp___26 = js_changebyte(data, (unsigned char )'A', 0);
#line 272
  if (tmp___26 == -1) {
#line 273
    goto clean;
  }
#line 274
  tempp = hname_2rfc1035(data);
#line 275
  if (tempp == -1) {
#line 276
    js_qstr2js(name, (char *)"ERROR");
#line 277
    js_qstr2js(data, (char *)"Malformed host/domain name");
#line 278
    goto error;
  }
#line 280
  break;
  case 16: 
#line 284
  tmp___27 = js_length(line___0);
#line 284
  tempp = (tmp___27 - pipep) - 2;
#line 285
  if (tempp < 0) {
#line 286
    goto clean;
  } else
#line 285
  if (tempp > 255) {
#line 286
    goto clean;
  }
#line 287
  tmp___28 = js_substr(line___0, data, pipep, tempp + 1);
#line 287
  if (tmp___28 == -1) {
#line 289
    goto clean;
  }
#line 290
  tmp___29 = js_changebyte(data, (unsigned char )tempp, 0);
#line 290
  if (tmp___29 == -1) {
#line 291
    goto clean;
  }
#line 292
  break;
  case -3: 
#line 296
  tmp___30 = js_atoi(line___0, pipep + 1);
#line 296
  tempp = (int )tmp___30;
#line 297
  if (tempp < 0) {
#line 298
    js_qstr2js(name, (char *)"ERROR");
#line 299
    js_qstr2js(data, (char *)"Bad MX type");
#line 300
    goto error;
  } else
#line 297
  if (tempp > 65535) {
#line 298
    js_qstr2js(name, (char *)"ERROR");
#line 299
    js_qstr2js(data, (char *)"Bad MX type");
#line 300
    goto error;
  }
#line 302
  type = (uint16_t )tempp;
#line 304
  tempp = js_match_offset(pipeq, line___0, pipep + 1);
#line 305
  if (tempp <= pipep) {
#line 306
    js_qstr2js(name, (char *)"ERROR");
#line 307
    js_qstr2js(data, (char *)"There must be four fields in the MX");
#line 308
    goto error;
  }
#line 310
  pipep = tempp;
#line 312
  tmp___31 = js_length(line___0);
#line 312
  tempp = (tmp___31 - pipep) - 2;
#line 313
  if (tempp < 0) {
#line 314
    goto clean;
  } else
#line 313
  if (tempp > 424) {
#line 314
    goto clean;
  }
#line 315
  tmp___32 = js_substr(line___0, data, pipep + 1, tempp);
#line 315
  if (tmp___32 == -1) {
#line 317
    goto clean;
  }
#line 318
  break;
  case 6: 
#line 321
  opipep = pipep;
#line 322
  pipep = js_match_offset(pipeq, line___0, pipep + 1);
#line 323
  if (pipep == -1) {
#line 324
    goto clean;
  }
#line 325
  if (pipep <= opipep) {
#line 326
    js_qstr2js(name, (char *)"ERROR");
#line 327
    js_qstr2js(data, (char *)"You must have nine fields in the SOA");
#line 328
    goto error;
  }
#line 330
  tmp___33 = js_substr(line___0, data, opipep, pipep - opipep);
#line 330
  if (tmp___33 == -1) {
#line 331
    goto clean;
  }
#line 332
  tmp___34 = js_changebyte(data, (unsigned char )'A', 0);
#line 332
  if (tmp___34 == -1) {
#line 333
    goto clean;
  }
#line 334
  tempp = hname_2rfc1035(data);
#line 335
  if (tempp == -1) {
#line 336
    js_qstr2js(name, (char *)"ERROR");
#line 337
    js_qstr2js(data, (char *)"Malformed SOA origin");
#line 338
    goto error;
  }
#line 340
  opipep = pipep;
#line 341
  pipep = js_match_offset(pipeq, line___0, pipep + 1);
#line 342
  if (pipep == -1) {
#line 343
    goto clean;
  }
#line 344
  if (pipep <= opipep) {
#line 345
    js_qstr2js(name, (char *)"ERROR");
#line 346
    js_qstr2js(data, (char *)"You must have nine fields in the SOA");
#line 347
    goto error;
  }
#line 350
  tstr___0 = js_create(512U, 1U);
#line 350
  if ((unsigned long )tstr___0 == (unsigned long )((js_string *)0)) {
#line 351
    goto clean;
  }
#line 352
  tmp___35 = js_substr(line___0, tstr___0, opipep, pipep - opipep);
#line 352
  if (tmp___35 == -1) {
#line 353
    js_destroy(tstr___0);
#line 354
    goto clean;
  }
#line 356
  tempp = email_2rfc1035(tstr___0);
#line 357
  if (tempp == -1) {
#line 358
    js_qstr2js(name, (char *)"ERROR");
#line 359
    js_qstr2js(data, (char *)"Malformed domain email");
#line 360
    js_destroy(tstr___0);
#line 361
    goto error;
  }
#line 363
  tmp___36 = js_append(tstr___0, data);
#line 363
  if (tmp___36 == -1) {
#line 364
    js_destroy(tstr___0);
#line 365
    goto clean;
  }
#line 367
  tmp___37 = js_destroy(tstr___0);
#line 367
  if (tmp___37 == -1) {
#line 368
    goto clean;
  }
#line 372
  counter = 0;
#line 372
  while (counter < 5) {
#line 373
    if (pipep == -2) {
#line 374
      js_qstr2js(name, (char *)"ERROR");
#line 375
      js_qstr2js(data, (char *)"You must have nine fields in the SOA");
#line 376
      goto error;
    }
#line 378
    soanum = js_atoi(line___0, pipep + 1);
#line 379
    tmp___38 = js_addbyte(data, (unsigned char )(soanum >> 24));
#line 379
    if (tmp___38 == -1) {
#line 380
      goto clean;
    }
#line 381
    tmp___39 = js_addbyte(data, (unsigned char )((soanum >> 16) & 255U));
#line 381
    if (tmp___39 == -1) {
#line 382
      goto clean;
    }
#line 383
    tmp___40 = js_addbyte(data, (unsigned char )((soanum >> 8) & 255U));
#line 383
    if (tmp___40 == -1) {
#line 384
      goto clean;
    }
#line 385
    tmp___41 = js_addbyte(data, (unsigned char )(soanum & 255U));
#line 385
    if (tmp___41 == -1) {
#line 386
      goto clean;
    }
#line 387
    pipep = js_match_offset(pipeq, line___0, pipep + 1);
#line 388
    if (pipep == -1) {
#line 389
      goto clean;
    }
#line 372
    counter ++;
  }
#line 391
  break;
  default: 
#line 393
  goto clean;
  }
#line 397
  tmp___42 = js_addbyte(name, (unsigned char )(((int )type & 65280) >> 16));
#line 397
  if (tmp___42 == -1) {
#line 398
    goto clean;
  }
#line 399
  tmp___43 = js_addbyte(name, (unsigned char )((int )type & 255));
#line 399
  if (tmp___43 == -1) {
#line 400
    goto clean;
  }
#line 402
  js_destroy(pipeq);
#line 402
  js_destroy(hashq___0);
#line 402
  js_destroy(starq);
#line 403
  js_destroy(blankq___0);
#line 403
  js_destroy(field);
#line 404
  return ((int )type);
  clean: 
#line 407
  js_destroy(pipeq);
#line 407
  js_destroy(hashq___0);
#line 407
  js_destroy(starq);
#line 408
  js_destroy(blankq___0);
#line 408
  js_destroy(field);
#line 409
  return (-1);
  error: 
#line 411
  js_destroy(pipeq);
#line 411
  js_destroy(hashq___0);
#line 411
  js_destroy(starq);
#line 412
  js_destroy(blankq___0);
#line 412
  js_destroy(field);
#line 413
  return (-2);
  cero: 
#line 415
  js_destroy(pipeq);
#line 415
  js_destroy(hashq___0);
#line 415
  js_destroy(starq);
#line 416
  js_destroy(blankq___0);
#line 416
  js_destroy(field);
#line 417
  return (0);
}
}
#line 429 "ParseCsv1.c"
int ddip_2_ip(js_string *ddip , js_string *ip , int offset ) 
{ int qr ;
  int counter ;
  int ret ;
  unsigned char ip_byte ;
  js_string *dotq___0 ;
  js_string *numdotq___0 ;
  char dot ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  js_string *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned int tmp___6 ;
  int tmp___7 ;

  {
#line 435
  dotq___0 = (js_string *)0;
#line 436
  numdotq___0 = (js_string *)0;
#line 438
  dot = (char )'.';
#line 441
  tmp = mara_goodjs(ddip);
#line 441
  if (tmp == -1) {
#line 442
    return (-1);
  }
#line 443
  tmp___0 = mara_goodjs(ip);
#line 443
  if (tmp___0 == -1) {
#line 444
    return (-1);
  }
#line 447
  if ((unsigned long )dotq___0 == (unsigned long )((js_string *)0)) {
#line 448
    dotq___0 = js_create(7U, 1U);
#line 448
    if ((unsigned long )dotq___0 == (unsigned long )((js_string *)0)) {
#line 449
      return (-1);
    }
#line 451
    tmp___1 = js_str2js(dotq___0, & dot, 1, 1);
#line 451
    if (tmp___1 == -1) {
#line 452
      js_destroy(dotq___0);
#line 453
      dotq___0 = (js_string *)0;
#line 454
      return (-1);
    }
  }
#line 457
  if ((unsigned long )numdotq___0 == (unsigned long )((js_string *)0)) {
#line 458
    numdotq___0 = js_create(211U, 1U);
#line 458
    if ((unsigned long )numdotq___0 == (unsigned long )((js_string *)0)) {
#line 459
      js_destroy(dotq___0);
#line 460
      return (-1);
    }
#line 462
    tmp___2 = js_set_encode(numdotq___0, 3);
#line 462
    if (tmp___2 == -1) {
#line 463
      js_destroy(numdotq___0);
#line 464
      js_destroy(dotq___0);
#line 465
      numdotq___0 = (js_string *)0;
#line 466
      return (-1);
    }
#line 469
    tmp___3 = js_numbers(numdotq___0);
#line 469
    if ((unsigned long )tmp___3 == (unsigned long )((js_string *)0)) {
#line 470
      js_destroy(numdotq___0);
#line 471
      js_destroy(dotq___0);
#line 472
      numdotq___0 = (js_string *)0;
#line 473
      return (-1);
    }
#line 476
    tmp___4 = js_append(dotq___0, numdotq___0);
#line 476
    if (tmp___4 == -1) {
#line 477
      js_destroy(numdotq___0);
#line 478
      js_destroy(dotq___0);
#line 479
      numdotq___0 = (js_string *)0;
#line 480
      return (-1);
    }
  }
#line 485
  ret = js_notmatch_offset(numdotq___0, ddip, offset);
#line 486
  if (ret == -1) {
#line 487
    goto clean;
  }
#line 490
  js_qstr2js(ip, (char *)"");
#line 493
  tmp___5 = js_length(ddip);
#line 493
  if (tmp___5 < 1) {
#line 494
    goto clean;
  }
#line 496
  counter = 0;
#line 496
  while (counter < 4) {
#line 497
    if (offset == -2) {
#line 498
      goto clean;
    }
#line 500
    tmp___6 = js_atoi(ddip, offset);
#line 500
    qr = (int )tmp___6;
#line 502
    if (qr < 0) {
#line 503
      goto clean;
    } else
#line 502
    if (qr > 255) {
#line 503
      goto clean;
    }
#line 505
    ip_byte = (unsigned char )qr;
#line 507
    tmp___7 = js_addbyte(ip, ip_byte);
#line 507
    if (tmp___7 == -1) {
#line 508
      goto clean;
    }
#line 510
    offset = js_match_offset(dotq___0, ddip, offset + 1);
#line 511
    if (offset == -1) {
#line 512
      goto clean;
    }
#line 514
    offset ++;
#line 496
    counter ++;
  }
#line 518
  if (ret < offset) {
#line 518
    if (offset != -1) {
#line 519
      goto clean;
    }
  }
#line 522
  js_destroy(dotq___0);
#line 523
  js_destroy(numdotq___0);
#line 526
  if (ret == -2) {
#line 527
    return (-2);
  }
#line 529
  return (ret);
  clean: 
#line 532
  js_destroy(dotq___0);
#line 533
  js_destroy(numdotq___0);
#line 534
  return (-1);
}
}
#line 546 "ParseCsv1.c"
int bs_process(js_string *in , js_string *out , js_string *sub ) 
{ int value___0 ;
  int iplace ;
  int oplace ;
  int subq ;
  int inlabel ;
  unsigned char byte ;
  int firstchar ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 552
  tmp = mara_goodjs(in);
#line 552
  if (tmp == -1) {
#line 553
    return (-1);
  }
#line 554
  tmp___0 = mara_goodjs(out);
#line 554
  if (tmp___0 == -1) {
#line 555
    return (-1);
  }
#line 556
  subq = 1;
#line 557
  if ((unsigned long )sub == (unsigned long )((js_string *)0)) {
#line 558
    subq = 0;
  } else {
#line 559
    tmp___1 = mara_goodjs(sub);
#line 559
    if (tmp___1 == -1) {
#line 560
      return (-1);
    }
  }
#line 562
  inlabel = 0;
#line 562
  oplace = inlabel;
#line 562
  iplace = oplace;
#line 563
  firstchar = 1;
#line 564
  while ((unsigned int )iplace < in->unit_count) {
#line 565
    byte = *(in->string + iplace);
#line 568
    if (inlabel) {
#line 568
      if ((int )byte >= 65) {
#line 568
        if ((int )byte <= 90) {
#line 569
          byte = (unsigned char )((int )byte + 32);
        }
      }
    }
#line 570
    if (firstchar == 1) {
#line 571
      inlabel = 1;
#line 572
      firstchar = 0;
    }
#line 574
    if ((int )byte == 35) {
#line 575
      inlabel = 0;
    } else
#line 574
    if ((int )byte == 124) {
#line 575
      inlabel = 0;
    }
#line 576
    if (subq) {
#line 576
      if ((int )byte == 37) {
#line 577
        if ((unsigned int )oplace >= out->max_count) {
#line 578
          return (-1);
        }
#line 579
        out->unit_count = (unsigned int )oplace;
#line 580
        js_append(sub, out);
#line 581
        oplace = (int )out->unit_count;
#line 582
        iplace ++;
#line 583
        continue;
      } else {
#line 576
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 585
    if ((int )byte == 92) {
#line 586
      iplace ++;
#line 587
      if ((unsigned int )iplace >= in->unit_count) {
#line 588
        return (-1);
      }
#line 589
      byte = *(in->string + iplace);
#line 590
      if ((int )byte >= 48) {
#line 590
        if ((int )byte <= 51) {
#line 591
          value___0 = ((int )byte - 48) * 64;
#line 593
          iplace ++;
#line 594
          if ((unsigned int )iplace >= in->unit_count) {
#line 595
            return (-1);
          }
#line 596
          byte = *(in->string + iplace);
#line 597
          if ((int )byte < 48) {
#line 598
            return (-1);
          } else
#line 597
          if ((int )byte > 57) {
#line 598
            return (-1);
          }
#line 599
          value___0 += ((int )byte - 48) * 8;
#line 601
          iplace ++;
#line 602
          if ((unsigned int )iplace >= in->unit_count) {
#line 603
            return (-1);
          }
#line 604
          byte = *(in->string + iplace);
#line 605
          if ((int )byte < 48) {
#line 606
            return (-1);
          } else
#line 605
          if ((int )byte > 57) {
#line 606
            return (-1);
          }
#line 607
          value___0 += (int )byte - 48;
#line 608
          byte = (unsigned char )value___0;
        } else {
#line 590
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 610
      if ((int )byte != 92) {
#line 610
        if ((int )byte != 37) {
#line 611
          return (-1);
        }
      }
    }
#line 614
    if ((unsigned int )oplace < out->max_count) {
#line 615
      *(out->string + oplace) = byte;
    } else {
#line 617
      return (-1);
    }
#line 619
    oplace ++;
#line 621
    iplace ++;
  }
#line 625
  out->unit_count = (unsigned int )oplace;
#line 626
  return (1);
}
}
#line 1 "ParseIpAcl.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-EVsxmDs4.i","")
#line 49 "ParseIpAcl.c"
int ddip_ip_mask(js_string *ddip , ipv4pair *ips , int offset ) ;
#line 49 "ParseIpAcl.c"
static js_string *dotq  =    (js_string *)0;
#line 50 "ParseIpAcl.c"
static js_string *numdotq  =    (js_string *)0;
#line 51 "ParseIpAcl.c"
static js_string *slashq  =    (js_string *)0;
#line 52 "ParseIpAcl.c"
static uint32_t masks[33]  = 
#line 52
  {      (uint32_t )0,      (uint32_t )(-0x7FFFFFFF-1),      3221225472U,      3758096384U, 
        4026531840U,      4160749568U,      4227858432U,      4261412864U, 
        4278190080U,      4286578688U,      4290772992U,      4292870144U, 
        4293918720U,      4294443008U,      4294705152U,      4294836224U, 
        4294901760U,      4294934528U,      4294950912U,      4294959104U, 
        4294963200U,      4294965248U,      4294966272U,      4294966784U, 
        4294967040U,      4294967168U,      4294967232U,      4294967264U, 
        4294967280U,      4294967288U,      4294967292U,      4294967294U, 
        4294967295U};
#line 43 "ParseIpAcl.c"
int ddip_ip_mask(js_string *ddip , ipv4pair *ips , int offset ) 
{ int qr ;
  int counter ;
  int firstoffset ;
  int slashp ;
  int ret ;
  unsigned char ip_byte ;
  char dot ;
  char slash ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  js_string *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  int tmp___11 ;

  {
#line 87
  dot = (char )'.';
#line 88
  slash = (char )'/';
#line 91
  tmp = mara_goodjs(ddip);
#line 91
  if (tmp == -1) {
#line 92
    return (-1);
  }
#line 93
  if ((unsigned long )ips == (unsigned long )((ipv4pair *)0)) {
#line 94
    return (-1);
  }
#line 97
  if ((unsigned long )dotq == (unsigned long )((js_string *)0)) {
#line 98
    dotq = js_create(7U, 1U);
#line 98
    if ((unsigned long )dotq == (unsigned long )((js_string *)0)) {
#line 99
      return (-1);
    }
#line 101
    tmp___0 = js_str2js(dotq, & dot, 1, 1);
#line 101
    if (tmp___0 == -1) {
#line 102
      js_destroy(dotq);
#line 103
      dotq = (js_string *)0;
#line 104
      return (-1);
    }
  }
#line 107
  if ((unsigned long )numdotq == (unsigned long )((js_string *)0)) {
#line 108
    numdotq = js_create(211U, 1U);
#line 108
    if ((unsigned long )numdotq == (unsigned long )((js_string *)0)) {
#line 109
      return (-1);
    }
#line 110
    tmp___1 = js_set_encode(numdotq, 3);
#line 110
    if (tmp___1 == -1) {
#line 111
      js_destroy(numdotq);
#line 112
      numdotq = (js_string *)0;
#line 113
      return (-1);
    }
#line 116
    tmp___2 = js_numbers(numdotq);
#line 116
    if ((unsigned long )tmp___2 == (unsigned long )((js_string *)0)) {
#line 117
      js_destroy(numdotq);
#line 118
      numdotq = (js_string *)0;
#line 119
      return (-1);
    }
#line 122
    tmp___3 = js_append(dotq, numdotq);
#line 122
    if (tmp___3 == -1) {
#line 123
      js_destroy(numdotq);
#line 124
      numdotq = (js_string *)0;
#line 125
      return (-1);
    }
  }
#line 128
  if ((unsigned long )slashq == (unsigned long )((js_string *)0)) {
#line 129
    slashq = js_create(7U, 1U);
#line 129
    if ((unsigned long )slashq == (unsigned long )((js_string *)0)) {
#line 130
      return (-1);
    }
#line 132
    tmp___4 = js_str2js(slashq, & slash, 1, 1);
#line 132
    if (tmp___4 == -1) {
#line 133
      js_destroy(slashq);
#line 134
      slashq = (js_string *)0;
#line 135
      return (-1);
    }
  }
#line 140
  firstoffset = offset;
#line 143
  ret = js_notmatch_offset(numdotq, ddip, offset);
#line 146
  if (ret == -1) {
#line 147
    return (-1);
  } else
#line 146
  if (ret == offset) {
#line 147
    return (-1);
  }
#line 150
  tmp___5 = js_length(ddip);
#line 150
  if (tmp___5 < offset + 1) {
#line 151
    return (-1);
  }
#line 153
  ips->ip = (uint32_t )0;
#line 155
  counter = 0;
#line 155
  while (counter < 4) {
#line 156
    if (offset == -2) {
#line 157
      return (-1);
    }
#line 159
    tmp___6 = js_atoi(ddip, offset);
#line 159
    qr = (int )tmp___6;
#line 161
    if (qr < 0) {
#line 162
      return (-1);
    } else
#line 161
    if (qr > 255) {
#line 162
      return (-1);
    }
#line 164
    ip_byte = (unsigned char )qr;
#line 167
    ips->ip |= (unsigned int )(((int )ip_byte & 255) << (24 - 8 * counter));
#line 170
    if (counter == 4) {
#line 170
      if (ret < offset) {
#line 171
        return (-1);
      }
    }
#line 173
    offset = js_match_offset(dotq, ddip, offset + 1);
#line 174
    if (offset == -1) {
#line 175
      return (-1);
    }
#line 177
    offset ++;
#line 155
    counter ++;
  }
#line 181
  tmp___7 = js_match_offset(slashq, ddip, firstoffset);
#line 181
  if (tmp___7 != ret) {
#line 183
    ips->mask = 4294967295U;
#line 184
    return (ret);
  } else {
#line 181
    tmp___8 = js_match_offset(slashq, ddip, firstoffset);
#line 181
    if (tmp___8 == -2) {
#line 183
      ips->mask = 4294967295U;
#line 184
      return (ret);
    }
  }
#line 186
  slashp = ret;
#line 190
  ret = js_match_offset(dotq, ddip, slashp + 1);
#line 191
  if (ret == -1) {
#line 192
    return (-1);
  }
#line 193
  offset = js_notmatch_offset(numdotq, ddip, slashp + 1);
#line 194
  if (offset == -1) {
#line 195
    return (-1);
  }
#line 197
  if (ret == -2) {
#line 197
    goto _L;
  } else
#line 197
  if (offset < ret) {
#line 197
    if (offset != -2) {
      _L: /* CIL Label */ 
#line 198
      tmp___9 = js_atoi(ddip, slashp + 1);
#line 198
      ret = (int )tmp___9;
#line 199
      if (ret < 0) {
#line 200
        return (-1);
      } else
#line 199
      if (ret > 32) {
#line 200
        return (-1);
      }
#line 201
      ips->mask = masks[ret];
#line 202
      if ((unsigned int )(offset + 1) < ddip->unit_count) {
#line 203
        return (offset + 1);
      } else {
#line 205
        return (-2);
      }
    } else {
#line 197
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 208
    offset = slashp + 1;
#line 209
    ips->mask = (uint32_t )0;
#line 210
    counter = 0;
#line 210
    while (counter < 4) {
#line 211
      if (offset == -2) {
#line 212
        return (-1);
      }
#line 214
      tmp___10 = js_atoi(ddip, offset);
#line 214
      qr = (int )tmp___10;
#line 216
      if (qr < 0) {
#line 217
        return (-1);
      } else
#line 216
      if (qr > 255) {
#line 217
        return (-1);
      }
#line 219
      ip_byte = (unsigned char )qr;
#line 222
      ips->mask |= (unsigned int )(((int )ip_byte & 255) << (24 - 8 * counter));
#line 224
      if (counter != 3) {
#line 225
        offset = js_match_offset(dotq, ddip, offset + 1);
#line 226
        if (offset == -1) {
#line 227
          return (-1);
        }
      } else {
#line 230
        tmp___11 = js_notmatch_offset(numdotq, ddip, offset + 1);
#line 230
        return (tmp___11);
      }
#line 232
      offset ++;
#line 210
      counter ++;
    }
#line 234
    return (-1);
  }
#line 237
  return (-1);
}
}
#line 258 "ParseIpAcl.c"
int make_ip_acl(js_string *in , ipv4pair *out , int max , int depth ) 
{ js_string *sub ;
  js_string *delimq ;
  js_string *value___0 ;
  int start ;
  int next ;
  int index ;
  char delim ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int nx ;
  int tmp___3 ;
  int nx___0 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 260
  sub = (js_string *)0;
#line 260
  delimq = (js_string *)0;
#line 260
  value___0 = (js_string *)0;
#line 261
  index = 0;
#line 262
  delim = (char )',';
#line 265
  if (depth > 32) {
#line 266
    return (-1);
  }
#line 267
  tmp = js_has_sanity(in);
#line 267
  if (tmp == -1) {
#line 268
    return (-1);
  }
#line 269
  if (in->unit_size != 1U) {
#line 270
    return (-1);
  }
#line 271
  if ((unsigned long )out == (unsigned long )((ipv4pair *)0)) {
#line 272
    return (-1);
  }
#line 275
  sub = js_create(256U, 1U);
#line 275
  if ((unsigned long )sub == (unsigned long )((js_string *)0)) {
#line 276
    return (-1);
  }
#line 277
  tmp___0 = js_set_encode(sub, 3);
#line 277
  if (tmp___0 == -1) {
#line 278
    return (-1);
  }
#line 279
  value___0 = js_create(512U, 1U);
#line 279
  if ((unsigned long )value___0 == (unsigned long )((js_string *)0)) {
#line 280
    return (-1);
  }
#line 281
  tmp___1 = js_set_encode(value___0, 3);
#line 281
  if (tmp___1 == -1) {
#line 282
    return (-1);
  }
#line 283
  delimq = js_create(7U, 1U);
#line 283
  if ((unsigned long )delimq == (unsigned long )((js_string *)0)) {
#line 284
    js_destroy(sub);
#line 285
    return (-1);
  }
#line 287
  tmp___2 = js_str2js(delimq, & delim, 1, 1);
#line 287
  if (tmp___2 == -1) {
#line 288
    js_destroy(sub);
#line 288
    js_destroy(value___0);
#line 288
    js_destroy(delimq);
#line 289
    return (-1);
  }
#line 292
  next = -1;
#line 293
  while (1) {
#line 294
    start = next + 1;
#line 296
    next = js_match_offset(delimq, in, start);
#line 297
    if (next == -1) {
#line 298
      js_destroy(sub);
#line 298
      js_destroy(delimq);
#line 298
      js_destroy(value___0);
#line 299
      return (-1);
    }
#line 302
    if (next == -2) {
#line 303
      nx = (int )(in->unit_count - 1U);
#line 305
      while (1) {
#line 305
        if (start < nx) {
#line 305
          if (! ((int )*(in->string + start) == 32)) {
#line 305
            break;
          }
        } else {
#line 305
          break;
        }
#line 306
        start ++;
      }
#line 309
      while (1) {
#line 309
        if (nx > start) {
#line 309
          if (! ((int )*(in->string + nx) == 32)) {
#line 309
            if (! ((int )*(in->string + start) == 9)) {
#line 309
              break;
            }
          }
        } else {
#line 309
          break;
        }
#line 311
        if (nx >= 0) {
#line 312
          nx --;
        } else {
#line 315
          js_destroy(sub);
#line 315
          js_destroy(delimq);
#line 315
          js_destroy(value___0);
#line 316
          return (-1);
        }
      }
#line 320
      tmp___3 = js_substr(in, sub, start, (nx + 1) - start);
#line 320
      if (tmp___3 == -1) {
#line 321
        js_destroy(sub);
#line 321
        js_destroy(delimq);
#line 321
        js_destroy(value___0);
#line 322
        return (-1);
      }
    } else {
#line 326
      nx___0 = next;
#line 328
      while (1) {
#line 328
        if (start < nx___0) {
#line 328
          if (! ((int )*(in->string + start) == 32)) {
#line 328
            if (! ((int )*(in->string + start) == 9)) {
#line 328
              break;
            }
          }
        } else {
#line 328
          break;
        }
#line 330
        start ++;
      }
#line 333
      while (1) {
#line 333
        if (nx___0 > start) {
#line 333
          if (! ((int )*(in->string + nx___0) == 32)) {
#line 333
            if (! ((int )*(in->string + start) == 9)) {
#line 333
              if (! ((int )*(in->string + nx___0) == 44)) {
#line 333
                break;
              }
            }
          }
        } else {
#line 333
          break;
        }
#line 336
        if (nx___0 >= 0) {
#line 337
          nx___0 --;
        } else {
#line 340
          js_destroy(sub);
#line 340
          js_destroy(delimq);
#line 340
          js_destroy(value___0);
#line 341
          return (-1);
        }
      }
#line 345
      tmp___4 = js_substr(in, sub, start, (nx___0 + 1) - start);
#line 345
      if (tmp___4 == -1) {
#line 346
        js_destroy(sub);
#line 346
        js_destroy(delimq);
#line 346
        js_destroy(value___0);
#line 347
        return (-1);
      }
    }
#line 351
    tmp___5 = js_qstr2js(value___0, (char *)"ipv4_alias");
#line 351
    if (tmp___5 == -1) {
#line 352
      js_destroy(sub);
#line 352
      js_destroy(delimq);
#line 352
      js_destroy(value___0);
#line 353
      return (-1);
    }
#line 356
    tmp___8 = read_dvar(value___0, sub, value___0);
#line 356
    if (tmp___8 != -1) {
#line 357
      tmp___6 = make_ip_acl(value___0, out, max, depth + 1);
#line 357
      if (tmp___6 == -1) {
#line 358
        js_destroy(sub);
#line 358
        js_destroy(delimq);
#line 358
        js_destroy(value___0);
#line 359
        return (-1);
      }
    } else {
#line 365
      while (1) {
#line 365
        if (index < max) {
#line 365
          if (! ((out + index)->ip != 4294967295U)) {
#line 365
            break;
          }
        } else {
#line 365
          break;
        }
#line 366
        index ++;
      }
#line 368
      if (index >= max) {
#line 369
        js_destroy(sub);
#line 369
        js_destroy(delimq);
#line 369
        js_destroy(value___0);
#line 370
        return (-1);
      }
#line 373
      tmp___7 = ddip_ip_mask(sub, out + index, 0);
#line 373
      if (tmp___7 == -1) {
#line 374
        js_destroy(sub);
#line 374
        js_destroy(delimq);
#line 374
        js_destroy(value___0);
#line 375
        return (-1);
      }
    }
#line 293
    if (! (next != -2)) {
#line 293
      break;
    }
  }
#line 380
  js_destroy(sub);
#line 381
  js_destroy(delimq);
#line 382
  js_destroy(value___0);
#line 383
  return (1);
}
}
#line 1 "Parse_ipv6.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-EakKnXwQ.i","")
#line 35 "Parse_ipv6.c"
int set_nybble(unsigned int nybble , unsigned char *istring , int point , int length ) 
{ char temp ;
  int place ;

  {
#line 39
  if (nybble < 0U) {
#line 40
    return (-1);
  } else
#line 39
  if (nybble > 15U) {
#line 40
    return (-1);
  }
#line 42
  if (length < 0) {
#line 43
    return (-1);
  }
#line 45
  if (length * 2 < point) {
#line 46
    return (-1);
  }
#line 48
  place = point >> 1;
#line 49
  temp = (char )*(istring + place);
#line 50
  if ((point & 1) == 0) {
#line 51
    nybble <<= 4;
#line 52
    temp = (char )((int )temp & 15);
#line 53
    temp = (char )((unsigned int )temp | nybble);
  } else {
#line 56
    temp = (char )((int )temp & 240);
#line 57
    temp = (char )((unsigned int )temp | nybble);
  }
#line 59
  *(istring + place) = (unsigned char )temp;
#line 60
  return (1);
}
}
#line 67 "Parse_ipv6.c"
int hchar_to_nybble(char i ) 
{ 

  {
#line 68
  if ((int )i >= 48) {
#line 68
    if ((int )i <= 57) {
#line 69
      return ((int )i - 48);
    }
  }
#line 70
  if ((int )i >= 97) {
#line 70
    if ((int )i <= 102) {
#line 71
      return (((int )i + 10) - 97);
    }
  }
#line 72
  if ((int )i >= 65) {
#line 72
    if ((int )i <= 70) {
#line 73
      return (((int )i + 10) - 65);
    }
  }
#line 74
  if ((int )i == 58) {
#line 75
    return (-2);
  }
#line 76
  return (-1);
}
}
#line 87 "Parse_ipv6.c"
int set_nybble_char(char nybble , unsigned char *istring , int point , int length ) 
{ int n ;
  int tmp ;

  {
#line 89
  n = hchar_to_nybble(nybble);
#line 90
  if (n == -1) {
#line 91
    return (-1);
  }
#line 92
  if (n == -2) {
#line 93
    return (-2);
  }
#line 94
  tmp = set_nybble((unsigned int )n, istring, point, length);
#line 94
  return (tmp);
}
}
#line 102 "Parse_ipv6.c"
int set_nybble_js(js_string *i , int i_offset , js_string *o , int o_offset ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 103
  tmp = js_has_sanity(i);
#line 103
  if (tmp != 1) {
#line 104
    return (-1);
  }
#line 105
  tmp___0 = js_has_sanity(o);
#line 105
  if (tmp___0 != 1) {
#line 106
    return (-1);
  }
#line 107
  if (i->unit_size != 1U) {
#line 108
    return (-1);
  }
#line 109
  if (o->unit_size != 1U) {
#line 110
    return (-1);
  }
#line 111
  if ((unsigned int )i_offset > i->unit_count) {
#line 112
    return (-1);
  }
#line 113
  if ((unsigned int )o_offset > o->unit_count * 2U) {
#line 114
    return (-1);
  }
#line 115
  tmp___1 = set_nybble_char((char )*(i->string + i_offset), o->string, o_offset, (int )o->unit_count);
#line 115
  return (tmp___1);
}
}
#line 126 "Parse_ipv6.c"
int is_hex_digit(char c ) 
{ int tmp ;

  {
#line 127
  if ((int )c >= 48) {
#line 127
    if ((int )c <= 57) {
#line 127
      tmp = 1;
    } else {
#line 127
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 127
  if ((int )c >= 65) {
#line 127
    if ((int )c <= 70) {
#line 127
      tmp = 1;
    } else {
#line 127
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 127
  if ((int )c >= 97) {
#line 127
    if ((int )c <= 102) {
#line 127
      tmp = 1;
    } else {
#line 127
      tmp = 0;
    }
  } else {
#line 127
    tmp = 0;
  }
#line 127
  return (tmp);
}
}
#line 138 "Parse_ipv6.c"
int is_colon(char c ) 
{ 

  {
#line 139
  return ((int )c == 58);
}
}
#line 149 "Parse_ipv6.c"
int count_thingys(js_string *i , int offset , int (*is_thingy)(char in ) ) 
{ int count ;
  int tmp ;

  {
#line 151
  if (i->unit_size != 1U) {
#line 152
    return (-1);
  }
#line 154
  if (i->unit_count >= i->max_count) {
#line 155
    return (-1);
  }
#line 157
  if ((unsigned int )offset > i->unit_count) {
#line 158
    return (-1);
  }
#line 160
  count = 0;
#line 161
  while (1) {
#line 161
    tmp = (*is_thingy)((char )*(i->string + offset));
#line 161
    if (! tmp) {
#line 161
      break;
    }
#line 162
    count ++;
#line 163
    offset ++;
#line 164
    if ((unsigned int )offset == i->unit_count) {
#line 165
      return (count);
    }
#line 167
    if ((unsigned int )offset > i->unit_count) {
#line 168
      return (-1);
    }
  }
#line 171
  return (count);
}
}
#line 184 "Parse_ipv6.c"
int count_digits(js_string *i , int offset ) 
{ int tmp ;

  {
#line 185
  tmp = count_thingys(i, offset, & is_hex_digit);
#line 185
  return (tmp);
}
}
#line 190 "Parse_ipv6.c"
int see_double_colon(js_string *i , int offset ) 
{ int tmp ;

  {
#line 191
  tmp = count_thingys(i, offset, & is_colon);
#line 191
  return (tmp);
}
}
#line 206 "Parse_ipv6.c"
int count_thingys_all(js_string *i , int offset , int (*is_thingy)(char in ) ) 
{ int count ;
  int tmp ;

  {
#line 208
  if (i->unit_size != 1U) {
#line 209
    return (-1);
  }
#line 211
  if (i->unit_count >= i->max_count) {
#line 212
    return (-1);
  }
#line 214
  if ((unsigned int )offset > i->unit_count) {
#line 215
    return (-1);
  }
#line 217
  count = 0;
#line 218
  while ((unsigned int )offset < i->unit_count) {
#line 219
    tmp = (*is_thingy)((char )*(i->string + offset));
#line 219
    if (tmp) {
#line 220
      count ++;
    }
#line 222
    offset ++;
  }
#line 224
  return (count);
}
}
#line 234 "Parse_ipv6.c"
int count_colons(js_string *i , int offset ) 
{ int tmp ;

  {
#line 235
  tmp = count_thingys_all(i, offset, & is_colon);
#line 235
  return (tmp);
}
}
#line 245 "Parse_ipv6.c"
js_string *ip6_to_raw(js_string *i ) 
{ js_string *o ;
  int input_point ;
  int output_point ;
  int counter ;
  int w ;
  int l ;
  int c ;
  int skipped ;
  int init_colon ;
  int tmp ;
  int q ;
  int n ;
  int tmp___0 ;
  int cc ;

  {
#line 249
  skipped = 0;
#line 250
  init_colon = 1;
#line 253
  tmp = js_has_sanity(i);
#line 253
  if (tmp != 1) {
#line 254
    return ((js_string *)0);
  }
#line 256
  if (i->unit_size != 1U) {
#line 257
    return ((js_string *)0);
  }
#line 261
  o = js_create(16U, 1U);
#line 261
  if ((unsigned long )o == (unsigned long )((js_string *)0)) {
#line 262
    return ((js_string *)0);
  }
#line 266
  counter = 0;
#line 266
  while (counter < 16) {
#line 267
    *(o->string + counter) = (unsigned char)0;
#line 266
    counter ++;
  }
#line 269
  o->unit_count = 16U;
#line 271
  output_point = 0;
#line 271
  input_point = output_point;
#line 273
  w = 1;
#line 275
  l = js_length(i);
#line 277
  c = 0;
#line 279
  while (1) {
#line 279
    if (output_point < 32) {
#line 279
      if (! (input_point < l)) {
#line 279
        break;
      }
    } else {
#line 279
      break;
    }
#line 284
    n = count_digits(i, input_point);
#line 285
    if (init_colon == 1) {
#line 285
      if (n == 0) {
#line 286
        goto zeros;
      }
    }
#line 288
    init_colon = 0;
#line 289
    if (n > 4) {
#line 290
      show_esc_stdout(o);
#line 290
      printf("\n");
#line 291
      js_dealloc((void *)o);
#line 292
      return ((js_string *)0);
    } else
#line 289
    if (n < 1) {
#line 290
      show_esc_stdout(o);
#line 290
      printf("\n");
#line 291
      js_dealloc((void *)o);
#line 292
      return ((js_string *)0);
    }
#line 295
    counter = 0;
#line 295
    while (counter < 4 - n) {
#line 296
      set_nybble(0U, o->string, output_point, (int )o->unit_count);
#line 297
      output_point ++;
#line 295
      counter ++;
    }
#line 299
    counter = 4 - n;
#line 299
    while (counter < 4) {
#line 300
      tmp___0 = set_nybble_js(i, input_point, o, output_point);
#line 300
      if (tmp___0 != 1) {
#line 302
        js_dealloc((void *)o);
#line 303
        return ((js_string *)0);
      }
#line 305
      input_point ++;
#line 306
      output_point ++;
#line 299
      counter ++;
    }
    zeros: 
#line 311
    if ((unsigned int )input_point < i->unit_count) {
#line 312
      q = see_double_colon(i, input_point);
    } else
#line 313
    if ((unsigned int )input_point == i->unit_count) {
#line 314
      q = 0;
    } else {
#line 316
      js_dealloc((void *)o);
#line 317
      return ((js_string *)0);
    }
#line 319
    if (q == -1) {
#line 320
      js_dealloc((void *)o);
#line 321
      return ((js_string *)0);
    }
#line 323
    if (q == 2) {
#line 325
      if (skipped != 0) {
#line 329
        js_dealloc((void *)o);
#line 330
        return ((js_string *)0);
      }
#line 332
      skipped = 1;
#line 333
      input_point ++;
#line 342
      cc = count_colons(i, input_point);
#line 343
      if (cc == -1) {
#line 344
        js_dealloc((void *)o);
#line 345
        return ((js_string *)0);
      }
#line 347
      if (init_colon == 1) {
#line 348
        cc --;
      }
#line 350
      output_point += 4 * ((8 - (c + 1)) - cc);
#line 351
      input_point ++;
    } else
#line 353
    if (q == 1) {
#line 354
      input_point ++;
    } else
#line 356
    if (q == 0) {
#line 356
      if ((unsigned int )input_point == i->unit_count) {
#line 357
        return (o);
      } else {
#line 360
        js_dealloc((void *)o);
#line 361
        return ((js_string *)0);
      }
    } else {
#line 360
      js_dealloc((void *)o);
#line 361
      return ((js_string *)0);
    }
#line 363
    init_colon = 0;
#line 364
    c ++;
  }
#line 366
  if (input_point < l) {
#line 367
    js_dealloc((void *)o);
#line 368
    return ((js_string *)0);
  }
#line 370
  return (o);
}
}
#line 1 "Csv2_read.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-L_m3WcDm.i","")
#line 240 "/usr/include/stdio.h"
extern int fclose(FILE * ) ;
#line 250
extern FILE *fopen(char const   * , char const   * )  __asm__("_fopen")  ;
#line 257 "Csv2_functions.h"
int csv2_close(csv2_read *file___0 ) ;
#line 258
int csv2_readchar(csv2_read *file___0 ) ;
#line 259
int csv2_justread(csv2_read *file___0 ) ;
#line 260
int csv2_error(csv2_read *file___0 , char *why ) ;
#line 261
int32_t csv2_get_unicode(csv2_read *file___0 ) ;
#line 262
int csv2_set_unicode(csv2_read *file___0 , int32_t in ) ;
#line 263
csv2_read *csv2_open(js_string *filename ) ;
#line 289
int csv2_push_file(csv2_read *file___0 , js_string *filename ) ;
#line 290
int csv2_pop_file(csv2_read *file___0 ) ;
#line 291
void csv2_allow_tilde(csv2_read *file___0 ) ;
#line 292
void csv2_forbid_tilde(csv2_read *file___0 ) ;
#line 293
void csv2_allow_leftbrace(csv2_read *file___0 ) ;
#line 294
void csv2_forbid_leftbrace(csv2_read *file___0 ) ;
#line 295
int csv2_tilde_seen(csv2_read *file___0 ) ;
#line 296
void csv2_reset_tilde_seen(csv2_read *file___0 ) ;
#line 36 "Csv2_read.c"
csv2_read *csv2_open(js_string *filename ) 
{ csv2_read *out ;
  int c ;
  void *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  FILE *tmp___3 ;

  {
#line 41
  if (filename->unit_size != 1U) {
#line 42
    return ((csv2_read *)0);
  }
#line 45
  tmp = js_alloc((int )sizeof(csv2_read ), 1);
#line 45
  out = (csv2_read *)tmp;
#line 45
  if ((unsigned long )out == (unsigned long )((csv2_read *)0)) {
#line 46
    return ((csv2_read *)0);
  }
#line 49
  tmp___1 = js_alloc((int )(filename->unit_count + 3U), 1);
#line 49
  tmp___0 = (char *)tmp___1;
#line 49
  out->filename = tmp___0;
#line 49
  if ((unsigned long )tmp___0 == (unsigned long )((char *)0)) {
#line 50
    js_dealloc((void *)out);
#line 51
    return ((csv2_read *)0);
  }
#line 54
  tmp___2 = js_js2str(filename, out->filename, (int )(filename->unit_count + 1U));
#line 54
  if (tmp___2 == -1) {
#line 56
    js_dealloc((void *)out);
#line 57
    return ((csv2_read *)0);
  }
#line 61
  out->stack = (csv2_file *)0;
#line 62
  out->stack_height = 0;
#line 63
  out->mnum = 0;
#line 64
  out->mplace = 0;
#line 65
  out->cplace = 0;
#line 66
  c = 0;
#line 66
  while (c < 19) {
#line 67
    out->context[c] = (char)0;
#line 66
    c ++;
  }
#line 69
  out->tilde_seen = (char)0;
#line 70
  out->tilde_handling = (char )csv2_tilde_handling;
#line 71
  if (csv2_tilde_handling == 0) {
#line 72
    out->chars_allowed = (char)1;
  } else {
#line 75
    out->chars_allowed = (char)0;
  }
#line 78
  out->linenum = 1;
#line 79
  out->justread = -328;
#line 81
  out->unicode = -1;
#line 82
  out->ok_to_read = 1;
#line 83
  out->seen_bug_msg = (char)0;
#line 85
  tmp___3 = fopen((char const   *)out->filename, "rb");
#line 85
  out->reading = tmp___3;
#line 85
  if ((unsigned long )tmp___3 == (unsigned long )((FILE *)0)) {
#line 86
    js_dealloc((void *)out);
#line 87
    return ((csv2_read *)0);
  }
#line 90
  return (out);
}
}
#line 100 "Csv2_read.c"
int csv2_close(csv2_read *file___0 ) 
{ csv2_file *v ;
  csv2_file *w ;
  int a ;
  int tmp ;
  int tmp___0 ;

  {
#line 102
  a = 0;
#line 103
  tmp = fclose(file___0->reading);
#line 103
  if (tmp != 0) {
#line 104
    return (-1);
  }
#line 107
  v = file___0->stack;
#line 108
  while (1) {
#line 108
    if ((unsigned long )v != (unsigned long )((csv2_file *)0)) {
#line 108
      if (! (a < 1000)) {
#line 108
        break;
      }
    } else {
#line 108
      break;
    }
#line 109
    w = v->next;
#line 110
    fclose(v->reading);
#line 111
    js_dealloc((void *)v->filename);
#line 112
    js_dealloc((void *)v);
#line 113
    v = w;
#line 114
    a ++;
  }
#line 117
  js_dealloc((void *)file___0->filename);
#line 119
  tmp___0 = js_dealloc((void *)file___0);
#line 119
  if (tmp___0 != 1) {
#line 120
    return (-1);
  }
#line 123
  return (1);
}
}
#line 132 "Csv2_read.c"
int csv2_readchar(csv2_read *file___0 ) 
{ int out ;
  char *mstrn ;
  int tmp ;

  {
#line 133
  out = -2;
#line 134
  mstrn = (char *)"NO MACROS YET**";
#line 137
  if (file___0->ok_to_read != 1) {
#line 138
    if ((int )file___0->seen_bug_msg == 0) {
#line 139
      printf("BUG: The code shouln\'t be trying to read from");
#line 140
      printf(" a closed stream!\n");
#line 141
      file___0->seen_bug_msg = (char )((int )file___0->seen_bug_msg + 1);
    }
#line 143
    return (-2);
  }
#line 149
  if (file___0->mnum == -1) {
#line 150
    if (file___0->mplace < 0) {
#line 151
      file___0->mplace = 0;
#line 152
      file___0->mnum = 0;
    } else
#line 150
    if (file___0->mplace >= 14) {
#line 151
      file___0->mplace = 0;
#line 152
      file___0->mnum = 0;
    } else {
#line 155
      out = (int )*(mstrn + file___0->mplace);
#line 156
      if (out == 0) {
#line 157
        file___0->mplace = 0;
#line 158
        file___0->mnum = 0;
      } else {
#line 161
        (file___0->mplace) ++;
#line 162
        file___0->justread = out;
#line 163
        return (out);
      }
    }
  }
#line 169
  if (file___0->mnum == 0) {
    read_char: 
#line 171
    out = getc(file___0->reading);
#line 177
    if (out < 32) {
#line 177
      if (out >= 0) {
#line 177
        if (out != 9) {
#line 177
          if (out != 13) {
#line 177
            if (out != 10) {
#line 179
              printf("Warning: Unprintable character in zone file: %02x\n", out);
            }
          }
        }
      }
    }
#line 182
    tmp = file___0->cplace;
#line 182
    (file___0->cplace) ++;
#line 182
    file___0->context[tmp] = (char )out;
#line 183
    if (file___0->cplace == 19) {
#line 183
      file___0->cplace = 0;
    }
#line 184
    if (out == 10) {
#line 185
      (file___0->linenum) ++;
    }
#line 187
    if (out == -1) {
#line 188
      if ((unsigned long )file___0->stack != (unsigned long )((csv2_file *)0)) {
#line 189
        csv2_pop_file(file___0);
#line 190
        goto read_char;
      }
#line 192
      return (-2);
    }
#line 195
    if (out == 126) {
#line 195
      if ((int )file___0->tilde_seen < 10) {
#line 196
        file___0->tilde_seen = (char )((int )file___0->tilde_seen + 1);
      }
    }
#line 199
    if (out == 123) {
#line 199
      if (((int )file___0->chars_allowed & 2) != 2) {
#line 202
        csv2_error(file___0, (char *)"The \'{\' character is currently not allowed there in zone files.\nPlease use an unquoted \\x7b if you need this character in a txt or raw record.\nSee the csv2_txt man page for more information.");
      } else {
#line 199
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 209
    if (out == 126) {
#line 209
      if (((int )file___0->chars_allowed & 1) != 1) {
#line 211
        csv2_error(file___0, (char *)"The \'~\' character is currently not allowed there in zone files.\nPlease use an unquoted \\x7e if you need this character in a txt or raw record.\nSee the csv2_txt man page for more information.");
      } else {
#line 218
        file___0->justread = out;
#line 219
        return (out);
      }
    } else {
#line 218
      file___0->justread = out;
#line 219
      return (out);
    }
  }
#line 222
  return (out);
}
}
#line 230 "Csv2_read.c"
int csv2_justread(csv2_read *file___0 ) 
{ 

  {
#line 231
  if (file___0->ok_to_read != 1) {
#line 232
    printf("BUG: Don\'t run csv2_justread on a closed file!\n");
#line 233
    return (-1);
  }
#line 235
  return (file___0->justread);
}
}
#line 239 "Csv2_read.c"
int csv2_error(csv2_read *file___0 , char *why ) 
{ int c ;
  int lastcr ;

  {
#line 241
  printf("Error: ");
#line 242
  printf("%s\n", why);
#line 243
  printf("Error is on line ");
#line 247
  if (file___0->justread == 10) {
#line 248
    (file___0->linenum) --;
#line 249
    file___0->justread = '\000';
  }
#line 251
  printf("%d", file___0->linenum);
#line 252
  printf(" in file ");
#line 253
  printf("%s\n", file___0->filename);
#line 256
  printf("context of error: ");
#line 258
  c = file___0->cplace;
#line 263
  lastcr = -1;
#line 264
  while (1) {
#line 265
    c ++;
#line 266
    c %= 19;
#line 267
    if ((int )file___0->context[c] == 10) {
#line 267
      if (c != file___0->cplace) {
#line 268
        lastcr = c;
      }
    }
#line 264
    if (! (c != file___0->cplace)) {
#line 264
      break;
    }
  }
#line 271
  if (lastcr != -1) {
#line 272
    c = lastcr + 1;
#line 273
    c %= 19;
  }
#line 277
  if (file___0->cplace == (c + 1) % 19) {
#line 281
    printf("<near beginning of line> ");
  } else
#line 277
  if (file___0->cplace == (c + 2) % 19) {
#line 281
    printf("<near beginning of line> ");
  } else
#line 277
  if (file___0->cplace == (c + 3) % 19) {
#line 281
    printf("<near beginning of line> ");
  } else
#line 277
  if (file___0->cplace == (c + 4) % 19) {
#line 281
    printf("<near beginning of line> ");
  }
#line 285
  while (1) {
#line 286
    if ((int )file___0->context[c] >= 32) {
#line 287
      printf("%c", (int )file___0->context[c]);
    } else
#line 289
    if ((int )file___0->context[c] == 9) {
#line 290
      printf("   ");
    } else
#line 291
    if ((int )file___0->context[c] > 0) {
#line 292
      printf("~");
    }
#line 294
    c ++;
#line 295
    c %= 19;
#line 285
    if (! (c != file___0->cplace)) {
#line 285
      break;
    }
  }
#line 298
  printf(" (closing this file)\n");
#line 300
  file___0->ok_to_read = 0;
#line 301
  return (1);
}
}
#line 308 "Csv2_read.c"
int csv2_push_file(csv2_read *file___0 , js_string *filename ) 
{ csv2_file *o ;
  char *nf ;
  FILE *nfd ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 313
  if (file___0->stack_height > 7) {
#line 314
    return (0);
  }
#line 317
  if ((unsigned long )filename == (unsigned long )((js_string *)0)) {
#line 318
    return (0);
  }
#line 321
  if (filename->unit_size != 1U) {
#line 322
    return (0);
  }
#line 325
  tmp = js_alloc((int )(filename->unit_count + 3U), 1);
#line 325
  nf = (char *)tmp;
#line 325
  if ((unsigned long )nf == (unsigned long )((char *)0)) {
#line 326
    return (0);
  }
#line 329
  tmp___0 = js_js2str(filename, nf, (int )(filename->unit_count + 1U));
#line 329
  if (tmp___0 == -1) {
#line 331
    js_dealloc((void *)nf);
#line 332
    return (0);
  }
#line 335
  nfd = fopen((char const   *)nf, "rb");
#line 335
  if ((unsigned long )nfd == (unsigned long )((FILE *)0)) {
#line 336
    js_dealloc((void *)nf);
#line 337
    return (0);
  }
#line 340
  tmp___1 = js_alloc(1, (int )(sizeof(csv2_file ) + 1UL));
#line 340
  o = (csv2_file *)tmp___1;
#line 340
  if ((unsigned long )o == (unsigned long )((csv2_file *)0)) {
#line 341
    js_dealloc((void *)nf);
#line 342
    fclose(nfd);
#line 343
    return (0);
  }
#line 346
  o->filename = file___0->filename;
#line 347
  o->reading = file___0->reading;
#line 348
  o->next = file___0->stack;
#line 349
  file___0->stack = o;
#line 350
  file___0->filename = nf;
#line 351
  file___0->reading = nfd;
#line 352
  (file___0->stack_height) ++;
#line 354
  return (1);
}
}
#line 362 "Csv2_read.c"
int csv2_pop_file(csv2_read *file___0 ) 
{ csv2_file *v ;

  {
#line 364
  fclose(file___0->reading);
#line 366
  js_dealloc((void *)file___0->filename);
#line 367
  v = file___0->stack;
#line 369
  if ((unsigned long )v == (unsigned long )((csv2_file *)0)) {
#line 370
    csv2_error(file___0, (char *)"Trying to pop from empty stack");
#line 371
    return (0);
  }
#line 374
  file___0->reading = v->reading;
#line 375
  file___0->filename = v->filename;
#line 376
  file___0->stack = v->next;
#line 377
  (file___0->stack_height) --;
#line 378
  if (file___0->stack_height < 0) {
#line 379
    csv2_error(file___0, (char *)"Trying to pop from empty stack");
#line 380
    return (0);
  }
#line 382
  js_dealloc((void *)v);
#line 384
  return (1);
}
}
#line 389 "Csv2_read.c"
int csv2_set_unicode(csv2_read *file___0 , int32_t in ) 
{ 

  {
#line 390
  if (file___0->ok_to_read != 1) {
#line 391
    printf("BUG: Don\'t run csv2_set_unicode on a closed file!\n");
#line 392
    return (-1);
  }
#line 394
  file___0->unicode = in;
#line 395
  return (0);
}
}
#line 399 "Csv2_read.c"
int32_t csv2_get_unicode(csv2_read *file___0 ) 
{ 

  {
#line 400
  if (file___0->ok_to_read != 1) {
#line 401
    printf("BUG: Don\'t run csv2_get_unicode on a closed file!\n");
#line 402
    return (-1);
  }
#line 404
  return (file___0->unicode);
}
}
#line 408 "Csv2_read.c"
void csv2_allow_tilde(csv2_read *file___0 ) 
{ 

  {
#line 409
  file___0->chars_allowed = (char )((int )file___0->chars_allowed | 1);
#line 410
  return;
}
}
#line 413 "Csv2_read.c"
void csv2_forbid_tilde(csv2_read *file___0 ) 
{ 

  {
#line 414
  file___0->chars_allowed = (char )((int )file___0->chars_allowed & 126);
#line 415
  return;
}
}
#line 418 "Csv2_read.c"
void csv2_allow_leftbrace(csv2_read *file___0 ) 
{ 

  {
#line 419
  file___0->chars_allowed = (char )((int )file___0->chars_allowed | 2);
#line 420
  return;
}
}
#line 423 "Csv2_read.c"
void csv2_forbid_leftbrace(csv2_read *file___0 ) 
{ 

  {
#line 424
  file___0->chars_allowed = (char )((int )file___0->chars_allowed & 125);
#line 425
  return;
}
}
#line 428 "Csv2_read.c"
int csv2_tilde_seen(csv2_read *file___0 ) 
{ 

  {
#line 429
  return ((int )file___0->tilde_seen);
}
}
#line 433 "Csv2_read.c"
void csv2_reset_tilde_seen(csv2_read *file___0 ) 
{ 

  {
#line 434
  file___0->tilde_seen = (char)0;
#line 435
  return;
}
}
/* compiler builtin: 
   void *__builtin___memcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
#line 1 "Csv2_main.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-S2h_Pp1l.i","")
#line 58 "/usr/include/secure/_string.h"
__inline static void *__inline_memcpy_chk(void *__dest , void const   *__src , size_t __len ) 
{ unsigned long tmp ;
  void *tmp___0 ;

  {
#line 61
  tmp = __builtin_object_size(__dest, 0);
#line 61
  tmp___0 = __builtin___memcpy_chk(__dest, __src, __len, tmp);
#line 61
  return (tmp___0);
}
}
#line 49 "Csv2_functions.h"
csv2_add_state *csv2_init_add_state(js_string *zone ) ;
#line 53
void csv2_zap_add_state(csv2_add_state *x ) ;
#line 58
int csv2_set_bighash(csv2_add_state *state , mhash *bighash___0 ) ;
#line 63
int csv2_set_add_method(csv2_add_state *state , int method ) ;
#line 67
int csv2_close_state(csv2_add_state *state ) ;
#line 72
int csv2_set_soa_serial(csv2_add_state *state , js_string *filename ) ;
#line 77
js_string *csv2_zone_to_udpzone(js_string *zone ) ;
#line 143
csv2_rr *copy_csv2_rr(csv2_rr *source ) ;
#line 164
int csv2_pop_buffer(csv2_add_state *state ) ;
#line 167
int csv2_add_soa(csv2_add_state *state ) ;
#line 215
int csv2_parse_zone_zoneserver(js_string *zone , int connect___0 , int soa_q , q_header *header ) ;
#line 224
int csv2_parse_zone(js_string *filename , csv2_add_state *state , int32_t starwhitis ) ;
#line 244
int csv2_read_rr(csv2_add_state *state , csv2_read *stream , int32_t starwhitis ) ;
#line 43 "Csv2_main.c"
int csv2_parse_main_bighash(mhash *main_table , int32_t starwhitis ) 
{ mhash *csv2s ;
  js_string *zone ;
  js_string *filename ;
  ipv4pair *iplist ;
  int x ;
  int tmp ;
  mhash *tmp___0 ;
  int tmp___1 ;
  js_string *t ;
  int tmp___2 ;

  {
#line 51
  tmp = dq_keyword2n((char *)"csv2");
#line 51
  tmp___0 = dvar_raw(tmp);
#line 51
  csv2s = tmp___0;
#line 54
  if ((unsigned long )csv2s == (unsigned long )((mhash *)0)) {
#line 55
    return (0);
  }
#line 60
  iplist = get_synthip_list();
#line 61
  x = 0;
#line 61
  while (x < 500) {
#line 62
    if ((iplist + x)->ip == 4294967295U) {
#line 63
      break;
    }
#line 65
    if ((iplist + x)->ip == 0U) {
#line 66
      printf("You can not have both csv2 zone files and have MaraDNS bind to 0.0.0.0\nMaraDNS now supports binding to multiple IPs; please use this feature.\n");
#line 71
      exit(1);
    }
#line 61
    x ++;
  }
#line 76
  zone = js_create(256U, 1U);
#line 76
  if ((unsigned long )zone == (unsigned long )((js_string *)0)) {
#line 77
    return (-1);
  }
#line 83
  tmp___1 = mhash_firstkey(csv2s, zone);
#line 83
  if (tmp___1 == 0) {
#line 84
    js_destroy(zone);
#line 85
    return (0);
  }
#line 89
  while (1) {
#line 90
    filename = mhash_get_js(csv2s, zone);
#line 91
    if ((unsigned long )zone != (unsigned long )((js_string *)0)) {
#line 94
      t = csv2_zone_to_udpzone(zone);
#line 94
      if ((unsigned long )t != (unsigned long )((js_string *)0)) {
#line 95
        csv2_parse_zone_bighash(zone, filename, main_table, starwhitis);
#line 97
        js_destroy(t);
      } else {
#line 99
        printf("Bad zone name ");
#line 100
        show_esc_stdout(zone);
#line 101
        printf(" (don\'t forget the trailing dot!)\n");
      }
    }
#line 89
    tmp___2 = mhash_nextkey(csv2s, zone);
#line 89
    if (! (tmp___2 != 0)) {
#line 89
      break;
    }
  }
#line 106
  js_destroy(zone);
#line 107
  return (0);
}
}
#line 113 "Csv2_main.c"
q_header *csv2_copy_header(q_header *in ) 
{ q_header *out ;
  void *tmp ;
  unsigned long tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  unsigned long tmp___5 ;

  {
#line 115
  tmp = js_alloc((int )sizeof(q_header ), 1);
#line 115
  out = (q_header *)tmp;
#line 115
  if ((unsigned long )out == (unsigned long )((q_header *)0)) {
#line 116
    return ((q_header *)0);
  }
#line 120
  tmp___5 = __builtin_object_size((void *)out, 0);
#line 120
  if (tmp___5 != 0xffffffffffffffffUL) {
#line 120
    tmp___1 = __builtin_object_size((void *)out, 0);
#line 120
    tmp___2 = __builtin___memcpy_chk((void *)out, (void const   *)in, sizeof(q_header ),
                                     tmp___1);
#line 120
    tmp___4 = tmp___2;
  } else {
#line 120
    tmp___3 = __inline_memcpy_chk((void *)out, (void const   *)in, sizeof(q_header ));
#line 120
    tmp___4 = tmp___3;
  }
#line 120
  if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
#line 121
    js_dealloc((void *)out);
#line 122
    return ((q_header *)0);
  }
#line 124
  return (out);
}
}
#line 131 "Csv2_main.c"
js_string *csv2_alabel_to_blabel(js_string *alabel ) 
{ js_string *tmp ;

  {
#line 132
  tmp = csv2_zone_to_udpzone(alabel);
#line 132
  return (tmp);
}
}
#line 139 "Csv2_main.c"
int csv2_append_rr(js_string *reply , csv2_rr *point ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 140
  if ((unsigned long )point == (unsigned long )((csv2_rr *)0)) {
#line 141
    return (-1);
  }
#line 143
  tmp = js_append(point->query, reply);
#line 143
  if (tmp == -1) {
#line 144
    return (-1);
  }
#line 146
  tmp___0 = js_adduint16(reply, point->rtype);
#line 146
  if (tmp___0 == -1) {
#line 147
    return (-1);
  }
#line 150
  tmp___1 = js_adduint16(reply, 1);
#line 150
  if (tmp___1 == -1) {
#line 151
    return (-1);
  }
#line 154
  js_adduint32(reply, (uint32_t )point->ttl);
#line 155
  tmp___2 = js_adduint16(reply, (int )(point->data)->unit_count);
#line 155
  if (tmp___2 == -1) {
#line 156
    return (-1);
  }
#line 158
  tmp___3 = js_append(point->data, reply);
#line 158
  if (tmp___3 == -1) {
#line 159
    return (-1);
  }
#line 161
  return (1);
}
}
#line 172 "Csv2_main.c"
int csv2_tcp_spit_data(csv2_add_state *state , int connect___0 , q_header *header ,
                       js_string *zone , int type , csv2_rr *soa ) 
{ q_header *h_copy ;
  unsigned char len[3] ;
  js_string *reply ;
  js_string *zone_name ;
  csv2_rr *point ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  csv2_rr *point___0 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  ssize_t tmp___7 ;
  ssize_t tmp___8 ;

  {
#line 179
  h_copy = csv2_copy_header(header);
#line 184
  h_copy->qr = 1;
#line 186
  h_copy->aa = 1;
#line 188
  h_copy->tc = 0;
#line 195
  h_copy->ra = 0;
#line 199
  h_copy->z = 0;
#line 200
  h_copy->rcode = 0;
#line 201
  h_copy->qdcount = (uint16_t )1;
#line 204
  h_copy->ancount = (uint16_t )1;
#line 205
  h_copy->nscount = (uint16_t )0;
#line 207
  h_copy->arcount = (uint16_t )0;
#line 211
  point = state->buffer;
#line 213
  if ((unsigned long )point == (unsigned long )((csv2_rr *)0)) {
#line 213
    if (type != 3) {
#line 214
      js_dealloc((void *)h_copy);
#line 215
      return (-1);
    }
  }
#line 218
  if (type != 3) {
#line 219
    point = point->next;
  }
#line 222
  if (type == 1) {
#line 223
    while ((unsigned long )point != (unsigned long )((csv2_rr *)0)) {
#line 224
      if (point->rtype != 2) {
#line 227
        break;
      }
#line 228
      h_copy->nscount = (uint16_t )((int )h_copy->nscount + 1);
#line 229
      if ((int )h_copy->nscount > 1000) {
#line 230
        js_dealloc((void *)h_copy);
#line 231
        return (-1);
      }
#line 233
      point = point->next;
    }
  }
#line 238
  reply = js_create(2048U, 1U);
#line 238
  if ((unsigned long )reply == (unsigned long )((js_string *)0)) {
#line 239
    js_dealloc((void *)h_copy);
#line 240
    return (-1);
  }
#line 244
  tmp = make_hdr(h_copy, reply);
#line 244
  if (tmp == -1) {
#line 245
    js_dealloc((void *)h_copy);
#line 246
    js_destroy(reply);
#line 247
    return (-1);
  }
#line 251
  if (type == 1) {
#line 253
    zone_name = csv2_alabel_to_blabel(zone);
#line 253
    if ((unsigned long )zone_name == (unsigned long )((js_string *)0)) {
#line 254
      js_dealloc((void *)h_copy);
#line 255
      js_destroy(reply);
#line 256
      return (-1);
    }
#line 258
    tmp___0 = js_append(zone_name, reply);
#line 258
    if (tmp___0 == -1) {
#line 259
      js_dealloc((void *)h_copy);
#line 260
      js_destroy(reply);
#line 261
      return (-1);
    }
#line 263
    tmp___1 = js_adduint16(reply, 6);
#line 263
    if (tmp___1 == -1) {
#line 264
      js_dealloc((void *)h_copy);
#line 265
      js_destroy(reply);
#line 266
      return (-1);
    }
#line 268
    js_destroy(zone_name);
  } else
#line 269
  if (type == 2) {
#line 269
    goto _L;
  } else
#line 269
  if (type == 3) {
    _L: /* CIL Label */ 
#line 271
    if (type == 2) {
#line 272
      point___0 = state->buffer;
    } else {
#line 275
      point___0 = soa;
    }
#line 277
    tmp___2 = js_append(point___0->query, reply);
#line 277
    if (tmp___2 == -1) {
#line 278
      js_dealloc((void *)h_copy);
#line 279
      js_destroy(reply);
#line 280
      return (-1);
    }
#line 282
    tmp___3 = js_adduint16(reply, point___0->rtype);
#line 282
    if (tmp___3 == -1) {
#line 283
      js_dealloc((void *)h_copy);
#line 284
      js_destroy(reply);
#line 285
      return (-1);
    }
  } else {
#line 288
    js_dealloc((void *)h_copy);
#line 289
    js_destroy(reply);
#line 290
    return (-1);
  }
#line 294
  tmp___4 = js_adduint16(reply, 1);
#line 294
  if (tmp___4 == -1) {
#line 295
    js_dealloc((void *)h_copy);
#line 296
    js_destroy(reply);
#line 297
    return (-1);
  }
#line 301
  if (type == 1) {
#line 302
    point = state->buffer;
  } else
#line 301
  if (type == 2) {
#line 302
    point = state->buffer;
  } else
#line 304
  if (type == 3) {
#line 305
    point = soa;
  }
#line 307
  tmp___5 = csv2_append_rr(reply, point);
#line 307
  if (tmp___5 == -1) {
#line 308
    js_dealloc((void *)h_copy);
#line 309
    js_destroy(reply);
#line 310
    return (-1);
  }
#line 314
  if (type == 1) {
#line 315
    point = point->next;
#line 316
    while ((unsigned long )point != (unsigned long )((csv2_rr *)0)) {
#line 317
      if (point->rtype != 2) {
#line 320
        break;
      }
#line 322
      tmp___6 = csv2_append_rr(reply, point);
#line 322
      if (tmp___6 == -1) {
#line 323
        js_dealloc((void *)h_copy);
#line 324
        js_destroy(reply);
#line 325
        return (-1);
      }
#line 327
      point = point->next;
    }
  }
#line 332
  len[0] = (unsigned char )((reply->unit_count & 65280U) >> 8);
#line 333
  len[1] = (unsigned char )(reply->unit_count & 255U);
#line 337
  tmp___7 = write(connect___0, (void const   *)(len), (size_t )2);
#line 337
  if (tmp___7 == -1L) {
#line 338
    js_dealloc((void *)h_copy);
#line 339
    js_destroy(reply);
#line 340
    return (-1);
  }
#line 342
  tmp___8 = write(connect___0, (void const   *)reply->string, (size_t )reply->unit_count);
#line 342
  if (tmp___8 == -1L) {
#line 343
    js_dealloc((void *)h_copy);
#line 344
    js_destroy(reply);
#line 345
    return (-1);
  }
#line 348
  js_dealloc((void *)h_copy);
#line 349
  js_destroy(reply);
#line 350
  return (1);
}
}
#line 355 "Csv2_main.c"
int csv2_tcp_spit_soa(csv2_add_state *state , int connect___0 , q_header *header ,
                      js_string *zone ) 
{ int tmp ;

  {
#line 357
  tmp = csv2_tcp_spit_data(state, connect___0, header, zone, 1, (csv2_rr *)0);
#line 357
  return (tmp);
}
}
#line 362 "Csv2_main.c"
int csv2_tcp_spit_buffer(csv2_add_state *state , int connect___0 , q_header *header ,
                         js_string *zone ) 
{ int tmp ;

  {
#line 364
  if (state->add_method != 2) {
#line 365
    return (-1);
  }
#line 367
  while ((unsigned long )state->buffer != (unsigned long )((csv2_rr *)0)) {
#line 368
    tmp = csv2_tcp_spit_data(state, connect___0, header, zone, 2, (csv2_rr *)0);
#line 368
    if (tmp == -1) {
#line 370
      return (-1);
    }
#line 372
    csv2_pop_buffer(state);
  }
#line 374
  return (1);
}
}
#line 389 "Csv2_main.c"
int csv2_parse_zone_zoneserver(js_string *zone , int connect___0 , int soa_q , q_header *header ) 
{ csv2_add_state *state ;
  int x ;
  csv2_read *stream ;
  csv2_rr *soa_save ;
  js_string *dvar_name ;
  js_string *filename ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int length ;
  unsigned char get[3] ;
  int tmp___4 ;
  ssize_t tmp___5 ;
  ssize_t tmp___6 ;
  ssize_t tmp___7 ;
  ssize_t tmp___8 ;
  int tmp___9 ;
  int c ;
  int q ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 399
  state = csv2_init_add_state(zone);
#line 399
  if ((unsigned long )state == (unsigned long )((csv2_add_state *)0)) {
#line 400
    return (0);
  }
#line 404
  tmp = csv2_set_add_method(state, 2);
#line 404
  if (tmp == -1) {
#line 405
    csv2_close_state(state);
#line 406
    return (0);
  }
#line 411
  filename = js_create(256U, 1U);
#line 411
  if ((unsigned long )filename == (unsigned long )((js_string *)0)) {
#line 412
    csv2_close_state(state);
#line 413
    return (0);
  }
#line 415
  dvar_name = js_create(6U, 1U);
#line 415
  if ((unsigned long )dvar_name == (unsigned long )((js_string *)0)) {
#line 416
    js_destroy(filename);
#line 417
    csv2_close_state(state);
#line 418
    return (0);
  }
#line 420
  tmp___0 = js_qstr2js(dvar_name, (char *)"csv2");
#line 420
  if (tmp___0 == -1) {
#line 421
    js_destroy(filename);
#line 422
    js_destroy(dvar_name);
#line 423
    csv2_close_state(state);
#line 424
    return (0);
  }
#line 426
  tmp___1 = read_dvar(dvar_name, zone, filename);
#line 426
  if (tmp___1 == -1) {
#line 427
    js_destroy(filename);
#line 428
    js_destroy(dvar_name);
#line 429
    csv2_close_state(state);
#line 430
    return (0);
  }
#line 436
  tmp___2 = csv2_set_soa_serial(state, filename);
#line 436
  if (tmp___2 == -1) {
#line 437
    printf("Error running stat() on ");
#line 438
    show_esc_stdout(filename);
#line 439
    printf("\n");
  }
#line 443
  stream = csv2_open(filename);
#line 444
  if ((unsigned long )stream == (unsigned long )((csv2_read *)0)) {
#line 445
    printf("Error opening ");
#line 446
    show_esc_stdout(filename);
#line 447
    printf("\n");
#line 448
    csv2_zap_add_state(state);
#line 449
    return (0);
  }
#line 455
  x = 0;
#line 455
  while (x < 29) {
#line 456
    if (state->in_ns != 1) {
#line 457
      break;
    }
#line 459
    tmp___3 = csv2_read_rr(state, stream, 0);
#line 459
    if (tmp___3 < 0) {
#line 460
      break;
    }
#line 455
    x ++;
  }
#line 466
  if (soa_q == 1) {
#line 469
    tmp___4 = csv2_tcp_spit_soa(state, connect___0, header, zone);
#line 469
    if (tmp___4 == -1) {
#line 471
      csv2_zap_add_state(state);
#line 472
      return (-1);
    }
#line 475
    if (connect___0 == 1) {
#line 476
      tmp___5 = read(0, (void *)(get), (size_t )2);
#line 476
      if (tmp___5 != 1L) {
#line 477
        csv2_zap_add_state(state);
#line 478
        return (-1);
      }
    } else {
#line 481
      tmp___6 = recv(connect___0, (void *)(get), (size_t )2, 0);
#line 481
      if (tmp___6 != 2L) {
#line 482
        csv2_zap_add_state(state);
#line 483
        return (-1);
      }
    }
#line 486
    length = (((int )get[0] & 255) << 8) | ((int )get[1] & 255);
#line 488
    while (length > 0) {
#line 489
      if (connect___0 == 1) {
#line 490
        tmp___7 = read(0, (void *)(get), (size_t )1);
#line 490
        if (tmp___7 != 1L) {
#line 491
          csv2_zap_add_state(state);
#line 492
          return (-1);
        }
      } else {
#line 495
        tmp___8 = recv(connect___0, (void *)(get), (size_t )1, 64);
#line 495
        if (tmp___8 != 1L) {
#line 496
          csv2_zap_add_state(state);
#line 497
          return (-1);
        }
      }
#line 500
      length --;
    }
  }
#line 509
  soa_save = copy_csv2_rr(state->buffer);
#line 512
  tmp___9 = csv2_tcp_spit_buffer(state, connect___0, header, zone);
#line 512
  if (tmp___9 == -1) {
#line 513
    js_dealloc((void *)soa_save);
#line 514
    csv2_zap_add_state(state);
#line 515
    return (-1);
  }
#line 519
  x = 0;
#line 519
  while (x < 100000) {
#line 522
    q = 0;
#line 523
    c = 0;
#line 523
    while (c < 20) {
#line 524
      q = csv2_read_rr(state, stream, 0);
#line 525
      if (q < 0) {
#line 526
        break;
      }
#line 523
      c ++;
    }
#line 530
    tmp___10 = csv2_tcp_spit_buffer(state, connect___0, header, zone);
#line 530
    if (tmp___10 == -1) {
#line 532
      js_dealloc((void *)soa_save);
#line 533
      csv2_zap_add_state(state);
#line 534
      return (-1);
    }
#line 537
    if (q < 0) {
#line 538
      break;
    }
#line 519
    x ++;
  }
#line 544
  tmp___11 = csv2_tcp_spit_data(state, connect___0, header, zone, 3, soa_save);
#line 544
  if (tmp___11 == -1) {
#line 546
    js_dealloc((void *)soa_save);
#line 547
    csv2_zap_add_state(state);
#line 548
    return (-1);
  }
#line 550
  csv2_zap_add_state(state);
#line 551
  return (1);
}
}
#line 556 "Csv2_main.c"
int csv2_parse_zone_bighash(js_string *zone , js_string *filename , mhash *bighash___0 ,
                            int32_t starwhitis ) 
{ csv2_add_state *state ;
  int nostar ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 563
  nostar = 0;
#line 563
  while ((unsigned int )nostar < zone->unit_size * zone->unit_count) {
#line 565
    if ((int )*(zone->string + nostar) == 42) {
#line 565
      if (zone->unit_count > 1U) {
#line 566
        printf("Illegal zone name: ");
#line 567
        nostar = 0;
#line 567
        while ((unsigned int )nostar < zone->unit_size * zone->unit_count) {
#line 569
          printf("%c", (int )*(zone->string + nostar));
#line 567
          nostar ++;
        }
#line 571
        printf("\nThis is a fatal error.\n");
#line 572
        exit(1);
      }
    }
#line 563
    nostar ++;
  }
#line 576
  state = csv2_init_add_state(zone);
#line 576
  if ((unsigned long )state == (unsigned long )((csv2_add_state *)0)) {
#line 577
    return (0);
  }
#line 579
  tmp = csv2_set_bighash(state, bighash___0);
#line 579
  if (tmp == -1) {
#line 580
    csv2_close_state(state);
#line 581
    return (0);
  }
#line 583
  if (starwhitis == 0) {
#line 584
    tmp___0 = csv2_set_add_method(state, 1);
#line 584
    if (tmp___0 == -1) {
#line 585
      csv2_close_state(state);
#line 586
      return (0);
    }
  } else
#line 588
  if (starwhitis == 1) {
#line 589
    tmp___1 = csv2_set_add_method(state, 3);
#line 589
    if (tmp___1 == -1) {
#line 590
      csv2_close_state(state);
#line 591
      return (0);
    }
  } else {
#line 594
    printf("FATAL: Illegal value %d for starwhitis\n", starwhitis);
#line 595
    exit(1);
  }
#line 598
  tmp___2 = csv2_parse_zone(filename, state, starwhitis);
#line 598
  return (tmp___2);
}
}
#line 602 "Csv2_main.c"
int csv2_parse_zone(js_string *filename , csv2_add_state *state , int32_t starwhitis ) 
{ csv2_read *stream ;
  int x ;
  int tmp ;
  int tmp___0 ;

  {
#line 607
  printf("Processing zone ");
#line 608
  show_esc_stdout(state->zone);
#line 609
  printf(" right now.\n");
#line 610
  printf("Filename: ");
#line 611
  show_esc_stdout(filename);
#line 612
  printf("\n");
#line 617
  tmp = csv2_set_soa_serial(state, filename);
#line 617
  if (tmp == -1) {
#line 618
    printf("Error running stat() on ");
#line 619
    show_esc_stdout(filename);
#line 620
    printf("\n");
  }
#line 623
  stream = csv2_open(filename);
#line 624
  if ((unsigned long )stream == (unsigned long )((csv2_read *)0)) {
#line 625
    printf("Error opening ");
#line 626
    show_esc_stdout(filename);
#line 627
    printf("\n");
#line 628
    csv2_zap_add_state(state);
#line 629
    return (0);
  }
#line 634
  x = 0;
#line 634
  while (x < 100000) {
#line 635
    tmp___0 = csv2_read_rr(state, stream, starwhitis);
#line 635
    if (tmp___0 < 0) {
#line 636
      break;
    }
#line 634
    x ++;
  }
#line 639
  csv2_close(stream);
#line 642
  if (state->in_ns == 1) {
#line 643
    csv2_add_soa(state);
  }
#line 645
  csv2_zap_add_state(state);
#line 646
  return (0);
}
}
#line 1 "Csv2_parse.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-W9MxSbUH.i","")
#line 176 "Csv2_functions.h"
int csv2_add_rr(csv2_add_state *state , js_string *query , int rtype , int32_t ttl ,
                js_string *data ) ;
#line 188
js_string *csv2_get_txt(csv2_read *stream , int numchunks ) ;
#line 193
js_string *csv2_get_raw(csv2_read *stream ) ;
#line 220
js_string *process_1stchar(csv2_read *stream , int (*is_ok)(int32_t in ) , char *pre ) ;
#line 226
int csv2_see_char(int32_t in , char *list ) ;
#line 227
int csv2_is_number(int32_t in ) ;
#line 228
int csv2_is_upper(int32_t in ) ;
#line 229
int csv2_is_lower(int32_t in ) ;
#line 230
int csv2_is_hibit(int32_t in ) ;
#line 231
int csv2_is_delimiter(int in ) ;
#line 232
int32_t csv2_get_utf8(csv2_read *stream ) ;
#line 233
int32_t csv2_read_unicode(csv2_read *stream ) ;
#line 234
int csv2_append_utf8(js_string *toappend , int32_t in ) ;
#line 235
int csv2_get_1st(csv2_read *stream , int (*is_ok)(int32_t in ) , int options ) ;
#line 236
int csv2_is_alpha(int32_t in ) ;
#line 237
int csv2_is_alphanum(int32_t in ) ;
#line 238
int csv2_is_text(int32_t in ) ;
#line 239
int csv2_is_dchar(int32_t in ) ;
#line 240
int csv2_is_starwhitis(int32_t in ) ;
#line 241
int csv2_numeric_rtype(js_string *text_rtype ) ;
#line 242
int32_t csv2_get_rtype(csv2_read *stream ) ;
#line 243
int32_t csv2_get_num(csv2_read *stream ) ;
#line 245
void process_comment(csv2_read *stream ) ;
#line 246
js_string *process_something(csv2_read *stream , int (*is_ok)(int32_t in ) ) ;
#line 247
js_string *process_number(csv2_read *stream ) ;
#line 248
js_string *process_textlabel(csv2_read *stream ) ;
#line 249
js_string *process_dname(csv2_read *stream , int starwhitis ) ;
#line 250
js_string *js_append_dname(js_string *o , csv2_read *stream , int starwhitis ) ;
#line 251
js_string *csv2_get_hostname(csv2_read *stream , js_string *zonename , int starwhitis ) ;
#line 253
js_string *csv2_get_dname(csv2_read *stream ) ;
#line 254
js_string *csv2_get_soa(csv2_read *stream , js_string *zone , csv2_add_state *state ) ;
#line 256
js_string *csv2_convert_percent(js_string *in , js_string *psub ) ;
#line 269
js_string *csv2_get_a(csv2_read *stream ) ;
#line 275
js_string *csv2_get_aaaa(csv2_read *stream ) ;
#line 282
js_string *csv2_get_wks(csv2_read *stream ) ;
#line 283
js_string *csv2_get_mbox(csv2_read *stream , js_string *zone , int count ) ;
#line 284
js_string *csv2_get_hex(csv2_read *stream ) ;
#line 285
js_string *csv2_get_loc(csv2_read *stream ) ;
#line 286
js_string *csv2_get_naptr(csv2_read *stream ) ;
#line 44 "Csv2_parse.c"
int csv2_see_char(int32_t in , char *list ) 
{ int counter ;

  {
#line 45
  counter = 0;
#line 46
  if ((unsigned long )list == (unsigned long )((char *)0)) {
#line 47
    return (0);
  }
#line 49
  while (1) {
#line 49
    if ((int )*list != 0) {
#line 49
      counter ++;
#line 49
      if (! (counter < 128)) {
#line 49
        break;
      }
    } else {
#line 49
      break;
    }
#line 50
    if ((int )*list == in) {
#line 51
      return (1);
    }
#line 53
    list ++;
  }
#line 55
  return (0);
}
}
#line 62 "Csv2_parse.c"
int csv2_is_number(int32_t in ) 
{ int tmp ;

  {
#line 63
  if (in >= 48) {
#line 63
    if (in <= 57) {
#line 63
      tmp = 1;
    } else {
#line 63
      tmp = 0;
    }
  } else {
#line 63
    tmp = 0;
  }
#line 63
  return (tmp);
}
}
#line 69 "Csv2_parse.c"
int csv2_is_number_orslash(int32_t in ) 
{ int tmp ;

  {
#line 70
  if (in >= 48) {
#line 70
    if (in <= 57) {
#line 70
      tmp = 1;
    } else {
#line 70
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 70
  if (in == 47) {
#line 70
    tmp = 1;
  } else {
#line 70
    tmp = 0;
  }
#line 70
  return (tmp);
}
}
#line 76 "Csv2_parse.c"
int csv2_is_upper(int32_t in ) 
{ int tmp ;

  {
#line 77
  if (in >= 65) {
#line 77
    if (in <= 90) {
#line 77
      tmp = 1;
    } else {
#line 77
      tmp = 0;
    }
  } else {
#line 77
    tmp = 0;
  }
#line 77
  return (tmp);
}
}
#line 83 "Csv2_parse.c"
int csv2_is_lower(int32_t in ) 
{ int tmp ;

  {
#line 84
  if (in >= 97) {
#line 84
    if (in <= 122) {
#line 84
      tmp = 1;
    } else {
#line 84
      tmp = 0;
    }
  } else {
#line 84
    tmp = 0;
  }
#line 84
  return (tmp);
}
}
#line 90 "Csv2_parse.c"
int csv2_is_hibit(int32_t in ) 
{ int tmp ;

  {
#line 91
  if (in >= 128) {
#line 91
    if (in <= 253) {
#line 91
      tmp = 1;
    } else {
#line 91
      tmp = 0;
    }
  } else {
#line 91
    tmp = 0;
  }
#line 91
  return (tmp);
}
}
#line 97 "Csv2_parse.c"
int csv2_is_delimiter(int in ) 
{ int tmp ;

  {
#line 98
  if (in == 13) {
#line 98
    tmp = 1;
  } else
#line 98
  if (in == 10) {
#line 98
    tmp = 1;
  } else
#line 98
  if (in == 9) {
#line 98
    tmp = 1;
  } else
#line 98
  if (in == 32) {
#line 98
    tmp = 1;
  } else
#line 98
  if (in == 124) {
#line 98
    tmp = 1;
  } else {
#line 98
    tmp = 0;
  }
#line 98
  return (tmp);
}
}
#line 104 "Csv2_parse.c"
int csv2_isnt_delimiter(int in ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 105
  tmp = csv2_is_delimiter(in);
#line 105
  if (tmp) {
#line 105
    tmp___0 = 0;
  } else {
#line 105
    tmp___0 = 1;
  }
#line 105
  return (tmp___0);
}
}
#line 115 "Csv2_parse.c"
int csv2_utf8_length(int in ) 
{ 

  {
#line 116
  if (in >= 254) {
#line 117
    return (-2);
  }
#line 119
  if (in < 0) {
#line 120
    return (-1);
  }
#line 122
  if (in < 128) {
#line 122
    if (in > 0) {
#line 123
      return (0);
    }
  }
#line 125
  if (in >= 128) {
#line 125
    if (in < 192) {
#line 126
      return (1);
    }
  }
#line 128
  if (in >= 192) {
#line 128
    if (in < 224) {
#line 129
      return (2);
    }
  }
#line 131
  if (in >= 224) {
#line 131
    if (in < 240) {
#line 132
      return (3);
    }
  }
#line 134
  if (in >= 240) {
#line 134
    if (in < 248) {
#line 135
      return (4);
    }
  }
#line 137
  if (in >= 248) {
#line 137
    if (in < 252) {
#line 138
      return (5);
    }
  }
#line 140
  if (in >= 252) {
#line 140
    if (in < 254) {
#line 141
      return (6);
    }
  }
#line 143
  return (-1);
}
}
#line 155 "Csv2_parse.c"
int32_t csv2_get_utf8(csv2_read *stream ) 
{ int32_t in ;
  int32_t out ;
  int len ;
  int count ;

  {
#line 158
  in = csv2_justread(stream);
#line 159
  len = csv2_utf8_length(in);
#line 162
  if (len < 2) {
#line 163
    csv2_error(stream, (char *)"Invalid UTF-8 sequence");
#line 164
    return (-164);
  }
#line 169
  out = in;
#line 170
  if (len == 2) {
#line 171
    out &= 31;
  } else
#line 172
  if (len == 3) {
#line 173
    out &= 15;
  } else
#line 174
  if (len == 4) {
#line 175
    out &= 7;
  } else
#line 176
  if (len == 5) {
#line 177
    out &= 3;
  } else
#line 178
  if (len == 6) {
#line 179
    out &= 1;
  } else {
#line 181
    csv2_error(stream, (char *)"Fatal error parsing UTF-8");
#line 182
    return (-164);
  }
#line 185
  count = len;
#line 187
  while (len > 1) {
#line 188
    out <<= 6;
#line 189
    in = csv2_readchar(stream);
#line 190
    if (in == -2) {
#line 191
      csv2_error(stream, (char *)"EOF in middle of UTF-8 sequence");
#line 192
      return (-164);
    }
#line 194
    if (in < 128) {
#line 195
      csv2_error(stream, (char *)"Invalid char in UTF-8 sequence");
#line 196
      return (-164);
    } else
#line 194
    if (in >= 192) {
#line 195
      csv2_error(stream, (char *)"Invalid char in UTF-8 sequence");
#line 196
      return (-164);
    }
#line 198
    in &= 63;
#line 199
    out |= in;
#line 200
    len --;
  }
#line 205
  if (out < 128) {
#line 206
    csv2_error(stream, (char *)"UTF-8 sequence too long");
#line 207
    return (-164);
  }
#line 209
  if (out < 2048) {
#line 209
    if (count > 2) {
#line 210
      csv2_error(stream, (char *)"UTF-8 sequence too long");
#line 211
      return (-164);
    }
  }
#line 213
  if (out < 65536) {
#line 213
    if (count > 3) {
#line 214
      csv2_error(stream, (char *)"UTF-8 sequence too long");
#line 215
      return (-164);
    }
  }
#line 217
  if (out < 2097152) {
#line 217
    if (count > 4) {
#line 218
      csv2_error(stream, (char *)"UTF-8 sequence too long");
#line 219
      return (-164);
    }
  }
#line 221
  if (out < 67108864) {
#line 221
    if (count > 5) {
#line 222
      csv2_error(stream, (char *)"UTF-8 sequence too long");
#line 223
      return (-164);
    }
  }
#line 226
  csv2_set_unicode(stream, out);
#line 227
  return (out);
}
}
#line 239 "Csv2_parse.c"
int32_t csv2_read_unicode(csv2_read *stream ) 
{ int32_t out ;
  int32_t tmp ;

  {
#line 241
  out = csv2_readchar(stream);
#line 242
  if (out < 0) {
#line 243
    return (out);
  }
#line 245
  if (out > 127) {
#line 246
    tmp = csv2_get_utf8(stream);
#line 246
    return (tmp);
  }
#line 248
  return (out);
}
}
#line 261 "Csv2_parse.c"
int csv2_append_utf8(js_string *toappend , int32_t in ) 
{ int tmp ;
  int temp[6] ;
  int counter ;
  int place ;
  int32_t shift ;

  {
#line 262
  tmp = js_has_sanity(toappend);
#line 262
  if (tmp == -1) {
#line 263
    return (-1);
  }
#line 266
  if (toappend->unit_size != 1U) {
#line 267
    return (-1);
  }
#line 270
  if (in < 0) {
#line 271
    return (-1);
  }
#line 275
  if (in < 128) {
#line 276
    if (toappend->unit_count + 1U > toappend->max_count) {
#line 277
      return (-1);
    }
#line 279
    *(toappend->string + toappend->unit_count) = (unsigned char )in;
#line 280
    (toappend->unit_count) ++;
#line 281
    return (1);
  } else {
#line 289
    shift = in;
#line 290
    counter = 5;
#line 291
    while (1) {
#line 291
      if (counter >= 0) {
#line 291
        if (! (shift > 0)) {
#line 291
          break;
        }
      } else {
#line 291
        break;
      }
#line 292
      temp[counter] = shift & 63;
#line 293
      shift >>= 6;
#line 294
      counter --;
    }
#line 296
    counter ++;
#line 297
    place = counter;
#line 298
    if (counter == 0) {
#line 299
      temp[counter] |= 252;
    } else
#line 300
    if (counter == 1) {
#line 301
      temp[counter] |= 248;
    } else
#line 302
    if (counter == 2) {
#line 303
      temp[counter] |= 240;
    } else
#line 304
    if (counter == 3) {
#line 305
      temp[counter] |= 224;
    } else
#line 306
    if (counter == 4) {
#line 307
      temp[counter] |= 192;
    } else {
#line 309
      return (-1);
    }
#line 310
    counter ++;
#line 310
    while (counter < 6) {
#line 311
      temp[counter] |= 128;
#line 310
      counter ++;
    }
#line 312
    counter = place;
#line 313
    while (counter < 6) {
#line 314
      if (toappend->unit_count + 1U > toappend->max_count) {
#line 315
        return (-1);
      }
#line 317
      *(toappend->string + toappend->unit_count) = (unsigned char )temp[counter];
#line 319
      (toappend->unit_count) ++;
#line 320
      counter ++;
    }
  }
#line 323
  return (1);
}
}
#line 327 "Csv2_parse.c"
void process_comment(csv2_read *stream ) 
{ int in ;
  int q ;
  int z ;

  {
#line 329
  q = 1;
#line 331
  z = (int )stream->chars_allowed;
#line 332
  csv2_allow_tilde(stream);
#line 333
  while (1) {
#line 334
    in = csv2_readchar(stream);
#line 336
    if (in == 126) {
#line 337
      stream->tilde_seen = (char )((int )stream->tilde_seen - 1);
    }
#line 339
    q ++;
#line 340
    if (q > 5000) {
#line 341
      csv2_error(stream, (char *)"Comment too long");
#line 342
      return;
    }
#line 333
    if (in != 10) {
#line 333
      if (in != 13) {
#line 333
        if (! (in != -2)) {
#line 333
          break;
        }
      } else {
#line 333
        break;
      }
    } else {
#line 333
      break;
    }
  }
#line 345
  stream->chars_allowed = (char )z;
#line 346
  return;
}
}
#line 350 "Csv2_parse.c"
int csv2_tilde_processing(csv2_read *stream ) 
{ int permitted ;
  int seen ;

  {
#line 354
  permitted = 0;
#line 359
  seen = csv2_tilde_seen(stream);
#line 361
  if ((int )stream->tilde_handling > 100) {
#line 362
    switch ((int )stream->tilde_handling) {
    case 101: 
#line 364
    permitted = 0;
#line 365
    break;
    case 102: 
#line 367
    permitted = -2;
#line 368
    break;
    case 103: 
#line 370
    permitted = 1;
#line 371
    break;
    }
#line 373
    if (seen > 1) {
#line 374
      csv2_error(stream, (char *)"A maximum of one tilde is allowed between records.\nIf you need tildes, set csv2_tilde_handling to 0");
#line 377
      return (-1);
    }
#line 379
    if (permitted != -2) {
#line 379
      if (seen != permitted) {
#line 380
        if (permitted == 0) {
#line 381
          csv2_error(stream, (char *)"No tildes allowed between RRs");
        } else
#line 383
        if (permitted == 1) {
#line 384
          csv2_error(stream, (char *)"You must have one tilde (~) between RRs");
        }
#line 387
        return (-1);
      }
    }
#line 389
    if (permitted == -2) {
#line 390
      if (seen == 1) {
#line 391
        stream->tilde_handling = (char)103;
      } else {
#line 393
        stream->tilde_handling = (char)101;
      }
    }
#line 397
    csv2_forbid_tilde(stream);
  } else
#line 404
  if ((int )stream->tilde_handling > 0) {
#line 404
    if ((int )stream->tilde_handling < 20) {
#line 405
      stream->tilde_handling = (char )((int )stream->tilde_handling + 100);
    }
  }
#line 407
  return (1);
}
}
#line 420 "Csv2_parse.c"
int csv2_get_1st(csv2_read *stream , int (*is_ok)(int32_t in ) , int options ) 
{ int32_t in ;
  int x ;
  int lastin ;
  int pipe_already_seen ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 423
  lastin = 0;
#line 424
  pipe_already_seen = 0;
#line 426
  in = csv2_justread(stream);
#line 427
  if (in > 127) {
#line 428
    in = csv2_get_unicode(stream);
  }
#line 430
  if (in > 127) {
#line 431
    in = csv2_get_unicode(stream);
  }
#line 435
  if (options != 1) {
#line 435
    tmp = (*is_ok)(in);
#line 435
    if (tmp) {
#line 436
      return (1);
    }
  }
#line 440
  if (options == 1) {
#line 440
    if (in == -328) {
#line 440
      tmp___1 = (*is_ok)(in);
#line 440
      if (tmp___1) {
#line 441
        tmp___0 = csv2_tilde_processing(stream);
#line 441
        return (tmp___0);
      }
    }
  }
#line 444
  if (options == 2) {
#line 444
    tmp___2 = (*is_ok)(in);
#line 444
    if (tmp___2) {
#line 445
      csv2_error(stream, (char *)"At least one whitespace character or | must be before this field");
#line 447
      return (-164);
    }
  }
#line 451
  if (options == 1) {
#line 451
    if (in == 46) {
#line 452
      tmp___3 = csv2_tilde_processing(stream);
#line 452
      return (tmp___3);
    }
  }
#line 458
  if (in != -328) {
#line 458
    tmp___4 = csv2_is_delimiter(in);
#line 458
    if (! tmp___4) {
#line 458
      if (in == 126) {
#line 458
        if (! ((int )stream->tilde_handling == 103)) {
#line 460
          csv2_error(stream, (char *)"Unexpected character");
#line 461
          return (-164);
        }
      } else {
#line 460
        csv2_error(stream, (char *)"Unexpected character");
#line 461
        return (-164);
      }
    }
  }
#line 464
  if (in == 124) {
#line 465
    pipe_already_seen = 1;
  }
#line 470
  if (options == 1) {
#line 471
    switch ((int )stream->tilde_handling) {
    case 101: 
#line 473
    csv2_forbid_tilde(stream);
#line 474
    break;
    case 102: 
    case 103: 
#line 477
    csv2_allow_tilde(stream);
#line 478
    break;
    }
#line 481
    csv2_reset_tilde_seen(stream);
#line 483
    if (in == 126) {
#line 484
      stream->tilde_seen = (char )((int )stream->tilde_seen + 1);
    }
  }
#line 488
  x = 0;
#line 488
  while (x < 10000) {
#line 489
    lastin = in;
#line 490
    in = csv2_read_unicode(stream);
#line 491
    if (in == -164) {
#line 492
      return (-1);
    }
#line 494
    if (in == -2) {
#line 495
      return (-2);
    }
#line 498
    if (in == 35) {
#line 499
      process_comment(stream);
#line 500
      in = '\n';
    } else
#line 502
    if (options != 1) {
#line 502
      tmp___10 = (*is_ok)(in);
#line 502
      if (tmp___10) {
#line 503
        return (1);
      } else {
#line 502
        goto _L___6;
      }
    } else
    _L___6: /* CIL Label */ 
#line 505
    if (options == 1) {
#line 505
      if (lastin == 13) {
#line 505
        goto _L___5;
      } else
#line 505
      if (lastin == 10) {
#line 505
        goto _L___5;
      } else
#line 505
      if (lastin == -328) {
        _L___5: /* CIL Label */ 
#line 505
        tmp___9 = (*is_ok)(in);
#line 505
        if (tmp___9) {
#line 508
          tmp___5 = csv2_tilde_processing(stream);
#line 508
          return (tmp___5);
        } else {
#line 505
          goto _L___4;
        }
      } else {
#line 505
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 510
    if (options == 1) {
#line 510
      tmp___8 = (*is_ok)(in);
#line 510
      if (tmp___8) {
#line 511
        csv2_error(stream, (char *)"Host name must be at the beginning of a line");
#line 513
        return (-164);
      } else {
#line 510
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 516
    if (options == 1) {
#line 516
      if (in == 46) {
#line 517
        tmp___6 = csv2_tilde_processing(stream);
#line 517
        return (tmp___6);
      } else {
#line 516
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 519
    if (in == 124) {
#line 520
      if (pipe_already_seen == 1) {
#line 521
        csv2_error(stream, (char *)"Only one pipe (|) character is allowed between fields");
#line 523
        return (-164);
      } else {
#line 525
        pipe_already_seen = 1;
      }
    } else
#line 529
    if (in == 126) {
#line 529
      if (options == 1) {
#line 529
        if ((int )stream->tilde_handling > 100) {
#line 531
          goto __Cont;
        } else {
#line 529
          goto _L___0;
        }
      } else {
#line 529
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 534
      tmp___7 = csv2_is_delimiter(in);
#line 534
      if (! tmp___7) {
#line 535
        csv2_error(stream, (char *)"Unexpected character");
#line 536
        return (-164);
      }
    }
#line 538
    if (in == -2) {
#line 539
      if (options == 1) {
#line 540
        tmp___11 = csv2_tilde_processing(stream);
#line 540
        return (tmp___11);
      }
#line 542
      return (1);
    }
    __Cont: /* CIL Label */ 
#line 488
    x ++;
  }
#line 545
  return (-1);
}
}
#line 553 "Csv2_parse.c"
js_string *process_1stchar(csv2_read *stream , int (*is_ok)(int32_t in ) , char *pre ) 
{ js_string *o ;
  int32_t look ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 559
  look = csv2_justread(stream);
#line 560
  if (look >= 192) {
#line 560
    if (look < 254) {
#line 561
      look = csv2_get_utf8(stream);
    } else {
#line 560
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 563
  if (look >= 128) {
#line 564
    look = csv2_get_unicode(stream);
  }
#line 567
  if (look == -164) {
#line 568
    return ((js_string *)0);
  }
#line 570
  tmp = (*is_ok)(look);
#line 570
  if (! tmp) {
#line 571
    csv2_error(stream, (char *)"Unexpected character");
#line 572
    return ((js_string *)0);
  }
#line 577
  o = js_create(256U, 1U);
#line 578
  if ((unsigned long )o == (unsigned long )((js_string *)0)) {
#line 579
    return ((js_string *)0);
  }
#line 581
  tmp___0 = js_set_encode(o, 2);
#line 581
  if (tmp___0 == -1) {
#line 582
    js_destroy(o);
#line 583
    return ((js_string *)0);
  }
#line 587
  if ((unsigned long )pre != (unsigned long )((char *)0)) {
#line 587
    tmp___1 = js_qstr2js(o, pre);
#line 587
    if (tmp___1 != 1) {
#line 588
      csv2_error(stream, (char *)"Error prepending pre");
#line 589
      js_destroy(o);
#line 590
      return ((js_string *)0);
    }
  }
#line 594
  tmp___2 = csv2_append_utf8(o, look);
#line 594
  if (tmp___2 < 0) {
#line 595
    csv2_error(stream, (char *)"Error appending character");
#line 596
    js_destroy(o);
#line 597
    return ((js_string *)0);
  }
#line 600
  return (o);
}
}
#line 608 "Csv2_parse.c"
js_string *process_something(csv2_read *stream , int (*is_ok)(int32_t in ) ) 
{ js_string *o ;
  int32_t look ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 614
  o = process_1stchar(stream, is_ok, (char *)0);
#line 615
  if ((unsigned long )o == (unsigned long )((js_string *)0)) {
#line 616
    return ((js_string *)0);
  }
#line 619
  while (1) {
#line 620
    look = csv2_read_unicode(stream);
#line 621
    if (look == -164) {
#line 622
      js_destroy(o);
#line 623
      return ((js_string *)0);
    }
#line 625
    if (look == 35) {
#line 626
      process_comment(stream);
#line 627
      return (o);
    }
#line 629
    tmp = (*is_ok)(look);
#line 629
    if (! tmp) {
#line 629
      tmp___0 = csv2_is_delimiter(look);
#line 629
      if (! tmp___0) {
#line 630
        csv2_error(stream, (char *)"Unexpected character");
#line 631
        js_destroy(o);
#line 632
        return ((js_string *)0);
      }
    }
#line 634
    tmp___1 = (*is_ok)(look);
#line 634
    if (tmp___1) {
#line 634
      tmp___2 = csv2_append_utf8(o, look);
#line 634
      if (tmp___2 < 0) {
#line 635
        csv2_error(stream, (char *)"Error appending character");
#line 636
        js_destroy(o);
#line 637
        return ((js_string *)0);
      }
    }
#line 619
    tmp___3 = (*is_ok)(look);
#line 619
    if (! tmp___3) {
#line 619
      break;
    }
  }
#line 641
  return (o);
}
}
#line 645 "Csv2_parse.c"
int csv2_is_alpha(int32_t in ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 646
  tmp = csv2_is_lower(in);
#line 646
  if (tmp) {
#line 646
    tmp___1 = 1;
  } else {
#line 646
    tmp___0 = csv2_is_upper(in);
#line 646
    if (tmp___0) {
#line 646
      tmp___1 = 1;
    } else {
#line 646
      tmp___1 = 0;
    }
  }
#line 646
  return (tmp___1);
}
}
#line 650 "Csv2_parse.c"
int csv2_is_alphanum(int32_t in ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 651
  tmp = csv2_is_alpha(in);
#line 651
  if (tmp) {
#line 651
    tmp___1 = 1;
  } else {
#line 651
    tmp___0 = csv2_is_number(in);
#line 651
    if (tmp___0) {
#line 651
      tmp___1 = 1;
    } else
#line 651
    if (in == 45) {
#line 651
      tmp___1 = 1;
    } else
#line 651
    if (in == 95) {
#line 651
      tmp___1 = 1;
    } else {
#line 651
      tmp___1 = 0;
    }
  }
#line 651
  return (tmp___1);
}
}
#line 656 "Csv2_parse.c"
int csv2_is_alphanum_orplus(int32_t in ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 657
  tmp = csv2_is_alphanum(in);
#line 657
  if (tmp) {
#line 657
    tmp___0 = 1;
  } else
#line 657
  if (in == 43) {
#line 657
    tmp___0 = 1;
  } else {
#line 657
    tmp___0 = 0;
  }
#line 657
  return (tmp___0);
}
}
#line 661 "Csv2_parse.c"
int csv2_is_text(int32_t in ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 662
  tmp = csv2_is_alphanum(in);
#line 662
  if (tmp) {
#line 662
    tmp___0 = 1;
  } else
#line 662
  if (in > 127) {
#line 662
    tmp___0 = 1;
  } else {
#line 662
    tmp___0 = 0;
  }
#line 662
  return (tmp___0);
}
}
#line 666 "Csv2_parse.c"
int csv2_is_dchar(int32_t in ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 667
  tmp = csv2_is_text(in);
#line 667
  if (tmp) {
#line 667
    tmp___0 = 1;
  } else
#line 667
  if (in == 37) {
#line 667
    tmp___0 = 1;
  } else {
#line 667
    tmp___0 = 0;
  }
#line 667
  return (tmp___0);
}
}
#line 671 "Csv2_parse.c"
int csv2_is_fchar(int32_t in ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 672
  tmp = csv2_is_text(in);
#line 672
  if (tmp) {
#line 672
    tmp___0 = 1;
  } else
#line 672
  if (in == 46) {
#line 672
    tmp___0 = 1;
  } else {
#line 672
    tmp___0 = 0;
  }
#line 672
  return (tmp___0);
}
}
#line 676 "Csv2_parse.c"
int csv2_is_starwhitis(int32_t in ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 677
  tmp = csv2_is_text(in);
#line 677
  if (tmp) {
#line 677
    tmp___0 = 1;
  } else
#line 677
  if (in == 42) {
#line 677
    tmp___0 = 1;
  } else
#line 677
  if (in == 37) {
#line 677
    tmp___0 = 1;
  } else {
#line 677
    tmp___0 = 0;
  }
#line 677
  return (tmp___0);
}
}
#line 681 "Csv2_parse.c"
int csv2_is_starwhitis_orslash(int32_t in ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 682
  tmp = csv2_is_text(in);
#line 682
  if (tmp) {
#line 682
    tmp___0 = 1;
  } else
#line 682
  if (in == 42) {
#line 682
    tmp___0 = 1;
  } else
#line 682
  if (in == 37) {
#line 682
    tmp___0 = 1;
  } else
#line 682
  if (in == 47) {
#line 682
    tmp___0 = 1;
  } else {
#line 682
    tmp___0 = 0;
  }
#line 682
  return (tmp___0);
}
}
#line 686 "Csv2_parse.c"
int csv2_is_starwhitis_ordot(int32_t in ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 687
  tmp = csv2_is_text(in);
#line 687
  if (tmp) {
#line 687
    tmp___0 = 1;
  } else
#line 687
  if (in == 42) {
#line 687
    tmp___0 = 1;
  } else
#line 687
  if (in == 37) {
#line 687
    tmp___0 = 1;
  } else
#line 687
  if (in == 46) {
#line 687
    tmp___0 = 1;
  } else {
#line 687
    tmp___0 = 0;
  }
#line 687
  return (tmp___0);
}
}
#line 696 "Csv2_parse.c"
js_string *process_number(csv2_read *stream ) 
{ js_string *tmp ;

  {
#line 697
  tmp = process_something(stream, & csv2_is_number);
#line 697
  return (tmp);
}
}
#line 704 "Csv2_parse.c"
js_string *process_textlabel(csv2_read *stream ) 
{ js_string *tmp ;

  {
#line 705
  tmp = process_something(stream, & csv2_is_text);
#line 705
  return (tmp);
}
}
#line 719 "Csv2_parse.c"
js_string *process_dname(csv2_read *stream , int starwhitis ) 
{ js_string *o ;
  js_string *ret ;

  {
#line 725
  o = process_1stchar(stream, & csv2_is_starwhitis_ordot, (char *)"Z");
#line 726
  if ((unsigned long )o == (unsigned long )((js_string *)0)) {
#line 727
    return ((js_string *)0);
  } else
#line 726
  if ((unsigned long )o->string == (unsigned long )((unsigned char *)0)) {
#line 727
    return ((js_string *)0);
  }
#line 730
  ret = js_append_dname(o, stream, starwhitis);
#line 731
  if ((unsigned long )ret == (unsigned long )((js_string *)0)) {
#line 732
    return ((js_string *)0);
  }
#line 735
  if (o->unit_count > 1U) {
#line 735
    if ((int )*(o->string + 1) == 46) {
#line 735
      if (o->unit_count != 2U) {
#line 736
        csv2_error(stream, (char *)"Dot can only be at beginning of hostname for root (\'.\') hostname");
#line 738
        return ((js_string *)0);
      }
    }
  }
#line 741
  if (o->unit_count == 2U) {
#line 741
    if ((int )*(o->string + 1) == 46) {
#line 742
      return (o);
    }
  }
#line 744
  return (ret);
}
}
#line 761 "Csv2_parse.c"
js_string *js_append_dname(js_string *o , csv2_read *stream , int starwhitis ) 
{ int x ;
  int32_t look ;
  int state ;
  int32_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int32_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 764
  state = 1;
#line 765
  look = csv2_justread(stream);
#line 768
  if (look == 37) {
#line 768
    if (starwhitis != 4) {
#line 768
      if (starwhitis != 5) {
#line 768
        goto _L;
      } else {
#line 768
        goto _L___1;
      }
    } else {
#line 768
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 768
  if (look == 46) {
    _L: /* CIL Label */ 
#line 770
    tmp = csv2_read_unicode(stream);
#line 770
    if (tmp == -164) {
#line 771
      js_destroy(o);
#line 772
      return ((js_string *)0);
    }
#line 774
    return (o);
  } else
#line 775
  if (look == 37) {
#line 775
    if (starwhitis == 4) {
#line 776
      csv2_error(stream, (char *)"\'%\' character not allowed");
#line 777
      js_destroy(o);
#line 778
      return ((js_string *)0);
    } else
#line 775
    if (starwhitis == 5) {
#line 776
      csv2_error(stream, (char *)"\'%\' character not allowed");
#line 777
      js_destroy(o);
#line 778
      return ((js_string *)0);
    }
  }
#line 786
  if (starwhitis != 0) {
#line 786
    if (starwhitis != 5) {
#line 787
      tmp___0 = csv2_is_text(look);
#line 787
      if (tmp___0) {
#line 788
        state = 1;
      } else
#line 790
      if (look == 42) {
#line 791
        if (starwhitis == 0) {
#line 793
          csv2_error(stream, (char *)"\'*\' character not allowed");
#line 794
          js_destroy(o);
#line 795
          return ((js_string *)0);
        } else
#line 791
        if (starwhitis == 3) {
#line 793
          csv2_error(stream, (char *)"\'*\' character not allowed");
#line 794
          js_destroy(o);
#line 795
          return ((js_string *)0);
        } else
#line 791
        if (starwhitis == 4) {
#line 793
          csv2_error(stream, (char *)"\'*\' character not allowed");
#line 794
          js_destroy(o);
#line 795
          return ((js_string *)0);
        } else
#line 791
        if (starwhitis == 5) {
#line 793
          csv2_error(stream, (char *)"\'*\' character not allowed");
#line 794
          js_destroy(o);
#line 795
          return ((js_string *)0);
        }
#line 797
        state = 2;
      } else {
#line 800
        csv2_error(stream, (char *)"Unexpected character");
#line 801
        js_destroy(o);
#line 802
        return ((js_string *)0);
      }
    } else {
#line 805
      state = 0;
    }
  } else {
#line 805
    state = 0;
  }
#line 809
  x = 0;
#line 809
  while (x < 10000) {
#line 810
    look = csv2_read_unicode(stream);
#line 811
    if (look == -164) {
#line 812
      js_destroy(o);
#line 813
      return ((js_string *)0);
    }
#line 819
    if (look == 46) {
#line 819
      if (state == 1) {
#line 820
        state = 0;
#line 824
        tmp___1 = csv2_append_utf8(o, '.');
#line 824
        if (tmp___1 < 0) {
#line 825
          csv2_error(stream, (char *)"Error appending character");
#line 826
          js_destroy(o);
#line 827
          return ((js_string *)0);
        }
      } else {
#line 819
        goto _L___17;
      }
    } else
    _L___17: /* CIL Label */ 
#line 830
    if (state == 1) {
#line 830
      tmp___13 = csv2_is_text(look);
#line 830
      if (tmp___13) {
#line 831
        tmp___2 = csv2_append_utf8(o, look);
#line 831
        if (tmp___2 < 0) {
#line 832
          csv2_error(stream, (char *)"Error appending character");
#line 833
          js_destroy(o);
#line 834
          return ((js_string *)0);
        }
      } else {
#line 830
        goto _L___16;
      }
    } else
    _L___16: /* CIL Label */ 
#line 842
    if (look == 35) {
#line 842
      if (state == 0) {
#line 842
        if (x > 0) {
#line 843
          process_comment(stream);
#line 844
          return (o);
        } else {
#line 842
          goto _L___15;
        }
      } else {
#line 842
        goto _L___15;
      }
    } else
    _L___15: /* CIL Label */ 
#line 847
    if (state == 0) {
#line 847
      if (look == 37) {
#line 847
        if (starwhitis != 4) {
#line 847
          if (starwhitis != 5) {
#line 849
            tmp___3 = csv2_append_utf8(o, look);
#line 849
            if (tmp___3 < 0) {
#line 850
              csv2_error(stream, (char *)"Error appending character");
#line 851
              js_destroy(o);
#line 852
              return ((js_string *)0);
            }
#line 858
            tmp___4 = csv2_read_unicode(stream);
#line 858
            if (tmp___4 == -164) {
#line 859
              js_destroy(o);
#line 860
              return ((js_string *)0);
            }
#line 862
            return (o);
          } else {
#line 847
            goto _L___13;
          }
        } else {
#line 847
          goto _L___13;
        }
      } else {
#line 847
        goto _L___13;
      }
    } else
    _L___13: /* CIL Label */ 
#line 867
    if (state == 0) {
#line 867
      tmp___12 = csv2_is_text(look);
#line 867
      if (tmp___12) {
#line 868
        state = 1;
#line 869
        tmp___5 = csv2_append_utf8(o, look);
#line 869
        if (tmp___5 < 0) {
#line 870
          csv2_error(stream, (char *)"Error appending character");
#line 871
          js_destroy(o);
#line 872
          return ((js_string *)0);
        }
      } else {
#line 867
        goto _L___10;
      }
    } else
    _L___10: /* CIL Label */ 
#line 878
    if (state == 0) {
#line 878
      if (starwhitis == 2) {
#line 878
        if (look == 42) {
#line 880
          state = 3;
#line 881
          tmp___6 = csv2_append_utf8(o, look);
#line 881
          if (tmp___6 < 0) {
#line 882
            csv2_error(stream, (char *)"Error appending character");
#line 883
            js_destroy(o);
#line 884
            return ((js_string *)0);
          }
        } else {
#line 878
          goto _L___9;
        }
      } else {
#line 878
        goto _L___9;
      }
    } else
    _L___9: /* CIL Label */ 
#line 888
    if (state == 0) {
#line 888
      tmp___11 = csv2_is_delimiter(look);
#line 888
      if (tmp___11) {
#line 889
        return (o);
      } else {
#line 888
        goto _L___7;
      }
    } else
    _L___7: /* CIL Label */ 
#line 895
    if (state == 2) {
#line 895
      if (look == 46) {
#line 896
        state = 0;
#line 897
        tmp___7 = csv2_append_utf8(o, look);
#line 897
        if (tmp___7 < 0) {
#line 898
          csv2_error(stream, (char *)"Error appending character");
#line 899
          js_destroy(o);
#line 900
          return ((js_string *)0);
        }
      } else {
#line 895
        goto _L___6;
      }
    } else
    _L___6: /* CIL Label */ 
#line 904
    if (state == 2) {
#line 904
      tmp___10 = csv2_is_delimiter(look);
#line 904
      if (tmp___10) {
#line 904
        if (starwhitis == 2) {
#line 906
          return (o);
        } else {
#line 904
          goto _L___5;
        }
      } else {
#line 904
        goto _L___5;
      }
    } else
    _L___5: /* CIL Label */ 
#line 912
    if (state == 3) {
#line 912
      tmp___9 = csv2_is_delimiter(look);
#line 912
      if (tmp___9) {
#line 914
        return (o);
      } else {
#line 912
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 917
    if (look == 35) {
#line 917
      if (state == 3) {
#line 918
        process_comment(stream);
#line 919
        return (o);
      } else {
#line 917
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
#line 921
      tmp___8 = csv2_is_delimiter(look);
#line 921
      if (tmp___8) {
#line 922
        csv2_error(stream, (char *)"Improper termination of label\nLabel must end with \'.\' or \'%\' (A \'*\' is allowed in csv2_default_zonefile)");
#line 924
        js_destroy(o);
#line 925
        return ((js_string *)0);
      } else {
#line 928
        csv2_error(stream, (char *)"Unexpected character");
#line 929
        js_destroy(o);
#line 930
        return ((js_string *)0);
      }
    }
#line 809
    x ++;
  }
#line 933
  js_destroy(o);
#line 934
  return ((js_string *)0);
}
}
#line 939 "Csv2_parse.c"
js_string *csv2_convert_percent(js_string *in , js_string *psub ) 
{ int tmp ;

  {
#line 941
  if (in->unit_size != 1U) {
#line 942
    return ((js_string *)0);
  }
#line 946
  if (in->unit_count >= 1U) {
#line 946
    if ((int )*((in->string + in->unit_count) - 1) == 37) {
#line 948
      (in->unit_count) --;
#line 949
      tmp = js_append(psub, in);
#line 949
      if (tmp == -1) {
#line 950
        return ((js_string *)0);
      }
    }
  }
#line 954
  return (in);
}
}
#line 967 "Csv2_parse.c"
js_string *csv2_get_hostname(csv2_read *stream , js_string *zonename , int starwhitis ) 
{ js_string *out ;
  js_string *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 970
  out = process_dname(stream, starwhitis);
#line 970
  if ((unsigned long )out == (unsigned long )((js_string *)0)) {
#line 971
    return ((js_string *)0);
  }
#line 975
  tmp = csv2_convert_percent(out, zonename);
#line 975
  if ((unsigned long )tmp == (unsigned long )((js_string *)0)) {
#line 976
    js_destroy(out);
#line 977
    return ((js_string *)0);
  }
#line 981
  if (starwhitis == 2) {
#line 982
    tmp___0 = hname_2rfc1035_starwhitis(out, 1);
#line 982
    if (tmp___0 < 0) {
#line 983
      js_destroy(out);
#line 984
      return ((js_string *)0);
    }
  } else {
#line 987
    tmp___1 = hname_2rfc1035_starwhitis(out, 0);
#line 987
    if (tmp___1 < 0) {
#line 988
      js_destroy(out);
#line 989
      return ((js_string *)0);
    }
  }
#line 996
  tmp___2 = starrecord_to_meta(out, 0);
#line 996
  if (tmp___2 == -1) {
#line 997
    js_destroy(out);
#line 998
    return ((js_string *)0);
  }
#line 1001
  return (out);
}
}
#line 1009 "Csv2_parse.c"
int csv2_numeric_rtype(js_string *text_rtype ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;

  {
#line 1012
  js_set_encode(text_rtype, 2);
#line 1013
  tmp = js_tolower(text_rtype);
#line 1013
  if (tmp == -1) {
#line 1014
    return (-1);
  }
#line 1017
  tmp___0 = js_qissame((char *)"in", text_rtype);
#line 1017
  if (tmp___0 == 1) {
#line 1018
    return (-2);
  }
#line 1020
  tmp___1 = js_qissame((char *)"raw", text_rtype);
#line 1020
  if (tmp___1 == 1) {
#line 1021
    return (-3);
  }
#line 1023
  tmp___2 = js_qissame((char *)"a", text_rtype);
#line 1023
  if (tmp___2 == 1) {
#line 1024
    return (1);
  }
#line 1026
  tmp___3 = js_qissame((char *)"ns", text_rtype);
#line 1026
  if (tmp___3 == 1) {
#line 1027
    return (2);
  }
#line 1029
  tmp___4 = js_qissame((char *)"cname", text_rtype);
#line 1029
  if (tmp___4 == 1) {
#line 1030
    return (5);
  }
#line 1032
  tmp___5 = js_qissame((char *)"soa", text_rtype);
#line 1032
  if (tmp___5 == 1) {
#line 1033
    return (6);
  }
#line 1035
  tmp___6 = js_qissame((char *)"ptr", text_rtype);
#line 1035
  if (tmp___6 == 1) {
#line 1036
    return (12);
  }
#line 1038
  tmp___7 = js_qissame((char *)"mx", text_rtype);
#line 1038
  if (tmp___7 == 1) {
#line 1039
    return (15);
  }
#line 1041
  tmp___8 = js_qissame((char *)"aaaa", text_rtype);
#line 1041
  if (tmp___8 == 1) {
#line 1042
    return (28);
  }
#line 1044
  tmp___9 = js_qissame((char *)"srv", text_rtype);
#line 1044
  if (tmp___9 == 1) {
#line 1045
    return (33);
  }
#line 1047
  tmp___10 = js_qissame((char *)"txt", text_rtype);
#line 1047
  if (tmp___10 == 1) {
#line 1048
    return (16);
  }
#line 1050
  tmp___11 = js_qissame((char *)"spf", text_rtype);
#line 1050
  if (tmp___11 == 1) {
#line 1051
    return (99);
  }
#line 1053
  tmp___12 = js_qissame((char *)"fqdn4", text_rtype);
#line 1053
  if (tmp___12 == 1) {
#line 1054
    return (65765);
  }
#line 1057
  tmp___13 = js_qissame((char *)"fqdn6", text_rtype);
#line 1057
  if (tmp___13 == 1) {
#line 1058
    return (65766);
  }
#line 1063
  tmp___14 = js_qissame((char *)"hinfo", text_rtype);
#line 1063
  if (tmp___14 == 1) {
#line 1064
    return (13);
  }
#line 1066
  tmp___15 = js_qissame((char *)"wks", text_rtype);
#line 1066
  if (tmp___15 == 1) {
#line 1067
    return (11);
  }
#line 1069
  tmp___16 = js_qissame((char *)"mb", text_rtype);
#line 1069
  if (tmp___16 == 1) {
#line 1070
    return (7);
  }
#line 1072
  tmp___17 = js_qissame((char *)"md", text_rtype);
#line 1072
  if (tmp___17 == 1) {
#line 1073
    return (3);
  }
#line 1075
  tmp___18 = js_qissame((char *)"mf", text_rtype);
#line 1075
  if (tmp___18 == 1) {
#line 1076
    return (4);
  }
#line 1078
  tmp___19 = js_qissame((char *)"mg", text_rtype);
#line 1078
  if (tmp___19 == 1) {
#line 1079
    return (8);
  }
#line 1081
  tmp___20 = js_qissame((char *)"mr", text_rtype);
#line 1081
  if (tmp___20 == 1) {
#line 1082
    return (9);
  }
#line 1084
  tmp___21 = js_qissame((char *)"minfo", text_rtype);
#line 1084
  if (tmp___21 == 1) {
#line 1085
    return (14);
  }
#line 1088
  tmp___22 = js_qissame((char *)"afsdb", text_rtype);
#line 1088
  if (tmp___22 == 1) {
#line 1089
    return (18);
  }
#line 1091
  tmp___23 = js_qissame((char *)"rp", text_rtype);
#line 1091
  if (tmp___23 == 1) {
#line 1092
    return (17);
  }
#line 1094
  tmp___24 = js_qissame((char *)"x25", text_rtype);
#line 1094
  if (tmp___24 == 1) {
#line 1095
    return (19);
  }
#line 1097
  tmp___25 = js_qissame((char *)"isdn", text_rtype);
#line 1097
  if (tmp___25 == 1) {
#line 1098
    return (20);
  }
#line 1100
  tmp___26 = js_qissame((char *)"rt", text_rtype);
#line 1100
  if (tmp___26 == 1) {
#line 1101
    return (21);
  }
#line 1104
  tmp___27 = js_qissame((char *)"nsap", text_rtype);
#line 1104
  if (tmp___27 == 1) {
#line 1105
    return (22);
  }
#line 1107
  tmp___28 = js_qissame((char *)"nsap-ptr", text_rtype);
#line 1107
  if (tmp___28 == 1) {
#line 1108
    return (23);
  }
#line 1111
  tmp___29 = js_qissame((char *)"px", text_rtype);
#line 1111
  if (tmp___29 == 1) {
#line 1112
    return (26);
  }
#line 1115
  tmp___30 = js_qissame((char *)"gpos", text_rtype);
#line 1115
  if (tmp___30 == 1) {
#line 1116
    return (27);
  }
#line 1119
  tmp___31 = js_qissame((char *)"loc", text_rtype);
#line 1119
  if (tmp___31 == 1) {
#line 1120
    return (29);
  }
#line 1123
  tmp___32 = js_qissame((char *)"naptr", text_rtype);
#line 1123
  if (tmp___32 == 1) {
#line 1124
    return (35);
  }
#line 1126
  return (-1);
}
}
#line 1130 "Csv2_parse.c"
int32_t csv2_get_rtype(csv2_read *stream ) 
{ js_string *r ;
  int32_t ret ;
  int tmp ;
  int tmp___0 ;

  {
#line 1134
  while (1) {
#line 1135
    tmp = csv2_get_1st(stream, & csv2_is_alpha, 0);
#line 1135
    if (tmp != 1) {
#line 1136
      return (-1);
    }
#line 1138
    r = process_textlabel(stream);
#line 1138
    if ((unsigned long )r == (unsigned long )((js_string *)0)) {
#line 1139
      return (-1);
    }
#line 1141
    ret = csv2_numeric_rtype(r);
#line 1142
    js_destroy(r);
#line 1144
    if (ret == -3) {
#line 1145
      tmp___0 = csv2_get_1st(stream, & csv2_is_number, 0);
#line 1145
      if (tmp___0 < 0) {
#line 1146
        csv2_error(stream, (char *)"RAW rr not followed by number");
#line 1148
        return (-1);
      }
#line 1150
      ret = csv2_get_num(stream);
#line 1151
      if (ret < 0) {
#line 1152
        return (-1);
      }
#line 1154
      ret += 100000;
#line 1155
      return (ret);
    }
#line 1157
    if (ret == -1) {
#line 1158
      return (-1);
    } else
#line 1157
    if (ret == 0) {
#line 1158
      return (-1);
    }
#line 1134
    if (ret <= -2) {
#line 1134
      if (! (ret >= -11)) {
#line 1134
        break;
      }
    } else {
#line 1134
      break;
    }
  }
#line 1163
  return (ret);
}
}
#line 1168 "Csv2_parse.c"
int32_t csv2_get_num(csv2_read *stream ) 
{ js_string *num ;
  int32_t ret ;
  int tmp ;
  int32_t tmp___0 ;
  int32_t tmp___1 ;
  int32_t tmp___2 ;
  int32_t tmp___3 ;
  int32_t tmp___4 ;
  int32_t tmp___5 ;
  int32_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;

  {
#line 1172
  tmp = csv2_get_1st(stream, & csv2_is_number_orslash, 0);
#line 1172
  if (tmp != 1) {
#line 1173
    return (-1);
  }
#line 1177
  tmp___8 = csv2_justread(stream);
#line 1177
  if (tmp___8 == 47) {
#line 1178
    tmp___0 = csv2_read_unicode(stream);
#line 1178
    if (tmp___0 != 115) {
#line 1179
      return (-1);
    }
#line 1181
    tmp___1 = csv2_read_unicode(stream);
#line 1181
    if (tmp___1 != 101) {
#line 1182
      return (-1);
    }
#line 1184
    tmp___2 = csv2_read_unicode(stream);
#line 1184
    if (tmp___2 != 114) {
#line 1185
      return (-1);
    }
#line 1187
    tmp___3 = csv2_read_unicode(stream);
#line 1187
    if (tmp___3 != 105) {
#line 1188
      return (-1);
    }
#line 1190
    tmp___4 = csv2_read_unicode(stream);
#line 1190
    if (tmp___4 != 97) {
#line 1191
      return (-1);
    }
#line 1193
    tmp___5 = csv2_read_unicode(stream);
#line 1193
    if (tmp___5 != 108) {
#line 1194
      return (-1);
    }
#line 1196
    tmp___6 = csv2_read_unicode(stream);
#line 1196
    tmp___7 = csv2_is_delimiter(tmp___6);
#line 1196
    if (! tmp___7) {
#line 1197
      return (-1);
    }
#line 1199
    return (-2);
  }
#line 1202
  num = process_number(stream);
#line 1202
  if ((unsigned long )num == (unsigned long )((js_string *)0)) {
#line 1203
    return (-1);
  }
#line 1206
  if ((int )*(num->string) == 48) {
#line 1206
    if (num->unit_count == 1U) {
#line 1207
      js_destroy(num);
#line 1208
      return (0);
    }
  }
#line 1210
  tmp___9 = js_atoi(num, 0);
#line 1210
  ret = (int32_t )tmp___9;
#line 1210
  if (ret == 0) {
#line 1211
    js_destroy(num);
#line 1212
    return (-1);
  }
#line 1214
  js_destroy(num);
#line 1215
  return (ret);
}
}
#line 1224 "Csv2_parse.c"
js_string *csv2_get_something(csv2_read *stream , int (*is_ok)(int32_t in ) ) 
{ js_string *o ;
  int tmp ;

  {
#line 1227
  tmp = csv2_get_1st(stream, is_ok, 0);
#line 1227
  if (tmp != 1) {
#line 1228
    return ((js_string *)0);
  }
#line 1231
  o = process_something(stream, is_ok);
#line 1231
  if ((unsigned long )o == (unsigned long )((js_string *)0)) {
#line 1232
    return ((js_string *)0);
  }
#line 1235
  return (o);
}
}
#line 1239 "Csv2_parse.c"
js_string *csv2_get_filename(csv2_read *stream ) 
{ js_string *tmp ;

  {
#line 1240
  tmp = csv2_get_something(stream, & csv2_is_fchar);
#line 1240
  return (tmp);
}
}
#line 1247 "Csv2_parse.c"
js_string *csv2_get_dname(csv2_read *stream ) 
{ int tmp ;
  js_string *tmp___0 ;

  {
#line 1251
  tmp = csv2_get_1st(stream, & csv2_is_text, 0);
#line 1251
  if (tmp != 1) {
#line 1252
    return ((js_string *)0);
  }
#line 1255
  tmp___0 = csv2_get_hostname(stream, (js_string *)0, 1);
#line 1255
  return (tmp___0);
}
}
#line 1264 "Csv2_parse.c"
js_string *csv2_get_mx(csv2_read *stream , js_string *zone , int pref ) 
{ js_string *out ;
  int num ;
  int hlabels ;
  int tmp ;
  js_string *name ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1267
  hlabels = 1;
#line 1270
  if (pref < 0) {
#line 1271
    num = csv2_get_num(stream);
#line 1271
    if (num < 0) {
#line 1272
      return ((js_string *)0);
    }
  } else {
#line 1275
    num = pref;
  }
#line 1277
  out = js_create(256U, 1U);
#line 1277
  if ((unsigned long )out == (unsigned long )((js_string *)0)) {
#line 1278
    return ((js_string *)0);
  }
#line 1280
  tmp = js_adduint16(out, num);
#line 1280
  if (tmp == -1) {
#line 1281
    js_destroy(out);
#line 1282
    return ((js_string *)0);
  }
#line 1285
  if (pref == -2) {
#line 1286
    hlabels = 2;
  }
#line 1290
  while (hlabels > 0) {
#line 1292
    tmp___0 = csv2_get_1st(stream, & csv2_is_dchar, 0);
#line 1292
    if (tmp___0 != 1) {
#line 1293
      js_destroy(out);
#line 1294
      return ((js_string *)0);
    }
#line 1296
    name = csv2_get_hostname(stream, zone, 3);
#line 1296
    if ((unsigned long )name == (unsigned long )((js_string *)0)) {
#line 1297
      js_destroy(out);
#line 1298
      return ((js_string *)0);
    }
#line 1300
    tmp___1 = js_append(name, out);
#line 1300
    if (tmp___1 == -1) {
#line 1301
      js_destroy(name);
#line 1302
      js_destroy(out);
#line 1303
      return ((js_string *)0);
    }
#line 1305
    js_destroy(name);
#line 1306
    hlabels --;
  }
#line 1309
  return (out);
}
}
#line 1315 "Csv2_parse.c"
js_string *csv2_get_srv(csv2_read *stream , js_string *zone ) 
{ js_string *out ;
  js_string *name ;
  int num ;
  int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1320
  out = js_create(256U, 1U);
#line 1320
  if ((unsigned long )out == (unsigned long )((js_string *)0)) {
#line 1321
    return ((js_string *)0);
  }
#line 1325
  c = 1;
#line 1325
  while (c <= 3) {
#line 1326
    num = csv2_get_num(stream);
#line 1326
    if (num < 0) {
#line 1327
      js_destroy(out);
#line 1328
      return ((js_string *)0);
    }
#line 1330
    tmp = js_adduint16(out, num);
#line 1330
    if (tmp == -1) {
#line 1331
      js_destroy(out);
#line 1332
      return ((js_string *)0);
    }
#line 1325
    c ++;
  }
#line 1337
  tmp___0 = csv2_get_1st(stream, & csv2_is_dchar, 0);
#line 1337
  if (tmp___0 != 1) {
#line 1338
    js_destroy(out);
#line 1339
    return ((js_string *)0);
  }
#line 1341
  name = csv2_get_hostname(stream, zone, 3);
#line 1341
  if ((unsigned long )name == (unsigned long )((js_string *)0)) {
#line 1342
    js_destroy(out);
#line 1343
    return ((js_string *)0);
  }
#line 1345
  tmp___1 = js_append(name, out);
#line 1345
  if (tmp___1 == -1) {
#line 1346
    js_destroy(name);
#line 1347
    js_destroy(out);
#line 1348
    return ((js_string *)0);
  }
#line 1351
  js_destroy(name);
#line 1352
  return (out);
}
}
#line 1361 "Csv2_parse.c"
int csv2_read_rr(csv2_add_state *state , csv2_read *stream , int32_t starwhitis ) 
{ js_string *name ;
  js_string *rddata ;
  js_string *zone ;
  int32_t ttl ;
  int32_t rtype ;
  int q ;
  int slash_command ;
  int32_t look ;
  int32_t cmd ;
  int newttl ;
  js_string *n ;
  int32_t tmp ;
  int32_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  js_string *tmp___3 ;
  js_string *n___0 ;
  csv2_origin *c ;
  csv2_origin *o ;
  int32_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  js_string *tmp___7 ;
  void *tmp___8 ;
  csv2_origin *o___0 ;
  int tmp___9 ;
  js_string *filename ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int32_t tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;

  {
#line 1362
  name = (js_string *)0;
#line 1362
  rddata = (js_string *)0;
#line 1363
  zone = (js_string *)0;
#line 1364
  ttl = 86400;
#line 1367
  slash_command = 0;
#line 1370
  if ((unsigned long )state->bighash == (unsigned long )((mhash *)0)) {
#line 1370
    if (state->add_method == 1) {
#line 1371
      return (-1);
    }
  }
#line 1373
  if ((unsigned long )state->zone == (unsigned long )((js_string *)0)) {
#line 1374
    return (-1);
  }
#line 1376
  if ((unsigned long )state->origin == (unsigned long )((js_string *)0)) {
#line 1377
    return (-1);
  }
#line 1380
  zone = state->origin;
#line 1387
  while (1) {
#line 1388
    slash_command = 0;
#line 1392
    q = csv2_get_1st(stream, & csv2_is_starwhitis_orslash, 1);
#line 1394
    if (q == -2) {
#line 1395
      return (-2);
    }
#line 1398
    if (q == -1) {
#line 1399
      return (-1);
    }
#line 1404
    tmp___12 = csv2_justread(stream);
#line 1404
    if (tmp___12 == 47) {
#line 1406
      slash_command = 1;
#line 1407
      look = csv2_read_unicode(stream);
#line 1408
      if (look == 116) {
#line 1409
        cmd = 1;
      } else
#line 1410
      if (look == 111) {
#line 1411
        cmd = 2;
      } else
#line 1412
      if (look == 114) {
#line 1413
        cmd = 5;
      } else {
#line 1415
        csv2_error(stream, (char *)"Invalid slash command");
#line 1416
        return (-1);
      }
#line 1419
      look = csv2_read_unicode(stream);
#line 1420
      if (cmd == 2) {
#line 1420
        if (look == 112) {
#line 1421
          cmd = 3;
        } else {
#line 1420
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 1422
      if (cmd == 1) {
#line 1422
        if (look != 116) {
#line 1424
          csv2_error(stream, (char *)"Invalid slash command");
#line 1425
          return (-1);
        } else {
#line 1422
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 1422
      if (cmd == 2) {
#line 1422
        if (look != 114) {
#line 1424
          csv2_error(stream, (char *)"Invalid slash command");
#line 1425
          return (-1);
        } else {
#line 1422
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1422
      if (cmd == 5) {
#line 1422
        if (look != 101) {
#line 1424
          csv2_error(stream, (char *)"Invalid slash command");
#line 1425
          return (-1);
        }
      }
#line 1428
      look = csv2_read_unicode(stream);
#line 1429
      if (cmd == 3) {
#line 1429
        if (look == 111) {
#line 1430
          cmd = 4;
        } else {
#line 1429
          goto _L___5;
        }
      } else
      _L___5: /* CIL Label */ 
#line 1431
      if (cmd == 1) {
#line 1431
        if (look != 108) {
#line 1434
          csv2_error(stream, (char *)"Invalid slash command");
#line 1435
          return (-1);
        } else {
#line 1431
          goto _L___4;
        }
      } else
      _L___4: /* CIL Label */ 
#line 1431
      if (cmd == 2) {
#line 1431
        if (look != 105) {
#line 1434
          csv2_error(stream, (char *)"Invalid slash command");
#line 1435
          return (-1);
        } else {
#line 1431
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
#line 1431
      if (cmd == 3) {
#line 1431
        if (look != 117) {
#line 1434
          csv2_error(stream, (char *)"Invalid slash command");
#line 1435
          return (-1);
        } else {
#line 1431
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 1431
      if (cmd == 5) {
#line 1431
        if (look != 97) {
#line 1434
          csv2_error(stream, (char *)"Invalid slash command");
#line 1435
          return (-1);
        }
      }
#line 1438
      look = csv2_read_unicode(stream);
#line 1439
      if (cmd == 1) {
#line 1439
        tmp___11 = csv2_is_delimiter(look);
#line 1439
        if (tmp___11) {
#line 1441
          newttl = csv2_get_num(stream);
#line 1442
          if (newttl < 0) {
#line 1443
            csv2_error(stream, (char *)"Invalid slash command");
#line 1445
            return (-1);
          }
#line 1447
          state->default_ttl = newttl;
        } else {
#line 1439
          goto _L___9;
        }
      } else
      _L___9: /* CIL Label */ 
#line 1448
      if (cmd == 2) {
#line 1448
        if (look == 103) {
#line 1450
          tmp = csv2_read_unicode(stream);
#line 1450
          if (tmp != 105) {
#line 1451
            csv2_error(stream, (char *)"Invalid slash command");
#line 1453
            return (-1);
          }
#line 1455
          tmp___0 = csv2_read_unicode(stream);
#line 1455
          if (tmp___0 != 110) {
#line 1456
            csv2_error(stream, (char *)"Invalid slash command");
#line 1458
            return (-1);
          }
#line 1460
          look = csv2_read_unicode(stream);
#line 1461
          tmp___1 = csv2_is_delimiter(look);
#line 1461
          if (! tmp___1) {
#line 1462
            csv2_error(stream, (char *)"Invalid slash command");
#line 1464
            return (-1);
          }
#line 1466
          tmp___2 = csv2_get_1st(stream, & csv2_is_dchar, 0);
#line 1466
          if (tmp___2 != 1) {
#line 1468
            csv2_error(stream, (char *)"Invalid argument for /origin");
#line 1470
            return (-1);
          }
#line 1472
          n = process_1stchar(stream, & csv2_is_starwhitis, (char *)0);
#line 1474
          if ((unsigned long )n == (unsigned long )((js_string *)0)) {
#line 1475
            csv2_error(stream, (char *)"Error processing /origin");
#line 1477
            return (-1);
          }
#line 1479
          n = js_append_dname(n, stream, 3);
#line 1480
          if ((unsigned long )n == (unsigned long )((js_string *)0)) {
#line 1481
            csv2_error(stream, (char *)"Invalid argument for /origin");
#line 1483
            return (-1);
          }
#line 1485
          tmp___3 = csv2_convert_percent(n, state->origin);
#line 1485
          if ((unsigned long )tmp___3 == (unsigned long )((js_string *)0)) {
#line 1487
            csv2_error(stream, (char *)"Problem running convert_percent");
#line 1489
            return (-1);
          }
#line 1491
          js_destroy(state->origin);
#line 1492
          state->origin = n;
#line 1493
          zone = n;
        } else {
#line 1448
          goto _L___8;
        }
      } else
      _L___8: /* CIL Label */ 
#line 1494
      if (cmd == 3) {
#line 1494
        if (look == 115) {
#line 1497
          tmp___4 = csv2_read_unicode(stream);
#line 1497
          if (tmp___4 != 104) {
#line 1498
            csv2_error(stream, (char *)"Invalid slash command");
#line 1500
            return (-1);
          }
#line 1502
          look = csv2_read_unicode(stream);
#line 1503
          tmp___5 = csv2_is_delimiter(look);
#line 1503
          if (! tmp___5) {
#line 1504
            csv2_error(stream, (char *)"Invalid slash command");
#line 1506
            return (-1);
          }
#line 1508
          tmp___6 = csv2_get_1st(stream, & csv2_is_dchar, 0);
#line 1508
          if (tmp___6 != 1) {
#line 1510
            csv2_error(stream, (char *)"Invalid argument for /opush");
#line 1512
            return (-1);
          }
#line 1514
          n___0 = process_1stchar(stream, & csv2_is_starwhitis, (char *)0);
#line 1516
          if ((unsigned long )n___0 == (unsigned long )((js_string *)0)) {
#line 1517
            csv2_error(stream, (char *)"Error processing /opush");
#line 1519
            return (-1);
          }
#line 1521
          n___0 = js_append_dname(n___0, stream, 3);
#line 1522
          if ((unsigned long )n___0 == (unsigned long )((js_string *)0)) {
#line 1523
            csv2_error(stream, (char *)"Invalid argument for /opush");
#line 1525
            return (-1);
          }
#line 1527
          tmp___7 = csv2_convert_percent(n___0, state->origin);
#line 1527
          if ((unsigned long )tmp___7 == (unsigned long )((js_string *)0)) {
#line 1529
            csv2_error(stream, (char *)"Problem running convert_percent");
#line 1531
            return (-1);
          }
#line 1534
          if (state->ostack_height > 7) {
#line 1536
            csv2_error(stream, (char *)"origin stack too high");
#line 1538
            return (-1);
          } else
#line 1534
          if (state->ostack_height < 0) {
#line 1536
            csv2_error(stream, (char *)"origin stack too high");
#line 1538
            return (-1);
          }
#line 1543
          (state->ostack_height) ++;
#line 1544
          o = state->ostack;
#line 1545
          tmp___8 = js_alloc(1, (int )sizeof(csv2_origin ));
#line 1545
          c = (csv2_origin *)tmp___8;
#line 1546
          if ((unsigned long )c == (unsigned long )((csv2_origin *)0)) {
#line 1547
            csv2_error(stream, (char *)"js_alloc error");
#line 1549
            return (-1);
          }
#line 1551
          c->origin = state->origin;
#line 1552
          c->next = o;
#line 1553
          state->ostack = c;
#line 1554
          state->origin = n___0;
#line 1555
          zone = state->origin;
        } else {
#line 1494
          goto _L___7;
        }
      } else
      _L___7: /* CIL Label */ 
#line 1556
      if (cmd == 4) {
#line 1556
        if (look == 112) {
#line 1558
          look = csv2_read_unicode(stream);
#line 1559
          tmp___9 = csv2_is_delimiter(look);
#line 1559
          if (! tmp___9) {
#line 1560
            csv2_error(stream, (char *)"Invalid slash command");
#line 1562
            return (-1);
          }
#line 1564
          if (state->ostack_height < 1) {
#line 1566
            csv2_error(stream, (char *)"origin stack too low");
#line 1568
            return (-1);
          } else
#line 1564
          if (state->ostack_height > 8) {
#line 1566
            csv2_error(stream, (char *)"origin stack too low");
#line 1568
            return (-1);
          }
#line 1570
          if ((unsigned long )state->ostack == (unsigned long )((csv2_origin *)0)) {
#line 1571
            csv2_error(stream, (char *)"origin stack empty");
#line 1573
            return (-1);
          }
#line 1577
          o___0 = state->ostack;
#line 1578
          js_destroy(state->origin);
#line 1579
          state->ostack = o___0->next;
#line 1580
          state->origin = o___0->origin;
#line 1581
          zone = state->origin;
#line 1582
          js_dealloc((void *)o___0);
        } else {
#line 1556
          goto _L___6;
        }
      } else
      _L___6: /* CIL Label */ 
#line 1583
      if (cmd == 5) {
#line 1583
        if (look == 100) {
#line 1585
          look = csv2_read_unicode(stream);
#line 1586
          tmp___10 = csv2_is_delimiter(look);
#line 1586
          if (! tmp___10) {
#line 1587
            csv2_error(stream, (char *)"Invalid slash command");
#line 1589
            return (-1);
          }
#line 1591
          filename = csv2_get_filename(stream);
#line 1592
          csv2_push_file(stream, filename);
#line 1593
          js_destroy(filename);
        } else {
#line 1595
          csv2_error(stream, (char *)"Invalid slash command");
#line 1596
          return (-1);
        }
      } else {
#line 1595
        csv2_error(stream, (char *)"Invalid slash command");
#line 1596
        return (-1);
      }
    }
#line 1387
    if (! (slash_command == 1)) {
#line 1387
      break;
    }
  }
#line 1607
  if (starwhitis == 0) {
#line 1608
    name = csv2_get_hostname(stream, zone, 1);
#line 1608
    if ((unsigned long )name == (unsigned long )((js_string *)0)) {
#line 1609
      csv2_error(stream, (char *)"Problem getting hostname");
#line 1610
      return (-1);
    }
  } else
#line 1612
  if (starwhitis == 1) {
#line 1613
    name = csv2_get_hostname(stream, zone, 2);
#line 1613
    if ((unsigned long )name == (unsigned long )((js_string *)0)) {
#line 1614
      csv2_error(stream, (char *)"Problem getting hostname");
#line 1615
      return (-1);
    }
  } else {
#line 1618
    csv2_error(stream, (char *)"Bad starwhitis value passed to csv2_read_rr");
#line 1620
    return (-1);
  }
#line 1625
  tmp___13 = csv2_get_1st(stream, & csv2_is_alphanum_orplus, 0);
#line 1625
  if (tmp___13 < 0) {
#line 1626
    js_destroy(name);
#line 1627
    csv2_error(stream, (char *)"Unexpected character");
#line 1628
    return (-1);
  }
#line 1631
  ttl = state->default_ttl;
#line 1633
  tmp___16 = csv2_justread(stream);
#line 1633
  if (tmp___16 == 43) {
#line 1634
    tmp___14 = csv2_read_unicode(stream);
#line 1634
    if (tmp___14 < 0) {
#line 1635
      js_destroy(name);
#line 1636
      csv2_error(stream, (char *)"Unexpected char around +");
#line 1637
      return (-1);
    }
#line 1639
    ttl = csv2_get_num(stream);
#line 1639
    if (ttl < 0) {
#line 1640
      js_destroy(name);
#line 1641
      csv2_error(stream, (char *)"Problem getting TTL");
#line 1642
      return (-1);
    }
#line 1645
    tmp___15 = csv2_get_1st(stream, & csv2_is_alphanum, 0);
#line 1645
    if (tmp___15 < 0) {
#line 1646
      js_destroy(name);
#line 1647
      csv2_error(stream, (char *)"Unexpected character");
#line 1648
      return (-1);
    }
  }
#line 1655
  tmp___19 = csv2_justread(stream);
#line 1655
  tmp___20 = csv2_is_alpha(tmp___19);
#line 1655
  if (tmp___20) {
#line 1656
    rtype = csv2_get_rtype(stream);
#line 1656
    if (rtype == -1) {
#line 1657
      js_destroy(name);
#line 1658
      csv2_error(stream, (char *)"Unknown Rtype");
#line 1659
      return (-1);
    }
  } else {
#line 1664
    tmp___17 = csv2_justread(stream);
#line 1664
    tmp___18 = csv2_is_number(tmp___17);
#line 1664
    if (tmp___18) {
#line 1665
      rtype = 1;
#line 1666
      rddata = csv2_get_a(stream);
#line 1668
      csv2_add_rr(state, name, rtype, ttl, rddata);
#line 1670
      js_destroy(name);
#line 1671
      js_destroy(rddata);
#line 1672
      return (1);
    } else {
#line 1675
      js_destroy(name);
#line 1676
      csv2_error(stream, (char *)"Unexpected char (shouldn\'t get here)");
#line 1677
      return (-1);
    }
  }
#line 1683
  switch (rtype) {
  case 1: 
#line 1685
  rddata = csv2_get_a(stream);
#line 1686
  break;
  case 28: 
#line 1688
  rddata = csv2_get_aaaa(stream);
#line 1689
  break;
  case 6: 
#line 1691
  rddata = csv2_get_soa(stream, zone, state);
#line 1692
  break;
  case 15: 
  case 18: 
  case 21: 
#line 1696
  rddata = csv2_get_mx(stream, zone, -1);
#line 1697
  break;
  case 33: 
#line 1699
  rddata = csv2_get_srv(stream, zone);
#line 1700
  break;
  case 16: 
  case 19: 
  case 20: 
  case 99: 
#line 1705
  if ((int )stream->tilde_handling == 2) {
#line 1707
    csv2_error(stream, (char *)"I\'m sorry, that record can not be the first record unless csv2_tilde_handling is set.");
#line 1710
    break;
  } else
#line 1705
  if ((int )stream->tilde_handling == 102) {
#line 1707
    csv2_error(stream, (char *)"I\'m sorry, that record can not be the first record unless csv2_tilde_handling is set.");
#line 1710
    break;
  }
#line 1712
  rddata = csv2_get_txt(stream, 0);
#line 1713
  break;
  case 8: 
  case 9: 
#line 1716
  rddata = csv2_get_mbox(stream, zone, 1);
#line 1717
  break;
  case 14: 
  case 17: 
#line 1720
  rddata = csv2_get_mbox(stream, zone, 2);
#line 1721
  break;
  case 2: 
  case 5: 
  case 12: 
  case 23: 
  case 7: 
#line 1727
  tmp___21 = csv2_get_1st(stream, & csv2_is_dchar, 0);
#line 1727
  if (tmp___21 != 1) {
#line 1729
    return (-1);
  }
#line 1731
  rddata = csv2_get_hostname(stream, zone, 3);
#line 1732
  break;
  case 65765: 
#line 1736
  rddata = csv2_get_a(stream);
#line 1737
  break;
  case 65766: 
#line 1742
  rddata = csv2_get_aaaa(stream);
#line 1743
  break;
  case 13: 
#line 1747
  rddata = csv2_get_txt(stream, 2);
#line 1748
  break;
  case 11: 
#line 1750
  if ((int )stream->tilde_handling == 2) {
#line 1752
    csv2_error(stream, (char *)"I\'m sorry, that record can not be the first record unless csv2_tilde_handling is set.");
#line 1755
    break;
  } else
#line 1750
  if ((int )stream->tilde_handling == 102) {
#line 1752
    csv2_error(stream, (char *)"I\'m sorry, that record can not be the first record unless csv2_tilde_handling is set.");
#line 1755
    break;
  }
#line 1757
  rddata = csv2_get_wks(stream);
#line 1758
  break;
  case 3: 
#line 1762
  rddata = csv2_get_mx(stream, zone, 0);
#line 1763
  rtype = 15;
#line 1764
  break;
  case 4: 
#line 1768
  rddata = csv2_get_mx(stream, zone, 10);
#line 1769
  rtype = 15;
#line 1770
  break;
  case 22: 
#line 1772
  rddata = csv2_get_hex(stream);
#line 1773
  break;
  case 26: 
#line 1775
  rddata = csv2_get_mx(stream, zone, -2);
#line 1776
  break;
  case 27: 
#line 1778
  rddata = csv2_get_txt(stream, 3);
#line 1779
  break;
  case 29: 
#line 1781
  if ((int )stream->tilde_handling == 2) {
#line 1783
    csv2_error(stream, (char *)"I\'m sorry, that record can not be the first record unless csv2_tilde_handling is set.");
#line 1786
    break;
  } else
#line 1781
  if ((int )stream->tilde_handling == 102) {
#line 1783
    csv2_error(stream, (char *)"I\'m sorry, that record can not be the first record unless csv2_tilde_handling is set.");
#line 1786
    break;
  }
#line 1788
  rddata = csv2_get_loc(stream);
#line 1789
  break;
  case 35: 
#line 1791
  rddata = csv2_get_naptr(stream);
#line 1792
  break;
  default: 
#line 1795
  if (rtype >= 100000) {
#line 1795
    if (rtype <= 165535) {
#line 1796
      rtype -= 100000;
#line 1797
      if (rtype == 255) {
#line 1798
        csv2_error(stream, (char *)"ANY (255) record type isn\'t for data");
      } else
#line 1800
      if (rtype == 251) {
#line 1801
        csv2_error(stream, (char *)"IXFR (251) record type isn\'t for data");
      } else
#line 1803
      if (rtype == 252) {
#line 1804
        csv2_error(stream, (char *)"AXFR (252) record type isn\'t for data");
      } else
#line 1806
      if (rtype == 253) {
#line 1807
        csv2_error(stream, (char *)"MAILB record type isn\'t for data");
      } else
#line 1809
      if (rtype == 254) {
#line 1810
        csv2_error(stream, (char *)"MAILA record type isn\'t for data");
      } else
#line 1812
      if (rtype == 38) {
#line 1813
        csv2_error(stream, (char *)"MaraDNS doesn\'t allow A6 records");
      } else
#line 1815
      if (rtype == 39) {
#line 1816
        csv2_error(stream, (char *)"MaraDNS doesn\'t allow DNAME records");
      } else
#line 1818
      if (rtype == 41) {
#line 1819
        csv2_error(stream, (char *)"OPT record type isn\'t for zone files");
      } else {
#line 1822
        rddata = csv2_get_raw(stream);
      }
    } else {
#line 1825
      csv2_error(stream, (char *)"Unsupported RTYPE");
    }
  } else {
#line 1825
    csv2_error(stream, (char *)"Unsupported RTYPE");
  }
  }
#line 1829
  if ((unsigned long )rddata == (unsigned long )((js_string *)0)) {
#line 1830
    csv2_error(stream, (char *)"Problem getting rddata");
#line 1831
    js_destroy(name);
#line 1832
    return (-1);
  }
#line 1835
  csv2_add_rr(state, name, rtype, ttl, rddata);
#line 1837
  js_destroy(name);
#line 1838
  js_destroy(rddata);
#line 1839
  return (1);
}
}
#line 1 "Csv2_rr_soa.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-Sbv6ojwm.i","")
#line 270 "Csv2_functions.h"
int csv2_b4_at(int32_t in ) ;
#line 271
js_string *process_mbox(csv2_read *stream ) ;
#line 281
int csv2_is_alphanum_ordot(int32_t in ) ;
#line 36 "Csv2_rr_soa.c"
int csv2_b4_at(int32_t in ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 38
  tmp = csv2_is_alphanum(in);
#line 38
  if (tmp) {
#line 38
    tmp___0 = 1;
  } else
#line 38
  if (in == 43) {
#line 38
    tmp___0 = 1;
  } else
#line 38
  if (in == 37) {
#line 38
    tmp___0 = 1;
  } else
#line 38
  if (in == 33) {
#line 38
    tmp___0 = 1;
  } else
#line 38
  if (in == 94) {
#line 38
    tmp___0 = 1;
  } else
#line 38
  if (in == 61) {
#line 38
    tmp___0 = 1;
  } else {
#line 38
    tmp___0 = 0;
  }
#line 38
  return (tmp___0);
}
}
#line 44 "Csv2_rr_soa.c"
js_string *process_mbox(csv2_read *stream ) 
{ js_string *o ;
  int32_t look ;
  int x ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  js_string *tmp___5 ;

  {
#line 49
  o = process_1stchar(stream, & csv2_is_alphanum_ordot, (char *)"Z");
#line 50
  if ((unsigned long )o == (unsigned long )((js_string *)0)) {
#line 51
    return ((js_string *)0);
  }
#line 55
  x = 0;
#line 55
  while (x < 10000) {
#line 56
    look = csv2_read_unicode(stream);
#line 59
    if (x == 0) {
#line 59
      if (o->unit_count >= 2U) {
#line 59
        if ((int )*(o->string + 1) == 46) {
#line 60
          tmp = csv2_is_delimiter(look);
#line 60
          if (tmp) {
#line 61
            return (o);
          }
#line 63
          csv2_error(stream, (char *)". can only be at start of label that is just a . by itself");
#line 65
          js_destroy(o);
#line 66
          return ((js_string *)0);
        }
      }
    }
#line 68
    if (look == -164) {
#line 69
      js_destroy(o);
#line 70
      return ((js_string *)0);
    }
#line 72
    if (look == 64) {
#line 72
      goto _L;
    } else
#line 72
    if (look == 46) {
      _L: /* CIL Label */ 
#line 73
      tmp___0 = csv2_append_utf8(o, look);
#line 73
      if (tmp___0 < 0) {
#line 74
        csv2_error(stream, (char *)"Error appending character");
#line 75
        js_destroy(o);
#line 76
        return ((js_string *)0);
      }
#line 78
      if (look == 46) {
#line 79
        look = csv2_read_unicode(stream);
#line 80
        tmp___2 = csv2_is_text(look);
#line 80
        if (tmp___2) {
#line 81
          tmp___1 = csv2_append_utf8(o, look);
#line 81
          if (tmp___1 < 0) {
#line 82
            csv2_error(stream, (char *)"Error appending character");
#line 84
            js_destroy(o);
#line 85
            return ((js_string *)0);
          }
        } else {
#line 88
          csv2_error(stream, (char *)"Strange character after dot");
#line 90
          js_destroy(o);
#line 91
          return ((js_string *)0);
        }
      }
#line 94
      break;
    }
#line 96
    tmp___4 = csv2_b4_at(look);
#line 96
    if (tmp___4) {
#line 97
      tmp___3 = csv2_append_utf8(o, look);
#line 97
      if (tmp___3 < 0) {
#line 98
        csv2_error(stream, (char *)"Error appending character");
#line 99
        js_destroy(o);
#line 100
        return ((js_string *)0);
      }
    } else {
#line 104
      csv2_error(stream, (char *)"Unexpected character before @ in mbox Yes, I know RFC2822 3.4 probably allows the character in question to be there. This is MaraDNS, not some platonic ideal.");
#line 109
      js_destroy(o);
#line 110
      return ((js_string *)0);
    }
#line 55
    x ++;
  }
#line 116
  tmp___5 = js_append_dname(o, stream, 0);
#line 116
  return (tmp___5);
}
}
#line 123 "Csv2_rr_soa.c"
js_string *csv2_get_soa(csv2_read *stream , js_string *zone , csv2_add_state *state ) 
{ js_string *name ;
  js_string *out ;
  int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int32_t num ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 129
  out = js_create(512U, 1U);
#line 129
  if ((unsigned long )out == (unsigned long )((js_string *)0)) {
#line 130
    return ((js_string *)0);
  }
#line 134
  tmp = csv2_get_1st(stream, & csv2_is_dchar, 0);
#line 134
  if (tmp != 1) {
#line 135
    return ((js_string *)0);
  }
#line 137
  name = csv2_get_hostname(stream, zone, 3);
#line 137
  if ((unsigned long )name == (unsigned long )((js_string *)0)) {
#line 138
    js_destroy(out);
#line 139
    return ((js_string *)0);
  }
#line 141
  tmp___0 = js_append(name, out);
#line 141
  if (tmp___0 == -1) {
#line 142
    js_destroy(name);
#line 143
    js_destroy(out);
#line 144
    return ((js_string *)0);
  }
#line 146
  js_destroy(name);
#line 149
  name = csv2_get_mbox(stream, zone, 1);
#line 150
  tmp___1 = js_append(name, out);
#line 150
  if (tmp___1 == -1) {
#line 151
    js_destroy(name);
#line 152
    js_destroy(out);
#line 153
    return ((js_string *)0);
  }
#line 155
  js_destroy(name);
#line 158
  c = 0;
#line 158
  while (c < 5) {
#line 160
    num = csv2_get_num(stream);
#line 163
    if (num == -2) {
#line 163
      if (c == 0) {
#line 164
        tmp___2 = js_adduint32(out, (uint32_t )state->soa_serial);
#line 164
        if (tmp___2 == -1) {
#line 165
          js_destroy(out);
#line 166
          return ((js_string *)0);
        }
      } else {
#line 163
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 168
    if (num < 0) {
#line 169
      js_destroy(out);
#line 170
      return ((js_string *)0);
    } else {
#line 171
      tmp___3 = js_adduint32(out, (uint32_t )num);
#line 171
      if (tmp___3 == -1) {
#line 172
        js_destroy(out);
#line 173
        return ((js_string *)0);
      }
    }
#line 158
    c ++;
  }
#line 176
  return (out);
}
}
#line 1 "Csv2_rr_aaaa.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-12r9RSQ_.i","")
#line 264 "Csv2_functions.h"
int csv2_is_hex(int32_t in ) ;
#line 265
int csv2_is_hex_or_colon(int32_t in ) ;
#line 266
js_string *process_aaaa(csv2_read *stream ) ;
#line 30 "Csv2_rr_aaaa.c"
int csv2_is_hex(int32_t in ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 31
  tmp = csv2_is_number(in);
#line 31
  if (tmp) {
#line 31
    tmp___0 = 1;
  } else
#line 31
  if (in >= 97) {
#line 31
    if (in <= 102) {
#line 31
      tmp___0 = 1;
    } else {
#line 31
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 31
  if (in >= 65) {
#line 31
    if (in <= 70) {
#line 31
      tmp___0 = 1;
    } else {
#line 31
      tmp___0 = 0;
    }
  } else {
#line 31
    tmp___0 = 0;
  }
#line 31
  return (tmp___0);
}
}
#line 35 "Csv2_rr_aaaa.c"
int csv2_is_hex_or_colon(int32_t in ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 36
  tmp = csv2_is_hex(in);
#line 36
  if (tmp) {
#line 36
    tmp___0 = 1;
  } else
#line 36
  if (in == 58) {
#line 36
    tmp___0 = 1;
  } else {
#line 36
    tmp___0 = 0;
  }
#line 36
  return (tmp___0);
}
}
#line 42 "Csv2_rr_aaaa.c"
js_string *process_aaaa(csv2_read *stream ) 
{ js_string *tmp ;

  {
#line 43
  tmp = process_something(stream, & csv2_is_hex_or_colon);
#line 43
  return (tmp);
}
}
#line 50 "Csv2_rr_aaaa.c"
js_string *csv2_get_aaaa(csv2_read *stream ) 
{ js_string *ip6hex ;
  js_string *out ;
  int tmp ;

  {
#line 54
  tmp = csv2_get_1st(stream, & csv2_is_hex_or_colon, 0);
#line 54
  if (tmp != 1) {
#line 55
    return ((js_string *)0);
  }
#line 58
  ip6hex = process_aaaa(stream);
#line 58
  if ((unsigned long )ip6hex == (unsigned long )((js_string *)0)) {
#line 59
    return ((js_string *)0);
  }
#line 62
  out = ip6_to_raw(ip6hex);
#line 62
  if ((unsigned long )out == (unsigned long )((js_string *)0)) {
#line 63
    js_destroy(ip6hex);
#line 64
    csv2_error(stream, (char *)"Invalid IPv6 address");
#line 65
    return ((js_string *)0);
  }
#line 68
  js_destroy(ip6hex);
#line 69
  return (out);
}
}
#line 1 "Csv2_rr_a.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-mrc8f5LG.i","")
#line 267 "Csv2_functions.h"
int csv2_is_number_or_dot(int32_t in ) ;
#line 268
js_string *process_ipv4_ddip(csv2_read *stream ) ;
#line 31 "Csv2_rr_a.c"
int csv2_is_number_or_dot(int32_t in ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 32
  tmp = csv2_is_number(in);
#line 32
  if (tmp) {
#line 32
    tmp___0 = 1;
  } else
#line 32
  if (in == 46) {
#line 32
    tmp___0 = 1;
  } else {
#line 32
    tmp___0 = 0;
  }
#line 32
  return (tmp___0);
}
}
#line 38 "Csv2_rr_a.c"
js_string *process_ipv4_ddip(csv2_read *stream ) 
{ js_string *o ;
  int32_t look ;
  int num_nums ;
  int x ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 41
  num_nums = 1;
#line 44
  o = process_1stchar(stream, & csv2_is_number, (char *)0);
#line 45
  if ((unsigned long )o == (unsigned long )((js_string *)0)) {
#line 46
    return ((js_string *)0);
  }
#line 49
  x = 0;
#line 49
  while (x < 10000) {
#line 50
    look = csv2_read_unicode(stream);
#line 51
    if (look == -164) {
#line 52
      js_destroy(o);
#line 53
      return ((js_string *)0);
    }
#line 55
    if (look == 35) {
#line 55
      if (num_nums == 4) {
#line 56
        process_comment(stream);
#line 57
        return (o);
      } else {
#line 55
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 59
    if (look == 46) {
#line 59
      if (num_nums < 4) {
#line 60
        num_nums ++;
#line 61
        tmp = csv2_append_utf8(o, '.');
#line 61
        if (tmp < 0) {
#line 62
          csv2_error(stream, (char *)"Error appending character");
#line 63
          js_destroy(o);
#line 64
          return ((js_string *)0);
        }
      } else {
#line 59
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 67
    if (look == 46) {
#line 68
      csv2_error(stream, (char *)"Too many numbers in ipv4 ddip");
#line 69
      js_destroy(o);
#line 70
      return ((js_string *)0);
    } else {
#line 72
      tmp___2 = csv2_is_number(look);
#line 72
      if (tmp___2) {
#line 73
        tmp___0 = csv2_append_utf8(o, look);
#line 73
        if (tmp___0 < 0) {
#line 74
          csv2_error(stream, (char *)"Error appending character");
#line 75
          js_destroy(o);
#line 76
          return ((js_string *)0);
        }
      } else {
#line 79
        tmp___1 = csv2_is_delimiter(look);
#line 79
        if (tmp___1) {
#line 79
          if (num_nums == 4) {
#line 80
            return (o);
          } else {
#line 83
            csv2_error(stream, (char *)"Unexpected character in ddip");
#line 84
            js_destroy(o);
#line 85
            return ((js_string *)0);
          }
        } else {
#line 83
          csv2_error(stream, (char *)"Unexpected character in ddip");
#line 84
          js_destroy(o);
#line 85
          return ((js_string *)0);
        }
      }
    }
#line 49
    x ++;
  }
#line 89
  js_destroy(o);
#line 90
  return ((js_string *)0);
}
}
#line 95 "Csv2_rr_a.c"
js_string *csv2_get_a(csv2_read *stream ) 
{ js_string *ddip ;
  js_string *out ;
  int tmp ;
  int tmp___0 ;

  {
#line 99
  tmp = csv2_get_1st(stream, & csv2_is_number, 0);
#line 99
  if (tmp != 1) {
#line 100
    return ((js_string *)0);
  }
#line 103
  ddip = process_ipv4_ddip(stream);
#line 103
  if ((unsigned long )ddip == (unsigned long )((js_string *)0)) {
#line 104
    return ((js_string *)0);
  }
#line 107
  out = js_create(7U, 1U);
#line 107
  if ((unsigned long )out == (unsigned long )((js_string *)0)) {
#line 108
    js_destroy(ddip);
#line 109
    return ((js_string *)0);
  }
#line 112
  tmp___0 = ddip_2_ip(ddip, out, 0);
#line 112
  if (tmp___0 == -1) {
#line 113
    js_destroy(ddip);
#line 114
    js_destroy(out);
#line 115
    return ((js_string *)0);
  }
#line 118
  js_destroy(ddip);
#line 119
  return (out);
}
}
#line 1 "Csv2_rr_wks.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-JBolk4Ft.i","")
#line 196 "Csv2_functions.h"
int csv2_is_hash(int32_t in ) ;
#line 276
js_string *csv2_get_string(csv2_read *stream , int numchunks , int post_txt ) ;
#line 280
int csv2_is_wks(int32_t in ) ;
#line 40 "Csv2_rr_wks.c"
int csv2_is_wks(int32_t in ) 
{ int tmp ;

  {
#line 41
  if (in == 44) {
#line 41
    tmp = 1;
  } else
#line 41
  if (in == 9) {
#line 41
    tmp = 1;
  } else
#line 41
  if (in == 32) {
#line 41
    tmp = 1;
  } else {
#line 41
    tmp = 0;
  }
#line 41
  return (tmp);
}
}
#line 45 "Csv2_rr_wks.c"
int csv2_is_alphanum_ordot(int32_t in ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 46
  tmp = csv2_is_alphanum(in);
#line 46
  if (tmp) {
#line 46
    tmp___0 = 1;
  } else
#line 46
  if (in == 46) {
#line 46
    tmp___0 = 1;
  } else {
#line 46
    tmp___0 = 0;
  }
#line 46
  return (tmp___0);
}
}
#line 50 "Csv2_rr_wks.c"
int csv2_is_signed_num(int32_t in ) 
{ int tmp ;

  {
#line 51
  if (in >= 48) {
#line 51
    if (in <= 57) {
#line 51
      tmp = 1;
    } else {
#line 51
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 51
  if (in == 45) {
#line 51
    tmp = 1;
  } else {
#line 51
    tmp = 0;
  }
#line 51
  return (tmp);
}
}
#line 56 "Csv2_rr_wks.c"
js_string *csv2_get_wks(csv2_read *stream ) 
{ js_string *ddip ;
  js_string *out ;
  int protocol ;
  int ports[13] ;
  int portindex ;
  int hiport ;
  int32_t look ;
  int x ;
  int num ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int pn ;
  int q ;
  int mask ;

  {
#line 61
  portindex = 0;
#line 62
  hiport = 0;
#line 66
  tmp = csv2_get_1st(stream, & csv2_is_number, 0);
#line 66
  if (tmp != 1) {
#line 67
    return ((js_string *)0);
  }
#line 71
  ddip = process_ipv4_ddip(stream);
#line 71
  if ((unsigned long )ddip == (unsigned long )((js_string *)0)) {
#line 72
    return ((js_string *)0);
  }
#line 76
  protocol = csv2_get_num(stream);
#line 77
  if (protocol < 0) {
#line 78
    js_destroy(ddip);
#line 79
    return ((js_string *)0);
  }
#line 82
  tmp___0 = csv2_get_1st(stream, & csv2_is_number, 0);
#line 82
  if (tmp___0 != 1) {
#line 83
    js_destroy(ddip);
#line 84
    return ((js_string *)0);
  }
#line 90
  if ((int )stream->tilde_handling == 103) {
#line 91
    csv2_allow_tilde(stream);
  }
#line 93
  look = csv2_justread(stream);
#line 94
  num = 0;
#line 95
  x = 0;
#line 95
  while (x < 1000) {
#line 96
    if ((int )stream->tilde_handling != 103) {
#line 100
      if (look == -2) {
#line 101
        break;
      } else
#line 100
      if (look == 10) {
#line 101
        break;
      } else
#line 100
      if (look == 13) {
#line 101
        break;
      } else {
#line 104
        tmp___1 = csv2_is_hash(look);
#line 104
        if (tmp___1) {
#line 105
          process_comment(stream);
#line 106
          break;
        }
      }
    } else
#line 111
    if (look == 126) {
#line 112
      break;
    } else {
#line 113
      tmp___2 = csv2_is_hash(look);
#line 113
      if (tmp___2) {
#line 114
        process_comment(stream);
#line 115
        look = csv2_read_unicode(stream);
#line 116
        goto __Cont;
      }
    }
#line 120
    tmp___4 = csv2_is_number(look);
#line 120
    if (tmp___4) {
#line 121
      num *= 10;
#line 122
      num += look - 48;
#line 127
      if (num > 100000) {
#line 128
        js_destroy(ddip);
#line 129
        return ((js_string *)0);
      }
    } else {
#line 134
      tmp___3 = csv2_is_wks(look);
#line 134
      if (tmp___3) {
#line 134
        goto _L___0;
      } else
#line 134
      if ((int )stream->tilde_handling == 103) {
#line 134
        if (look == 13) {
#line 134
          goto _L___0;
        } else
#line 134
        if (look == 10) {
          _L___0: /* CIL Label */ 
#line 138
          if (portindex >= 10) {
#line 139
            js_destroy(ddip);
#line 140
            return ((js_string *)0);
          }
#line 142
          ports[portindex] = num;
#line 143
          portindex ++;
#line 144
          if (num > hiport) {
#line 145
            hiport = num;
          }
#line 147
          if (num > 1024) {
#line 148
            js_destroy(ddip);
#line 149
            return ((js_string *)0);
          }
#line 151
          num = 0;
        } else {
#line 155
          js_destroy(ddip);
#line 156
          return ((js_string *)0);
        }
      } else {
#line 155
        js_destroy(ddip);
#line 156
        return ((js_string *)0);
      }
    }
#line 158
    look = csv2_read_unicode(stream);
    __Cont: /* CIL Label */ 
#line 95
    x ++;
  }
#line 166
  if (num > 0) {
#line 166
    if (num < 1024) {
#line 167
      if (portindex >= 10) {
#line 168
        js_destroy(ddip);
#line 169
        return ((js_string *)0);
      }
#line 171
      ports[portindex] = num;
#line 172
      if (num > hiport) {
#line 173
        hiport = num;
      }
    }
  }
#line 178
  out = js_create((unsigned int )((hiport >> 3) + 6), 1U);
#line 178
  if ((unsigned long )out == (unsigned long )((js_string *)0)) {
#line 179
    js_destroy(ddip);
#line 180
    return ((js_string *)0);
  }
#line 184
  x = 0;
#line 184
  while (x < (hiport >> 3) + 6) {
#line 185
    *(out->string + x) = (unsigned char)0;
#line 184
    x ++;
  }
#line 190
  tmp___5 = ddip_2_ip(ddip, out, 0);
#line 190
  if (tmp___5 == -1) {
#line 191
    js_destroy(ddip);
#line 192
    js_destroy(out);
#line 193
    return ((js_string *)0);
  }
#line 197
  out->unit_count = (unsigned int )(6 + (hiport >> 3));
#line 200
  if (out->max_count < out->unit_count) {
#line 201
    js_destroy(ddip);
#line 202
    js_destroy(out);
#line 203
    return ((js_string *)0);
  }
#line 207
  *(out->string + 4) = (unsigned char )(protocol & 255);
#line 210
  x = 0;
#line 210
  while (x < portindex) {
#line 212
    pn = ports[x];
#line 213
    q = pn >> 3;
#line 214
    mask = 128 >> pn % 8;
#line 215
    if ((unsigned int )q >= out->unit_count) {
#line 216
      js_destroy(ddip);
#line 217
      js_destroy(out);
#line 218
      return ((js_string *)0);
    }
#line 220
    *((out->string + q) + 5) = (unsigned char )((int )*((out->string + q) + 5) | mask);
#line 210
    x ++;
  }
#line 223
  js_destroy(ddip);
#line 224
  return (out);
}
}
#line 230 "Csv2_rr_wks.c"
js_string *csv2_get_mbox(csv2_read *stream , js_string *zone , int count ) 
{ js_string *name ;
  js_string *out ;
  int c ;
  int tmp ;
  js_string *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 235
  out = js_create(512U, 1U);
#line 235
  if ((unsigned long )out == (unsigned long )((js_string *)0)) {
#line 236
    return ((js_string *)0);
  }
#line 239
  c = 0;
#line 239
  while (c < count) {
#line 241
    tmp = csv2_get_1st(stream, & csv2_is_alphanum_ordot, 0);
#line 241
    if (tmp != 1) {
#line 243
      js_destroy(out);
#line 244
      return ((js_string *)0);
    }
#line 246
    name = process_mbox(stream);
#line 246
    if ((unsigned long )name == (unsigned long )((js_string *)0)) {
#line 247
      js_destroy(out);
#line 248
      return ((js_string *)0);
    }
#line 250
    tmp___0 = csv2_convert_percent(name, zone);
#line 250
    if ((unsigned long )tmp___0 == (unsigned long )((js_string *)0)) {
#line 251
      js_destroy(name);
#line 252
      js_destroy(out);
#line 253
      return ((js_string *)0);
    }
#line 255
    tmp___1 = email_2rfc1035(name);
#line 255
    if (tmp___1 == -1) {
#line 256
      js_destroy(name);
#line 257
      js_destroy(out);
#line 258
      return ((js_string *)0);
    }
#line 260
    tmp___2 = js_append(name, out);
#line 260
    if (tmp___2 == -1) {
#line 261
      js_destroy(name);
#line 262
      js_destroy(out);
#line 263
      return ((js_string *)0);
    }
#line 265
    js_destroy(name);
#line 239
    c ++;
  }
#line 267
  return (out);
}
}
#line 272 "Csv2_rr_wks.c"
js_string *csv2_get_hex(csv2_read *stream ) 
{ js_string *out ;
  int32_t look ;
  int place ;
  int tmp ;
  int tmp___0 ;
  int32_t tmp___1 ;
  int lnybble ;
  int rnybble ;
  int chr ;
  int x ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 279
  tmp = csv2_get_1st(stream, & csv2_is_number, 0);
#line 279
  if (tmp != 1) {
#line 280
    return ((js_string *)0);
  }
#line 282
  tmp___0 = csv2_justread(stream);
#line 282
  if (tmp___0 != 48) {
#line 283
    return ((js_string *)0);
  }
#line 285
  tmp___1 = csv2_read_unicode(stream);
#line 285
  if (tmp___1 != 120) {
#line 286
    return ((js_string *)0);
  }
#line 289
  look = -1;
#line 290
  place = 0;
#line 292
  out = js_create(256U, 1U);
#line 293
  if ((unsigned long )out == (unsigned long )((js_string *)0)) {
#line 294
    return ((js_string *)0);
  }
#line 297
  while (1) {
#line 297
    if (look != -2) {
#line 297
      tmp___4 = csv2_is_delimiter(look);
#line 297
      if (tmp___4) {
#line 297
        break;
      }
    } else {
#line 297
      break;
    }
#line 301
    look = csv2_read_unicode(stream);
#line 302
    x = 0;
#line 304
    while (1) {
#line 304
      if (look == 46) {
#line 304
        if (! (x < 10000)) {
#line 304
          break;
        }
      } else {
#line 304
        break;
      }
#line 305
      look = csv2_read_unicode(stream);
#line 306
      x ++;
    }
#line 308
    if (look >= 48) {
#line 308
      if (look <= 57) {
#line 309
        lnybble = look - 48;
      } else {
#line 308
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 311
    if (look >= 97) {
#line 311
      if (look <= 102) {
#line 312
        lnybble = look - 97;
      } else {
#line 311
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 314
    if (look >= 65) {
#line 314
      if (look <= 70) {
#line 315
        lnybble = look - 65;
      } else {
#line 314
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 317
    if (look == -2) {
#line 318
      break;
    } else {
#line 317
      tmp___2 = csv2_is_delimiter(look);
#line 317
      if (tmp___2) {
#line 318
        break;
      } else {
#line 321
        csv2_error(stream, (char *)"Unexpected char");
#line 322
        js_destroy(out);
#line 323
        return ((js_string *)0);
      }
    }
#line 325
    look = csv2_read_unicode(stream);
#line 327
    if (look == 46) {
#line 328
      csv2_error(stream, (char *)"Dot not at byte boundary");
#line 329
      js_destroy(out);
#line 330
      return ((js_string *)0);
    }
#line 332
    if (look >= 48) {
#line 332
      if (look <= 57) {
#line 333
        rnybble = look - 48;
      } else {
#line 332
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 335
    if (look >= 97) {
#line 335
      if (look <= 102) {
#line 336
        rnybble = look - 97;
      } else {
#line 335
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 338
    if (look >= 65) {
#line 338
      if (look <= 70) {
#line 339
        rnybble = look - 65;
      } else {
#line 338
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 341
    if (look == -2) {
#line 342
      csv2_error(stream, (char *)"Record must end on byte boundary");
#line 343
      js_destroy(out);
#line 344
      return ((js_string *)0);
    } else {
#line 341
      tmp___3 = csv2_is_delimiter(look);
#line 341
      if (tmp___3) {
#line 342
        csv2_error(stream, (char *)"Record must end on byte boundary");
#line 343
        js_destroy(out);
#line 344
        return ((js_string *)0);
      } else {
#line 347
        csv2_error(stream, (char *)"Unexpected char");
#line 348
        js_destroy(out);
#line 349
        return ((js_string *)0);
      }
    }
#line 351
    chr = (((lnybble & 15) << 4) | (rnybble & 15)) & 255;
#line 352
    if ((unsigned int )(place + 7) > out->max_count) {
#line 353
      js_destroy(out);
#line 354
      return ((js_string *)0);
    }
#line 356
    out->unit_count = (unsigned int )(place + 1);
#line 357
    *(out->string + place) = (unsigned char )chr;
#line 358
    place ++;
  }
#line 361
  return (out);
}
}
#line 370 "Csv2_rr_wks.c"
int32_t csv2_get_int(csv2_read *stream , int mulfactor ) 
{ int out ;
  int32_t look ;
  int x ;
  int decimal ;
  int sign ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 371
  out = 0;
#line 374
  decimal = 0;
#line 375
  sign = 1;
#line 377
  if (mulfactor == 3) {
#line 378
    mulfactor = 1000;
  } else
#line 379
  if (mulfactor == 2) {
#line 380
    mulfactor = 100;
  } else
#line 381
  if (mulfactor == 1) {
#line 382
    mulfactor = 10;
  } else
#line 383
  if (mulfactor == 0) {
#line 384
    mulfactor = 1;
  } else {
#line 386
    return (0);
  }
#line 389
  look = csv2_justread(stream);
#line 390
  if (look == 45) {
#line 391
    sign = -1;
#line 392
    look = csv2_read_unicode(stream);
  }
#line 395
  x = 0;
#line 395
  while (x < 100) {
#line 396
    tmp___1 = csv2_is_number_or_dot(look);
#line 396
    if (tmp___1) {
#line 399
      tmp___0 = csv2_is_number(look);
#line 399
      if (tmp___0) {
#line 400
        out *= 10;
#line 401
        out += look - 48;
      } else
#line 403
      if (look == 46) {
#line 404
        decimal = 0;
#line 405
        out *= mulfactor;
#line 406
        look = csv2_read_unicode(stream);
#line 407
        while (1) {
#line 407
          tmp = csv2_is_number(look);
#line 407
          if (tmp) {
#line 407
            if (! (mulfactor > 1)) {
#line 407
              break;
            }
          } else {
#line 407
            break;
          }
#line 408
          mulfactor /= 10;
#line 409
          decimal += (look - 48) * mulfactor;
#line 410
          look = csv2_read_unicode(stream);
        }
#line 412
        return ((out + decimal) * sign);
      }
    } else {
#line 397
      return ((out * mulfactor) * sign);
    }
#line 414
    look = csv2_read_unicode(stream);
#line 395
    x ++;
  }
#line 416
  return (0);
}
}
#line 421 "Csv2_rr_wks.c"
uint32_t csv2_get_lon_lat(csv2_read *stream , char r1 , char r2 , char r3 , char r4 ) 
{ uint32_t out ;
  int degrees ;
  int mins ;
  int secs ;
  int32_t look ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 424
  degrees = 0;
#line 425
  mins = 0;
#line 426
  secs = 0;
#line 429
  tmp = csv2_get_1st(stream, & csv2_is_number, 0);
#line 429
  if (tmp != 1) {
#line 430
    return ((uint32_t )0);
  }
#line 433
  degrees = csv2_get_int(stream, 0);
#line 435
  tmp___0 = csv2_get_1st(stream, & csv2_is_alphanum, 0);
#line 435
  if (tmp___0 != 1) {
#line 436
    return ((uint32_t )0);
  }
#line 439
  look = csv2_justread(stream);
#line 440
  if (look == (int32_t )r1) {
#line 441
    goto process;
  } else
#line 440
  if (look == (int32_t )r2) {
#line 441
    goto process;
  } else
#line 440
  if (look == (int32_t )r3) {
#line 441
    goto process;
  } else
#line 440
  if (look == (int32_t )r4) {
#line 441
    goto process;
  } else {
#line 442
    tmp___1 = csv2_is_number(look);
#line 442
    if (tmp___1) {
#line 443
      mins = csv2_get_int(stream, 0);
    } else {
#line 445
      return ((uint32_t )0);
    }
  }
#line 448
  tmp___2 = csv2_get_1st(stream, & csv2_is_alphanum, 0);
#line 448
  if (tmp___2 != 1) {
#line 449
    return ((uint32_t )0);
  }
#line 452
  look = csv2_justread(stream);
#line 453
  if (look == (int32_t )r1) {
#line 454
    goto process;
  } else
#line 453
  if (look == (int32_t )r2) {
#line 454
    goto process;
  } else
#line 453
  if (look == (int32_t )r3) {
#line 454
    goto process;
  } else
#line 453
  if (look == (int32_t )r4) {
#line 454
    goto process;
  } else {
#line 455
    tmp___3 = csv2_is_number(look);
#line 455
    if (tmp___3) {
#line 456
      secs = csv2_get_int(stream, 3);
    } else {
#line 458
      return ((uint32_t )0);
    }
  }
#line 461
  tmp___4 = csv2_get_1st(stream, & csv2_is_alphanum, 0);
#line 461
  if (tmp___4 != 1) {
#line 462
    return ((uint32_t )0);
  }
#line 464
  look = csv2_justread(stream);
  process: 
#line 468
  if (look != (int32_t )r1) {
#line 468
    if (look != (int32_t )r2) {
#line 468
      if (look != (int32_t )r3) {
#line 468
        if (look != (int32_t )r4) {
#line 469
          return ((uint32_t )0);
        }
      }
    }
  }
#line 472
  out = 2147483648U;
#line 474
  if (look == (int32_t )r1) {
#line 475
    out += (uint32_t )((degrees * 3600000 + mins * 60000) + secs);
  } else
#line 474
  if (look == (int32_t )r2) {
#line 475
    out += (uint32_t )((degrees * 3600000 + mins * 60000) + secs);
  } else {
#line 477
    out -= (uint32_t )((degrees * 3600000 + mins * 60000) + secs);
  }
#line 482
  csv2_read_unicode(stream);
#line 484
  return (out);
}
}
#line 489 "Csv2_rr_wks.c"
js_string *csv2_get_loc(csv2_read *stream ) 
{ uint32_t lat ;
  uint32_t lon ;
  uint32_t alt ;
  int size ;
  int hpre ;
  int vpre ;
  int32_t look ;
  int32_t get ;
  int x ;
  js_string *out ;
  int tmp ;
  int q ;
  int v ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 490
  lat = (uint32_t )0;
#line 491
  lon = (uint32_t )0;
#line 492
  alt = (uint32_t )0;
#line 493
  size = -1;
#line 494
  hpre = -1;
#line 495
  vpre = -1;
#line 503
  lat = csv2_get_lon_lat(stream, (char )'N', (char )'n', (char )'S', (char )'s');
#line 504
  lon = csv2_get_lon_lat(stream, (char )'E', (char )'e', (char )'W', (char )'w');
#line 507
  tmp = csv2_get_1st(stream, & csv2_is_signed_num, 0);
#line 507
  if (tmp == 0) {
#line 508
    return ((js_string *)0);
  }
#line 510
  get = csv2_get_int(stream, 2);
#line 511
  get += 10000000;
#line 512
  if (get < 0) {
#line 513
    return ((js_string *)0);
  }
#line 515
  alt = (uint32_t )get;
#line 516
  look = csv2_read_unicode(stream);
#line 517
  if (look == 109) {
#line 518
    look = csv2_read_unicode(stream);
  }
#line 523
  get = -2;
#line 526
  if ((int )stream->tilde_handling == 103) {
#line 527
    csv2_allow_tilde(stream);
  }
#line 530
  x = 0;
#line 530
  while (x < 1000) {
#line 531
    tmp___0 = csv2_is_wks(look);
#line 531
    if (tmp___0) {
#line 531
      goto _L;
    } else
#line 531
    if (look == 13) {
#line 531
      goto _L;
    } else
#line 531
    if (look == 10) {
#line 531
      goto _L;
    } else
#line 531
    if (look == -2) {
#line 531
      goto _L;
    } else {
#line 531
      tmp___1 = csv2_is_hash(look);
#line 531
      if (tmp___1) {
        _L: /* CIL Label */ 
#line 533
        q = 1;
#line 534
        v = 0;
#line 535
        if (get != -2) {
#line 536
          if (get == -1) {
#line 537
            get = 1;
          }
#line 539
          while (1) {
#line 539
            if (get >= 10) {
#line 539
              if (! (q < 10)) {
#line 539
                break;
              }
            } else {
#line 539
              break;
            }
#line 540
            q ++;
#line 541
            get /= 10;
          }
#line 543
          q ++;
#line 544
          v = (get & 15) << 4;
#line 545
          v |= q & 15;
#line 546
          if (size == -1) {
#line 547
            size = v;
          } else
#line 549
          if (hpre == -1) {
#line 550
            hpre = v;
          } else
#line 552
          if (vpre == -1) {
#line 553
            vpre = v;
          } else {
#line 556
            printf("here\n");
#line 557
            return ((js_string *)0);
          }
#line 559
          get = -2;
        }
      }
    }
#line 563
    if ((int )stream->tilde_handling != 103) {
#line 564
      if (look == -2) {
#line 565
        break;
      } else
#line 564
      if (look == 10) {
#line 565
        break;
      } else
#line 564
      if (look == 13) {
#line 565
        break;
      } else {
#line 567
        tmp___2 = csv2_is_hash(look);
#line 567
        if (tmp___2) {
#line 568
          process_comment(stream);
#line 569
          break;
        }
      }
    } else
#line 574
    if (look == 126) {
#line 575
      break;
    } else {
#line 576
      tmp___3 = csv2_is_hash(look);
#line 576
      if (tmp___3) {
#line 577
        process_comment(stream);
#line 578
        look = csv2_read_unicode(stream);
#line 579
        goto __Cont;
      }
    }
#line 583
    tmp___5 = csv2_is_number(look);
#line 583
    if (tmp___5) {
#line 584
      if (get < 0) {
#line 585
        get = 0;
      }
#line 587
      get *= 10;
#line 588
      get += look - 48;
    } else {
#line 592
      tmp___4 = csv2_is_wks(look);
#line 592
      if (! tmp___4) {
#line 592
        if (look != 109) {
#line 592
          if ((int )stream->tilde_handling == 103) {
#line 592
            if (! (look == 13)) {
#line 592
              if (! (look == 10)) {
#line 595
                return ((js_string *)0);
              }
            }
          } else {
#line 595
            return ((js_string *)0);
          }
        }
      }
    }
#line 597
    look = csv2_read_unicode(stream);
    __Cont: /* CIL Label */ 
#line 530
    x ++;
  }
#line 600
  if (size == -1) {
#line 601
    size = 18;
  }
#line 603
  if (hpre == -1) {
#line 604
    hpre = 22;
  }
#line 606
  if (vpre == -1) {
#line 607
    vpre = 19;
  }
#line 610
  out = js_create(18U, 1U);
#line 610
  if ((unsigned long )out == (unsigned long )((js_string *)0)) {
#line 611
    return ((js_string *)0);
  }
#line 613
  *(out->string) = (unsigned char)0;
#line 615
  *(out->string + 1) = (unsigned char )(size & 255);
#line 616
  *(out->string + 2) = (unsigned char )(hpre & 255);
#line 617
  *(out->string + 3) = (unsigned char )(vpre & 255);
#line 619
  *(out->string + 4) = (unsigned char )((lat >> 24) & 255U);
#line 620
  *(out->string + 5) = (unsigned char )((lat >> 16) & 255U);
#line 621
  *(out->string + 6) = (unsigned char )((lat >> 8) & 255U);
#line 622
  *(out->string + 7) = (unsigned char )(lat & 255U);
#line 624
  *(out->string + 8) = (unsigned char )((lon >> 24) & 255U);
#line 625
  *(out->string + 9) = (unsigned char )((lon >> 16) & 255U);
#line 626
  *(out->string + 10) = (unsigned char )((lon >> 8) & 255U);
#line 627
  *(out->string + 11) = (unsigned char )(lon & 255U);
#line 629
  *(out->string + 12) = (unsigned char )((alt >> 24) & 255U);
#line 630
  *(out->string + 13) = (unsigned char )((alt >> 16) & 255U);
#line 631
  *(out->string + 14) = (unsigned char )((alt >> 8) & 255U);
#line 632
  *(out->string + 15) = (unsigned char )(alt & 255U);
#line 633
  out->unit_count = 16U;
#line 634
  return (out);
}
}
#line 640 "Csv2_rr_wks.c"
js_string *csv2_get_naptr(csv2_read *stream ) 
{ js_string *out ;
  js_string *name ;
  js_string *zone ;
  int num ;
  int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 643
  out = (js_string *)0;
#line 644
  name = (js_string *)0;
#line 645
  zone = (js_string *)0;
#line 646
  num = 0;
#line 647
  c = 0;
#line 649
  out = js_create(256U, 1U);
#line 650
  if ((unsigned long )out == (unsigned long )((js_string *)0)) {
#line 651
    return ((js_string *)0);
  }
#line 656
  c = 1;
#line 656
  while (c <= 2) {
#line 657
    num = csv2_get_num(stream);
#line 657
    if (num < 0) {
#line 658
      js_destroy(out);
#line 659
      return ((js_string *)0);
    }
#line 661
    tmp = js_adduint16(out, num);
#line 661
    if (tmp == -1) {
#line 662
      js_destroy(out);
#line 663
      return ((js_string *)0);
    }
#line 656
    c ++;
  }
#line 668
  name = csv2_get_string(stream, 3, 1);
#line 669
  if ((unsigned long )name == (unsigned long )((js_string *)0)) {
#line 670
    js_destroy(out);
#line 671
    return ((js_string *)0);
  }
#line 675
  tmp___0 = js_append(name, out);
#line 675
  if (tmp___0 == -1) {
#line 676
    js_destroy(name);
#line 677
    js_destroy(out);
#line 678
    return ((js_string *)0);
  }
#line 681
  js_destroy(name);
#line 684
  tmp___1 = csv2_get_1st(stream, & csv2_is_dchar, 0);
#line 684
  if (tmp___1 != 1) {
#line 685
    js_destroy(out);
#line 686
    return ((js_string *)0);
  }
#line 689
  zone = js_create(256U, 1U);
#line 692
  if ((unsigned long )zone == (unsigned long )((js_string *)0)) {
#line 693
    js_destroy(out);
#line 694
    return ((js_string *)0);
  }
#line 697
  name = csv2_get_hostname(stream, zone, 3);
#line 699
  js_destroy(zone);
#line 701
  if ((unsigned long )name == (unsigned long )((js_string *)0)) {
#line 702
    js_destroy(out);
#line 703
    return ((js_string *)0);
  }
#line 707
  tmp___2 = js_append(name, out);
#line 707
  if (tmp___2 == -1) {
#line 708
    js_destroy(name);
#line 709
    js_destroy(out);
#line 710
    return ((js_string *)0);
  }
#line 713
  js_destroy(name);
#line 714
  return (out);
}
}
#line 1 "Csv2_database.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-lONainuT.i","")
#line 86 "Csv2_functions.h"
int csv2_add_rr_debug(csv2_add_state *state , js_string *query , int rtype , int32_t ttl ,
                      js_string *data ) ;
#line 95
int csv2_add_rr_bighash(csv2_add_state *state , js_string *query , int rtype , int32_t ttl ,
                        js_string *data , int32_t starwhitis ) ;
#line 104
int csv2_add_rr_zoneserver(csv2_add_state *state , js_string *query , int rtype ,
                           int32_t ttl , js_string *data ) ;
#line 111
js_string *csv2_synth_query(csv2_add_state *state ) ;
#line 114
int csv2_synthesize_soa(csv2_add_state *state ) ;
#line 121
js_string *csv2_synth_ip(csv2_add_state *state , uint32_t ip , int actually_make_record ) ;
#line 125
int csv2_make_synth_ns(csv2_add_state *state , uint32_t ip ) ;
#line 130
int csv2_is_private_ip(uint32_t ip ) ;
#line 135
int csv2_is_localhost_ip(uint32_t ip ) ;
#line 139
int csv2_synthesize_ns(csv2_add_state *state ) ;
#line 148
int csv2_push_buffer(csv2_add_state *state , js_string *query , int rtype , int32_t ttl ,
                     js_string *data ) ;
#line 155
int csv2_set_soa(csv2_add_state *state , js_string *query , js_string *data , int32_t ttl ) ;
#line 160
int csv2_is_zonetop(csv2_add_state *state , js_string *query ) ;
#line 171
js_string *csv2_copy_js(js_string *s ) ;
#line 180
int csv2_add_rr_w(csv2_add_state *state , js_string *query , int rtype , int32_t ttl ,
                  js_string *data ) ;
#line 436 "/usr/include/sys/stat.h"
extern int stat(char const   * , struct stat * )  __asm__("_stat$INODE64")  ;
#line 142 "/usr/include/time.h"
extern struct tm *gmtime_r(time_t const   * , struct tm * ) ;
#line 67 "Csv2_database.c"
csv2_add_state *csv2_init_add_state(js_string *zone ) 
{ js_string *nzone ;
  js_string *norigin ;
  csv2_add_state *new ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 70
  if (zone->unit_size != 1U) {
#line 71
    return ((csv2_add_state *)0);
  }
#line 73
  tmp = js_alloc(1, (int )sizeof(csv2_add_state ));
#line 73
  new = (csv2_add_state *)tmp;
#line 73
  if ((unsigned long )new == (unsigned long )((csv2_add_state *)0)) {
#line 74
    return ((csv2_add_state *)0);
  }
#line 76
  nzone = js_create(zone->unit_count + 1U, 1U);
#line 76
  if ((unsigned long )nzone == (unsigned long )((js_string *)0)) {
#line 77
    js_dealloc((void *)new);
#line 78
    return ((csv2_add_state *)0);
  }
#line 80
  norigin = js_create(zone->unit_count + 1U, 1U);
#line 80
  if ((unsigned long )norigin == (unsigned long )((js_string *)0)) {
#line 81
    js_dealloc((void *)new);
#line 82
    return ((csv2_add_state *)0);
  }
#line 84
  tmp___0 = js_copy(zone, nzone);
#line 84
  if (tmp___0 == -1) {
#line 85
    js_destroy(nzone);
#line 86
    js_dealloc((void *)new);
#line 87
    return ((csv2_add_state *)0);
  }
#line 89
  tmp___1 = js_copy(zone, norigin);
#line 89
  if (tmp___1 == -1) {
#line 90
    js_destroy(nzone);
#line 91
    js_dealloc((void *)new);
#line 92
    return ((csv2_add_state *)0);
  }
#line 94
  new->buffer = (csv2_rr *)0;
#line 95
  new->zone = nzone;
#line 96
  new->origin = norigin;
#line 97
  new->ostack = (csv2_origin *)0;
#line 99
  new->ostack_height = 0;
#line 100
  new->rrnum = 0;
#line 101
  new->bighash = (mhash *)0;
#line 102
  new->add_method = 0;
#line 103
  new->soa_serial = 1;
#line 104
  new->default_ttl = 86400;
#line 105
  new->in_ns = 1;
#line 106
  new->zone_nses_added = 0;
#line 107
  return (new);
}
}
#line 110 "Csv2_database.c"
void csv2_zap_add_state(csv2_add_state *x ) 
{ int a ;
  csv2_origin *v ;
  csv2_origin *q ;
  csv2_rr *y ;
  csv2_rr *z ;

  {
#line 111
  a = 0;
#line 116
  v = x->ostack;
#line 117
  while (1) {
#line 117
    if ((unsigned long )v != (unsigned long )((csv2_origin *)0)) {
#line 117
      if (! (a < 10000)) {
#line 117
        break;
      }
    } else {
#line 117
      break;
    }
#line 118
    js_destroy(v->origin);
#line 119
    q = v->next;
#line 120
    js_dealloc((void *)v);
#line 121
    v = q;
#line 122
    a ++;
  }
#line 124
  a = 0;
#line 127
  y = x->buffer;
#line 128
  while (1) {
#line 128
    if ((unsigned long )y != (unsigned long )((csv2_rr *)0)) {
#line 128
      if (! (a < 10000)) {
#line 128
        break;
      }
    } else {
#line 128
      break;
    }
#line 129
    js_destroy(y->query);
#line 130
    js_destroy(y->data);
#line 131
    z = y->next;
#line 132
    js_dealloc((void *)y);
#line 133
    y = z;
#line 134
    a ++;
  }
#line 136
  a = 0;
#line 139
  if ((unsigned long )x->zone != (unsigned long )((js_string *)0)) {
#line 140
    js_destroy(x->zone);
#line 141
    x->zone = (js_string *)0;
  }
#line 144
  if ((unsigned long )x->origin != (unsigned long )((js_string *)0)) {
#line 145
    js_destroy(x->origin);
#line 146
    x->origin = (js_string *)0;
  }
#line 150
  js_dealloc((void *)x);
#line 151
  return;
}
}
#line 160 "Csv2_database.c"
int csv2_set_bighash(csv2_add_state *state , mhash *bighash___0 ) 
{ 

  {
#line 161
  if ((unsigned long )state == (unsigned long )((csv2_add_state *)0)) {
#line 162
    return (-1);
  }
#line 164
  state->bighash = bighash___0;
#line 165
  return (1);
}
}
#line 171 "Csv2_database.c"
int csv2_set_add_method(csv2_add_state *state , int method ) 
{ 

  {
#line 172
  if ((unsigned long )state == (unsigned long )((csv2_add_state *)0)) {
#line 173
    return (-1);
  }
#line 175
  state->add_method = method;
#line 176
  return (1);
}
}
#line 181 "Csv2_database.c"
int csv2_close_state(csv2_add_state *state ) 
{ 

  {
#line 182
  csv2_zap_add_state(state);
#line 183
  return (1);
}
}
#line 189 "Csv2_database.c"
int csv2_set_soa_serial(csv2_add_state *state , js_string *filename ) 
{ char name[256] ;
  struct stat buf ;
  time_t t ;
  int64_t q ;
  int tmp ;
  int tmp___0 ;
  struct tm bd ;
  struct tm *tmp___1 ;
  int tmp___2 ;

  {
#line 194
  tmp = js_js2str(filename, name, 200);
#line 194
  if (tmp == -1) {
#line 195
    return (-1);
  }
#line 197
  tmp___0 = stat((char const   *)(name), & buf);
#line 197
  if (tmp___0 == -1) {
#line 198
    return (-1);
  }
#line 200
  t = buf.st_mtimespec.tv_sec;
#line 202
  if (t < 290805600L) {
#line 203
    t += 2147483648L;
  }
#line 205
  tmp___2 = show_synth_soa_serial();
#line 205
  if (tmp___2 != 2) {
#line 206
    q = (int64_t )t;
#line 207
    q -= 290805600LL;
#line 208
    q /= 6LL;
  } else {
#line 214
    tmp___1 = gmtime_r((time_t const   *)(& t), & bd);
#line 214
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 215
      return (1979032815);
    }
#line 220
    q = (int64_t )(bd.tm_year + 1900);
#line 221
    q *= 100LL;
#line 222
    q += (int64_t )(bd.tm_mon + 1);
#line 223
    q *= 100LL;
#line 224
    q += (int64_t )bd.tm_mday;
#line 225
    q *= 100LL;
#line 226
    q += (int64_t )bd.tm_hour;
  }
#line 228
  state->soa_serial = (int32_t )q;
#line 229
  return (1);
}
}
#line 235 "Csv2_database.c"
js_string *csv2_zone_to_udpzone(js_string *zone ) 
{ js_string *udpzone ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 240
  udpzone = js_create(128U, 1U);
#line 240
  if ((unsigned long )udpzone == (unsigned long )((js_string *)0)) {
#line 241
    return ((js_string *)0);
  }
#line 243
  tmp = js_qstr2js(udpzone, (char *)"A");
#line 243
  if (tmp == -1) {
#line 244
    js_destroy(udpzone);
#line 245
    return ((js_string *)0);
  }
#line 247
  tmp___0 = js_append(zone, udpzone);
#line 247
  if (tmp___0 == -1) {
#line 248
    js_destroy(udpzone);
#line 249
    return ((js_string *)0);
  }
#line 251
  tmp___1 = hname_2rfc1035_starwhitis(udpzone, 1);
#line 251
  if (tmp___1 == -1) {
#line 252
    js_destroy(udpzone);
#line 256
    return ((js_string *)0);
  }
#line 258
  return (udpzone);
}
}
#line 268 "Csv2_database.c"
int csv2_add_rr_debug(csv2_add_state *state , js_string *query , int rtype , int32_t ttl ,
                      js_string *data ) 
{ 

  {
#line 270
  if ((unsigned long )state == (unsigned long )((csv2_add_state *)0)) {
#line 271
    return (-1);
  }
#line 273
  printf("Name: ");
#line 274
  show_esc_stdout(query);
#line 275
  printf("\nrtype: %d\nttl %d\n", rtype, ttl);
#line 276
  printf("rddata: ");
#line 276
  show_esc_stdout(data);
#line 276
  printf("\n\n");
#line 277
  return (1);
}
}
#line 286 "Csv2_database.c"
int csv2_add_rr_bighash(csv2_add_state *state , js_string *query , int rtype , int32_t ttl ,
                        js_string *data , int32_t starwhitis ) 
{ js_string *cquery ;
  js_string *udpzone ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 292
  if ((unsigned long )state->bighash == (unsigned long )((mhash *)0)) {
#line 293
    return (-1);
  }
#line 295
  if ((unsigned long )state->zone == (unsigned long )((js_string *)0)) {
#line 296
    return (-1);
  }
#line 298
  if ((unsigned long )state->origin == (unsigned long )((js_string *)0)) {
#line 299
    return (-1);
  }
#line 301
  tmp = js_has_sanity(query);
#line 301
  if (tmp == -1) {
#line 302
    return (-1);
  }
#line 304
  if (query->unit_size != 1U) {
#line 305
    return (-1);
  }
#line 307
  tmp___0 = js_has_sanity(data);
#line 307
  if (tmp___0 == -1) {
#line 308
    return (-1);
  }
#line 310
  if (data->unit_size != 1U) {
#line 311
    return (-1);
  }
#line 314
  if (ttl < 60) {
#line 315
    ttl = 60;
  }
#line 317
  if (ttl > 63072000) {
#line 318
    ttl = 63072000;
  }
#line 323
  cquery = js_create(query->unit_count + 3U, 1U);
#line 323
  if ((unsigned long )cquery == (unsigned long )((js_string *)0)) {
#line 324
    return (-1);
  }
#line 326
  tmp___1 = js_copy(query, cquery);
#line 326
  if (tmp___1 == -1) {
#line 327
    js_destroy(cquery);
#line 328
    return (-1);
  }
#line 330
  tmp___2 = js_adduint16(cquery, rtype);
#line 330
  if (tmp___2 == -1) {
#line 331
    js_destroy(cquery);
#line 332
    return (-1);
  }
#line 335
  udpzone = csv2_zone_to_udpzone(state->zone);
#line 335
  if ((unsigned long )udpzone == (unsigned long )((js_string *)0)) {
#line 336
    js_destroy(cquery);
#line 337
    return (-1);
  }
#line 341
  tmp___3 = js_adduint16(udpzone, 2);
#line 341
  if (tmp___3 == -1) {
#line 342
    js_destroy(cquery);
#line 343
    js_destroy(udpzone);
#line 344
    return (-1);
  }
#line 348
  add_rr_to_bighash(state->bighash, cquery, data, (uint32_t )ttl, udpzone, (uint16_t )0);
#line 349
  js_destroy(udpzone);
#line 350
  js_destroy(cquery);
#line 351
  return (1);
}
}
#line 360 "Csv2_database.c"
int csv2_add_rr_zoneserver(csv2_add_state *state , js_string *query , int rtype ,
                           int32_t ttl , js_string *data ) 
{ int ret ;
  js_string *cquery ;
  int tmp ;
  int tmp___0 ;

  {
#line 368
  if (rtype == 6) {
#line 369
    return (1);
  }
#line 375
  if (query->unit_count >= 1U) {
#line 375
    if ((int )*(query->string) == 95) {
#line 376
      cquery = js_create(query->unit_count + 2U, 1U);
#line 376
      if ((unsigned long )cquery == (unsigned long )((js_string *)0)) {
#line 377
        return (-1);
      }
#line 381
      tmp = js_qstr2js(cquery, (char *)"\001");
#line 381
      if (tmp == -1) {
#line 382
        js_destroy(cquery);
#line 383
        return (-1);
      }
#line 387
      tmp___0 = js_append(query, cquery);
#line 387
      if (tmp___0 == -1) {
#line 388
        js_destroy(cquery);
#line 389
        return (-1);
      }
#line 393
      if (cquery->unit_count < 2U) {
#line 394
        js_destroy(cquery);
#line 395
        return (-1);
      }
#line 397
      *(cquery->string + 1) = (unsigned char )'*';
#line 399
      ret = csv2_push_buffer(state, cquery, rtype, ttl, data);
#line 400
      js_destroy(cquery);
    } else {
#line 402
      ret = csv2_push_buffer(state, query, rtype, ttl, data);
    }
  } else {
#line 402
    ret = csv2_push_buffer(state, query, rtype, ttl, data);
  }
#line 404
  return (ret);
}
}
#line 411 "Csv2_database.c"
js_string *csv2_synth_query(csv2_add_state *state ) 
{ js_string *query ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 416
  query = js_create(256U, 1U);
#line 416
  if ((unsigned long )query == (unsigned long )((js_string *)0)) {
#line 417
    return ((js_string *)0);
  }
#line 419
  tmp = js_qstr2js(query, (char *)"Z");
#line 419
  if (tmp == -1) {
#line 420
    js_destroy(query);
#line 421
    return ((js_string *)0);
  }
#line 423
  tmp___0 = js_append(state->zone, query);
#line 423
  if (tmp___0 == -1) {
#line 424
    js_destroy(query);
#line 425
    return ((js_string *)0);
  }
#line 427
  tmp___1 = hname_2rfc1035(query);
#line 427
  if (tmp___1 == -1) {
#line 428
    js_destroy(query);
#line 429
    return ((js_string *)0);
  }
#line 431
  return (query);
}
}
#line 435 "Csv2_database.c"
int csv2_synthesize_soa(csv2_add_state *state ) 
{ js_string *query ;
  js_string *email ;
  js_string *data ;
  int ret ;
  int tmp ;
  js_string *tmp___0 ;
  int tmp___1 ;
  js_string *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 440
  query = csv2_synth_query(state);
#line 440
  if ((unsigned long )query == (unsigned long )((js_string *)0)) {
#line 441
    return (-1);
  }
#line 447
  data = js_create(256U, 1U);
#line 447
  if ((unsigned long )data == (unsigned long )((js_string *)0)) {
#line 448
    js_destroy(query);
#line 449
    return (-1);
  }
#line 451
  tmp___2 = show_synth_soa_origin();
#line 451
  if ((unsigned long )tmp___2 == (unsigned long )((js_string *)0)) {
#line 453
    tmp = js_copy(query, data);
#line 453
    if (tmp == -1) {
#line 454
      js_destroy(query);
#line 455
      js_destroy(data);
#line 456
      return (-1);
    }
  } else {
#line 459
    tmp___0 = show_synth_soa_origin();
#line 459
    tmp___1 = js_copy(tmp___0, data);
#line 459
    if (tmp___1 == -1) {
#line 460
      js_destroy(query);
#line 461
      js_destroy(data);
#line 462
      return (-1);
    }
  }
#line 468
  email = js_create(256U, 1U);
#line 468
  if ((unsigned long )email == (unsigned long )((js_string *)0)) {
#line 469
    js_destroy(query);
#line 470
    js_destroy(data);
#line 471
    return (-1);
  }
#line 473
  tmp___3 = js_qappend((char *)"Zhostmaster.", email);
#line 473
  if (tmp___3 == -1) {
#line 474
    js_destroy(query);
#line 475
    js_destroy(data);
#line 476
    js_destroy(email);
#line 477
    return (-1);
  }
#line 479
  tmp___4 = js_append(state->zone, email);
#line 479
  if (tmp___4 == -1) {
#line 480
    js_destroy(query);
#line 481
    js_destroy(data);
#line 482
    js_destroy(email);
#line 483
    return (-1);
  }
#line 485
  tmp___5 = hname_2rfc1035(email);
#line 485
  if (tmp___5 == -1) {
#line 486
    js_destroy(query);
#line 487
    js_destroy(data);
#line 488
    js_destroy(email);
#line 489
    return (-1);
  }
#line 491
  tmp___6 = js_append(email, data);
#line 491
  if (tmp___6 == -1) {
#line 492
    js_destroy(query);
#line 493
    js_destroy(data);
#line 494
    js_destroy(email);
#line 495
    return (-1);
  }
#line 497
  js_destroy(email);
#line 500
  tmp___7 = js_adduint32(data, (uint32_t )state->soa_serial);
#line 500
  if (tmp___7 == -1) {
#line 501
    js_destroy(query);
#line 502
    js_destroy(data);
#line 503
    return (-1);
  }
#line 507
  tmp___8 = js_adduint32(data, (uint32_t )7200);
#line 507
  if (tmp___8 == -1) {
#line 508
    js_destroy(query);
#line 509
    js_destroy(data);
#line 510
    return (-1);
  }
#line 514
  tmp___9 = js_adduint32(data, (uint32_t )3600);
#line 514
  if (tmp___9 == -1) {
#line 515
    js_destroy(query);
#line 516
    js_destroy(data);
#line 517
    return (-1);
  }
#line 521
  tmp___10 = js_adduint32(data, (uint32_t )604800);
#line 521
  if (tmp___10 == -1) {
#line 522
    js_destroy(query);
#line 523
    js_destroy(data);
#line 524
    return (-1);
  }
#line 528
  tmp___11 = js_adduint32(data, (uint32_t )3600);
#line 528
  if (tmp___11 == -1) {
#line 529
    js_destroy(query);
#line 530
    js_destroy(data);
#line 531
    return (-1);
  }
#line 534
  ret = csv2_set_soa(state, query, data, 86400);
#line 535
  js_destroy(query);
#line 536
  js_destroy(data);
#line 537
  return (ret);
}
}
#line 545 "Csv2_database.c"
js_string *csv2_synth_ip(csv2_add_state *state , uint32_t ip , int actually_make_record ) 
{ js_string *name ;
  js_string *rddata ;
  int c ;
  int32_t q ;
  int tmp ;
  int32_t x ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 554
  name = js_create(20U + (state->zone)->unit_count, 1U);
#line 554
  if ((unsigned long )name == (unsigned long )((js_string *)0)) {
#line 555
    return ((js_string *)0);
  }
#line 557
  tmp = js_qstr2js(name, (char *)"Zsynth-ip-");
#line 557
  if (tmp == 0) {
#line 558
    js_destroy(name);
#line 559
    return ((js_string *)0);
  }
#line 561
  q = (int32_t )ip;
#line 562
  c = 0;
#line 562
  while (c < 8) {
#line 564
    x = q;
#line 565
    x >>= 28;
#line 566
    x &= 15;
#line 567
    if (x < 10) {
#line 568
      tmp___0 = js_addbyte(name, (unsigned char )(48 + x));
#line 568
      if (tmp___0 == -1) {
#line 569
        js_destroy(name);
#line 570
        return ((js_string *)0);
      }
    } else {
#line 573
      tmp___1 = js_addbyte(name, (unsigned char )(97 + (x - 10)));
#line 573
      if (tmp___1 == -1) {
#line 574
        js_destroy(name);
#line 575
        return ((js_string *)0);
      }
    }
#line 578
    q <<= 4;
#line 562
    c ++;
  }
#line 580
  tmp___2 = js_qappend((char *)".", name);
#line 580
  if (tmp___2 == -1) {
#line 581
    js_destroy(name);
#line 582
    return ((js_string *)0);
  }
#line 584
  tmp___3 = js_append(state->zone, name);
#line 584
  if (tmp___3 == -1) {
#line 585
    js_destroy(name);
#line 586
    return ((js_string *)0);
  }
#line 588
  tmp___4 = hname_2rfc1035(name);
#line 588
  if (tmp___4 == -1) {
#line 589
    js_destroy(name);
#line 590
    return ((js_string *)0);
  }
#line 595
  if (actually_make_record != 1) {
#line 596
    return (name);
  }
#line 602
  rddata = js_create(5U, 1U);
#line 602
  if ((unsigned long )rddata == (unsigned long )((js_string *)0)) {
#line 603
    js_destroy(name);
#line 604
    return ((js_string *)0);
  }
#line 606
  c = 3;
#line 606
  while (c >= 0) {
#line 607
    *(rddata->string + c) = (unsigned char )(ip & 255U);
#line 608
    ip >>= 8;
#line 606
    c --;
  }
#line 610
  rddata->unit_count = 4U;
#line 611
  tmp___5 = csv2_add_rr_w(state, name, 1, 86400, rddata);
#line 611
  if (tmp___5 == -1) {
#line 612
    js_destroy(name);
#line 613
    js_destroy(rddata);
#line 614
    return ((js_string *)0);
  }
#line 616
  js_destroy(rddata);
#line 618
  return (name);
}
}
#line 623 "Csv2_database.c"
int csv2_make_synth_ns(csv2_add_state *state , uint32_t ip ) 
{ js_string *query ;
  js_string *data ;

  {
#line 631
  query = csv2_synth_query(state);
#line 631
  if ((unsigned long )query == (unsigned long )((js_string *)0)) {
#line 632
    return (-1);
  }
#line 636
  data = csv2_synth_ip(state, ip, 0);
#line 636
  if ((unsigned long )data == (unsigned long )((js_string *)0)) {
#line 637
    js_destroy(query);
#line 638
    return (-1);
  }
#line 642
  csv2_add_rr_w(state, query, 2, 86400, data);
#line 643
  js_destroy(query);
#line 644
  js_destroy(data);
#line 645
  return (1);
}
}
#line 651 "Csv2_database.c"
int csv2_is_private_ip(uint32_t ip ) 
{ int tmp ;

  {
#line 652
  if ((ip & 4278190080U) == 2130706432U) {
#line 652
    tmp = 1;
  } else
#line 652
  if ((ip & 4278190080U) == 167772160U) {
#line 652
    tmp = 1;
  } else
#line 652
  if ((ip & 4293918720U) == 2886729728U) {
#line 652
    tmp = 1;
  } else
#line 652
  if ((ip & 4294901760U) == 3232235520U) {
#line 652
    tmp = 1;
  } else {
#line 652
    tmp = 0;
  }
#line 652
  return (tmp);
}
}
#line 661 "Csv2_database.c"
int csv2_is_localhost_ip(uint32_t ip ) 
{ 

  {
#line 662
  return ((ip & 4278190080U) == 2130706432U);
}
}
#line 667 "Csv2_database.c"
int csv2_synthesize_ns(csv2_add_state *state ) 
{ ipv4pair *iplist ;
  int c ;
  int public_ips ;
  int non_localhost_ips ;
  js_string *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 671
  public_ips = 0;
#line 672
  non_localhost_ips = 0;
#line 675
  iplist = get_synthip_list();
#line 680
  c = 0;
#line 680
  while (c < 500) {
#line 681
    if ((iplist + c)->ip == 4294967295U) {
#line 682
      break;
    }
#line 684
    if ((iplist + c)->ip == 0U) {
#line 685
      printf("Warning: No NS records can be syntesized\n");
#line 686
      return (-1);
    }
#line 680
    c ++;
  }
#line 691
  c = 0;
#line 691
  while (c < 500) {
#line 692
    if ((iplist + c)->ip == 4294967295U) {
#line 693
      break;
    }
#line 695
    tmp___0 = csv2_is_private_ip((iplist + c)->ip);
#line 695
    if (! tmp___0) {
#line 696
      public_ips = 1;
#line 697
      non_localhost_ips = 1;
    }
#line 691
    c ++;
  }
#line 702
  if (public_ips != 1) {
#line 703
    c = 0;
#line 703
    while (c < 500) {
#line 704
      if ((iplist + c)->ip == 4294967295U) {
#line 705
        break;
      }
#line 707
      tmp___1 = csv2_is_localhost_ip((iplist + c)->ip);
#line 707
      if (! tmp___1) {
#line 708
        non_localhost_ips = 1;
      }
#line 703
      c ++;
    }
  }
#line 714
  if (public_ips == 1) {
#line 716
    c = 0;
#line 716
    while (c < 500) {
#line 717
      if ((iplist + c)->ip == 4294967295U) {
#line 718
        break;
      }
#line 720
      tmp___2 = csv2_is_private_ip((iplist + c)->ip);
#line 720
      if (! tmp___2) {
#line 721
        csv2_make_synth_ns(state, (iplist + c)->ip);
      }
#line 716
      c ++;
    }
#line 725
    c = 0;
#line 725
    while (c < 500) {
#line 726
      if ((iplist + c)->ip == 4294967295U) {
#line 727
        break;
      }
#line 729
      tmp___3 = csv2_is_private_ip((iplist + c)->ip);
#line 729
      if (! tmp___3) {
#line 730
        tmp = csv2_synth_ip(state, (iplist + c)->ip, 1);
#line 731
        js_destroy(tmp);
      }
#line 725
      c ++;
    }
  } else
#line 735
  if (non_localhost_ips == 1) {
#line 737
    c = 0;
#line 737
    while (c < 500) {
#line 738
      if ((iplist + c)->ip == 4294967295U) {
#line 739
        break;
      }
#line 741
      tmp___4 = csv2_is_localhost_ip((iplist + c)->ip);
#line 741
      if (! tmp___4) {
#line 742
        csv2_make_synth_ns(state, (iplist + c)->ip);
      }
#line 737
      c ++;
    }
#line 746
    c = 0;
#line 746
    while (c < 500) {
#line 747
      if ((iplist + c)->ip == 4294967295U) {
#line 748
        break;
      }
#line 750
      tmp___5 = csv2_is_localhost_ip((iplist + c)->ip);
#line 750
      if (! tmp___5) {
#line 751
        tmp = csv2_synth_ip(state, (iplist + c)->ip, 1);
#line 752
        js_destroy(tmp);
      }
#line 746
      c ++;
    }
  } else {
#line 758
    c = 0;
#line 758
    while (c < 500) {
#line 759
      if ((iplist + c)->ip == 4294967295U) {
#line 760
        break;
      }
#line 762
      csv2_make_synth_ns(state, (iplist + c)->ip);
#line 758
      c ++;
    }
#line 765
    c = 0;
#line 765
    while (c < 500) {
#line 766
      if ((iplist + c)->ip == 4294967295U) {
#line 767
        break;
      }
#line 769
      tmp = csv2_synth_ip(state, (iplist + c)->ip, 1);
#line 770
      js_destroy(tmp);
#line 765
      c ++;
    }
  }
#line 774
  return (1);
}
}
#line 779 "Csv2_database.c"
csv2_rr *copy_csv2_rr(csv2_rr *source ) 
{ csv2_rr *new ;
  js_string *q ;
  js_string *d ;
  void *tmp ;

  {
#line 783
  q = csv2_copy_js(source->query);
#line 783
  if ((unsigned long )q == (unsigned long )((js_string *)0)) {
#line 784
    return ((csv2_rr *)0);
  }
#line 786
  d = csv2_copy_js(source->data);
#line 786
  if ((unsigned long )d == (unsigned long )((js_string *)0)) {
#line 787
    js_destroy(q);
#line 788
    return ((csv2_rr *)0);
  }
#line 792
  tmp = js_alloc((int )sizeof(csv2_rr ), 1);
#line 792
  new = (csv2_rr *)tmp;
#line 792
  if ((unsigned long )new == (unsigned long )((csv2_rr *)0)) {
#line 793
    js_destroy(q);
#line 794
    js_destroy(d);
#line 795
    return ((csv2_rr *)0);
  }
#line 797
  new->query = q;
#line 798
  new->data = d;
#line 799
  new->rtype = source->rtype;
#line 800
  new->ttl = source->ttl;
#line 801
  new->next = (struct csv2_rr *)0;
#line 803
  return (new);
}
}
#line 809 "Csv2_database.c"
int csv2_push_buffer(csv2_add_state *state , js_string *query , int rtype , int32_t ttl ,
                     js_string *data ) 
{ js_string *q ;
  js_string *d ;
  csv2_rr *new ;
  csv2_rr *point ;
  int x ;
  void *tmp ;

  {
#line 816
  q = csv2_copy_js(query);
#line 816
  if ((unsigned long )q == (unsigned long )((js_string *)0)) {
#line 817
    return (-1);
  }
#line 819
  d = csv2_copy_js(data);
#line 819
  if ((unsigned long )d == (unsigned long )((js_string *)0)) {
#line 820
    js_destroy(q);
#line 821
    return (-1);
  }
#line 825
  tmp = js_alloc((int )sizeof(csv2_rr ), 1);
#line 825
  new = (csv2_rr *)tmp;
#line 825
  if ((unsigned long )new == (unsigned long )((csv2_rr *)0)) {
#line 826
    js_destroy(q);
#line 827
    js_destroy(d);
#line 828
    return (-1);
  }
#line 830
  new->query = q;
#line 831
  new->data = d;
#line 832
  new->rtype = rtype;
#line 833
  new->ttl = ttl;
#line 834
  new->next = (struct csv2_rr *)0;
#line 838
  if ((unsigned long )state->buffer == (unsigned long )((csv2_rr *)0)) {
#line 839
    state->buffer = new;
  }
#line 841
  point = state->buffer;
#line 845
  if ((unsigned long )state->buffer != (unsigned long )new) {
#line 846
    x = 0;
#line 846
    while (x < 30) {
#line 847
      if ((unsigned long )point->next == (unsigned long )((struct csv2_rr *)0)) {
#line 848
        break;
      }
#line 850
      point = point->next;
#line 846
      x ++;
    }
  }
#line 855
  if ((unsigned long )state->buffer != (unsigned long )new) {
#line 855
    if ((unsigned long )point->next != (unsigned long )((struct csv2_rr *)0)) {
#line 856
      js_destroy(q);
#line 857
      js_destroy(d);
#line 858
      js_dealloc((void *)new);
#line 859
      return (-1);
    }
  }
#line 862
  if ((unsigned long )state->buffer != (unsigned long )new) {
#line 863
    point->next = new;
  }
#line 865
  return (1);
}
}
#line 873 "Csv2_database.c"
int csv2_set_soa(csv2_add_state *state , js_string *query , js_string *data , int32_t ttl ) 
{ int tmp ;

  {
#line 876
  tmp = csv2_push_buffer(state, query, 6, ttl, data);
#line 876
  return (tmp);
}
}
#line 882 "Csv2_database.c"
int csv2_is_zonetop(csv2_add_state *state , js_string *query ) 
{ js_string *q ;
  int tmp ;

  {
#line 885
  q = csv2_zone_to_udpzone(state->zone);
#line 885
  if ((unsigned long )q == (unsigned long )((js_string *)0)) {
#line 886
    return (0);
  }
#line 888
  tmp = js_issame(q, query);
#line 888
  if (tmp == 1) {
#line 889
    js_destroy(q);
#line 890
    return (1);
  }
#line 892
  js_destroy(q);
#line 893
  return (0);
}
}
#line 898 "Csv2_database.c"
int csv2_pop_buffer(csv2_add_state *state ) 
{ csv2_rr *save ;
  int ret ;

  {
#line 901
  if ((unsigned long )state->buffer == (unsigned long )((csv2_rr *)0)) {
#line 902
    return (0);
  }
#line 905
  save = (state->buffer)->next;
#line 909
  if (state->add_method != 2) {
#line 910
    ret = csv2_add_rr_w(state, (state->buffer)->query, (state->buffer)->rtype, (state->buffer)->ttl,
                        (state->buffer)->data);
  } else {
#line 914
    ret = 1;
  }
#line 916
  if (ret != -1) {
#line 917
    js_destroy((state->buffer)->query);
#line 919
    js_destroy((state->buffer)->data);
#line 921
    js_dealloc((void *)state->buffer);
#line 922
    state->buffer = save;
  }
#line 924
  return (ret);
}
}
#line 928 "Csv2_database.c"
int csv2_add_soa(csv2_add_state *state ) 
{ int tmp ;

  {
#line 929
  if (state->in_ns != 1) {
#line 930
    return (-1);
  }
#line 932
  if ((unsigned long )state->buffer == (unsigned long )((csv2_rr *)0)) {
#line 933
    return (-1);
  } else
#line 932
  if ((state->buffer)->rtype != 6) {
#line 933
    return (-1);
  }
#line 935
  state->in_ns = 0;
#line 936
  tmp = csv2_pop_buffer(state);
#line 936
  return (tmp);
}
}
#line 941 "Csv2_database.c"
js_string *csv2_copy_js(js_string *s ) 
{ js_string *c ;
  int tmp ;

  {
#line 943
  if (s->unit_size != 1U) {
#line 944
    return ((js_string *)0);
  }
#line 946
  c = js_create(s->unit_count + 1U, 1U);
#line 946
  if ((unsigned long )c == (unsigned long )((js_string *)0)) {
#line 947
    return ((js_string *)0);
  }
#line 949
  tmp = js_copy(s, c);
#line 949
  if (tmp == -1) {
#line 950
    js_destroy(c);
#line 951
    return ((js_string *)0);
  }
#line 953
  return (c);
}
}
#line 959 "Csv2_database.c"
int csv2_add_rr(csv2_add_state *state , js_string *query , int rtype , int32_t ttl ,
                js_string *data ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 963
  (state->rrnum) ++;
#line 964
  if (state->rrnum == 1) {
#line 964
    if (rtype != 6) {
#line 964
      if (state->add_method != 3) {
#line 966
        csv2_synthesize_soa(state);
      } else {
#line 964
        goto _L___2;
      }
    } else {
#line 964
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 968
  if (state->rrnum == 1) {
#line 968
    if (rtype != 6) {
#line 968
      if (state->add_method == 3) {
#line 970
        printf("Please put an SOA record in the default zone file\n");
#line 971
        return (-1);
      } else {
#line 968
        goto _L___0;
      }
    } else {
#line 968
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 973
  if (state->rrnum == 1) {
#line 974
    tmp = csv2_set_soa(state, query, data, ttl);
#line 974
    return (tmp);
  } else
#line 976
  if (rtype == 6) {
#line 979
    printf("Warning: Only one SOA per zone file.\nThis SOA must be the first record in the zone.\nOther SOA records are ignored\n");
#line 982
    return (-1);
  }
#line 989
  if (state->zone_nses_added == 0) {
#line 989
    if (state->in_ns == 1) {
#line 989
      if (rtype == 2) {
#line 989
        tmp___0 = csv2_is_zonetop(state, query);
#line 989
        if (tmp___0) {
#line 991
          state->zone_nses_added = 1;
        }
      }
    }
  }
#line 996
  if (state->in_ns == 0) {
#line 996
    if (rtype == 2) {
#line 996
      tmp___1 = csv2_is_zonetop(state, query);
#line 996
      if (tmp___1) {
#line 998
        printf("Warning: Authoritative NSes must be immediately after SOA\nOr the first records in the zone\nOtherwise, the record is ignored\n");
#line 1002
        return (-1);
      } else {
#line 996
        goto _L___6;
      }
    } else {
#line 996
      goto _L___6;
    }
  } else
  _L___6: /* CIL Label */ 
#line 1005
  if (state->in_ns == 0) {
#line 1005
    if (rtype == 2) {
#line 1005
      if (state->add_method == 3) {
#line 1006
        printf("Warning: Delegation NS records are not permitted in\nthe default zonefile.  This record is ignored\n");
#line 1008
        return (-1);
      } else {
#line 1005
        goto _L___4;
      }
    } else {
#line 1005
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 1011
  if (rtype == 5) {
#line 1011
    if (state->add_method == 3) {
#line 1012
      printf("Warning: CNAME records are not permitted in the\ndefault zonefile.  This record is ignored\n");
#line 1014
      return (-1);
    }
  }
#line 1022
  if (state->in_ns == 1) {
#line 1022
    if (rtype != 2) {
#line 1022
      goto _L___7;
    } else {
#line 1022
      tmp___2 = csv2_is_zonetop(state, query);
#line 1022
      if (! tmp___2) {
        _L___7: /* CIL Label */ 
#line 1027
        if (state->zone_nses_added == 0) {
#line 1027
          if (state->add_method != 3) {
#line 1029
            csv2_synthesize_ns(state);
          }
        }
#line 1031
        if (state->zone_nses_added == 0) {
#line 1031
          if (state->add_method == 3) {
#line 1033
            printf("Please include NS records in a default zone file\n");
#line 1035
            return (-1);
          }
        }
#line 1037
        if (state->add_method != 2) {
#line 1038
          csv2_add_soa(state);
        }
#line 1040
        state->in_ns = 0;
      }
    }
  }
#line 1043
  tmp___3 = csv2_add_rr_w(state, query, rtype, ttl, data);
#line 1043
  return (tmp___3);
}
}
#line 1052 "Csv2_database.c"
js_string *csv2_make_ptr_query(js_string *binary_ip ) 
{ js_string *ptr_label ;
  int len ;
  int counter ;
  int tmp ;
  char a ;
  int b ;
  int c ;
  int d ;

  {
#line 1054
  len = 0;
#line 1055
  counter = 0;
#line 1058
  tmp = js_length(binary_ip);
#line 1058
  if (tmp != 4) {
#line 1059
    return ((js_string *)0);
  }
#line 1061
  ptr_label = js_create(31U, 1U);
#line 1062
  if ((unsigned long )ptr_label == (unsigned long )((js_string *)0)) {
#line 1063
    return ((js_string *)0);
  }
#line 1068
  counter = 3;
#line 1068
  while (counter >= 0) {
#line 1071
    c = 1;
#line 1073
    a = (char )*(binary_ip->string + counter);
#line 1077
    b = (int )a;
#line 1078
    b &= 255;
#line 1080
    if (b < 0) {
#line 1081
      b += 128;
    }
#line 1083
    if (b > 99) {
#line 1084
      c ++;
    }
#line 1086
    if (b > 9) {
#line 1087
      c ++;
    }
#line 1089
    if (len <= 30) {
#line 1090
      *(ptr_label->string + len) = (unsigned char )c;
    }
#line 1091
    d = c;
#line 1092
    while (c > 0) {
#line 1093
      if (len + c <= 30) {
#line 1094
        *((ptr_label->string + len) + c) = (unsigned char )(48 + b % 10);
      }
#line 1095
      b /= 10;
#line 1096
      c --;
    }
#line 1098
    len ++;
#line 1099
    len += d;
#line 1068
    counter --;
  }
#line 1103
  if ((unsigned int )len < ptr_label->max_count) {
#line 1104
    ptr_label->unit_count = (unsigned int )len;
  }
#line 1107
  js_qappend((char *)".in-addr.arpa.", ptr_label);
#line 1108
  if (len <= 30) {
#line 1109
    *(ptr_label->string + len) = (unsigned char)7;
  }
#line 1111
  len += 8;
#line 1112
  if (len <= 30) {
#line 1113
    *(ptr_label->string + len) = (unsigned char)4;
  }
#line 1115
  len += 5;
#line 1116
  if (len <= 30) {
#line 1117
    *(ptr_label->string + len) = (unsigned char)0;
  }
#line 1120
  return (ptr_label);
}
}
#line 1129 "Csv2_database.c"
js_string *csv2_make_ptr6_query(js_string *binary_ip ) 
{ js_string *ptr_label ;
  int len ;
  int counter ;
  int tmp ;
  char a ;
  int b ;

  {
#line 1131
  len = 0;
#line 1132
  counter = 0;
#line 1135
  tmp = js_length(binary_ip);
#line 1135
  if (tmp != 16) {
#line 1136
    return ((js_string *)0);
  }
#line 1138
  ptr_label = js_create(256U, 1U);
#line 1139
  if ((unsigned long )ptr_label == (unsigned long )((js_string *)0)) {
#line 1140
    return ((js_string *)0);
  }
#line 1143
  counter = 15;
#line 1143
  while (counter >= 0) {
#line 1147
    a = (char )*(binary_ip->string + counter);
#line 1150
    *(ptr_label->string + len) = (unsigned char)1;
#line 1151
    len ++;
#line 1152
    b = (int )a & 15;
#line 1153
    if (b > 9) {
#line 1153
      b += 87;
    } else {
#line 1154
      b += 48;
    }
#line 1155
    *(ptr_label->string + len) = (unsigned char )b;
#line 1156
    len ++;
#line 1159
    *(ptr_label->string + len) = (unsigned char)1;
#line 1160
    len ++;
#line 1161
    b = ((int )a >> 4) & 15;
#line 1162
    if (b > 9) {
#line 1162
      b += 87;
    } else {
#line 1163
      b += 48;
    }
#line 1164
    *(ptr_label->string + len) = (unsigned char )b;
#line 1165
    len ++;
#line 1143
    counter --;
  }
#line 1168
  if (len <= 250) {
#line 1169
    *(ptr_label->string + len) = (unsigned char)3;
#line 1170
    *((ptr_label->string + len) + 1) = (unsigned char )'i';
#line 1171
    *((ptr_label->string + len) + 2) = (unsigned char )'p';
#line 1172
    *((ptr_label->string + len) + 3) = (unsigned char )'6';
#line 1173
    len += 4;
  }
#line 1176
  if (len <= 250) {
#line 1177
    *(ptr_label->string + len) = (unsigned char)4;
#line 1178
    *((ptr_label->string + len) + 1) = (unsigned char )'a';
#line 1179
    *((ptr_label->string + len) + 2) = (unsigned char )'r';
#line 1180
    *((ptr_label->string + len) + 3) = (unsigned char )'p';
#line 1181
    *((ptr_label->string + len) + 4) = (unsigned char )'a';
#line 1182
    len += 5;
  }
#line 1184
  if (len <= 255) {
#line 1185
    *(ptr_label->string + len) = (unsigned char)0;
#line 1186
    len ++;
  }
#line 1188
  ptr_label->unit_size = 1U;
#line 1189
  ptr_label->unit_count = (unsigned int )len;
#line 1190
  return (ptr_label);
}
}
#line 1196 "Csv2_database.c"
int csv2_add_rr_w(csv2_add_state *state , js_string *query , int rtype , int32_t ttl ,
                  js_string *data ) 
{ js_string *cquery ;
  int ret ;
  int counter ;
  int tmp ;
  js_string *pq ;
  js_string *pq___0 ;

  {
#line 1199
  ret = -1;
#line 1199
  counter = -1;
#line 1200
  if ((unsigned long )state == (unsigned long )((csv2_add_state *)0)) {
#line 1201
    return (-1);
  }
#line 1205
  cquery = js_create(query->unit_count + 1U, 1U);
#line 1205
  if ((unsigned long )cquery == (unsigned long )((js_string *)0)) {
#line 1206
    return (-1);
  }
#line 1208
  tmp = js_copy(query, cquery);
#line 1208
  if (tmp == -1) {
#line 1209
    js_destroy(cquery);
#line 1210
    return (-1);
  }
#line 1214
  counter = 0;
#line 1215
  if (cquery->unit_count < 0U) {
#line 1216
    js_destroy(cquery);
#line 1217
    return (-1);
  }
#line 1221
  while ((unsigned int )counter < cquery->unit_count) {
#line 1222
    if ((int )*(cquery->string + counter) >= 65) {
#line 1222
      if ((int )*(cquery->string + counter) <= 90) {
#line 1224
        *(cquery->string + counter) = (unsigned char )((int )*(cquery->string + counter) + 32);
      }
    }
#line 1226
    counter ++;
  }
#line 1232
  if (rtype == 65765) {
#line 1232
    if (state->add_method != 3) {
#line 1234
      rtype = 1;
#line 1235
      pq = csv2_make_ptr_query(data);
#line 1238
      csv2_add_rr_w(state, pq, 12, ttl, cquery);
#line 1239
      js_destroy(pq);
    } else {
#line 1232
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1240
  if (rtype == 65765) {
#line 1240
    if (state->add_method == 3) {
#line 1241
      printf("Warning: FQDN4 records are not permitted in the\ndefault zonefile.  This record is ignored.\n");
#line 1243
      js_destroy(cquery);
#line 1244
      return (-1);
    }
  }
#line 1247
  if (rtype == 65766) {
#line 1247
    if (state->add_method != 3) {
#line 1249
      rtype = 28;
#line 1250
      pq___0 = csv2_make_ptr6_query(data);
#line 1253
      csv2_add_rr_w(state, pq___0, 12, ttl, cquery);
#line 1254
      js_destroy(pq___0);
    } else {
#line 1247
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1255
  if (rtype == 65766) {
#line 1255
    if (state->add_method == 3) {
#line 1256
      printf("Warning: FQDN6 records are not permitted in the\ndefault zonefile.  This record is ignored.\n");
#line 1258
      js_destroy(cquery);
#line 1259
      return (-1);
    }
  }
#line 1262
  ret = -1;
#line 1263
  switch (state->add_method) {
  case 1: 
#line 1265
  ret = csv2_add_rr_bighash(state, cquery, rtype, ttl, data, 0);
#line 1267
  break;
  case 2: 
#line 1269
  ret = csv2_add_rr_zoneserver(state, cquery, rtype, ttl, data);
#line 1271
  break;
  case 3: 
#line 1276
  ret = csv2_add_rr_bighash(state, cquery, rtype, ttl, data, 1);
#line 1278
  break;
  default: 
#line 1280
  ret = csv2_add_rr_debug(state, cquery, rtype, ttl, data);
  }
#line 1283
  js_destroy(cquery);
#line 1284
  return (ret);
}
}
#line 1 "Csv2_rr_txt.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-4eNzx0Gr.i","")
#line 70 "Csv2_rr_txt.c"
int csv2_is_txtchar(int32_t in ) 
{ int tmp ;

  {
#line 71
  if (in >= 48) {
#line 71
    if (in <= 57) {
#line 71
      tmp = 1;
    } else {
#line 71
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 71
  if (in >= 97) {
#line 71
    if (in <= 122) {
#line 71
      tmp = 1;
    } else {
#line 71
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 71
  if (in >= 65) {
#line 71
    if (in <= 90) {
#line 71
      tmp = 1;
    } else {
#line 71
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 71
  if (in == 45) {
#line 71
    tmp = 1;
  } else
#line 71
  if (in == 95) {
#line 71
    tmp = 1;
  } else
#line 71
  if (in == 43) {
#line 71
    tmp = 1;
  } else
#line 71
  if (in == 37) {
#line 71
    tmp = 1;
  } else
#line 71
  if (in == 33) {
#line 71
    tmp = 1;
  } else
#line 71
  if (in == 94) {
#line 71
    tmp = 1;
  } else
#line 71
  if (in == 61) {
#line 71
    tmp = 1;
  } else
#line 71
  if (in == 59) {
#line 71
    tmp = 1;
  } else
#line 71
  if (in == 92) {
#line 71
    tmp = 1;
  } else
#line 71
  if (in == 39) {
#line 71
    tmp = 1;
  } else {
#line 71
    tmp = 0;
  }
#line 71
  return (tmp);
}
}
#line 87 "Csv2_rr_txt.c"
int csv2_is_txt_bchar(int32_t in ) 
{ int tmp ;

  {
#line 88
  if (in >= 48) {
#line 88
    if (in <= 57) {
#line 88
      tmp = 1;
    } else {
#line 88
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 88
  if (in >= 97) {
#line 88
    if (in <= 122) {
#line 88
      tmp = 1;
    } else {
#line 88
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 88
  if (in >= 65) {
#line 88
    if (in <= 90) {
#line 88
      tmp = 1;
    } else {
#line 88
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 88
  if (in == 45) {
#line 88
    tmp = 1;
  } else
#line 88
  if (in == 95) {
#line 88
    tmp = 1;
  } else
#line 88
  if (in == 43) {
#line 88
    tmp = 1;
  } else
#line 88
  if (in == 37) {
#line 88
    tmp = 1;
  } else
#line 88
  if (in == 33) {
#line 88
    tmp = 1;
  } else
#line 88
  if (in == 94) {
#line 88
    tmp = 1;
  } else
#line 88
  if (in == 61) {
#line 88
    tmp = 1;
  } else {
#line 88
    tmp = 0;
  }
#line 88
  return (tmp);
}
}
#line 101 "Csv2_rr_txt.c"
int csv2_isnt_quote(int32_t in ) 
{ 

  {
#line 102
  return (in != 39);
}
}
#line 106 "Csv2_rr_txt.c"
int csv2_is_quote(int32_t in ) 
{ 

  {
#line 107
  return (in == 39);
}
}
#line 111 "Csv2_rr_txt.c"
int csv2_is_pipe(int32_t in ) 
{ 

  {
#line 112
  return (in == 124);
}
}
#line 116 "Csv2_rr_txt.c"
int csv2_is_0123(int32_t in ) 
{ int tmp ;

  {
#line 117
  if (in >= 48) {
#line 117
    if (in <= 51) {
#line 117
      tmp = 1;
    } else {
#line 117
      tmp = 0;
    }
  } else {
#line 117
    tmp = 0;
  }
#line 117
  return (tmp);
}
}
#line 121 "Csv2_rr_txt.c"
int csv2_is_x(int32_t in ) 
{ 

  {
#line 122
  return (in == 120);
}
}
#line 126 "Csv2_rr_txt.c"
int csv2_is_hash(int32_t in ) 
{ 

  {
#line 127
  return (in == 35);
}
}
#line 131 "Csv2_rr_txt.c"
int csv2_is_octal(int32_t in ) 
{ int tmp ;

  {
#line 132
  if (in >= 48) {
#line 132
    if (in <= 55) {
#line 132
      tmp = 1;
    } else {
#line 132
      tmp = 0;
    }
  } else {
#line 132
    tmp = 0;
  }
#line 132
  return (tmp);
}
}
#line 136 "Csv2_rr_txt.c"
int csv2_is_bslash(int32_t in ) 
{ 

  {
#line 137
  return (in == 92);
}
}
#line 141 "Csv2_rr_txt.c"
int csv2_is_semicolon(int32_t in ) 
{ 

  {
#line 142
  return (in == 59);
}
}
#line 148 "Csv2_rr_txt.c"
js_string *csv2_get_txt(csv2_read *stream , int numchunks ) 
{ js_string *tmp ;

  {
#line 149
  tmp = csv2_get_string(stream, numchunks, 0);
#line 149
  return (tmp);
}
}
#line 155 "Csv2_rr_txt.c"
js_string *csv2_get_raw(csv2_read *stream ) 
{ js_string *tmp ;

  {
#line 156
  tmp = csv2_get_string(stream, -1, 0);
#line 156
  return (tmp);
}
}
#line 166 "Csv2_rr_txt.c"
int csv2_txt_append(js_string *out , int32_t chr , int *len ) 
{ int tmp ;

  {
#line 167
  tmp = csv2_append_utf8(out, chr);
#line 167
  if (tmp == -1) {
#line 168
    js_destroy(out);
#line 169
    return (0);
  }
#line 171
  if (chr < 128) {
#line 173
    (*len) ++;
  } else
#line 174
  if (chr < 2048) {
#line 175
    *len += 2;
  } else
#line 176
  if (chr < 65536) {
#line 177
    *len += 3;
  } else
#line 178
  if (chr < 2097152) {
#line 179
    *len += 4;
  } else {
#line 180
    printf("Whoo!  Unicode is huge!\n");
#line 180
    exit(1);
  }
#line 181
  return (1);
}
}
#line 187 "Csv2_rr_txt.c"
js_string *csv2_finalize_txt(csv2_read *stream , int numchunks , int chunkcount ,
                             int txt_len_place , int txt_len , js_string *out ) 
{ 

  {
#line 192
  if (numchunks != -1) {
#line 193
    if (txt_len_place < 0) {
#line 194
      js_destroy(out);
#line 195
      return ((js_string *)0);
    } else
#line 193
    if ((unsigned int )txt_len_place > out->max_count) {
#line 194
      js_destroy(out);
#line 195
      return ((js_string *)0);
    }
#line 197
    if (txt_len > 255) {
#line 198
      csv2_error(stream, (char *)"Single TXT chunk too long");
#line 199
      js_destroy(out);
#line 200
      return ((js_string *)0);
    }
#line 202
    *(out->string + txt_len_place) = (unsigned char )txt_len;
#line 203
    chunkcount ++;
  }
#line 206
  if (numchunks > 0) {
#line 206
    if (chunkcount != numchunks) {
#line 207
      csv2_error(stream, (char *)"Incorrect number of chunks for this RR");
#line 208
      js_destroy(out);
#line 209
      return ((js_string *)0);
    }
  }
#line 212
  return (out);
}
}
#line 221 "Csv2_rr_txt.c"
js_string *csv2_get_string(csv2_read *stream , int numchunks , int post_txt ) 
{ int state ;
  int out_num ;
  int txt_len_place ;
  int txt_len ;
  int chunkcount ;
  int x ;
  int32_t look ;
  js_string *out ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  js_string *tmp___10 ;
  int tmp___11 ;
  js_string *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  js_string *tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;

  {
#line 223
  out_num = 0;
#line 224
  txt_len_place = -1;
#line 226
  chunkcount = 0;
#line 231
  if ((int )stream->tilde_handling == 103) {
#line 232
    csv2_allow_tilde(stream);
  }
#line 235
  tmp = csv2_get_1st(stream, & csv2_is_txtchar, 0);
#line 235
  if (tmp != 1) {
#line 236
    return ((js_string *)0);
  }
#line 239
  look = csv2_justread(stream);
#line 240
  if (look >= 192) {
#line 240
    if (look < 254) {
#line 241
      look = csv2_get_utf8(stream);
    } else {
#line 240
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 243
  if (look >= 128) {
#line 244
    look = csv2_get_unicode(stream);
  }
#line 247
  if (look == -164) {
#line 248
    return ((js_string *)0);
  }
#line 252
  out = js_create(1513U, 1U);
#line 252
  if ((unsigned long )out == (unsigned long )((js_string *)0)) {
#line 253
    return ((js_string *)0);
  }
#line 256
  tmp___0 = js_set_encode(out, 2);
#line 256
  if (tmp___0 == -1) {
#line 257
    js_destroy(out);
#line 258
    return ((js_string *)0);
  }
#line 263
  if (numchunks != -1) {
#line 264
    txt_len_place = (int )out->unit_count;
#line 265
    txt_len = 0;
#line 266
    chunkcount = 0;
#line 267
    tmp___1 = csv2_append_utf8(out, 0);
#line 267
    if (tmp___1 == -1) {
#line 268
      js_destroy(out);
#line 269
      return ((js_string *)0);
    }
  }
#line 275
  tmp___8 = csv2_is_txt_bchar(look);
#line 275
  if (tmp___8) {
#line 277
    tmp___2 = csv2_txt_append(out, look, & txt_len);
#line 277
    if (tmp___2 != 1) {
#line 278
      csv2_error(stream, (char *)"Error appending character");
#line 279
      return ((js_string *)0);
    }
#line 281
    state = 1;
  } else {
#line 285
    tmp___7 = csv2_is_bslash(look);
#line 285
    if (tmp___7) {
#line 286
      state = 3;
    } else {
#line 290
      tmp___6 = csv2_is_quote(look);
#line 290
      if (tmp___6) {
#line 291
        state = 2;
      } else {
#line 295
        tmp___5 = csv2_is_semicolon(look);
#line 295
        if (tmp___5) {
#line 295
          if (numchunks != -1) {
#line 296
            if (txt_len_place < 0) {
#line 297
              js_destroy(out);
#line 298
              return ((js_string *)0);
            } else
#line 296
            if ((unsigned int )txt_len_place > out->max_count) {
#line 297
              js_destroy(out);
#line 298
              return ((js_string *)0);
            }
#line 300
            if (txt_len > 255) {
#line 301
              csv2_error(stream, (char *)"Single TXT chunk too long");
#line 302
              js_destroy(out);
#line 303
              return ((js_string *)0);
            }
#line 305
            *(out->string + txt_len_place) = (unsigned char )txt_len;
#line 306
            txt_len_place = (int )out->unit_count;
#line 307
            txt_len = 0;
#line 308
            chunkcount ++;
#line 309
            tmp___3 = csv2_append_utf8(out, 0);
#line 309
            if (tmp___3 == -1) {
#line 310
              js_destroy(out);
#line 311
              return ((js_string *)0);
            }
#line 313
            state = 1;
          } else {
#line 295
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
#line 314
          tmp___4 = csv2_is_semicolon(look);
#line 314
          if (tmp___4) {
#line 315
            csv2_error(stream, (char *)"No non-quoted ; in non-TXT records");
#line 316
            js_destroy(out);
#line 317
            return ((js_string *)0);
          } else {
#line 320
            csv2_error(stream, (char *)"Unexpected char at beginning of rdata");
#line 321
            js_destroy(out);
#line 322
            return ((js_string *)0);
          }
        }
      }
    }
  }
#line 325
  x = 0;
#line 325
  while (x < 10000) {
#line 326
    look = csv2_read_unicode(stream);
#line 329
    if (look == -2) {
#line 329
      if (state != 1) {
#line 329
        if (state != 10) {
#line 331
          csv2_error(stream, (char *)"Unterminated RR");
#line 332
          js_destroy(out);
#line 333
          return ((js_string *)0);
        }
      }
    }
#line 336
    if (state == 1) {
#line 338
      tmp___20 = csv2_is_txt_bchar(look);
#line 338
      if (tmp___20) {
#line 339
        tmp___9 = csv2_txt_append(out, look, & txt_len);
#line 339
        if (tmp___9 != 1) {
#line 340
          return ((js_string *)0);
        }
      } else {
#line 343
        tmp___17 = csv2_is_delimiter(look);
#line 343
        if (tmp___17) {
#line 343
          if ((int )stream->tilde_handling != 103) {
#line 351
            tmp___10 = csv2_finalize_txt(stream, numchunks, chunkcount, txt_len_place,
                                         txt_len, out);
#line 351
            return (tmp___10);
          } else {
#line 343
            goto _L___8;
          }
        } else
        _L___8: /* CIL Label */ 
#line 343
        if (look == 126) {
#line 343
          if ((int )stream->tilde_handling == 103) {
#line 343
            if (post_txt == 0) {
#line 351
              tmp___10 = csv2_finalize_txt(stream, numchunks, chunkcount, txt_len_place,
                                           txt_len, out);
#line 351
              return (tmp___10);
            } else {
#line 343
              goto _L___7;
            }
          } else {
#line 343
            goto _L___7;
          }
        } else {
          _L___7: /* CIL Label */ 
#line 343
          tmp___18 = csv2_is_delimiter(look);
#line 343
          if (tmp___18) {
#line 343
            if (numchunks == -1) {
#line 351
              tmp___10 = csv2_finalize_txt(stream, numchunks, chunkcount, txt_len_place,
                                           txt_len, out);
#line 351
              return (tmp___10);
            } else {
#line 343
              goto _L___5;
            }
          } else {
            _L___5: /* CIL Label */ 
#line 343
            tmp___19 = csv2_is_delimiter(look);
#line 343
            if (tmp___19) {
#line 343
              if (post_txt == 1) {
#line 351
                tmp___10 = csv2_finalize_txt(stream, numchunks, chunkcount, txt_len_place,
                                             txt_len, out);
#line 351
                return (tmp___10);
              } else {
#line 343
                goto _L___4;
              }
            } else
            _L___4: /* CIL Label */ 
#line 343
            if (look == -2) {
#line 351
              tmp___10 = csv2_finalize_txt(stream, numchunks, chunkcount, txt_len_place,
                                           txt_len, out);
#line 351
              return (tmp___10);
            } else {
#line 355
              tmp___16 = csv2_is_bslash(look);
#line 355
              if (tmp___16) {
#line 356
                state = 3;
              } else {
#line 359
                tmp___15 = csv2_is_quote(look);
#line 359
                if (tmp___15) {
#line 360
                  state = 2;
                } else
#line 363
                if (look == 59) {
#line 363
                  if (numchunks != -1) {
#line 364
                    if (txt_len_place < 0) {
#line 366
                      js_destroy(out);
#line 367
                      return ((js_string *)0);
                    } else
#line 364
                    if ((unsigned int )txt_len_place > out->max_count) {
#line 366
                      js_destroy(out);
#line 367
                      return ((js_string *)0);
                    }
#line 369
                    if (txt_len > 255) {
#line 370
                      csv2_error(stream, (char *)"Single TXT chunk too long");
#line 372
                      js_destroy(out);
#line 373
                      return ((js_string *)0);
                    }
#line 375
                    *(out->string + txt_len_place) = (unsigned char )txt_len;
#line 376
                    chunkcount ++;
#line 377
                    txt_len_place = (int )out->unit_count;
#line 378
                    txt_len = 0;
#line 379
                    tmp___11 = csv2_append_utf8(out, 0);
#line 379
                    if (tmp___11 == -1) {
#line 380
                      js_destroy(out);
#line 381
                      return ((js_string *)0);
                    }
#line 383
                    state = 1;
                  } else {
#line 363
                    goto _L___3;
                  }
                } else
                _L___3: /* CIL Label */ 
#line 385
                if ((int )stream->tilde_handling == 103) {
#line 385
                  tmp___14 = csv2_is_delimiter(look);
#line 385
                  if (tmp___14) {
#line 385
                    if (look != 124) {
#line 387
                      state = 10;
                    } else {
#line 385
                      goto _L___2;
                    }
                  } else {
#line 385
                    goto _L___2;
                  }
                } else {
                  _L___2: /* CIL Label */ 
#line 390
                  tmp___13 = csv2_is_hash(look);
#line 390
                  if (tmp___13) {
#line 391
                    process_comment(stream);
#line 392
                    if ((int )stream->tilde_handling != 103) {
#line 393
                      tmp___12 = csv2_finalize_txt(stream, numchunks, chunkcount,
                                                   txt_len_place, txt_len, out);
#line 393
                      return (tmp___12);
                    }
                  } else
#line 399
                  if (numchunks != -1) {
#line 400
                    csv2_error(stream, (char *)"Syntax error in TXT/SPF RR");
#line 402
                    js_destroy(out);
#line 403
                    return ((js_string *)0);
                  } else
#line 405
                  if (numchunks == -1) {
#line 406
                    csv2_error(stream, (char *)"Syntax error in RAW");
#line 408
                    js_destroy(out);
#line 409
                    return ((js_string *)0);
                  } else {
#line 412
                    csv2_error(stream, (char *)"Something weird in csv2_rr_txt");
#line 414
                    js_destroy(out);
#line 415
                    return ((js_string *)0);
                  }
                }
              }
            }
          }
        }
      }
    } else
#line 419
    if (state == 2) {
#line 422
      tmp___23 = csv2_is_quote(look);
#line 422
      if (tmp___23) {
#line 423
        state = 1;
      } else
#line 424
      if ((int )stream->tilde_handling == 103) {
#line 425
        if (look == 35) {
#line 426
          csv2_error(stream, (char *)"The # character is not allowed in TXT records\nPlease use the \'\\x23\' escape sequence instead.");
#line 429
          return ((js_string *)0);
        } else
#line 430
        if (look == 124) {
#line 431
          csv2_error(stream, (char *)"The | character is not allowed in TXT records\nPlease use the \'\\x7c\' escape sequence instead.");
#line 434
          return ((js_string *)0);
        } else
#line 435
        if (look == 126) {
#line 436
          csv2_error(stream, (char *)"The ~ character is not allowed in TXT records\nPlease use the \'\\x7e\' escape sequence instead.");
#line 439
          return ((js_string *)0);
        } else
#line 440
        if (look == 127) {
#line 441
          csv2_error(stream, (char *)"The DEL character is not allowed in TXT records\nPlease use the \'\\x7f\' escape sequence instead.");
        } else
#line 444
        if (look < 32) {
#line 445
          csv2_error(stream, (char *)"Control characters (including newlines) are not allowed in TXT records\nPlease use the appropriate escape sequence instead.");
#line 448
          return ((js_string *)0);
        } else {
#line 449
          tmp___21 = csv2_txt_append(out, look, & txt_len);
#line 449
          if (tmp___21 != 1) {
#line 451
            return ((js_string *)0);
          }
        }
      } else {
#line 454
        tmp___22 = csv2_txt_append(out, look, & txt_len);
#line 454
        if (tmp___22 != 1) {
#line 455
          return ((js_string *)0);
        }
      }
    } else
#line 459
    if (state == 3) {
#line 461
      tmp___30 = csv2_is_quote(look);
#line 461
      if (tmp___30) {
#line 462
        tmp___24 = csv2_txt_append(out, look, & txt_len);
#line 462
        if (tmp___24 != 1) {
#line 463
          return ((js_string *)0);
        }
#line 465
        state = 1;
      } else {
#line 468
        tmp___29 = csv2_is_pipe(look);
#line 468
        if (tmp___29) {
#line 469
          csv2_error(stream, (char *)"Please don\'t backslash | characters");
#line 471
          js_destroy(out);
#line 472
          return ((js_string *)0);
        } else {
#line 475
          tmp___28 = csv2_is_hash(look);
#line 475
          if (tmp___28) {
#line 479
            process_comment(stream);
#line 480
            state = 4;
          } else {
#line 483
            tmp___27 = csv2_is_delimiter(look);
#line 483
            if (tmp___27) {
#line 484
              state = 4;
            } else {
#line 487
              tmp___26 = csv2_is_0123(look);
#line 487
              if (tmp___26) {
#line 488
                state = 5;
#line 489
                out_num = look - 48;
              } else {
#line 492
                tmp___25 = csv2_is_x(look);
#line 492
                if (tmp___25) {
#line 493
                  state = 7;
#line 494
                  out_num = 0;
                } else {
#line 497
                  csv2_error(stream, (char *)"Invalid character after backslash");
#line 499
                  js_destroy(out);
#line 500
                  return ((js_string *)0);
                }
              }
            }
          }
        }
      }
    } else
#line 503
    if (state == 4) {
#line 505
      tmp___37 = csv2_is_txt_bchar(look);
#line 505
      if (tmp___37) {
#line 506
        tmp___31 = csv2_txt_append(out, look, & txt_len);
#line 506
        if (tmp___31 != 1) {
#line 507
          js_destroy(out);
#line 508
          return ((js_string *)0);
        }
#line 510
        state = 1;
      } else {
#line 513
        tmp___36 = csv2_is_quote(look);
#line 513
        if (tmp___36) {
#line 514
          state = 2;
        } else {
#line 517
          tmp___35 = csv2_is_pipe(look);
#line 517
          if (tmp___35) {
#line 518
            csv2_error(stream, (char *)"Please don\'t have a pipe be after a backslash and whitespace");
#line 520
            js_destroy(out);
#line 521
            return ((js_string *)0);
          } else {
#line 524
            tmp___34 = csv2_is_hash(look);
#line 524
            if (tmp___34) {
#line 525
              process_comment(stream);
            } else {
#line 536
              tmp___33 = csv2_is_delimiter(look);
#line 536
              if (tmp___33) {
#line 537
                state = 4;
              } else {
#line 539
                tmp___32 = csv2_is_bslash(look);
#line 539
                if (tmp___32) {
#line 540
                  state = 3;
                } else {
#line 543
                  csv2_error(stream, (char *)"Invalid character after backslash and white space");
#line 545
                  js_destroy(out);
#line 546
                  return ((js_string *)0);
                }
              }
            }
          }
        }
      }
    } else
#line 549
    if (state == 5) {
#line 550
      tmp___38 = csv2_is_octal(look);
#line 550
      if (tmp___38) {
#line 551
        out_num *= 8;
#line 552
        out_num += look - 48;
#line 553
        state = 6;
      } else {
#line 556
        csv2_error(stream, (char *)"Invalid octal digit");
#line 557
        js_destroy(out);
#line 558
        return ((js_string *)0);
      }
    } else
#line 561
    if (state == 6) {
#line 562
      tmp___40 = csv2_is_octal(look);
#line 562
      if (tmp___40) {
#line 563
        out_num *= 8;
#line 564
        out_num += look - 48;
#line 565
        tmp___39 = js_addbyte(out, (unsigned char )out_num);
#line 565
        if (tmp___39 == -1) {
#line 566
          js_destroy(out);
#line 567
          return ((js_string *)0);
        }
#line 569
        txt_len ++;
#line 570
        out_num = 0;
#line 571
        state = 1;
      } else {
#line 574
        csv2_error(stream, (char *)"Invalid octal digit");
#line 575
        js_destroy(out);
#line 576
        return ((js_string *)0);
      }
    } else
#line 579
    if (state == 7) {
#line 580
      tmp___44 = csv2_is_hex(look);
#line 580
      if (tmp___44) {
#line 581
        out_num = 0;
#line 582
        tmp___43 = csv2_is_number(look);
#line 582
        if (tmp___43) {
#line 583
          out_num += look - 48;
        } else {
#line 585
          tmp___42 = csv2_is_upper(look);
#line 585
          if (tmp___42) {
#line 586
            out_num += (look + 10) - 65;
          } else {
#line 588
            tmp___41 = csv2_is_lower(look);
#line 588
            if (tmp___41) {
#line 589
              out_num += (look + 10) - 97;
            }
          }
        }
#line 591
        state = 8;
      } else {
#line 594
        csv2_error(stream, (char *)"Invalid hex digit");
#line 595
        js_destroy(out);
#line 596
        return ((js_string *)0);
      }
    } else
#line 599
    if (state == 8) {
#line 600
      tmp___49 = csv2_is_hex(look);
#line 600
      if (tmp___49) {
#line 601
        out_num *= 16;
#line 602
        tmp___47 = csv2_is_number(look);
#line 602
        if (tmp___47) {
#line 603
          out_num += look - 48;
        } else {
#line 605
          tmp___46 = csv2_is_upper(look);
#line 605
          if (tmp___46) {
#line 606
            out_num += (look + 10) - 65;
          } else {
#line 608
            tmp___45 = csv2_is_lower(look);
#line 608
            if (tmp___45) {
#line 609
              out_num += (look + 10) - 97;
            }
          }
        }
#line 611
        tmp___48 = js_addbyte(out, (unsigned char )out_num);
#line 611
        if (tmp___48 == -1) {
#line 612
          js_destroy(out);
#line 613
          return ((js_string *)0);
        }
#line 615
        txt_len ++;
#line 616
        out_num = 0;
#line 617
        state = 1;
      } else {
#line 620
        csv2_error(stream, (char *)"Invalid hex digit");
#line 621
        js_destroy(out);
#line 622
        return ((js_string *)0);
      }
    } else
#line 625
    if (state == 10) {
#line 627
      tmp___53 = csv2_is_hash(look);
#line 627
      if (tmp___53) {
#line 628
        process_comment(stream);
      } else
#line 630
      if (look == 126) {
#line 631
        tmp___50 = csv2_finalize_txt(stream, numchunks, chunkcount, txt_len_place,
                                     txt_len, out);
#line 631
        return (tmp___50);
      } else
#line 630
      if (look == -2) {
#line 631
        tmp___50 = csv2_finalize_txt(stream, numchunks, chunkcount, txt_len_place,
                                     txt_len, out);
#line 631
        return (tmp___50);
      } else
#line 634
      if (look == 39) {
#line 634
        goto _L___9;
      } else
#line 634
      if (look == 92) {
        _L___9: /* CIL Label */ 
#line 635
        if (txt_len_place < 0) {
#line 637
          js_destroy(out);
#line 638
          return ((js_string *)0);
        } else
#line 635
        if ((unsigned int )txt_len_place > out->max_count) {
#line 637
          js_destroy(out);
#line 638
          return ((js_string *)0);
        }
#line 640
        if (txt_len > 255) {
#line 641
          csv2_error(stream, (char *)"Single TXT chunk too long");
#line 643
          js_destroy(out);
#line 644
          return ((js_string *)0);
        }
#line 646
        *(out->string + txt_len_place) = (unsigned char )txt_len;
#line 647
        chunkcount ++;
#line 648
        txt_len_place = (int )out->unit_count;
#line 649
        txt_len = 0;
#line 650
        tmp___51 = csv2_append_utf8(out, 0);
#line 650
        if (tmp___51 == -1) {
#line 651
          js_destroy(out);
#line 652
          return ((js_string *)0);
        }
#line 654
        if (look == 39) {
#line 655
          state = 2;
        } else
#line 656
        if (look == 92) {
#line 657
          state = 3;
        } else {
#line 659
          printf("Fatal error in BETWEEN_CHUNK state!\n");
#line 661
          exit(1);
        }
      } else
#line 664
      if (look == 124) {
#line 665
        csv2_error(stream, (char *)"Pipes are not allowed between TXT chunks");
#line 667
        js_destroy(out);
#line 668
        return ((js_string *)0);
      } else {
#line 669
        tmp___52 = csv2_is_delimiter(look);
#line 669
        if (! tmp___52) {
#line 670
          csv2_error(stream, (char *)"Invalid character between chunks; this might be caused by a TXT RR not\nterminated by a ~ character");
#line 673
          js_destroy(out);
#line 674
          return ((js_string *)0);
        }
      }
    }
#line 325
    x ++;
  }
#line 681
  csv2_error(stream, (char *)"RR too long");
#line 682
  js_destroy(out);
#line 683
  return ((js_string *)0);
}
}
#line 1 "Csv2_esc_txt.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-9USBLfZK.i","")
#line 27 "Csv2_esc_txt.c"
int escape_stdout_csv2(js_string *js ) 
{ unsigned char this ;
  int inquote ;
  int counter ;
  int tmp ;

  {
#line 29
  inquote = 0;
#line 29
  counter = 0;
#line 32
  tmp = js_has_sanity(js);
#line 32
  if (tmp < 0) {
#line 33
    return (-1);
  }
#line 34
  if (js->unit_size != 1U) {
#line 35
    return (-1);
  }
#line 37
  inquote = 0;
#line 39
  while ((unsigned int )counter < js->unit_count) {
#line 40
    this = *(js->string + counter);
#line 41
    if ((int )this < 32) {
#line 41
      goto _L;
    } else
#line 41
    if ((int )this > 122) {
#line 41
      goto _L;
    } else
#line 41
    if ((int )this == 35) {
      _L: /* CIL Label */ 
#line 46
      if (inquote == 1) {
#line 47
        printf("\'");
#line 48
        inquote = 0;
      }
#line 50
      printf("\\x%02x", (int )this);
    } else
#line 52
    if ((int )this == 39) {
#line 53
      if (inquote == 1) {
#line 54
        printf("\'\\\'\'");
      } else {
#line 57
        printf("\\\'");
      }
    } else {
#line 61
      if (inquote == 0) {
#line 62
        inquote = 1;
#line 63
        printf("\'");
      }
#line 65
      printf("%c", (int )this);
    }
#line 67
    counter ++;
  }
#line 70
  if (inquote == 1) {
#line 71
    printf("\'");
  }
#line 74
  return (1);
}
}
#line 80 "Csv2_esc_txt.c"
void human_readable_dns_query(js_string *query , int hide_qtype ) 
{ unsigned char this ;
  int counter ;
  int dlen ;
  int qtype ;
  int x ;
  unsigned char *that ;
  int tmp ;

  {
#line 82
  counter = 0;
#line 82
  dlen = -1;
#line 85
  tmp = js_has_sanity(query);
#line 85
  if (tmp < 0) {
#line 86
    printf(":ERROR:\n");
#line 87
    return;
  }
#line 89
  if (query->unit_size != 1U) {
#line 90
    printf(":ERROR:\n");
#line 91
    return;
  }
#line 94
  if (query->unit_count < 2U) {
#line 95
    printf(":ERROR:\n");
  }
#line 98
  that = query->string;
#line 99
  qtype = (int )*((that + query->unit_count) - 1);
#line 100
  qtype += (int )*((that + query->unit_count) - 2) << 8;
#line 101
  if (hide_qtype != 1) {
#line 102
    printf("%d:", qtype);
  }
#line 105
  x = 0;
#line 105
  while (x < 10000) {
#line 106
    if ((unsigned int )counter > query->unit_count) {
#line 107
      printf(":ERROR:105:\n");
#line 108
      return;
    } else
#line 106
    if (counter < 0) {
#line 107
      printf(":ERROR:105:\n");
#line 108
      return;
    }
#line 110
    dlen = (int )*(query->string + counter);
#line 111
    if (dlen == 95) {
#line 112
      printf("{STAR}");
#line 113
      if (counter == 0) {
#line 113
        if (query->unit_count != 3U) {
#line 116
          counter ++;
#line 117
          goto __Cont;
        } else {
#line 119
          break;
        }
      } else {
#line 119
        break;
      }
    }
#line 122
    if (dlen > 64) {
#line 123
      printf(":ERROR:110:%d:\n", dlen);
#line 124
      return;
    } else
#line 122
    if (dlen < 0) {
#line 123
      printf(":ERROR:110:%d:\n", dlen);
#line 124
      return;
    }
#line 126
    if (dlen == 0) {
#line 127
      break;
    }
#line 129
    while (dlen > 0) {
#line 130
      counter ++;
#line 131
      if ((unsigned int )counter > query->unit_count) {
#line 132
        printf(":ERROR:119:\n");
#line 133
        return;
      } else
#line 131
      if (counter < 0) {
#line 132
        printf(":ERROR:119:\n");
#line 133
        return;
      }
#line 135
      this = *(query->string + counter);
#line 136
      if ((int )this < 32) {
#line 138
        printf("\\x%02x", (int )this);
      } else
#line 136
      if ((int )this > 127) {
#line 138
        printf("\\x%02x", (int )this);
      } else
#line 136
      if ((int )this == 46) {
#line 138
        printf("\\x%02x", (int )this);
      } else
#line 136
      if ((int )this == 58) {
#line 138
        printf("\\x%02x", (int )this);
      } else {
#line 140
        printf("%c", (int )this);
      }
#line 142
      dlen --;
    }
#line 144
    counter ++;
#line 145
    printf(".");
    __Cont: /* CIL Label */ 
#line 105
    x ++;
  }
#line 148
  if ((unsigned int )counter != query->unit_count - 3U) {
#line 149
    printf(":ERROR:%d:%d:\n", counter, query->unit_count);
  }
#line 152
  return;
}
}
#line 1 "rng-api-fst.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-BGDLNpak.i","")
#line 57 "rng-alg-fst.h"
int rngKeySetupEnc(u32 *rk , u8 const   *cipherKey , int keyBits ) ;
#line 58
void rngEncrypt(u32 const   *rk , int Nr , u8 const   *pt , u8 *ct ) ;
#line 67 "rng-api-fst.c"
int makeKey(keyInstance *key___0 , MARA_BYTE direction , int keyLen , char *keyMaterial ) 
{ int i ;
  char *keyMat ;
  u8 cipherKey[32] ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int v ;

  {
#line 72
  if ((unsigned long )key___0 == (unsigned long )((void *)0)) {
#line 73
    return (-3);
  }
#line 76
  if ((int )direction == 0) {
#line 77
    key___0->direction = direction;
  } else {
#line 79
    return (-1);
  }
#line 82
  if (keyLen == 128) {
#line 83
    key___0->keyLen = keyLen;
  } else {
#line 85
    return (-2);
  }
#line 91
  tmp___0 = __builtin_object_size((void *)(key___0->keyMaterial), 0);
#line 91
  if (tmp___0 != 0xffffffffffffffffUL) {
#line 91
    tmp = __builtin_object_size((void *)(key___0->keyMaterial), 0);
#line 91
    __builtin___memcpy_chk((void *)(key___0->keyMaterial), (void const   *)keyMaterial,
                           (unsigned long )(keyLen / 8), tmp);
  } else {
#line 91
    __inline_memcpy_chk((void *)(key___0->keyMaterial), (void const   *)keyMaterial,
                        (size_t )(keyLen / 8));
  }
#line 95
  keyMat = key___0->keyMaterial;
#line 96
  i = 0;
#line 96
  while (i < key___0->keyLen / 8) {
#line 112
    v = (int )*keyMat;
#line 113
    keyMat ++;
#line 115
    cipherKey[i] = (u8 )v;
#line 96
    i ++;
  }
#line 117
  if ((int )direction == 0) {
#line 118
    key___0->Nr = rngKeySetupEnc(key___0->rk, (u8 const   *)(cipherKey), keyLen);
  } else {
#line 120
    return (-1);
  }
#line 122
  rngKeySetupEnc(key___0->ek, (u8 const   *)(cipherKey), keyLen);
#line 123
  return (1);
}
}
#line 126 "rng-api-fst.c"
int cipherInit(cipherInstance *cipher , MARA_BYTE mode , char *IV ) 
{ unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 127
  if ((int )mode == 1) {
#line 128
    cipher->mode = mode;
  } else {
#line 130
    return (-4);
  }
#line 132
  if ((unsigned long )IV != (unsigned long )((void *)0)) {
#line 133
    return (-4);
  } else {
#line 135
    tmp___0 = __builtin_object_size((void *)(cipher->IV), 0);
#line 135
    if (tmp___0 != 0xffffffffffffffffUL) {
#line 135
      tmp = __builtin_object_size((void *)(cipher->IV), 0);
#line 135
      __builtin___memset_chk((void *)(cipher->IV), 0, 16UL, tmp);
    } else {
#line 135
      __inline_memset_chk((void *)(cipher->IV), 0, (size_t )16);
    }
  }
#line 137
  return (1);
}
}
#line 140 "rng-api-fst.c"
int blockEncrypt(cipherInstance *cipher , keyInstance *key___0 , MARA_BYTE *input ,
                 int inputLen , MARA_BYTE *outBuffer ) 
{ int i ;
  int numBlocks ;

  {
#line 144
  if ((unsigned long )cipher == (unsigned long )((void *)0)) {
#line 147
    return (-5);
  } else
#line 144
  if ((unsigned long )key___0 == (unsigned long )((void *)0)) {
#line 147
    return (-5);
  } else
#line 144
  if ((int )key___0->direction == 1) {
#line 147
    return (-5);
  }
#line 149
  if ((unsigned long )input == (unsigned long )((void *)0)) {
#line 150
    return (0);
  } else
#line 149
  if (inputLen <= 0) {
#line 150
    return (0);
  }
#line 153
  numBlocks = inputLen / 128;
#line 155
  switch ((int )cipher->mode) {
  case 1: 
#line 157
  i = numBlocks;
#line 157
  while (i > 0) {
#line 158
    rngEncrypt((u32 const   *)(key___0->rk), key___0->Nr, (u8 const   *)input, (u8 *)outBuffer);
#line 159
    input += 16;
#line 160
    outBuffer += 16;
#line 157
    i --;
  }
#line 162
  break;
  default: 
#line 165
  return (-5);
  }
#line 168
  return (128 * numBlocks);
}
}
#line 1 "rng-alg-fst.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-3wI1t9B1.i","")
#line 3 "rng-32bit-tables.h"
static u32 const   Te0[256]  = 
#line 3 "rng-32bit-tables.h"
  {      (u32 const   )3017953435U,      (u32 const   )1672792582U,      (u32 const   )2246353620U,      (u32 const   )560743938U, 
        (u32 const   )980369320U,      (u32 const   )2786508149U,      (u32 const   )323814928U,      (u32 const   )1298184604U, 
        (u32 const   )392868941U,      (u32 const   )2135030158U,      (u32 const   )3799505551U,      (u32 const   )3454798025U, 
        (u32 const   )1510608337U,      (u32 const   )453212586U,      (u32 const   )2070301651U,      (u32 const   )2715875159U, 
        (u32 const   )4205140826U,      (u32 const   )3929646389U,      (u32 const   )3315758963U,      (u32 const   )2977696056U, 
        (u32 const   )539224030U,      (u32 const   )3564185792U,      (u32 const   )2089812465U,      (u32 const   )582860413U, 
        (u32 const   )3967831755U,      (u32 const   )3107092098U,      (u32 const   )3172320479U,      (u32 const   )3385571988U, 
        (u32 const   )2760434902U,      (u32 const   )21995996U,      (u32 const   )1617244793U,      (u32 const   )4269992199U, 
        (u32 const   )1960738379U,      (u32 const   )2833328433U,      (u32 const   )69710429U,      (u32 const   )3864029394U, 
        (u32 const   )2307747635U,      (u32 const   )2458785433U,      (u32 const   )302163916U,      (u32 const   )2049567247U, 
        (u32 const   )522505207U,      (u32 const   )1682079780U,      (u32 const   )3715167910U,      (u32 const   )3200531616U, 
        (u32 const   )755338213U,      (u32 const   )368373230U,      (u32 const   )1462526442U,      (u32 const   )485831560U, 
        (u32 const   )4185170725U,      (u32 const   )1078384039U,      (u32 const   )733765659U,      (u32 const   )3735097049U, 
        (u32 const   )1121487876U,      (u32 const   )2402583757U,      (u32 const   )1600265808U,      (u32 const   )2203928874U, 
        (u32 const   )4112346818U,      (u32 const   )798741062U,      (u32 const   )3213598076U,      (u32 const   )3994949480U, 
        (u32 const   )1812791198U,      (u32 const   )371529105U,      (u32 const   )927552403U,      (u32 const   )1555293743U, 
        (u32 const   )1057434665U,      (u32 const   )1272533602U,      (u32 const   )90706817U,      (u32 const   )2416987962U, 
        (u32 const   )64092287U,      (u32 const   )1380217451U,      (u32 const   )3577645340U,      (u32 const   )2596301091U, 
        (u32 const   )1368754708U,      (u32 const   )2438983398U,      (u32 const   )3756961541U,      (u32 const   )2046300784U, 
        (u32 const   )3536372542U,      (u32 const   )968804311U,      (u32 const   )1983916008U,      (u32 const   )1208527389U, 
        (u32 const   )3480375658U,      (u32 const   )647629856U,      (u32 const   )2872103246U,      (u32 const   )3260300625U, 
        (u32 const   )1997506100U,      (u32 const   )2695845515U,      (u32 const   )668315132U,      (u32 const   )1342103615U, 
        (u32 const   )3021216441U,      (u32 const   )2363849906U,      (u32 const   )720617927U,      (u32 const   )3687390552U, 
        (u32 const   )3606016355U,      (u32 const   )1020712022U,      (u32 const   )1531292685U,      (u32 const   )1044942325U, 
        (u32 const   )841039890U,      (u32 const   )3785761520U,      (u32 const   )2609891583U,      (u32 const   )1133981144U, 
        (u32 const   )3433277717U,      (u32 const   )678271076U,      (u32 const   )837859437U,      (u32 const   )882420716U, 
        (u32 const   )1932014697U,      (u32 const   )1876756449U,      (u32 const   )1747668419U,      (u32 const   )1725749639U, 
        (u32 const   )1449377846U,      (u32 const   )1660644314U,      (u32 const   )2507693243U,      (u32 const   )3877619982U, 
        (u32 const   )1919391157U,      (u32 const   )3411403575U,      (u32 const   )1576814579U,      (u32 const   )1895418902U, 
        (u32 const   )3062514458U,      (u32 const   )2177044617U,      (u32 const   )3838718321U,      (u32 const   )220621883U, 
        (u32 const   )2898697068U,      (u32 const   )2556309632U,      (u32 const   )3666263172U,      (u32 const   )1833131586U, 
        (u32 const   )1768221727U,      (u32 const   )112847870U,      (u32 const   )2225799944U,      (u32 const   )3135475453U, 
        (u32 const   )299065267U,      (u32 const   )0U,      (u32 const   )251106372U,      (u32 const   )4226480774U, 
        (u32 const   )3148623649U,      (u32 const   )1695359480U,      (u32 const   )2925052623U,      (u32 const   )2251643563U, 
        (u32 const   )1630180261U,      (u32 const   )4099067678U,      (u32 const   )1147234298U,      (u32 const   )2272983927U, 
        (u32 const   )4087645500U,      (u32 const   )2807635113U,      (u32 const   )2111807533U,      (u32 const   )1486115954U, 
        (u32 const   )2625209053U,      (u32 const   )3625510183U,      (u32 const   )862904782U,      (u32 const   )133581346U, 
        (u32 const   )2781299978U,      (u32 const   )2156704085U,      (u32 const   )3083199174U,      (u32 const   )4015109812U, 
        (u32 const   )906424911U,      (u32 const   )4291643611U,      (u32 const   )1437743177U,      (u32 const   )1811592636U, 
        (u32 const   )1320239587U,      (u32 const   )2390435089U,      (u32 const   )1790252128U,      (u32 const   )4250079608U, 
        (u32 const   )416448981U,      (u32 const   )3548865250U,      (u32 const   )4075496672U,      (u32 const   )3390718699U, 
        (u32 const   )3695138682U,      (u32 const   )2294468335U,      (u32 const   )2376785262U,      (u32 const   )43932067U, 
        (u32 const   )429727753U,      (u32 const   )2956175588U,      (u32 const   )151117414U,      (u32 const   )208260583U, 
        (u32 const   )263730584U,      (u32 const   )4152571745U,      (u32 const   )4140603069U,      (u32 const   )2025305004U, 
        (u32 const   )1972494231U,      (u32 const   )1229392833U,      (u32 const   )3850473645U,      (u32 const   )2548434200U, 
        (u32 const   )3617640639U,      (u32 const   )1251406782U,      (u32 const   )2678618786U,      (u32 const   )3924319562U, 
        (u32 const   )195004357U,      (u32 const   )1160693286U,      (u32 const   )3160040707U,      (u32 const   )3646375163U, 
        (u32 const   )2568065372U,      (u32 const   )2527700164U,      (u32 const   )1191132761U,      (u32 const   )1278154816U, 
        (u32 const   )2486697319U,      (u32 const   )3812129619U,      (u32 const   )1033467274U,      (u32 const   )3342610128U, 
        (u32 const   )743057977U,      (u32 const   )625734751U,      (u32 const   )603070369U,      (u32 const   )441243766U, 
        (u32 const   )3495336605U,      (u32 const   )3095254878U,      (u32 const   )498766420U,      (u32 const   )955344395U, 
        (u32 const   )2721124136U,      (u32 const   )1580056460U,      (u32 const   )1202757509U,      (u32 const   )347819058U, 
        (u32 const   )2846787821U,      (u32 const   )1356475336U,      (u32 const   )604263811U,      (u32 const   )3950380265U, 
        (u32 const   )3042687845U,      (u32 const   )510356011U,      (u32 const   )2182277366U,      (u32 const   )4047166623U, 
        (u32 const   )3234489586U,      (u32 const   )139362234U,      (u32 const   )2742988532U,      (u32 const   )903285296U, 
        (u32 const   )3989827351U,      (u32 const   )3773399852U,      (u32 const   )817830321U,      (u32 const   )2665995134U, 
        (u32 const   )3903323286U,      (u32 const   )2478946117U,      (u32 const   )4229738660U,      (u32 const   )2997743943U, 
        (u32 const   )278724207U,      (u32 const   )2911451824U,      (u32 const   )2937545491U,      (u32 const   )785675162U, 
        (u32 const   )1855104573U,      (u32 const   )2637570817U,      (u32 const   )4164616953U,      (u32 const   )3329462028U, 
        (u32 const   )3246769454U,      (u32 const   )3364100936U,      (u32 const   )1737717851U,      (u32 const   )2860478610U, 
        (u32 const   )1091138683U,      (u32 const   )3273366669U,      (u32 const   )1907781066U,      (u32 const   )2333292176U, 
        (u32 const   )3508091713U,      (u32 const   )1425906069U,      (u32 const   )3303921327U,      (u32 const   )2114869330U, 
        (u32 const   )991993460U,      (u32 const   )2321323852U,      (u32 const   )4034231619U,      (u32 const   )1507587502U, 
        (u32 const   )3460165814U,      (u32 const   )1393284023U,      (u32 const   )181413401U,      (u32 const   )690108856U};
#line 69 "rng-32bit-tables.h"
static u32 const   Te1[256]  = 
#line 69
  {      (u32 const   )2612257360U,      (u32 const   )107197642U,      (u32 const   )3565544610U,      (u32 const   )35744838U, 
        (u32 const   )2822401855U,      (u32 const   )1973819069U,      (u32 const   )269700358U,      (u32 const   )2622316729U, 
        (u32 const   )1293380276U,      (u32 const   )2390704633U,      (u32 const   )2413983706U,      (u32 const   )3385715720U, 
        (u32 const   )3512338957U,      (u32 const   )2853897081U,      (u32 const   )3548079691U,      (u32 const   )1470226679U, 
        (u32 const   )1526375771U,      (u32 const   )904542629U,      (u32 const   )1942332023U,      (u32 const   )951155721U, 
        (u32 const   )3726648295U,      (u32 const   )3235148072U,      (u32 const   )4051472385U,      (u32 const   )2099428798U, 
        (u32 const   )3421274190U,      (u32 const   )2193175158U,      (u32 const   )3753711044U,      (u32 const   )2496252858U, 
        (u32 const   )3601107172U,      (u32 const   )3691073441U,      (u32 const   )2036360498U,      (u32 const   )134120169U, 
        (u32 const   )1265950334U,      (u32 const   )833151273U,      (u32 const   )1560553394U,      (u32 const   )3538309224U, 
        (u32 const   )864652655U,      (u32 const   )2576518678U,      (u32 const   )3423732391U,      (u32 const   )259664362U, 
        (u32 const   )4146013387U,      (u32 const   )610550400U,      (u32 const   )2799530230U,      (u32 const   )2696856636U, 
        (u32 const   )3844933003U,      (u32 const   )3994416365U,      (u32 const   )3931581537U,      (u32 const   )2283599155U, 
        (u32 const   )637105315U,      (u32 const   )2806007509U,      (u32 const   )455851104U,      (u32 const   )3655246094U, 
        (u32 const   )71489676U,      (u32 const   )3448714372U,      (u32 const   )1348428318U,      (u32 const   )713252169U, 
        (u32 const   )3270843758U,      (u32 const   )1177525202U,      (u32 const   )2092927901U,      (u32 const   )1760435735U, 
        (u32 const   )2657881343U,      (u32 const   )2434147605U,      (u32 const   )2469874003U,      (u32 const   )794604518U, 
        (u32 const   )691996460U,      (u32 const   )1649138002U,      (u32 const   )2164615187U,      (u32 const   )982519887U, 
        (u32 const   )2130956792U,      (u32 const   )1800553586U,      (u32 const   )483737225U,      (u32 const   )597344361U, 
        (u32 const   )340891018U,      (u32 const   )3868286958U,      (u32 const   )98561711U,      (u32 const   )1887041554U, 
        (u32 const   )1054001347U,      (u32 const   )3610885831U,      (u32 const   )3900063783U,      (u32 const   )491260074U, 
        (u32 const   )1791980113U,      (u32 const   )539400716U,      (u32 const   )1319842001U,      (u32 const   )1371690045U, 
        (u32 const   )880217990U,      (u32 const   )2342563670U,      (u32 const   )4230469037U,      (u32 const   )1062207200U, 
        (u32 const   )3115586586U,      (u32 const   )2995578236U,      (u32 const   )3341480897U,      (u32 const   )1490798877U, 
        (u32 const   )1675030385U,      (u32 const   )1446827732U,      (u32 const   )224085420U,      (u32 const   )4114499725U, 
        (u32 const   )305275200U,      (u32 const   )4041319970U,      (u32 const   )4288384968U,      (u32 const   )3628308269U, 
        (u32 const   )365732777U,      (u32 const   )1680371096U,      (u32 const   )1831989432U,      (u32 const   )3962869931U, 
        (u32 const   )1769154612U,      (u32 const   )3782204679U,      (u32 const   )3278383949U,      (u32 const   )2271665369U, 
        (u32 const   )911631296U,      (u32 const   )3663919979U,      (u32 const   )3147135068U,      (u32 const   )250027977U, 
        (u32 const   )3044173717U,      (u32 const   )936072675U,      (u32 const   )4083022919U,      (u32 const   )376502732U, 
        (u32 const   )448170563U,      (u32 const   )2306982672U,      (u32 const   )1910820401U,      (u32 const   )990717548U, 
        (u32 const   )1823262363U,      (u32 const   )2157469232U,      (u32 const   )2228913852U,      (u32 const   )1114456926U, 
        (u32 const   )527000812U,      (u32 const   )4261853675U,      (u32 const   )142912259U,      (u32 const   )4256883598U, 
        (u32 const   )3004289887U,      (u32 const   )0U,      (u32 const   )1141831572U,      (u32 const   )2264656634U, 
        (u32 const   )565947439U,      (u32 const   )4167372065U,      (u32 const   )3484309698U,      (u32 const   )2877699418U, 
        (u32 const   )2774608531U,      (u32 const   )519328463U,      (u32 const   )4198785383U,      (u32 const   )2005367547U, 
        (u32 const   )1022600325U,      (u32 const   )2846316828U,      (u32 const   )763223968U,      (u32 const   )1918407764U, 
        (u32 const   )3718019458U,      (u32 const   )668473573U,      (u32 const   )3459477217U,      (u32 const   )570947146U, 
        (u32 const   )178636613U,      (u32 const   )1434487985U,      (u32 const   )3333932514U,      (u32 const   )3035582902U, 
        (u32 const   )1328940786U,      (u32 const   )3690974536U,      (u32 const   )1230352952U,      (u32 const   )3161193141U, 
        (u32 const   )3813585217U,      (u32 const   )294550309U,      (u32 const   )1617605908U,      (u32 const   )2029867793U, 
        (u32 const   )3575173761U,      (u32 const   )3805513570U,      (u32 const   )3774016292U,      (u32 const   )3955890754U, 
        (u32 const   )2061254487U,      (u32 const   )4018717390U,      (u32 const   )1854778077U,      (u32 const   )2734857817U, 
        (u32 const   )152673568U,      (u32 const   )3836752808U,      (u32 const   )1711866334U,      (u32 const   )3876350413U, 
        (u32 const   )2551167029U,      (u32 const   )1643610935U,      (u32 const   )3187068054U,      (u32 const   )2893592499U, 
        (u32 const   )2541064671U,      (u32 const   )3242805003U,      (u32 const   )2917499280U,      (u32 const   )412608005U, 
        (u32 const   )3218579664U,      (u32 const   )3192559347U,      (u32 const   )2728372346U,      (u32 const   )1256843357U, 
        (u32 const   )3305873287U,      (u32 const   )642068166U,      (u32 const   )62675557U,      (u32 const   )4225324868U, 
        (u32 const   )1553535377U,      (u32 const   )3298208164U,      (u32 const   )1497825086U,      (u32 const   )1078734616U, 
        (u32 const   )1737766909U,      (u32 const   )1407400059U,      (u32 const   )2319292789U,      (u32 const   )3502717998U, 
        (u32 const   )959203882U,      (u32 const   )1596279796U,      (u32 const   )2703487519U,      (u32 const   )1981435096U, 
        (u32 const   )2647676570U,      (u32 const   )1589149143U,      (u32 const   )1411234450U,      (u32 const   )188281190U, 
        (u32 const   )681718031U,      (u32 const   )2354982335U,      (u32 const   )2236067999U,      (u32 const   )840219468U, 
        (u32 const   )3987320456U,      (u32 const   )3360741931U,      (u32 const   )2200175701U,      (u32 const   )3924522500U, 
        (u32 const   )1706384315U,      (u32 const   )723413866U,      (u32 const   )4135719656U,      (u32 const   )2683386588U, 
        (u32 const   )4072720996U,      (u32 const   )3121106559U,      (u32 const   )4104355502U,      (u32 const   )808834826U, 
        (u32 const   )401461231U,      (u32 const   )752937347U,      (u32 const   )2972761881U,      (u32 const   )2124343259U, 
        (u32 const   )2531829756U,      (u32 const   )1167311287U,      (u32 const   )2767985840U,      (u32 const   )1202892273U, 
        (u32 const   )1863359742U,      (u32 const   )2964162874U,      (u32 const   )330241891U,      (u32 const   )2586760307U, 
        (u32 const   )1030656678U,      (u32 const   )27080227U,      (u32 const   )4193794818U,      (u32 const   )214332303U, 
        (u32 const   )784434629U,      (u32 const   )1221100571U,      (u32 const   )1533514616U,      (u32 const   )2460647280U, 
        (u32 const   )2067859828U,      (u32 const   )2378374044U,      (u32 const   )3396449901U,      (u32 const   )2425033526U, 
        (u32 const   )1104222523U,      (u32 const   )2505375129U,      (u32 const   )2948918742U,      (u32 const   )1383992920U, 
        (u32 const   )1950032030U,      (u32 const   )1284136087U,      (u32 const   )1139832189U,      (u32 const   )2925124597U, 
        (u32 const   )3066969584U,      (u32 const   )3075673043U,      (u32 const   )420139046U,      (u32 const   )3089703481U};
#line 135 "rng-32bit-tables.h"
static u32 const   Te2[256]  = 
#line 135
  {      (u32 const   )1352381410U,      (u32 const   )3389416372U,      (u32 const   )2731836900U,      (u32 const   )1174544748U, 
        (u32 const   )1067989615U,      (u32 const   )3178604054U,      (u32 const   )101716813U,      (u32 const   )3114028384U, 
        (u32 const   )3024951146U,      (u32 const   )4186865473U,      (u32 const   )3666862711U,      (u32 const   )147443180U, 
        (u32 const   )231823882U,      (u32 const   )2041191171U,      (u32 const   )1272150886U,      (u32 const   )4149715424U, 
        (u32 const   )1532689061U,      (u32 const   )2771774009U,      (u32 const   )2004075938U,      (u32 const   )154710396U, 
        (u32 const   )3890094115U,      (u32 const   )683725937U,      (u32 const   )32603280U,      (u32 const   )3195871933U, 
        (u32 const   )1321987200U,      (u32 const   )1988278578U,      (u32 const   )3302997269U,      (u32 const   )3130313163U, 
        (u32 const   )3839272072U,      (u32 const   )2715550031U,      (u32 const   )846815333U,      (u32 const   )3909615234U, 
        (u32 const   )2118874334U,      (u32 const   )691120353U,      (u32 const   )2992440359U,      (u32 const   )1758651984U, 
        (u32 const   )1865648525U,      (u32 const   )379163278U,      (u32 const   )2815169026U,      (u32 const   )3926882857U, 
        (u32 const   )3421970212U,      (u32 const   )2149868610U,      (u32 const   )4138130800U,      (u32 const   )1017167556U, 
        (u32 const   )2347052293U,      (u32 const   )3991803380U,      (u32 const   )1642747692U,      (u32 const   )864558325U, 
        (u32 const   )2737174900U,      (u32 const   )3584507974U,      (u32 const   )1612393404U,      (u32 const   )249159329U, 
        (u32 const   )2349089496U,      (u32 const   )2228064052U,      (u32 const   )508583778U,      (u32 const   )1227522909U, 
        (u32 const   )1858270493U,      (u32 const   )3527815067U,      (u32 const   )2642198411U,      (u32 const   )392752670U, 
        (u32 const   )4288572428U,      (u32 const   )361829925U,      (u32 const   )1402156873U,      (u32 const   )3861863603U, 
        (u32 const   )740900615U,      (u32 const   )1382173657U,      (u32 const   )327222632U,      (u32 const   )1329238032U, 
        (u32 const   )4169073617U,      (u32 const   )1919636036U,      (u32 const   )2300368190U,      (u32 const   )1763941056U, 
        (u32 const   )2316587413U,      (u32 const   )4008087903U,      (u32 const   )2936397806U,      (u32 const   )309361144U, 
        (u32 const   )3275674312U,      (u32 const   )3352771006U,      (u32 const   )669546048U,      (u32 const   )2854045704U, 
        (u32 const   )1365954418U,      (u32 const   )203433626U,      (u32 const   )3511593776U,      (u32 const   )1028768340U, 
        (u32 const   )2251585295U,      (u32 const   )1451991215U,      (u32 const   )2918983637U,      (u32 const   )3762245630U, 
        (u32 const   )448377876U,      (u32 const   )2092076261U,      (u32 const   )3251055347U,      (u32 const   )492362697U, 
        (u32 const   )1902368495U,      (u32 const   )3562421462U,      (u32 const   )2886556485U,      (u32 const   )2381659720U, 
        (u32 const   )1074934305U,      (u32 const   )586211750U,      (u32 const   )3372194703U,      (u32 const   )769147799U, 
        (u32 const   )2836778147U,      (u32 const   )2556700781U,      (u32 const   )3094163952U,      (u32 const   )2884383896U, 
        (u32 const   )879325992U,      (u32 const   )132214749U,      (u32 const   )1304651819U,      (u32 const   )3649529564U, 
        (u32 const   )3224786531U,      (u32 const   )1809474299U,      (u32 const   )1555797368U,      (u32 const   )3373197087U, 
        (u32 const   )2511696487U,      (u32 const   )3812084565U,      (u32 const   )1207131644U,      (u32 const   )3424022777U, 
        (u32 const   )1125824138U,      (u32 const   )277447107U,      (u32 const   )829547726U,      (u32 const   )1815809318U, 
        (u32 const   )2607590598U,      (u32 const   )813733982U,      (u32 const   )3162823302U,      (u32 const   )1581411651U, 
        (u32 const   )3961481572U,      (u32 const   )3959293625U,      (u32 const   )50889899U,      (u32 const   )2398993123U, 
        (u32 const   )1605571027U,      (u32 const   )0U,      (u32 const   )2487488247U,      (u32 const   )4203150314U, 
        (u32 const   )790739884U,      (u32 const   )569926925U,      (u32 const   )3268390488U,      (u32 const   )1521190453U, 
        (u32 const   )2477089066U,      (u32 const   )3474912338U,      (u32 const   )1744454753U,      (u32 const   )4218914682U, 
        (u32 const   )2235364260U,      (u32 const   )480880473U,      (u32 const   )2687335903U,      (u32 const   )1416779924U, 
        (u32 const   )2195561593U,      (u32 const   )3844593688U,      (u32 const   )3788387182U,      (u32 const   )1243744246U, 
        (u32 const   )1158325703U,      (u32 const   )2975170700U,      (u32 const   )3804673989U,      (u32 const   )3065311057U, 
        (u32 const   )4065277446U,      (u32 const   )1222377421U,      (u32 const   )944330162U,      (u32 const   )3049024506U, 
        (u32 const   )1105415857U,      (u32 const   )621907579U,      (u32 const   )341863093U,      (u32 const   )293141843U, 
        (u32 const   )2178226386U,      (u32 const   )1659032455U,      (u32 const   )618722027U,      (u32 const   )1122748954U, 
        (u32 const   )1467669567U,      (u32 const   )3471804610U,      (u32 const   )3715009962U,      (u32 const   )1503855262U, 
        (u32 const   )537467293U,      (u32 const   )2833559603U,      (u32 const   )3731228929U,      (u32 const   )3454471273U, 
        (u32 const   )899157944U,      (u32 const   )929167235U,      (u32 const   )2529031884U,      (u32 const   )3014424759U, 
        (u32 const   )3751245201U,      (u32 const   )197216583U,      (u32 const   )2427315585U,      (u32 const   )85497830U, 
        (u32 const   )3502233504U,      (u32 const   )4089334422U,      (u32 const   )2057478056U,      (u32 const   )1565190632U, 
        (u32 const   )2277837727U,      (u32 const   )3324396846U,      (u32 const   )1694743642U,      (u32 const   )1157355863U, 
        (u32 const   )2438764817U,      (u32 const   )2764347049U,      (u32 const   )1046038271U,      (u32 const   )406866991U, 
        (u32 const   )4251423799U,      (u32 const   )2069095224U,      (u32 const   )1971994009U,      (u32 const   )785434428U, 
        (u32 const   )708389962U,      (u32 const   )4099876171U,      (u32 const   )530654194U,      (u32 const   )3631618636U, 
        (u32 const   )2594033750U,      (u32 const   )3613309053U,      (u32 const   )2454986170U,      (u32 const   )1712011505U, 
        (u32 const   )254321201U,      (u32 const   )3213647405U,      (u32 const   )2676311984U,      (u32 const   )1278350523U, 
        (u32 const   )2297276846U,      (u32 const   )734548186U,      (u32 const   )1434657796U,      (u32 const   )82439030U, 
        (u32 const   )3144004955U,      (u32 const   )1781210731U,      (u32 const   )3908469266U,      (u32 const   )3701469498U, 
        (u32 const   )1693630666U,      (u32 const   )2142898254U,      (u32 const   )2935268222U,      (u32 const   )170931671U, 
        (u32 const   )4011322831U,      (u32 const   )2200756457U,      (u32 const   )431042751U,      (u32 const   )3682508519U, 
        (u32 const   )4237748391U,      (u32 const   )3074790337U,      (u32 const   )2963602460U,      (u32 const   )4048007853U, 
        (u32 const   )4268691612U,      (u32 const   )984657289U,      (u32 const   )1662234391U,      (u32 const   )1939484372U, 
        (u32 const   )2789043858U,      (u32 const   )587308342U,      (u32 const   )49936443U,      (u32 const   )2399979123U, 
        (u32 const   )3308175749U,      (u32 const   )457754756U,      (u32 const   )2019256211U,      (u32 const   )1888660095U, 
        (u32 const   )1954234633U,      (u32 const   )2626536219U,      (u32 const   )1841983926U,      (u32 const   )915442451U, 
        (u32 const   )994169113U,      (u32 const   )2576700669U,      (u32 const   )3601843437U,      (u32 const   )1481801230U, 
        (u32 const   )2658417440U,      (u32 const   )2538375772U,      (u32 const   )2101604469U,      (u32 const   )4121844187U, 
        (u32 const   )4038512189U,      (u32 const   )3552006923U,      (u32 const   )639175376U,      (u32 const   )968370466U};
#line 201 "rng-32bit-tables.h"
static u32 const   Te3[256]  = 
#line 201
  {      (u32 const   )3796933555U,      (u32 const   )3033138787U,      (u32 const   )3835876485U,      (u32 const   )1816527393U, 
        (u32 const   )1866442810U,      (u32 const   )381515174U,      (u32 const   )1292242963U,      (u32 const   )1622776909U, 
        (u32 const   )1790201111U,      (u32 const   )1106873983U,      (u32 const   )2010812386U,      (u32 const   )3959998925U, 
        (u32 const   )168677722U,      (u32 const   )58305051U,      (u32 const   )1716245371U,      (u32 const   )3774306209U, 
        (u32 const   )2774227706U,      (u32 const   )967128554U,      (u32 const   )2725737413U,      (u32 const   )2080979121U, 
        (u32 const   )602398240U,      (u32 const   )1898496212U,      (u32 const   )2416046460U,      (u32 const   )3183377698U, 
        (u32 const   )2152647660U,      (u32 const   )846627513U,      (u32 const   )365223869U,      (u32 const   )3418002633U, 
        (u32 const   )2296698532U,      (u32 const   )1336007681U,      (u32 const   )1697806688U,      (u32 const   )2196310014U, 
        (u32 const   )3732818804U,      (u32 const   )3777573288U,      (u32 const   )666000644U,      (u32 const   )1349047014U, 
        (u32 const   )2372875145U,      (u32 const   )2383845778U,      (u32 const   )44551186U,      (u32 const   )703205242U, 
        (u32 const   )617346847U,      (u32 const   )1115694180U,      (u32 const   )1895212765U,      (u32 const   )3292307646U, 
        (u32 const   )93054253U,      (u32 const   )4109233685U,      (u32 const   )744614487U,      (u32 const   )4113795100U, 
        (u32 const   )1956849145U,      (u32 const   )1188407104U,      (u32 const   )3160415019U,      (u32 const   )2702105054U, 
        (u32 const   )3633054786U,      (u32 const   )881118607U,      (u32 const   )1646153823U,      (u32 const   )1565076099U, 
        (u32 const   )493798133U,      (u32 const   )2614249007U,      (u32 const   )2342354111U,      (u32 const   )504850670U, 
        (u32 const   )218078828U,      (u32 const   )622170390U,      (u32 const   )1230213943U,      (u32 const   )3018207068U, 
        (u32 const   )120334655U,      (u32 const   )3646054987U,      (u32 const   )1746108677U,      (u32 const   )273627792U, 
        (u32 const   )3522723587U,      (u32 const   )1148349266U,      (u32 const   )1049173205U,      (u32 const   )3228115866U, 
        (u32 const   )2508854353U,      (u32 const   )1609492113U,      (u32 const   )4004447711U,      (u32 const   )4161958009U, 
        (u32 const   )3368238802U,      (u32 const   )3200767801U,      (u32 const   )1076357238U,      (u32 const   )145366344U, 
        (u32 const   )1917938383U,      (u32 const   )2584485926U,      (u32 const   )819023531U,      (u32 const   )1413304770U, 
        (u32 const   )260453495U,      (u32 const   )2941684640U,      (u32 const   )3584949287U,      (u32 const   )4276109135U, 
        (u32 const   )337295796U,      (u32 const   )3850154636U,      (u32 const   )4089562922U,      (u32 const   )3374143707U, 
        (u32 const   )4017185750U,      (u32 const   )3604239932U,      (u32 const   )1168903515U,      (u32 const   )1217262910U, 
        (u32 const   )557847090U,      (u32 const   )2787307745U,      (u32 const   )2412314523U,      (u32 const   )2536364099U, 
        (u32 const   )2745767372U,      (u32 const   )1838703656U,      (u32 const   )4038618417U,      (u32 const   )2561403956U, 
        (u32 const   )674523507U,      (u32 const   )3708281199U,      (u32 const   )726516584U,      (u32 const   )3705243494U, 
        (u32 const   )1673541206U,      (u32 const   )4218149474U,      (u32 const   )2019343253U,      (u32 const   )533270247U, 
        (u32 const   )1737864562U,      (u32 const   )1440954315U,      (u32 const   )4232573789U,      (u32 const   )4190901872U, 
        (u32 const   )2319653558U,      (u32 const   )3272640897U,      (u32 const   )3459346916U,      (u32 const   )644627213U, 
        (u32 const   )3332074668U,      (u32 const   )1580236952U,      (u32 const   )2260501722U,      (u32 const   )1130250861U, 
        (u32 const   )1693196137U,      (u32 const   )3119250950U,      (u32 const   )2869102724U,      (u32 const   )3817799098U, 
        (u32 const   )3546264337U,      (u32 const   )0U,      (u32 const   )4153689102U,      (u32 const   )3942287099U, 
        (u32 const   )2888769979U,      (u32 const   )220330085U,      (u32 const   )1489162158U,      (u32 const   )895134598U, 
        (u32 const   )714319201U,      (u32 const   )1389305588U,      (u32 const   )1634204228U,      (u32 const   )2063300487U, 
        (u32 const   )2760195315U,      (u32 const   )1495050663U,      (u32 const   )3751816573U,      (u32 const   )2488562264U, 
        (u32 const   )2038619548U,      (u32 const   )417671128U,      (u32 const   )1860292147U,      (u32 const   )4132053511U, 
        (u32 const   )3343190693U,      (u32 const   )2360432000U,      (u32 const   )3319973559U,      (u32 const   )1370928367U, 
        (u32 const   )116543286U,      (u32 const   )3444104191U,      (u32 const   )2990033237U,      (u32 const   )4206214251U, 
        (u32 const   )2973885262U,      (u32 const   )2066026894U,      (u32 const   )3038011498U,      (u32 const   )1393654013U, 
        (u32 const   )3531724056U,      (u32 const   )2271404755U,      (u32 const   )3945062642U,      (u32 const   )440593354U, 
        (u32 const   )1062697692U,      (u32 const   )3268341640U,      (u32 const   )2866638477U,      (u32 const   )2656674562U, 
        (u32 const   )2636122393U,      (u32 const   )866706608U,      (u32 const   )31352329U,      (u32 const   )1775101708U, 
        (u32 const   )3090520079U,      (u32 const   )2201444855U,      (u32 const   )3432431094U,      (u32 const   )3082005624U, 
        (u32 const   )2447349621U,      (u32 const   )1191952713U,      (u32 const   )2173742565U,      (u32 const   )3859093655U, 
        (u32 const   )2698035159U,      (u32 const   )2532556362U,      (u32 const   )2826609311U,      (u32 const   )3898428137U, 
        (u32 const   )2676475147U,      (u32 const   )784737861U,      (u32 const   )1516569532U,      (u32 const   )1464138713U, 
        (u32 const   )294739097U,      (u32 const   )2846147734U,      (u32 const   )4282276166U,      (u32 const   )790118476U, 
        (u32 const   )939354004U,      (u32 const   )947606499U,      (u32 const   )2574617149U,      (u32 const   )1009701063U, 
        (u32 const   )1244281132U,      (u32 const   )1274306341U,      (u32 const   )4062159139U,      (u32 const   )1289254426U, 
        (u32 const   )1452973520U,      (u32 const   )2111266488U,      (u32 const   )3130151965U,      (u32 const   )4049996600U, 
        (u32 const   )823077026U,      (u32 const   )767528030U,      (u32 const   )2963244359U,      (u32 const   )3142332948U, 
        (u32 const   )2928209321U,      (u32 const   )3660302416U,      (u32 const   )72712996U,      (u32 const   )1980033515U, 
        (u32 const   )1539007925U,      (u32 const   )1802119966U,      (u32 const   )317257346U,      (u32 const   )987537393U, 
        (u32 const   )3395613376U,      (u32 const   )1316993544U,      (u32 const   )2125395107U,      (u32 const   )3607769141U, 
        (u32 const   )3488552941U,      (u32 const   )3917688032U,      (u32 const   )3206132016U,      (u32 const   )3889921694U, 
        (u32 const   )2818348776U,      (u32 const   )3250013587U,      (u32 const   )481338620U,      (u32 const   )2918270898U, 
        (u32 const   )2633920272U,      (u32 const   )2302324909U,      (u32 const   )392369071U,      (u32 const   )3564345902U, 
        (u32 const   )2460368238U,      (u32 const   )908263837U,      (u32 const   )990050808U,      (u32 const   )1938754758U, 
        (u32 const   )2244292289U,      (u32 const   )2216380616U,      (u32 const   )2474138471U,      (u32 const   )2138084010U, 
        (u32 const   )158628673U,      (u32 const   )463244739U,      (u32 const   )3060648561U,      (u32 const   )322343051U, 
        (u32 const   )423313873U,      (u32 const   )4254700884U,      (u32 const   )3990269892U,      (u32 const   )240669310U, 
        (u32 const   )547255355U,      (u32 const   )1553419402U,      (u32 const   )1971143664U,      (u32 const   )3690311257U, 
        (u32 const   )1039185614U,      (u32 const   )198424403U,      (u32 const   )3492157706U,      (u32 const   )574208041U};
#line 267 "rng-32bit-tables.h"
static u32 const   Te4[256]  = 
#line 267
  {      (u32 const   )404232216U,      (u32 const   )589505315U,      (u32 const   )3334915782U,      (u32 const   )3907578088U, 
        (u32 const   )2273806215U,      (u32 const   )3099113656U,      (u32 const   )16843009U,      (u32 const   )1330597711U, 
        (u32 const   )909522486U,      (u32 const   )2795939494U,      (u32 const   )3537031890U,      (u32 const   )4126537205U, 
        (u32 const   )2038004089U,      (u32 const   )1869573999U,      (u32 const   )2442236305U,      (u32 const   )1381126738U, 
        (u32 const   )1616928864U,      (u32 const   )3166485692U,      (u32 const   )2610666395U,      (u32 const   )2391707278U, 
        (u32 const   )2745410467U,      (u32 const   )202116108U,      (u32 const   )2071690107U,      (u32 const   )892679477U, 
        (u32 const   )488447261U,      (u32 const   )3772834016U,      (u32 const   )3621246935U,      (u32 const   )3267543746U, 
        (u32 const   )774778414U,      (u32 const   )1263225675U,      (u32 const   )4278124286U,      (u32 const   )1465341783U, 
        (u32 const   )353703189U,      (u32 const   )2004318071U,      (u32 const   )926365495U,      (u32 const   )3857049061U, 
        (u32 const   )2678038431U,      (u32 const   )4042322160U,      (u32 const   )1246382666U,      (u32 const   )3671775962U, 
        (u32 const   )1482184792U,      (u32 const   )3385444809U,      (u32 const   )690563369U,      (u32 const   )168430090U, 
        (u32 const   )2981212593U,      (u32 const   )2694881440U,      (u32 const   )1802201963U,      (u32 const   )2240120197U, 
        (u32 const   )3183328701U,      (u32 const   )1566399837U,      (u32 const   )269488144U,      (u32 const   )4109694196U, 
        (u32 const   )3419130827U,      (u32 const   )1044266558U,      (u32 const   )84215045U,      (u32 const   )1734829927U, 
        (u32 const   )3840206052U,      (u32 const   )656877351U,      (u32 const   )1094795585U,      (u32 const   )2341178251U, 
        (u32 const   )2812782503U,      (u32 const   )2105376125U,      (u32 const   )2509608341U,      (u32 const   )3638089944U, 
        (u32 const   )4227595259U,      (u32 const   )4008636142U,      (u32 const   )2088533116U,      (u32 const   )1717986918U, 
        (u32 const   )3722304989U,      (u32 const   )387389207U,      (u32 const   )1195853639U,      (u32 const   )2661195422U, 
        (u32 const   )3402287818U,      (u32 const   )757935405U,      (u32 const   )3217014719U,      (u32 const   )117901063U, 
        (u32 const   )2913840557U,      (u32 const   )1515870810U,      (u32 const   )2206434179U,      (u32 const   )858993459U, 
        (u32 const   )1667457891U,      (u32 const   )33686018U,      (u32 const   )2863311530U,      (u32 const   )1903260017U, 
        (u32 const   )3368601800U,      (u32 const   )421075225U,      (u32 const   )1229539657U,      (u32 const   )3654932953U, 
        (u32 const   )4076008178U,      (u32 const   )3823363043U,      (u32 const   )1532713819U,      (u32 const   )2290649224U, 
        (u32 const   )2593823386U,      (u32 const   )640034342U,      (u32 const   )842150450U,      (u32 const   )2964369584U, 
        (u32 const   )3924421097U,      (u32 const   )252645135U,      (u32 const   )3587560917U,      (u32 const   )2155905152U, 
        (u32 const   )3200171710U,      (u32 const   )3452816845U,      (u32 const   )875836468U,      (u32 const   )1212696648U, 
        (u32 const   )4294967295U,      (u32 const   )2054847098U,      (u32 const   )2425393296U,      (u32 const   )1600085855U, 
        (u32 const   )538976288U,      (u32 const   )1751672936U,      (u32 const   )437918234U,      (u32 const   )2930683566U, 
        (u32 const   )3031741620U,      (u32 const   )1414812756U,      (u32 const   )2475922323U,      (u32 const   )572662306U, 
        (u32 const   )1684300900U,      (u32 const   )4059165169U,      (u32 const   )1936946035U,      (u32 const   )303174162U, 
        (u32 const   )1077952576U,      (u32 const   )134744072U,      (u32 const   )3284386755U,      (u32 const   )3974950124U, 
        (u32 const   )3688618971U,      (u32 const   )2711724449U,      (u32 const   )2374864269U,      (u32 const   )1027423549U, 
        (u32 const   )2543294359U,      (u32 const   )0U,      (u32 const   )3486502863U,      (u32 const   )724249387U, 
        (u32 const   )1987475062U,      (u32 const   )2189591170U,      (u32 const   )3604403926U,      (u32 const   )454761243U, 
        (u32 const   )3048584629U,      (u32 const   )2947526575U,      (u32 const   )1785358954U,      (u32 const   )1347440720U, 
        (u32 const   )1162167621U,      (u32 const   )4092851187U,      (u32 const   )808464432U,      (u32 const   )4025479151U, 
        (u32 const   )1061109567U,      (u32 const   )1431655765U,      (u32 const   )2728567458U,      (u32 const   )3941264106U, 
        (u32 const   )1701143909U,      (u32 const   )3132799674U,      (u32 const   )791621423U,      (u32 const   )3233857728U, 
        (u32 const   )3739147998U,      (u32 const   )471604252U,      (u32 const   )4261281277U,      (u32 const   )1296911693U, 
        (u32 const   )2459079314U,      (u32 const   )1970632053U,      (u32 const   )101058054U,      (u32 const   )2324335242U, 
        (u32 const   )2998055602U,      (u32 const   )3873892070U,      (u32 const   )235802126U,      (u32 const   )522133279U, 
        (u32 const   )1650614882U,      (u32 const   )3570717908U,      (u32 const   )2829625512U,      (u32 const   )2526451350U, 
        (u32 const   )4193909241U,      (u32 const   )3318072773U,      (u32 const   )623191333U,      (u32 const   )1499027801U, 
        (u32 const   )2223277188U,      (u32 const   )1920103026U,      (u32 const   )960051513U,      (u32 const   )1280068684U, 
        (u32 const   )1583242846U,      (u32 const   )2021161080U,      (u32 const   )943208504U,      (u32 const   )2358021260U, 
        (u32 const   )3520188881U,      (u32 const   )2779096485U,      (u32 const   )3806520034U,      (u32 const   )1633771873U, 
        (u32 const   )3014898611U,      (u32 const   )555819297U,      (u32 const   )2627509404U,      (u32 const   )505290270U, 
        (u32 const   )1128481603U,      (u32 const   )3351758791U,      (u32 const   )4244438268U,      (u32 const   )67372036U, 
        (u32 const   )1364283729U,      (u32 const   )2576980377U,      (u32 const   )1835887981U,      (u32 const   )218959117U, 
        (u32 const   )4210752250U,      (u32 const   )3755991007U,      (u32 const   )2122219134U,      (u32 const   )606348324U, 
        (u32 const   )993737531U,      (u32 const   )2880154539U,      (u32 const   )3469659854U,      (u32 const   )286331153U, 
        (u32 const   )2408550287U,      (u32 const   )1313754702U,      (u32 const   )3082270647U,      (u32 const   )3958107115U, 
        (u32 const   )1010580540U,      (u32 const   )2172748161U,      (u32 const   )2492765332U,      (u32 const   )4160223223U, 
        (u32 const   )3115956665U,      (u32 const   )320017171U,      (u32 const   )741092396U,      (u32 const   )3553874899U, 
        (u32 const   )3890735079U,      (u32 const   )1852730990U,      (u32 const   )3301229764U,      (u32 const   )50529027U, 
        (u32 const   )1448498774U,      (u32 const   )1145324612U,      (u32 const   )2139062143U,      (u32 const   )2846468521U, 
        (u32 const   )707406378U,      (u32 const   )3149642683U,      (u32 const   )3250700737U,      (u32 const   )1397969747U, 
        (u32 const   )3705461980U,      (u32 const   )185273099U,      (u32 const   )2644352413U,      (u32 const   )1819044972U, 
        (u32 const   )825307441U,      (u32 const   )1953789044U,      (u32 const   )4143380214U,      (u32 const   )1179010630U, 
        (u32 const   )2896997548U,      (u32 const   )2307492233U,      (u32 const   )336860180U,      (u32 const   )3789677025U, 
        (u32 const   )370546198U,      (u32 const   )976894522U,      (u32 const   )1768515945U,      (u32 const   )151587081U, 
        (u32 const   )1886417008U,      (u32 const   )3065427638U,      (u32 const   )3503345872U,      (u32 const   )3991793133U, 
        (u32 const   )3435973836U,      (u32 const   )1111638594U,      (u32 const   )2560137368U,      (u32 const   )2762253476U, 
        (u32 const   )673720360U,      (u32 const   )1549556828U,      (u32 const   )4177066232U,      (u32 const   )2256963206U};
#line 53 "rng-alg-fst.c"
static u32 const   rcon[10]  = 
#line 53 "rng-alg-fst.c"
  {      (u32 const   )16777216,      (u32 const   )33554432,      (u32 const   )67108864,      (u32 const   )134217728, 
        (u32 const   )268435456,      (u32 const   )536870912,      (u32 const   )1073741824,      (u32 const   )(-0x7FFFFFFF-1), 
        (u32 const   )452984832,      (u32 const   )905969664};
#line 63 "rng-alg-fst.c"
unsigned char Sc[256]  ;
#line 64 "rng-alg-fst.c"
u32 STe0[256]  ;
#line 65 "rng-alg-fst.c"
u32 STe1[256]  ;
#line 66 "rng-alg-fst.c"
u32 STe2[256]  ;
#line 67 "rng-alg-fst.c"
u32 STe3[256]  ;
#line 68 "rng-alg-fst.c"
u32 STe4[256]  ;
#line 86 "rng-alg-fst.c"
int rngKeySetupEnc(u32 *rk , u8 const   *cipherKey , int keyBits ) 
{ int i ;
  unsigned char rbytes[512] ;
  unsigned char u8_swap ;
  u32 u32_swap ;
  u32 temp ;
  u32 *rks ;
  int q ;
  unsigned char z ;
  unsigned char x ;
  unsigned char y ;

  {
#line 87
  i = 0;
#line 94
  rks = rk;
#line 96
  *(rk + 0) = ((((u32 )*(cipherKey + 0) << 24) ^ ((u32 )*(cipherKey + 1) << 16)) ^ ((u32 )*(cipherKey + 2) << 8)) ^ (u32 )*(cipherKey + 3);
#line 97
  *(rk + 1) = ((((u32 )*((cipherKey + 4) + 0) << 24) ^ ((u32 )*((cipherKey + 4) + 1) << 16)) ^ ((u32 )*((cipherKey + 4) + 2) << 8)) ^ (u32 )*((cipherKey + 4) + 3);
#line 98
  *(rk + 2) = ((((u32 )*((cipherKey + 8) + 0) << 24) ^ ((u32 )*((cipherKey + 8) + 1) << 16)) ^ ((u32 )*((cipherKey + 8) + 2) << 8)) ^ (u32 )*((cipherKey + 8) + 3);
#line 99
  *(rk + 3) = ((((u32 )*((cipherKey + 12) + 0) << 24) ^ ((u32 )*((cipherKey + 12) + 1) << 16)) ^ ((u32 )*((cipherKey + 12) + 2) << 8)) ^ (u32 )*((cipherKey + 12) + 3);
#line 100
  if (keyBits == 128) {
#line 101
    while (1) {
#line 102
      temp = *(rk + 3);
#line 103
      *(rk + 4) = ((((*(rk + 0) ^ (unsigned int )(Te4[(temp >> 16) & 255U] & 4278190080U)) ^ (unsigned int )(Te4[(temp >> 8) & 255U] & 16711680U)) ^ (unsigned int )(Te4[temp & 255U] & 65280U)) ^ (unsigned int )(Te4[temp >> 24] & 255U)) ^ (unsigned int )rcon[i];
#line 109
      *(rk + 5) = *(rk + 1) ^ *(rk + 4);
#line 110
      *(rk + 6) = *(rk + 2) ^ *(rk + 5);
#line 111
      *(rk + 7) = *(rk + 3) ^ *(rk + 6);
#line 112
      i ++;
#line 112
      if (i == 10) {
#line 113
        break;
      }
#line 115
      rk += 4;
    }
  } else {
#line 119
    printf("Fatal error during rng setup\n");
#line 120
    exit(1);
  }
#line 123
  i = 0;
#line 123
  while (i < 256) {
#line 124
    Sc[i] = (unsigned char )i;
#line 125
    STe0[i] = (u32 )Te0[i];
#line 126
    STe1[i] = (u32 )Te1[i];
#line 127
    STe2[i] = (u32 )Te2[i];
#line 128
    STe3[i] = (u32 )Te3[i];
#line 129
    STe4[i] = (u32 )Te4[i];
#line 123
    i ++;
  }
#line 133
  i = 0;
#line 133
  while (i < 512) {
#line 134
    rbytes[i] = (unsigned char )((i * 7) % 256);
#line 135
    if (i > 255) {
#line 135
      rbytes[i] = (unsigned char )((int )rbytes[i] ^ 255);
    }
#line 133
    i ++;
  }
#line 140
  i = 0;
#line 140
  while (i < 512) {
#line 142
    rngEncrypt((u32 const   *)rks, 10, (u8 const   *)(rbytes + i), (u8 *)(rbytes + i));
#line 143
    q = 0;
#line 143
    while (q < 16) {
#line 145
      z = rbytes[i + q];
#line 150
      u8_swap = Sc[z];
#line 151
      Sc[z] = Sc[1];
#line 152
      Sc[1] = u8_swap;
#line 155
      x = Sc[z];
#line 156
      y = Sc[1];
#line 159
      u32_swap = STe0[x];
#line 160
      STe0[x] = STe0[y];
#line 161
      STe0[y] = u32_swap;
#line 163
      u32_swap = STe1[x];
#line 164
      STe1[x] = STe1[y];
#line 165
      STe1[y] = u32_swap;
#line 167
      u32_swap = STe2[x];
#line 168
      STe2[x] = STe2[y];
#line 169
      STe2[y] = u32_swap;
#line 171
      u32_swap = STe3[x];
#line 172
      STe3[x] = STe3[y];
#line 173
      STe3[y] = u32_swap;
#line 175
      u32_swap = STe4[x];
#line 176
      STe4[x] = STe4[y];
#line 177
      STe4[y] = u32_swap;
#line 143
      q ++;
    }
#line 140
    i += 16;
  }
#line 182
  return (10);
}
}
#line 185 "rng-alg-fst.c"
void rngEncrypt(u32 const   *rk , int Nr , u8 const   *pt , u8 *ct ) 
{ u32 s0 ;
  u32 s1 ;
  u32 s2 ;
  u32 s3 ;
  u32 t0 ;
  u32 t1 ;
  u32 t2 ;
  u32 t3 ;
  int r ;

  {
#line 193
  s0 = (((((u32 )*(pt + 0) << 24) ^ ((u32 )*(pt + 1) << 16)) ^ ((u32 )*(pt + 2) << 8)) ^ (u32 )*(pt + 3)) ^ (unsigned int )*(rk + 0);
#line 194
  s1 = (((((u32 )*((pt + 4) + 0) << 24) ^ ((u32 )*((pt + 4) + 1) << 16)) ^ ((u32 )*((pt + 4) + 2) << 8)) ^ (u32 )*((pt + 4) + 3)) ^ (unsigned int )*(rk + 1);
#line 195
  s2 = (((((u32 )*((pt + 8) + 0) << 24) ^ ((u32 )*((pt + 8) + 1) << 16)) ^ ((u32 )*((pt + 8) + 2) << 8)) ^ (u32 )*((pt + 8) + 3)) ^ (unsigned int )*(rk + 2);
#line 196
  s3 = (((((u32 )*((pt + 12) + 0) << 24) ^ ((u32 )*((pt + 12) + 1) << 16)) ^ ((u32 )*((pt + 12) + 2) << 8)) ^ (u32 )*((pt + 12) + 3)) ^ (unsigned int )*(rk + 3);
#line 201
  t0 = (u32 )Sc[0];
#line 202
  t1 = (u32 )Sc[32];
#line 203
  t2 = (u32 )Sc[64];
#line 204
  t3 = (u32 )Sc[96];
#line 205
  t0 = (u32 )Sc[128];
#line 206
  t1 = (u32 )Sc[160];
#line 207
  t2 = (u32 )Sc[192];
#line 208
  t3 = (u32 )Sc[224];
#line 213
  r = Nr >> 1;
#line 214
  while (1) {
#line 215
    t0 = (((STe0[Sc[s0 >> 24]] ^ STe1[Sc[(s1 >> 16) & 255U]]) ^ STe2[Sc[(s2 >> 8) & 255U]]) ^ STe3[Sc[s3 & 255U]]) ^ (unsigned int )*(rk + 4);
#line 221
    t1 = (((STe0[Sc[s1 >> 24]] ^ STe1[Sc[(s2 >> 16) & 255U]]) ^ STe2[Sc[(s3 >> 8) & 255U]]) ^ STe3[Sc[s0 & 255U]]) ^ (unsigned int )*(rk + 5);
#line 227
    t2 = (((STe0[Sc[s2 >> 24]] ^ STe1[Sc[(s3 >> 16) & 255U]]) ^ STe2[Sc[(s0 >> 8) & 255U]]) ^ STe3[Sc[s1 & 255U]]) ^ (unsigned int )*(rk + 6);
#line 233
    t3 = (((STe0[Sc[s3 >> 24]] ^ STe1[Sc[(s0 >> 16) & 255U]]) ^ STe2[Sc[(s1 >> 8) & 255U]]) ^ STe3[Sc[s2 & 255U]]) ^ (unsigned int )*(rk + 7);
#line 240
    rk += 8;
#line 241
    r --;
#line 241
    if (r == 0) {
#line 242
      break;
    }
#line 245
    s0 = (((STe0[Sc[t0 >> 24]] ^ STe1[Sc[(t1 >> 16) & 255U]]) ^ STe2[Sc[(t2 >> 8) & 255U]]) ^ STe3[Sc[t3 & 255U]]) ^ (unsigned int )*(rk + 0);
#line 251
    s1 = (((STe0[Sc[t1 >> 24]] ^ STe1[Sc[(t2 >> 16) & 255U]]) ^ STe2[Sc[(t3 >> 8) & 255U]]) ^ STe3[Sc[t0 & 255U]]) ^ (unsigned int )*(rk + 1);
#line 257
    s2 = (((STe0[Sc[t2 >> 24]] ^ STe1[Sc[(t3 >> 16) & 255U]]) ^ STe2[Sc[(t0 >> 8) & 255U]]) ^ STe3[Sc[t1 & 255U]]) ^ (unsigned int )*(rk + 2);
#line 263
    s3 = (((STe0[Sc[t3 >> 24]] ^ STe1[Sc[(t0 >> 16) & 255U]]) ^ STe2[Sc[(t1 >> 8) & 255U]]) ^ STe3[Sc[t2 & 255U]]) ^ (unsigned int )*(rk + 3);
  }
#line 274
  s0 = ((((STe4[Sc[t0 >> 24]] & 4278190080U) ^ (STe4[Sc[(t1 >> 16) & 255U]] & 16711680U)) ^ (STe4[Sc[(t2 >> 8) & 255U]] & 65280U)) ^ (STe4[Sc[t3 & 255U]] & 255U)) ^ (unsigned int )*(rk + 0);
#line 280
  *(ct + 0) = (u8 )(s0 >> 24);
#line 280
  *(ct + 1) = (u8 )(s0 >> 16);
#line 280
  *(ct + 2) = (u8 )(s0 >> 8);
#line 280
  *(ct + 3) = (u8 )s0;
#line 281
  s1 = ((((STe4[Sc[t1 >> 24]] & 4278190080U) ^ (STe4[Sc[(t2 >> 16) & 255U]] & 16711680U)) ^ (STe4[Sc[(t3 >> 8) & 255U]] & 65280U)) ^ (STe4[Sc[t0 & 255U]] & 255U)) ^ (unsigned int )*(rk + 1);
#line 287
  *((ct + 4) + 0) = (u8 )(s1 >> 24);
#line 287
  *((ct + 4) + 1) = (u8 )(s1 >> 16);
#line 287
  *((ct + 4) + 2) = (u8 )(s1 >> 8);
#line 287
  *((ct + 4) + 3) = (u8 )s1;
#line 288
  s2 = ((((STe4[Sc[t2 >> 24]] & 4278190080U) ^ (STe4[Sc[(t3 >> 16) & 255U]] & 16711680U)) ^ (STe4[Sc[(t0 >> 8) & 255U]] & 65280U)) ^ (STe4[Sc[t1 & 255U]] & 255U)) ^ (unsigned int )*(rk + 2);
#line 294
  *((ct + 8) + 0) = (u8 )(s2 >> 24);
#line 294
  *((ct + 8) + 1) = (u8 )(s2 >> 16);
#line 294
  *((ct + 8) + 2) = (u8 )(s2 >> 8);
#line 294
  *((ct + 8) + 3) = (u8 )s2;
#line 295
  s3 = ((((STe4[Sc[t3 >> 24]] & 4278190080U) ^ (STe4[Sc[(t0 >> 16) & 255U]] & 16711680U)) ^ (STe4[Sc[(t1 >> 8) & 255U]] & 65280U)) ^ (STe4[Sc[t2 & 255U]] & 255U)) ^ (unsigned int )*(rk + 3);
#line 301
  *((ct + 12) + 0) = (u8 )(s3 >> 24);
#line 301
  *((ct + 12) + 1) = (u8 )(s3 >> 16);
#line 301
  *((ct + 12) + 2) = (u8 )(s3 >> 8);
#line 301
  *((ct + 12) + 3) = (u8 )s3;
#line 302
  return;
}
}
