/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

#line 134 "/usr/include/bits/types.h"
typedef unsigned long __dev_t;
#line 135 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 136 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 137 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 138 "/usr/include/bits/types.h"
typedef unsigned long __ino64_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned long __nlink_t;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 149 "/usr/include/bits/types.h"
typedef long __time_t;
#line 164 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 169 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 170 "/usr/include/bits/types.h"
typedef long __blkcnt64_t;
#line 71 "/usr/include/sys/types.h"
typedef __mode_t mode_t;
#line 211 "/usr/lib/x86_64-linux-gnu/gcc/x86_64-linux-gnu/4.5.2/include/stddef.h"
typedef unsigned long size_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 323 "/usr/lib/x86_64-linux-gnu/gcc/x86_64-linux-gnu/4.5.2/include/stddef.h"
typedef int wchar_t;
#line 46 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   long __unused[3] ;
};
#line 119 "/usr/include/bits/stat.h"
struct stat64 {
   __dev_t st_dev ;
   __ino64_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   long __unused[3] ;
};
#line 27 "allocator.h"
struct allocator {
   void *(*allocate)(size_t  ) ;
   void *(*reallocate)(void * , size_t  ) ;
   void (*free)(void * ) ;
   void (*die)(size_t  ) ;
};
#line 142 "/usr/include/bits/types.h"
typedef long __off64_t;
#line 180 "/usr/include/bits/types.h"
typedef long __ssize_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 149 "/usr/lib/x86_64-linux-gnu/gcc/x86_64-linux-gnu/4.5.2/include/stddef.h"
typedef long ptrdiff_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/x86_64-linux-gnu/gcc/x86_64-linux-gnu/4.5.2/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 341 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 889 "/usr/include/stdio.h"
struct obstack;
#line 32 "quotearg.h"
enum quoting_style {
    literal_quoting_style = 0,
    shell_quoting_style = 1,
    shell_always_quoting_style = 2,
    c_quoting_style = 3,
    c_maybe_quoting_style = 4,
    escape_quoting_style = 5,
    locale_quoting_style = 6,
    clocale_quoting_style = 7,
    custom_quoting_style = 8
} ;
#line 23 "argv-iter.h"
struct argv_iterator;
#line 25
enum argv_iter_err {
    AI_ERR_OK = 1,
    AI_ERR_EOF = 2,
    AI_ERR_MEM = 3,
    AI_ERR_READ = 4
} ;
#line 25 "argv-iter.c"
struct argv_iterator {
   FILE *fp ;
   size_t item_idx ;
   char *tok ;
   size_t buf_len ;
   char **arg_list ;
   char **p ;
};
#line 28 "backupfile.h"
enum backup_type {
    no_backups = 0,
    simple_backups = 1,
    numbered_existing_backups = 2,
    numbered_backups = 3
} ;
#line 23 "/usr/include/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 128 "/usr/include/dirent.h"
struct __dirstream;
#line 128 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 146 "backupfile.c"
enum numbered_backup_result {
    BACKUP_IS_SAME_LENGTH = 0,
    BACKUP_IS_LONGER = 1,
    BACKUP_IS_NEW = 2
} ;
#line 34 "base64.h"
struct base64_decode_context {
   unsigned int i ;
   char buf[4] ;
};
#line 28 "/usr/include/xlocale.h"
struct __locale_data;
#line 28 "/usr/include/xlocale.h"
struct __locale_struct {
   struct __locale_data *__locales[13] ;
   unsigned short const   *__ctype_b ;
   int const   *__ctype_tolower ;
   int const   *__ctype_toupper ;
   char const   *__names[13] ;
};
#line 28 "/usr/include/xlocale.h"
typedef struct __locale_struct *__locale_t;
#line 43 "/usr/include/xlocale.h"
typedef __locale_t locale_t;
#line 192 "/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 50 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 44 "/usr/include/bits/uio.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 35 "/usr/include/bits/socket.h"
typedef __socklen_t socklen_t;
#line 29 "/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 178 "/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 251 "/usr/include/bits/socket.h"
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
#line 278 "/usr/include/bits/socket.h"
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
#line 92 "/usr/include/sys/socket.h"
struct sockaddr_at;
#line 92
struct sockaddr_ax25;
#line 92
struct sockaddr_dl;
#line 92
struct sockaddr_eon;
#line 92
struct sockaddr_in;
#line 92
struct sockaddr_in6;
#line 92
struct sockaddr_inarp;
#line 92
struct sockaddr_ipx;
#line 92
struct sockaddr_iso;
#line 92
struct sockaddr_ns;
#line 92
struct sockaddr_un;
#line 92
struct sockaddr_x25;
#line 92 "/usr/include/sys/socket.h"
union __anonunion___SOCKADDR_ARG_18 {
   struct sockaddr * __restrict  __sockaddr__ ;
   struct sockaddr_at * __restrict  __sockaddr_at__ ;
   struct sockaddr_ax25 * __restrict  __sockaddr_ax25__ ;
   struct sockaddr_dl * __restrict  __sockaddr_dl__ ;
   struct sockaddr_eon * __restrict  __sockaddr_eon__ ;
   struct sockaddr_in * __restrict  __sockaddr_in__ ;
   struct sockaddr_in6 * __restrict  __sockaddr_in6__ ;
   struct sockaddr_inarp * __restrict  __sockaddr_inarp__ ;
   struct sockaddr_ipx * __restrict  __sockaddr_ipx__ ;
   struct sockaddr_iso * __restrict  __sockaddr_iso__ ;
   struct sockaddr_ns * __restrict  __sockaddr_ns__ ;
   struct sockaddr_un * __restrict  __sockaddr_un__ ;
   struct sockaddr_x25 * __restrict  __sockaddr_x25__ ;
};
#line 92 "/usr/include/sys/socket.h"
typedef union __anonunion___SOCKADDR_ARG_18  __attribute__((__transparent_union__)) __SOCKADDR_ARG;
#line 97 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 141 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 142 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 198 "/usr/include/netinet/in.h"
union __anonunion___in6_u_22 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 198 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion___in6_u_22 __in6_u ;
};
#line 225 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 239 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 569 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 22 "canonicalize.h"
enum canonicalize_mode_t {
    CAN_EXISTING = 0,
    CAN_ALL_BUT_LAST = 1,
    CAN_MISSING = 2
} ;
#line 33 "canonicalize.h"
typedef enum canonicalize_mode_t canonicalize_mode_t;
#line 43 "hash.h"
struct hash_tuning {
   float shrink_threshold ;
   float shrink_factor ;
   float growth_threshold ;
   float growth_factor ;
   _Bool is_n_buckets ;
};
#line 55 "hash.h"
typedef struct hash_tuning Hash_tuning;
#line 57
struct hash_table;
#line 59 "hash.h"
typedef struct hash_table Hash_table;
#line 91 "/usr/include/stdio.h"
typedef __off_t off_t;
#line 64 "md5.h"
struct md5_ctx {
   uint32_t A ;
   uint32_t B ;
   uint32_t C ;
   uint32_t D ;
   uint32_t total[2] ;
   uint32_t buflen ;
   uint32_t buffer[32] ;
};
#line 35 "sha1.h"
struct sha1_ctx {
   uint32_t A ;
   uint32_t B ;
   uint32_t C ;
   uint32_t D ;
   uint32_t E ;
   uint32_t total[2] ;
   uint32_t buflen ;
   uint32_t buffer[32] ;
};
#line 29 "sha256.h"
struct sha256_ctx {
   uint32_t state[8] ;
   uint32_t total[2] ;
   size_t buflen ;
   uint32_t buffer[32] ;
};
#line 56 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 29 "u64.h"
typedef uint64_t u64;
#line 30 "sha512.h"
struct sha512_ctx {
   u64 state[8] ;
   u64 total[2] ;
   size_t buflen ;
   u64 buffer[32] ;
};
#line 49 "/usr/include/sys/types.h"
typedef __ino_t ino_t;
#line 61 "/usr/include/sys/types.h"
typedef __dev_t dev_t;
#line 136 "/usr/include/stdint.h"
typedef unsigned long uintmax_t;
#line 7 "dev-ino.h"
struct dev_ino {
   ino_t st_ino ;
   dev_t st_dev ;
};
#line 28 "cycle-check.h"
struct cycle_check_state {
   struct dev_ino dev_ino ;
   uintmax_t chdir_counter ;
   int magic ;
};
#line 13 "di-set.h"
struct di_set;
#line 15 "ino-map.h"
struct ino_map;
#line 33 "di-set.c"
typedef size_t hashint;
#line 52 "di-set.c"
struct di_ent {
   dev_t dev ;
   struct hash_table *ino_set ;
};
#line 59 "di-set.c"
struct di_set {
   struct hash_table *dev_map ;
   struct ino_map *ino_map ;
   struct di_ent *probe ;
};
#line 76 "/usr/include/time.h"
typedef __time_t time_t;
#line 41 "/usr/include/bits/types.h"
typedef int __int32_t;
#line 65 "/usr/include/stdio.h"
typedef struct _IO_FILE __FILE;
#line 83 "/usr/include/wchar.h"
union __anonunion___value_4 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 83 "/usr/include/wchar.h"
struct __anonstruct___mbstate_t_3 {
   int __count ;
   union __anonunion___value_4 __value ;
};
#line 83 "/usr/include/wchar.h"
typedef struct __anonstruct___mbstate_t_3 __mbstate_t;
#line 352 "/usr/lib/x86_64-linux-gnu/gcc/x86_64-linux-gnu/4.5.2/include/stddef.h"
typedef unsigned int wint_t;
#line 106 "/usr/include/wchar.h"
typedef __mbstate_t mbstate_t;
#line 40 "exclude.h"
struct exclude;
#line 161 "mbchar.h"
struct mbchar {
   char const   *ptr ;
   size_t bytes ;
   _Bool wc_valid ;
   wchar_t wc ;
   char buf[24] ;
};
#line 173 "mbchar.h"
typedef struct mbchar mbchar_t;
#line 109 "mbuiter.h"
struct mbuiter_multi {
   _Bool in_shift ;
   mbstate_t state ;
   _Bool next_done ;
   struct mbchar cur ;
};
#line 202 "mbuiter.h"
typedef struct mbuiter_multi mbui_iterator_t;
#line 74 "exclude.c"
struct patopts {
   char const   *pattern ;
   int options ;
};
#line 82 "exclude.c"
struct exclude_pattern {
   struct patopts *exclude ;
   size_t exclude_alloc ;
   size_t exclude_count ;
};
#line 89
enum exclude_type {
    exclude_hash = 0,
    exclude_pattern = 1
} ;
#line 95 "exclude.c"
union __anonunion_v_31 {
   Hash_table *table ;
   struct exclude_pattern pat ;
};
#line 95 "exclude.c"
struct exclude_segment {
   struct exclude_segment *next ;
   enum exclude_type type ;
   int options ;
   union __anonunion_v_31 v ;
};
#line 108 "exclude.c"
struct exclude {
   struct exclude_segment *head ;
   struct exclude_segment *tail ;
};
#line 45 "fadvise.h"
enum __anonenum_fadvice_t_20 {
    FADVISE_NORMAL = 0,
    FADVISE_SEQUENTIAL = 2,
    FADVISE_NOREUSE = 5,
    FADVISE_DONTNEED = 4,
    FADVISE_WILLNEED = 3,
    FADVISE_RANDOM = 1
} ;
#line 45 "fadvise.h"
typedef enum __anonenum_fadvice_t_20 fadvice_t;
#line 102 "/usr/lib/x86_64-linux-gnu/gcc/x86_64-linux-gnu/4.5.2/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 9 "hash-triple.h"
struct F_triple {
   char *name ;
   ino_t st_ino ;
   dev_t st_dev ;
};
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 151 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 158 "/usr/include/bits/types.h"
typedef int __clockid_t;
#line 92 "/usr/include/time.h"
typedef __clockid_t clockid_t;
#line 75 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 57 "/usr/include/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 63 "/usr/include/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 66 "/usr/include/sys/types.h"
typedef __gid_t gid_t;
#line 44 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 46 "hash.c"
struct hash_entry {
   void *data ;
   struct hash_entry *next ;
};
#line 52 "hash.c"
struct hash_table {
   struct hash_entry *bucket ;
   struct hash_entry  const  *bucket_limit ;
   size_t n_buckets ;
   size_t n_buckets_used ;
   size_t n_entries ;
   Hash_tuning const   *tuning ;
   size_t (*hasher)(void const   * , size_t  ) ;
   _Bool (*comparator)(void const   * , void const   * ) ;
   void (*data_freer)(void * ) ;
   struct hash_entry *free_entry_list ;
};
#line 23 "heap.h"
struct heap;
#line 33 "heap.c"
struct heap {
   void **array ;
   size_t capacity ;
   size_t count ;
   int (*compare)(void const   * , void const   * ) ;
};
#line 135 "/usr/include/stdint.h"
typedef long intmax_t;
#line 35 "/usr/include/inttypes.h"
typedef int __gwchar_t;
#line 26 "./xstrtol.h"
enum strtol_error {
    LONGINT_OK = 0,
    LONGINT_OVERFLOW = 1,
    LONGINT_INVALID_SUFFIX_CHAR = 2,
    LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW = 3,
    LONGINT_INVALID = 4
} ;
#line 39 "./xstrtol.h"
typedef enum strtol_error strtol_error;
#line 54 "/usr/include/locale.h"
struct lconv {
   char *decimal_point ;
   char *thousands_sep ;
   char *grouping ;
   char *int_curr_symbol ;
   char *currency_symbol ;
   char *mon_decimal_point ;
   char *mon_thousands_sep ;
   char *mon_grouping ;
   char *positive_sign ;
   char *negative_sign ;
   char int_frac_digits ;
   char frac_digits ;
   char p_cs_precedes ;
   char p_sep_by_space ;
   char n_cs_precedes ;
   char n_sep_by_space ;
   char p_sign_posn ;
   char n_sign_posn ;
   char int_p_cs_precedes ;
   char int_p_sep_by_space ;
   char int_n_cs_precedes ;
   char int_n_sep_by_space ;
   char int_p_sign_posn ;
   char int_n_sign_posn ;
};
#line 31 "i-ring.h"
struct I_ring {
   int ir_data[4] ;
   int ir_default_val ;
   unsigned int ir_front ;
   unsigned int ir_back ;
   _Bool ir_empty ;
};
#line 39 "i-ring.h"
typedef struct I_ring I_ring;
#line 81 "/usr/include/sys/types.h"
typedef __uid_t uid_t;
#line 50 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 36 "idcache.c"
union __anonunion_id_24 {
   uid_t u ;
   gid_t g ;
};
#line 36 "idcache.c"
struct userid {
   union __anonunion_id_24 id ;
   struct userid *next ;
   char name[] ;
};
#line 31 "ino-map.c"
struct ino_map_ent {
   ino_t ino ;
   size_t mapped_ino ;
};
#line 38 "ino-map.c"
struct ino_map {
   struct hash_table *map ;
   size_t next_mapped_ino ;
   struct ino_map_ent *probe ;
};
#line 26 "linebuffer.h"
struct linebuffer {
   size_t size ;
   size_t length ;
   char *buffer ;
};
#line 37 "/usr/include/nl_types.h"
typedef int nl_item;
#line 50 "/usr/include/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 61 "/usr/include/bits/pthreadtypes.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 61 "/usr/include/bits/pthreadtypes.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 76 "/usr/include/bits/pthreadtypes.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   int __spins ;
   __pthread_list_t __list ;
};
#line 76 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_11 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 76 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_11 pthread_mutex_t;
#line 106 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_mutexattr_t_12 {
   char __size[4] ;
   int __align ;
};
#line 106 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutexattr_t_12 pthread_mutexattr_t;
#line 144 "/usr/include/bits/pthreadtypes.h"
typedef int pthread_once_t;
#line 278 "./glthread/lock.h"
typedef pthread_mutex_t gl_recursive_lock_t;
#line 196 "./getopt.h"
struct rpl_option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 53 "malloca.c"
struct preliminary_header {
   void *next ;
   char room[sizeof(int )] ;
};
#line 57 "malloca.c"
struct header {
   void *next ;
   char room[((((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL - sizeof(struct preliminary_header )) + sizeof(int )] ;
};
#line 19 "mbsalign.h"
enum __anonenum_mbs_align_t_1 {
    MBS_ALIGN_LEFT = 0,
    MBS_ALIGN_RIGHT = 1,
    MBS_ALIGN_CENTER = 2
} ;
#line 19 "mbsalign.h"
typedef enum __anonenum_mbs_align_t_1 mbs_align_t;
#line 43 "memchr2.c"
typedef unsigned long longword;
#line 2 "mkancesdirs.h"
struct savewd;
#line 143 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 99 "/usr/include/sys/types.h"
typedef __pid_t pid_t;
#line 28 "savewd.h"
enum __anonenum_state_18 {
    INITIAL_STATE = 0,
    FD_STATE = 1,
    FD_POST_CHDIR_STATE = 2,
    FORKING_STATE = 3,
    ERROR_STATE = 4,
    FINAL_STATE = 5
} ;
#line 28 "savewd.h"
union __anonunion_val_19 {
   int fd ;
   int errnum ;
   pid_t child ;
};
#line 28 "savewd.h"
struct savewd {
   enum __anonenum_state_18 state ;
   union __anonunion_val_19 val ;
};
#line 25 "modechange.h"
struct mode_change;
#line 98 "modechange.c"
struct mode_change {
   char op ;
   char flag ;
   mode_t affected ;
   mode_t value ;
   mode_t mentioned ;
};
#line 35 "nproc.h"
enum nproc_query {
    NPROC_ALL = 0,
    NPROC_CURRENT = 1,
    NPROC_CURRENT_OVERRIDABLE = 2
} ;
#line 116 "/usr/include/bits/sched.h"
typedef unsigned long __cpu_mask;
#line 123 "/usr/include/bits/sched.h"
struct __anonstruct_cpu_set_t_24 {
   __cpu_mask __bits[1024UL / (8UL * sizeof(__cpu_mask ))] ;
};
#line 123 "/usr/include/bits/sched.h"
typedef struct __anonstruct_cpu_set_t_24 cpu_set_t;
#line 111 "parse-datetime.y"
typedef long long_time_t;
#line 126 "parse-datetime.y"
struct __anonstruct_textint_29 {
   _Bool negative ;
   long value ;
   size_t digits ;
};
#line 126 "parse-datetime.y"
typedef struct __anonstruct_textint_29 textint;
#line 134 "parse-datetime.y"
struct __anonstruct_table_30 {
   char const   *name ;
   int type ;
   int value ;
};
#line 134 "parse-datetime.y"
typedef struct __anonstruct_table_30 table;
#line 147 "parse-datetime.y"
struct __anonstruct_relative_time_33 {
   long year ;
   long month ;
   long day ;
   long hour ;
   long minutes ;
   long_time_t seconds ;
   long ns ;
};
#line 147 "parse-datetime.y"
typedef struct __anonstruct_relative_time_33 relative_time;
#line 166 "parse-datetime.y"
struct __anonstruct_parser_control_34 {
   char const   *input ;
   long day_ordinal ;
   int day_number ;
   int local_isdst ;
   long time_zone ;
   int meridian ;
   textint year ;
   long month ;
   long day ;
   long hour ;
   long minutes ;
   struct timespec seconds ;
   relative_time rel ;
   _Bool timespec_seen ;
   _Bool rels_seen ;
   size_t dates_seen ;
   size_t days_seen ;
   size_t local_zones_seen ;
   size_t dsts_seen ;
   size_t times_seen ;
   size_t zones_seen ;
   table local_time_zone_table[3] ;
};
#line 166 "parse-datetime.y"
typedef struct __anonstruct_parser_control_34 parser_control;
#line 211
union YYSTYPE;
#line 429 "parse-datetime.c"
union YYSTYPE {
   long intval ;
   textint textintval ;
   struct timespec timespec ;
   relative_time rel ;
};
#line 429 "parse-datetime.c"
typedef union YYSTYPE YYSTYPE;
#line 464 "parse-datetime.c"
typedef unsigned char yytype_uint8;
#line 471 "parse-datetime.c"
typedef signed char yytype_int8;
#line 485 "parse-datetime.c"
typedef short yytype_int16;
#line 616 "parse-datetime.c"
union yyalloc {
   yytype_int16 yyss_alloc ;
   YYSTYPE yyvs_alloc ;
};
#line 66 "fpucw.h"
typedef unsigned short fpucw_t;
#line 237 "quotearg.h"
struct quoting_options;
#line 45 "quotearg.c"
struct quoting_options {
   enum quoting_style style ;
   int flags ;
   unsigned int quote_these_too[255UL / (sizeof(int ) * 8UL) + 1UL] ;
   char const   *left_quote ;
   char const   *right_quote ;
};
#line 677 "quotearg.c"
struct slotvec {
   size_t size ;
   char *val ;
};
#line 25 "randread.h"
struct randread_source;
#line 30 "randint.h"
typedef uintmax_t randint;
#line 33
struct randint_source;
#line 54 "randint.c"
struct randint_source {
   struct randread_source *source ;
   randint randnum ;
   randint randmax ;
};
#line 77 "randperm.c"
struct sparse_ent_ {
   size_t index ;
   size_t val ;
};
#line 98 "randperm.c"
typedef Hash_table sparse_map;
#line 81 "/usr/include/stdint.h"
typedef unsigned long uint_least64_t;
#line 44 "rand-isaac.h"
typedef uint_least64_t isaac_word;
#line 56 "rand-isaac.h"
struct isaac_state {
   isaac_word m[1 << 8] ;
   isaac_word a ;
   isaac_word b ;
   isaac_word c ;
};
#line 79 "randread.c"
union __anonunion_data_32 {
   isaac_word w[1 << 8] ;
   unsigned char b[(unsigned long )(1 << 8) * sizeof(isaac_word )] ;
};
#line 79 "randread.c"
struct isaac {
   size_t buffered ;
   struct isaac_state state ;
   union __anonunion_data_32 data ;
};
#line 79 "randread.c"
union __anonunion_buf_31 {
   char c[2UL * ((unsigned long )(1 << 8) * sizeof(isaac_word ))] ;
   struct isaac isaac ;
};
#line 79 "randread.c"
struct randread_source {
   FILE *source ;
   void (*handler)(void const   * ) ;
   void const   *handler_arg ;
   union __anonunion_buf_31 buf ;
};
#line 26 "readtokens.h"
struct tokenbuffer {
   size_t size ;
   char *buffer ;
};
#line 31 "readtokens.h"
typedef struct tokenbuffer token_buffer;
#line 142 "obstack.h"
struct _obstack_chunk {
   char *limit ;
   struct _obstack_chunk *prev ;
   char contents[4] ;
};
#line 149 "obstack.h"
union __anonunion_temp_26 {
   long tempint ;
   void *tempptr ;
};
#line 149 "obstack.h"
struct obstack {
   long chunk_size ;
   struct _obstack_chunk *chunk ;
   char *object_base ;
   char *next_free ;
   char *chunk_limit ;
   union __anonunion_temp_26 temp ;
   int alignment_mask ;
   struct _obstack_chunk *(*chunkfun)(void * , long  ) ;
   void (*freefun)(void * , struct _obstack_chunk * ) ;
   void *extra_arg ;
   unsigned int use_extra_arg : 1 ;
   unsigned int maybe_empty_object : 1 ;
   unsigned int alloc_failed : 1 ;
};
#line 28 "readtokens0.h"
struct Tokens {
   size_t n_tok ;
   char **tok ;
   size_t *tok_len ;
   struct obstack o_data ;
   struct obstack o_tok ;
   struct obstack o_tok_len ;
};
#line 24 "save-cwd.h"
struct saved_cwd {
   int desc ;
   char *name ;
};
#line 29 "/usr/include/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 29 "/usr/include/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 209 "savewd.c"
union __anonunion_50 {
   int __in ;
   int __i ;
};
#line 208 "savewd.c"
union __anonunion_51 {
   int __in ;
   int __i ;
};
#line 210 "savewd.c"
union __anonunion_52 {
   int __in ;
   int __i ;
};
#line 30 "/usr/include/iconv.h"
typedef void *iconv_t;
#line 66 "striconv.c"
union __anonunion_tmp_21 {
   unsigned int align ;
   char buf[4096] ;
};
#line 100 "mbiter.h"
struct mbiter_multi {
   char const   *limit ;
   _Bool in_shift ;
   mbstate_t state ;
   _Bool next_done ;
   struct mbchar cur ;
};
#line 195 "mbiter.h"
typedef struct mbiter_multi mbi_iterator_t;
#line 27 "unitypes.h"
typedef uint32_t ucs4_t;
#line 60 "utimecmp.c"
struct fs_res {
   dev_t dev ;
   int resolution ;
   _Bool exact ;
};
#line 40 "chdir-long.c"
struct cd_buf {
   int fd ;
};
#line 27 "fsusage.h"
struct fs_usage {
   uintmax_t fsu_blocksize ;
   uintmax_t fsu_blocks ;
   uintmax_t fsu_bfree ;
   uintmax_t fsu_bavail ;
   _Bool fsu_bavail_top_bit_set ;
   uintmax_t fsu_files ;
   uintmax_t fsu_ffree ;
};
#line 144 "/usr/include/bits/types.h"
struct __anonstruct___fsid_t_1 {
   int __val[2] ;
};
#line 144 "/usr/include/bits/types.h"
typedef struct __anonstruct___fsid_t_1 __fsid_t;
#line 173 "/usr/include/bits/types.h"
typedef unsigned long __fsblkcnt_t;
#line 177 "/usr/include/bits/types.h"
typedef unsigned long __fsfilcnt_t;
#line 25 "/usr/include/bits/statfs.h"
struct statfs {
   long f_type ;
   long f_bsize ;
   __fsblkcnt_t f_blocks ;
   __fsblkcnt_t f_bfree ;
   __fsblkcnt_t f_bavail ;
   __fsfilcnt_t f_files ;
   __fsfilcnt_t f_ffree ;
   __fsid_t f_fsid ;
   long f_namelen ;
   long f_frsize ;
   long f_flags ;
   long f_spare[4] ;
};
#line 76 "/usr/include/sys/types.h"
typedef __nlink_t nlink_t;
#line 74 "fts_.h"
struct _ftsent;
#line 74 "fts_.h"
union __anonunion_fts_cycle_20 {
   struct hash_table *ht ;
   struct cycle_check_state *state ;
};
#line 74 "fts_.h"
struct __anonstruct_FTS_19 {
   struct _ftsent *fts_cur ;
   struct _ftsent *fts_child ;
   struct _ftsent **fts_array ;
   dev_t fts_dev ;
   char *fts_path ;
   int fts_rfd ;
   int fts_cwd_fd ;
   size_t fts_pathlen ;
   size_t fts_nitems ;
   int (*fts_compar)(struct _ftsent  const  ** , struct _ftsent  const  ** ) ;
   int fts_options ;
   struct hash_table *fts_leaf_optimization_works_ht ;
   union __anonunion_fts_cycle_20 fts_cycle ;
   I_ring fts_fd_ring ;
};
#line 74 "fts_.h"
typedef struct __anonstruct_FTS_19 FTS;
#line 191 "fts_.h"
struct _ftsent {
   struct _ftsent *fts_cycle ;
   struct _ftsent *fts_parent ;
   struct _ftsent *fts_link ;
   DIR *fts_dirp ;
   long fts_number ;
   void *fts_pointer ;
   char *fts_accpath ;
   char *fts_path ;
   int fts_errno ;
   int fts_symfd ;
   size_t fts_pathlen ;
   FTS *fts_fts ;
   ptrdiff_t fts_level ;
   size_t fts_namelen ;
   nlink_t fts_n_dirs_remaining ;
   unsigned short fts_info ;
   unsigned short fts_flags ;
   unsigned short fts_instr ;
   struct stat fts_statp[1] ;
   char fts_name[1] ;
};
#line 191 "fts_.h"
typedef struct _ftsent FTSENT;
#line 24 "fts-cycle.c"
struct Active_dir {
   dev_t dev ;
   ino_t ino ;
   FTSENT *fts_ent ;
};
#line 725 "fts.c"
struct LCO_ent {
   dev_t st_dev ;
   _Bool opt_ok ;
};
#line 28 "xtime.h"
typedef long long xtime_t;
#line 62 "getopt_int.h"
enum __ord {
    REQUIRE_ORDER = 0,
    PERMUTE = 1,
    RETURN_IN_ORDER = 2
} ;
#line 68 "getopt_int.h"
struct _getopt_data {
   int rpl_optind ;
   int rpl_opterr ;
   int rpl_optopt ;
   char *rpl_optarg ;
   int __initialized ;
   char *__nextchar ;
   enum __ord __ordering ;
   int __posixly_correct ;
   int __first_nonopt ;
   int __last_nonopt ;
};
#line 485 "getopt.c"
struct option_list {
   struct rpl_option  const  *p ;
   struct option_list *next ;
};
#line 24 "/usr/include/bits/termios.h"
typedef unsigned char cc_t;
#line 25 "/usr/include/bits/termios.h"
typedef unsigned int speed_t;
#line 26 "/usr/include/bits/termios.h"
typedef unsigned int tcflag_t;
#line 29 "/usr/include/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 80 "isnan.c"
union __anonunion_memory_double_2 {
   long double value ;
   unsigned int word[((sizeof(long double ) + sizeof(unsigned int )) - 1UL) / sizeof(unsigned int )] ;
};
#line 80 "isnan.c"
typedef union __anonunion_memory_double_2 memory_double;
#line 26 "mountlist.h"
struct mount_entry {
   char *me_devname ;
   char *me_mountdir ;
   char *me_type ;
   dev_t me_dev ;
   unsigned int me_dummy : 1 ;
   unsigned int me_remote : 1 ;
   unsigned int me_type_malloced : 1 ;
   struct mount_entry *me_next ;
};
#line 54 "/usr/include/mntent.h"
struct mntent {
   char *mnt_fsname ;
   char *mnt_dir ;
   char *mnt_type ;
   char *mnt_opts ;
   int mnt_freq ;
   int mnt_passno ;
};
#line 52 "printf-args.h"
enum __anonenum_arg_type_3 {
    TYPE_NONE = 0,
    TYPE_SCHAR = 1,
    TYPE_UCHAR = 2,
    TYPE_SHORT = 3,
    TYPE_USHORT = 4,
    TYPE_INT = 5,
    TYPE_UINT = 6,
    TYPE_LONGINT = 7,
    TYPE_ULONGINT = 8,
    TYPE_LONGLONGINT = 9,
    TYPE_ULONGLONGINT = 10,
    TYPE_DOUBLE = 11,
    TYPE_LONGDOUBLE = 12,
    TYPE_CHAR = 13,
    TYPE_WIDE_CHAR = 14,
    TYPE_STRING = 15,
    TYPE_WIDE_STRING = 16,
    TYPE_POINTER = 17,
    TYPE_COUNT_SCHAR_POINTER = 18,
    TYPE_COUNT_SHORT_POINTER = 19,
    TYPE_COUNT_INT_POINTER = 20,
    TYPE_COUNT_LONGINT_POINTER = 21,
    TYPE_COUNT_LONGLONGINT_POINTER = 22
} ;
#line 52 "printf-args.h"
typedef enum __anonenum_arg_type_3 arg_type;
#line 94 "printf-args.h"
union __anonunion_a_5 {
   signed char a_schar ;
   unsigned char a_uchar ;
   short a_short ;
   unsigned short a_ushort ;
   int a_int ;
   unsigned int a_uint ;
   long a_longint ;
   unsigned long a_ulongint ;
   long long a_longlongint ;
   unsigned long long a_ulonglongint ;
   float a_float ;
   double a_double ;
   long double a_longdouble ;
   int a_char ;
   wint_t a_wide_char ;
   char const   *a_string ;
   wchar_t const   *a_wide_string ;
   void *a_pointer ;
   signed char *a_count_schar_pointer ;
   short *a_count_short_pointer ;
   int *a_count_int_pointer ;
   long *a_count_longint_pointer ;
   long long *a_count_longlongint_pointer ;
};
#line 94 "printf-args.h"
struct __anonstruct_argument_4 {
   arg_type type ;
   union __anonunion_a_5 a ;
};
#line 94 "printf-args.h"
typedef struct __anonstruct_argument_4 argument;
#line 144 "printf-args.h"
struct __anonstruct_arguments_6 {
   size_t count ;
   argument *arg ;
   argument direct_alloc_arg[7] ;
};
#line 144 "printf-args.h"
typedef struct __anonstruct_arguments_6 arguments;
#line 56 "printf-parse.h"
struct __anonstruct_char_directive_7 {
   char const   *dir_start ;
   char const   *dir_end ;
   int flags ;
   char const   *width_start ;
   char const   *width_end ;
   size_t width_arg_index ;
   char const   *precision_start ;
   char const   *precision_end ;
   size_t precision_arg_index ;
   char conversion ;
   size_t arg_index ;
};
#line 56 "printf-parse.h"
typedef struct __anonstruct_char_directive_7 char_directive;
#line 73 "printf-parse.h"
struct __anonstruct_char_directives_8 {
   size_t count ;
   char_directive *dir ;
   size_t max_width_length ;
   size_t max_precision_length ;
   char_directive direct_alloc_dir[7] ;
};
#line 73 "printf-parse.h"
typedef struct __anonstruct_char_directives_8 char_directives;
#line 43 "/usr/include/bits/utmpx.h"
struct __exit_status {
   short e_termination ;
   short e_exit ;
};
#line 56 "/usr/include/bits/utmpx.h"
struct __anonstruct_ut_tv_16 {
   __int32_t tv_sec ;
   __int32_t tv_usec ;
};
#line 56 "/usr/include/bits/utmpx.h"
struct utmpx {
   short ut_type ;
   __pid_t ut_pid ;
   char ut_line[32] ;
   char ut_id[4] ;
   char ut_user[32] ;
   char ut_host[256] ;
   struct __exit_status ut_exit ;
   __int32_t ut_session ;
   struct __anonstruct_ut_tv_16 ut_tv ;
   __int32_t ut_addr_v6[4] ;
   char __unused[20] ;
};
#line 144 "readutmp.h"
typedef struct utmpx STRUCT_UTMP;
#line 41 "sig2str.c"
struct numname {
   int num ;
   char const   name[8] ;
};
#line 64 "/usr/include/bits/mathinline.h"
union __anonunion___u_36 {
   long double __l ;
   int __i[3] ;
};
#line 26 "copy.h"
enum Sparse_type {
    SPARSE_UNUSED = 0,
    SPARSE_NEVER = 1,
    SPARSE_AUTO = 2,
    SPARSE_ALWAYS = 3
} ;
#line 47
enum Reflink_type {
    REFLINK_NEVER = 0,
    REFLINK_AUTO = 1,
    REFLINK_ALWAYS = 2
} ;
#line 60
enum Interactive {
    I_ALWAYS_YES = 1,
    I_ALWAYS_NO = 2,
    I_ASK_USER = 3,
    I_UNSPECIFIED = 4
} ;
#line 69
enum Dereference_symlink {
    DEREF_UNDEFINED = 1,
    DEREF_NEVER = 2,
    DEREF_COMMAND_LINE_ARGUMENTS = 3,
    DEREF_ALWAYS = 4
} ;
#line 98 "copy.h"
struct cp_options {
   enum backup_type backup_type ;
   enum Dereference_symlink dereference ;
   enum Interactive interactive ;
   enum Sparse_type sparse_mode ;
   mode_t mode ;
   _Bool copy_as_regular ;
   _Bool unlink_dest_before_opening ;
   _Bool unlink_dest_after_failed_open ;
   _Bool hard_link ;
   _Bool move_mode ;
   _Bool chown_privileges ;
   _Bool owner_privileges ;
   _Bool one_file_system ;
   _Bool preserve_ownership ;
   _Bool preserve_mode ;
   _Bool preserve_timestamps ;
   _Bool preserve_links ;
   _Bool data_copy_required ;
   _Bool require_preserve ;
   _Bool preserve_security_context ;
   _Bool require_preserve_context ;
   _Bool preserve_xattr ;
   _Bool require_preserve_xattr ;
   _Bool reduce_diagnostics ;
   _Bool recursive ;
   _Bool set_mode ;
   _Bool symbolic_link ;
   _Bool update ;
   _Bool verbose ;
   _Bool stdin_tty ;
   _Bool open_dangling_dest_symlink ;
   enum Reflink_type reflink_mode ;
   Hash_table *dest_info ;
   Hash_table *src_info ;
};
#line 23 "remove.h"
enum rm_interactive {
    RMI_ALWAYS = 3,
    RMI_SOMETIMES = 4,
    RMI_NEVER = 5
} ;
#line 32 "remove.h"
struct rm_options {
   _Bool ignore_missing_files ;
   enum rm_interactive interactive ;
   _Bool one_file_system ;
   _Bool recursive ;
   struct dev_ino *root_dev_ino ;
   _Bool stdin_tty ;
   _Bool verbose ;
   _Bool require_restore_cwd ;
};
#line 71
enum RM_status {
    RM_OK = 2,
    RM_USER_DECLINED = 3,
    RM_ERROR = 4,
    RM_NONEMPTY_DIR = 5
} ;
#line 123 "/usr/include/stdint.h"
typedef unsigned long uintptr_t;
#line 23 "extent-scan.h"
struct extent_info {
   off_t ext_logical ;
   uint64_t ext_length ;
   uint32_t ext_flags ;
};
#line 36 "extent-scan.h"
struct extent_scan {
   int fd ;
   off_t scan_start ;
   uint32_t fm_flags ;
   uint32_t ei_count ;
   _Bool initial_scan_failed ;
   _Bool hit_final_extent ;
   struct extent_info *ext_info ;
};
#line 97 "copy.c"
struct dir_list {
   struct dir_list *parent ;
   ino_t ino ;
   dev_t dev ;
};
#line 154 "copy.c"
typedef uintptr_t word;
#line 992 "copy.c"
typedef uintptr_t word___0;
#line 33 "cp-hash.c"
struct Src_to_dest {
   ino_t st_ino ;
   dev_t st_dev ;
   char *name ;
};
#line 14 "fiemap.h"
struct fiemap_extent {
   uint64_t fe_logical ;
   uint64_t fe_physical ;
   uint64_t fe_length ;
   uint64_t fe_reserved64[2] ;
   uint32_t fe_flags ;
   uint32_t fe_reserved[3] ;
};
#line 35 "fiemap.h"
struct fiemap {
   uint64_t fm_start ;
   uint64_t fm_length ;
   uint32_t fm_flags ;
   uint32_t fm_mapped_extents ;
   uint32_t fm_extent_count ;
   uint32_t fm_reserved ;
   struct fiemap_extent fm_extents[0] ;
};
#line 96 "extent-scan.c"
union __anonunion_fiemap_buf_38 {
   struct fiemap f ;
   char c[4096] ;
};
#line 36 "remove.c"
enum Ternary {
    T_UNKNOWN = 2,
    T_NO = 3,
    T_YES = 4
} ;
#line 42 "remove.c"
typedef enum Ternary Ternary;
#line 47
enum Prompt_action {
    PA_DESCEND_INTO_DIR = 2,
    PA_REMOVE_DIR = 3
} ;
/* compiler builtin: 
   int __builtin_strcmp(char const   * , char const   * ) ;  */
/* compiler builtin: 
   void *__builtin___memmove_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin_strchr(char * , int  ) ;  */
/* compiler builtin: 
   void *__builtin___memcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin___vsprintf_chk(char * , int  , unsigned long  , char const   * ,
                                __builtin_va_list  ) ;  */
/* compiler builtin: 
   char *__builtin___strncpy_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void *__builtin___mempcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin___strcat_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void __builtin_va_copy(__builtin_va_list  , __builtin_va_list  ) ;  */
/* compiler builtin: 
   unsigned long __builtin_strlen(char const   * ) ;  */
/* compiler builtin: 
   unsigned long __builtin_object_size(void * , int  ) ;  */
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   int __builtin___sprintf_chk(char * , int  , unsigned long  , char const   *  , ...) ;  */
/* compiler builtin: 
   int __builtin___snprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                char const   *  , ...) ;  */
/* compiler builtin: 
   int __builtin___vsnprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                 char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   char *__builtin___strcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin___stpcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin_va_arg_pack_len(void) ;  */
/* compiler builtin: 
   void *__builtin___memset_chk(void * , int  , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin___strncat_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   unsigned long __builtin_strspn(char const   * , char const   * ) ;  */
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
/* compiler builtin: 
   int __builtin_va_arg_pack(void) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   unsigned long __builtin_strcspn(char const   * , char const   * ) ;  */
#line 1 "cil-UvvUMqSt.o"
#pragma merger(0,"/tmp/cil-r6xtHYbb.i","")
#line 1 "set-mode-acl.o"
#pragma merger(0,"/tmp/cil-cjMIscCZ.i","-g,-O2")
#line 31 "/usr/include/sys/sysmacros.h"
__inline extern  __attribute__((__nothrow__)) unsigned int gnu_dev_major(unsigned long long __dev ) ;
#line 34
__inline extern  __attribute__((__nothrow__)) unsigned int gnu_dev_minor(unsigned long long __dev ) ;
#line 37
__inline extern  __attribute__((__nothrow__)) unsigned long long gnu_dev_makedev(unsigned int __major ,
                                                                                 unsigned int __minor ) ;
#line 42
__inline extern  __attribute__((__nothrow__)) unsigned int gnu_dev_major(unsigned long long __dev ) ;
#line 42 "/usr/include/sys/sysmacros.h"
__inline extern unsigned int gnu_dev_major(unsigned long long __dev ) 
{ 

  {
#line 45
  return ((unsigned int )(((__dev >> 8) & 4095ULL) | (unsigned long long )((unsigned int )(__dev >> 32) & 4294963200U)));
}
}
#line 48
__inline extern  __attribute__((__nothrow__)) unsigned int gnu_dev_minor(unsigned long long __dev ) ;
#line 48 "/usr/include/sys/sysmacros.h"
__inline extern unsigned int gnu_dev_minor(unsigned long long __dev ) 
{ 

  {
#line 51
  return ((unsigned int )((__dev & 255ULL) | (unsigned long long )((unsigned int )(__dev >> 12) & 4294967040U)));
}
}
#line 54
__inline extern  __attribute__((__nothrow__)) unsigned long long gnu_dev_makedev(unsigned int __major ,
                                                                                 unsigned int __minor ) ;
#line 54 "/usr/include/sys/sysmacros.h"
__inline extern unsigned long long gnu_dev_makedev(unsigned int __major , unsigned int __minor ) 
{ 

  {
#line 57
  return (((unsigned long long )((__minor & 255U) | ((__major & 4095U) << 8)) | ((unsigned long long )(__minor & 4294967040U) << 12)) | ((unsigned long long )(__major & 4294963200U) << 32));
}
}
#line 211 "/usr/include/sys/stat.h"
__inline extern  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 216
__inline extern  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 230
__inline extern  __attribute__((__nothrow__)) int stat64(char const   * __restrict  __path ,
                                                         struct stat64 * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 232
__inline extern  __attribute__((__nothrow__)) int fstat64(int __fd , struct stat64 *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 240
__inline extern  __attribute__((__nothrow__)) int fstatat(int __fd , char const   * __restrict  __filename ,
                                                          struct stat * __restrict  __statbuf ,
                                                          int __flag )  __attribute__((__nonnull__(2,3))) ;
#line 255
__inline extern  __attribute__((__nothrow__)) int fstatat64(int __fd , char const   * __restrict  __filename ,
                                                            struct stat64 * __restrict  __statbuf ,
                                                            int __flag )  __attribute__((__nonnull__(2,3))) ;
#line 265
__inline extern  __attribute__((__nothrow__)) int lstat(char const   * __restrict  __path ,
                                                        struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 278
__inline extern  __attribute__((__nothrow__)) int lstat64(char const   * __restrict  __path ,
                                                          struct stat64 * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 286
extern  __attribute__((__nothrow__)) int chmod(char const   *__file , __mode_t __mode )  __attribute__((__nonnull__(1))) ;
#line 299
extern  __attribute__((__nothrow__)) int fchmod(int __fd , __mode_t __mode ) ;
#line 338
__inline extern  __attribute__((__nothrow__)) int mknod(char const   *__path , __mode_t __mode ,
                                                        __dev_t __dev )  __attribute__((__nonnull__(1))) ;
#line 345
__inline extern  __attribute__((__nothrow__)) int mknodat(int __fd , char const   *__path ,
                                                          __mode_t __mode , __dev_t __dev )  __attribute__((__nonnull__(2))) ;
#line 401
extern  __attribute__((__nothrow__)) int __fxstat(int __ver , int __fildes , struct stat *__stat_buf )  __attribute__((__nonnull__(3))) ;
#line 403
extern  __attribute__((__nothrow__)) int __xstat(int __ver , char const   *__filename ,
                                                 struct stat *__stat_buf )  __attribute__((__nonnull__(2,3))) ;
#line 405
extern  __attribute__((__nothrow__)) int __lxstat(int __ver , char const   *__filename ,
                                                  struct stat *__stat_buf )  __attribute__((__nonnull__(2,3))) ;
#line 407
extern  __attribute__((__nothrow__)) int __fxstatat(int __ver , int __fildes , char const   *__filename ,
                                                    struct stat *__stat_buf , int __flag )  __attribute__((__nonnull__(3,4))) ;
#line 434
extern  __attribute__((__nothrow__)) int __fxstat64(int __ver , int __fildes , struct stat64 *__stat_buf )  __attribute__((__nonnull__(3))) ;
#line 436
extern  __attribute__((__nothrow__)) int __xstat64(int __ver , char const   *__filename ,
                                                   struct stat64 *__stat_buf )  __attribute__((__nonnull__(2,3))) ;
#line 438
extern  __attribute__((__nothrow__)) int __lxstat64(int __ver , char const   *__filename ,
                                                    struct stat64 *__stat_buf )  __attribute__((__nonnull__(2,3))) ;
#line 440
extern  __attribute__((__nothrow__)) int __fxstatat64(int __ver , int __fildes , char const   *__filename ,
                                                      struct stat64 *__stat_buf ,
                                                      int __flag )  __attribute__((__nonnull__(3,4))) ;
#line 444
extern  __attribute__((__nothrow__)) int __xmknod(int __ver , char const   *__path ,
                                                  __mode_t __mode , __dev_t *__dev )  __attribute__((__nonnull__(2,4))) ;
#line 447
extern  __attribute__((__nothrow__)) int __xmknodat(int __ver , int __fd , char const   *__path ,
                                                    __mode_t __mode , __dev_t *__dev )  __attribute__((__nonnull__(3,5))) ;
#line 454
__inline extern  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 454 "/usr/include/sys/stat.h"
__inline extern int stat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ int tmp ;

  {
#line 457
  tmp = __xstat(1, (char const   *)__path, (struct stat *)__statbuf);
#line 457
  return (tmp);
}
}
#line 461
__inline extern  __attribute__((__nothrow__)) int lstat(char const   * __restrict  __path ,
                                                        struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 461 "/usr/include/sys/stat.h"
__inline extern int lstat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ int tmp ;

  {
#line 464
  tmp = __lxstat(1, (char const   *)__path, (struct stat *)__statbuf);
#line 464
  return (tmp);
}
}
#line 468
__inline extern  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 468 "/usr/include/sys/stat.h"
__inline extern int fstat(int __fd , struct stat *__statbuf ) 
{ int tmp ;

  {
#line 471
  tmp = __fxstat(1, __fd, __statbuf);
#line 471
  return (tmp);
}
}
#line 475
__inline extern  __attribute__((__nothrow__)) int fstatat(int __fd , char const   * __restrict  __filename ,
                                                          struct stat * __restrict  __statbuf ,
                                                          int __flag )  __attribute__((__nonnull__(2,3))) ;
#line 475 "/usr/include/sys/stat.h"
__inline extern int fstatat(int __fd , char const   * __restrict  __filename , struct stat * __restrict  __statbuf ,
                            int __flag ) 
{ int tmp ;

  {
#line 479
  tmp = __fxstatat(1, __fd, (char const   *)__filename, (struct stat *)__statbuf,
                   __flag);
#line 479
  return (tmp);
}
}
#line 484
__inline extern  __attribute__((__nothrow__)) int mknod(char const   *__path , __mode_t __mode ,
                                                        __dev_t __dev )  __attribute__((__nonnull__(1))) ;
#line 484 "/usr/include/sys/stat.h"
__inline extern int mknod(char const   *__path , __mode_t __mode , __dev_t __dev ) 
{ int tmp ;

  {
#line 487
  tmp = __xmknod(0, __path, __mode, & __dev);
#line 487
  return (tmp);
}
}
#line 492
__inline extern  __attribute__((__nothrow__)) int mknodat(int __fd , char const   *__path ,
                                                          __mode_t __mode , __dev_t __dev )  __attribute__((__nonnull__(2))) ;
#line 492 "/usr/include/sys/stat.h"
__inline extern int mknodat(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev ) 
{ int tmp ;

  {
#line 496
  tmp = __xmknodat(0, __fd, __path, __mode, & __dev);
#line 496
  return (tmp);
}
}
#line 503
__inline extern  __attribute__((__nothrow__)) int stat64(char const   * __restrict  __path ,
                                                         struct stat64 * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 503 "/usr/include/sys/stat.h"
__inline extern int stat64(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) 
{ int tmp ;

  {
#line 506
  tmp = __xstat64(1, (char const   *)__path, (struct stat64 *)__statbuf);
#line 506
  return (tmp);
}
}
#line 510
__inline extern  __attribute__((__nothrow__)) int lstat64(char const   * __restrict  __path ,
                                                          struct stat64 * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 510 "/usr/include/sys/stat.h"
__inline extern int lstat64(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) 
{ int tmp ;

  {
#line 513
  tmp = __lxstat64(1, (char const   *)__path, (struct stat64 *)__statbuf);
#line 513
  return (tmp);
}
}
#line 517
__inline extern  __attribute__((__nothrow__)) int fstat64(int __fd , struct stat64 *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 517 "/usr/include/sys/stat.h"
__inline extern int fstat64(int __fd , struct stat64 *__statbuf ) 
{ int tmp ;

  {
#line 520
  tmp = __fxstat64(1, __fd, __statbuf);
#line 520
  return (tmp);
}
}
#line 524
__inline extern  __attribute__((__nothrow__)) int fstatat64(int __fd , char const   * __restrict  __filename ,
                                                            struct stat64 * __restrict  __statbuf ,
                                                            int __flag )  __attribute__((__nonnull__(2,3))) ;
#line 524 "/usr/include/sys/stat.h"
__inline extern int fstatat64(int __fd , char const   * __restrict  __filename , struct stat64 * __restrict  __statbuf ,
                              int __flag ) 
{ int tmp ;

  {
#line 528
  tmp = __fxstatat64(1, __fd, (char const   *)__filename, (struct stat64 *)__statbuf,
                     __flag);
#line 528
  return (tmp);
}
}
#line 25 "acl.h"
int set_acl(char const   *name , int desc , mode_t mode ) ;
#line 26
int qset_acl(char const   *name , int desc , mode_t mode ) ;
#line 27
int chmod_or_fchmod(char const   *name , int desc , mode_t mode ) ;
#line 145 "/usr/include/stdlib.h"
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__warn_unused_result__,
__pure__, __nonnull__(1))) ;
#line 148
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__warn_unused_result__,
__pure__, __nonnull__(1))) ;
#line 151
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__warn_unused_result__,
__pure__, __nonnull__(1))) ;
#line 158
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__warn_unused_result__,
__pure__, __nonnull__(1))) ;
#line 165
extern  __attribute__((__nothrow__)) double strtod(char const   * __restrict  __nptr ,
                                                   char ** __restrict  __endptr )  __attribute__((__warn_unused_result__,
__nonnull__(1))) ;
#line 184
extern  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                 char ** __restrict  __endptr , int __base )  __attribute__((__warn_unused_result__,
__nonnull__(1))) ;
#line 210
extern  __attribute__((__nothrow__)) long long strtoll(char const   * __restrict  __nptr ,
                                                       char ** __restrict  __endptr ,
                                                       int __base )  __attribute__((__warn_unused_result__,
__nonnull__(1))) ;
#line 278
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__warn_unused_result__,
__pure__, __nonnull__(1))) ;
#line 278 "/usr/include/stdlib.h"
__inline extern double atof(char const   *__nptr ) 
{ double tmp ;

  {
#line 281
  tmp = strtod((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)));
#line 281
  return (tmp);
}
}
#line 283
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__warn_unused_result__,
__pure__, __nonnull__(1))) ;
#line 283 "/usr/include/stdlib.h"
__inline extern int atoi(char const   *__nptr ) 
{ long tmp ;

  {
#line 286
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
#line 286
  return ((int )tmp);
}
}
#line 288
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__warn_unused_result__,
__pure__, __nonnull__(1))) ;
#line 288 "/usr/include/stdlib.h"
__inline extern long atol(char const   *__nptr ) 
{ long tmp ;

  {
#line 291
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
#line 291
  return (tmp);
}
}
#line 297
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__warn_unused_result__,
__pure__, __nonnull__(1))) ;
#line 297 "/usr/include/stdlib.h"
__inline extern long long atoll(char const   *__nptr ) 
{ long long tmp ;

  {
#line 300
  tmp = strtoll((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
                10);
#line 300
  return (tmp);
}
}
#line 867
__inline extern  __attribute__((__nothrow__)) int __attribute__((__warn_unused_result__,
__artificial__))  ( __attribute__((__always_inline__)) wctomb)(char *__s , wchar_t __wchar )  __attribute__((__warn_unused_result__)) ;
#line 871
__inline extern  __attribute__((__nothrow__)) size_t __attribute__((__artificial__))  ( __attribute__((__always_inline__)) mbstowcs)(wchar_t * __restrict  __dst ,
                                                                                                                                     char const   * __restrict  __src ,
                                                                                                                                     size_t __len ) ;
#line 874
__inline extern  __attribute__((__nothrow__)) size_t __attribute__((__artificial__))  ( __attribute__((__always_inline__)) wcstombs)(char * __restrict  __dst ,
                                                                                                                                     wchar_t const   * __restrict  __src ,
                                                                                                                                     size_t __len ) ;
#line 937
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) ptsname_r)(int __fd ,
                                                                                                                                   char *__buf ,
                                                                                                                                   size_t __buflen )  __attribute__((__nonnull__(2))) ;
#line 24 "/usr/include/bits/stdlib.h"
extern  __attribute__((__nothrow__)) char *__realpath_chk(char const   * __restrict  __name ,
                                                          char * __restrict  __resolved ,
                                                          size_t __resolvedlen )  __attribute__((__warn_unused_result__)) ;
#line 27
extern  __attribute__((__nothrow__)) char *__realpath_alias(char const   * __restrict  __name ,
                                                            char * __restrict  __resolved )  __asm__("realpath") __attribute__((__warn_unused_result__)) ;
#line 37
__inline extern  __attribute__((__nothrow__)) char __attribute__((__warn_unused_result__,
__artificial__))  *( __attribute__((__always_inline__)) realpath)(char const   * __restrict  __name ,
                                                                  char * __restrict  __resolved )  __attribute__((__warn_unused_result__)) ;
#line 37
__inline extern  __attribute__((__nothrow__)) char __attribute__((__warn_unused_result__,
__artificial__))  *( __attribute__((__always_inline__)) realpath)(char const   * __restrict  __name ,
                                                                  char * __restrict  __resolved )  __attribute__((__warn_unused_result__)) ;
#line 37 "/usr/include/bits/stdlib.h"
__inline extern char __attribute__((__warn_unused_result__, __artificial__))  *( __attribute__((__always_inline__)) realpath)(char const   * __restrict  __name ,
                                                                                                                              char * __restrict  __resolved ) 
{ unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;

  {
#line 40
  tmp___1 = __builtin_object_size((void *)__resolved, 1);
#line 40
  if (tmp___1 != 0xffffffffffffffffUL) {
#line 46
    tmp = __builtin_object_size((void *)__resolved, 1);
#line 46
    tmp___0 = __realpath_chk(__name, __resolved, tmp);
#line 46
    return ((char __attribute__((__warn_unused_result__, __artificial__))  *)tmp___0);
  }
#line 49
  tmp___2 = __realpath_alias(__name, __resolved);
#line 49
  return ((char __attribute__((__warn_unused_result__, __artificial__))  *)tmp___2);
}
}
#line 53
extern  __attribute__((__nothrow__)) int __ptsname_r_chk(int __fd , char *__buf ,
                                                         size_t __buflen , size_t __nreal )  __attribute__((__nonnull__(2))) ;
#line 55
extern  __attribute__((__nothrow__)) int __ptsname_r_alias(int __fd , char *__buf ,
                                                           size_t __buflen )  __asm__("ptsname_r") __attribute__((__nonnull__(2))) ;
#line 58
extern  __attribute__((__nothrow__)) int __ptsname_r_chk_warn(int __fd , char *__buf ,
                                                              size_t __buflen , size_t __nreal )  __asm__("__ptsname_r_chk") __attribute__((__warning__("ptsname_r called with buflen bigger than size of buf"),
__nonnull__(2))) ;
#line 64
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) ptsname_r)(int __fd ,
                                                                                                                                   char *__buf ,
                                                                                                                                   size_t __buflen )  __attribute__((__nonnull__(2))) ;
#line 64 "/usr/include/bits/stdlib.h"
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) ptsname_r)(int __fd ,
                                                                                                     char *__buf ,
                                                                                                     size_t __buflen ) 
{ unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
#line 67
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 67
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 70
    tmp = __builtin_object_size((void *)__buf, 1);
#line 70
    tmp___0 = __ptsname_r_chk(__fd, __buf, __buflen, tmp);
#line 70
    return ((int __attribute__((__artificial__))  )tmp___0);
#line 71
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 71
    if (__buflen > tmp___3) {
#line 72
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 72
      tmp___2 = __ptsname_r_chk_warn(__fd, __buf, __buflen, tmp___1);
#line 72
      return ((int __attribute__((__artificial__))  )tmp___2);
    }
  }
#line 74
  tmp___5 = __ptsname_r_alias(__fd, __buf, __buflen);
#line 74
  return ((int __attribute__((__artificial__))  )tmp___5);
}
}
#line 78
extern  __attribute__((__nothrow__)) int __wctomb_chk(char *__s , wchar_t __wchar ,
                                                      size_t __buflen )  __attribute__((__warn_unused_result__)) ;
#line 80
extern  __attribute__((__nothrow__)) int __wctomb_alias(char *__s , wchar_t __wchar )  __asm__("wctomb") __attribute__((__warn_unused_result__)) ;
#line 83
__inline extern  __attribute__((__nothrow__)) int __attribute__((__warn_unused_result__,
__artificial__))  ( __attribute__((__always_inline__)) wctomb)(char *__s , wchar_t __wchar )  __attribute__((__warn_unused_result__)) ;
#line 83 "/usr/include/bits/stdlib.h"
__inline extern int __attribute__((__warn_unused_result__, __artificial__))  ( __attribute__((__always_inline__)) wctomb)(char *__s ,
                                                                                                                          wchar_t __wchar ) 
{ unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;

  {
#line 93
  tmp___1 = __builtin_object_size((void *)__s, 1);
#line 93
  if (tmp___1 != 0xffffffffffffffffUL) {
#line 93
    tmp___2 = __builtin_object_size((void *)__s, 1);
#line 93
    if (16UL > tmp___2) {
#line 94
      tmp = __builtin_object_size((void *)__s, 1);
#line 94
      tmp___0 = __wctomb_chk(__s, __wchar, tmp);
#line 94
      return ((int __attribute__((__artificial__))  )tmp___0);
    }
  }
#line 95
  tmp___3 = __wctomb_alias(__s, __wchar);
#line 95
  return ((int __attribute__((__artificial__))  )tmp___3);
}
}
#line 99
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk(wchar_t * __restrict  __dst ,
                                                           char const   * __restrict  __src ,
                                                           size_t __len , size_t __dstlen ) ;
#line 102
extern  __attribute__((__nothrow__)) size_t __mbstowcs_alias(wchar_t * __restrict  __dst ,
                                                             char const   * __restrict  __src ,
                                                             size_t __len )  __asm__("mbstowcs")  ;
#line 106
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk_warn(wchar_t * __restrict  __dst ,
                                                                char const   * __restrict  __src ,
                                                                size_t __len , size_t __dstlen )  __asm__("__mbstowcs_chk") __attribute__((__warning__("mbstowcs called with dst buffer smaller than len * sizeof (wchar_t)"))) ;
#line 113
__inline extern  __attribute__((__nothrow__)) size_t __attribute__((__artificial__))  ( __attribute__((__always_inline__)) mbstowcs)(wchar_t * __restrict  __dst ,
                                                                                                                                     char const   * __restrict  __src ,
                                                                                                                                     size_t __len ) ;
#line 113 "/usr/include/bits/stdlib.h"
__inline extern size_t __attribute__((__artificial__))  ( __attribute__((__always_inline__)) mbstowcs)(wchar_t * __restrict  __dst ,
                                                                                                       char const   * __restrict  __src ,
                                                                                                       size_t __len ) 
{ unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
#line 117
  tmp___4 = __builtin_object_size((void *)__dst, 1);
#line 117
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 120
    tmp = __builtin_object_size((void *)__dst, 1);
#line 120
    tmp___0 = __mbstowcs_chk(__dst, __src, __len, tmp / sizeof(wchar_t ));
#line 120
    return ((size_t __attribute__((__artificial__))  )tmp___0);
#line 123
    tmp___3 = __builtin_object_size((void *)__dst, 1);
#line 123
    if (__len > tmp___3 / sizeof(wchar_t )) {
#line 124
      tmp___1 = __builtin_object_size((void *)__dst, 1);
#line 124
      tmp___2 = __mbstowcs_chk_warn(__dst, __src, __len, tmp___1 / sizeof(wchar_t ));
#line 124
      return ((size_t __attribute__((__artificial__))  )tmp___2);
    }
  }
#line 127
  tmp___5 = __mbstowcs_alias(__dst, __src, __len);
#line 127
  return ((size_t __attribute__((__artificial__))  )tmp___5);
}
}
#line 131
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk(char * __restrict  __dst ,
                                                           wchar_t const   * __restrict  __src ,
                                                           size_t __len , size_t __dstlen ) ;
#line 134
extern  __attribute__((__nothrow__)) size_t __wcstombs_alias(char * __restrict  __dst ,
                                                             wchar_t const   * __restrict  __src ,
                                                             size_t __len )  __asm__("wcstombs")  ;
#line 138
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk_warn(char * __restrict  __dst ,
                                                                wchar_t const   * __restrict  __src ,
                                                                size_t __len , size_t __dstlen )  __asm__("__wcstombs_chk") __attribute__((__warning__("wcstombs called with dst buffer smaller than len"))) ;
#line 144
__inline extern  __attribute__((__nothrow__)) size_t __attribute__((__artificial__))  ( __attribute__((__always_inline__)) wcstombs)(char * __restrict  __dst ,
                                                                                                                                     wchar_t const   * __restrict  __src ,
                                                                                                                                     size_t __len ) ;
#line 144 "/usr/include/bits/stdlib.h"
__inline extern size_t __attribute__((__artificial__))  ( __attribute__((__always_inline__)) wcstombs)(char * __restrict  __dst ,
                                                                                                       wchar_t const   * __restrict  __src ,
                                                                                                       size_t __len ) 
{ unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
#line 148
  tmp___4 = __builtin_object_size((void *)__dst, 1);
#line 148
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 151
    tmp = __builtin_object_size((void *)__dst, 1);
#line 151
    tmp___0 = __wcstombs_chk(__dst, __src, __len, tmp);
#line 151
    return ((size_t __attribute__((__artificial__))  )tmp___0);
#line 152
    tmp___3 = __builtin_object_size((void *)__dst, 1);
#line 152
    if (__len > tmp___3) {
#line 153
      tmp___1 = __builtin_object_size((void *)__dst, 1);
#line 153
      tmp___2 = __wcstombs_chk_warn(__dst, __src, __len, tmp___1);
#line 153
      return ((size_t __attribute__((__artificial__))  )tmp___2);
    }
  }
#line 155
  tmp___5 = __wcstombs_alias(__dst, __src, __len);
#line 155
  return ((size_t __attribute__((__artificial__))  )tmp___5);
}
}
#line 42 "error.h"
extern void ( /* format attribute */  error)(int __status , int __errnum , char const   *__format 
                                             , ...) ;
#line 20 "quote.h"
char const   *quote(char const   *name ) ;
#line 47 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 52 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *dcgettext(char const   *__domainname ,
                                                     char const   *__msgid , int __category )  __attribute__((__format_arg__(2))) ;
#line 44 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void __attribute__((__artificial__))  *( __attribute__((__always_inline__)) memcpy)(void * __restrict  __dest ,
                                                                                                                                  void const   * __restrict  __src ,
                                                                                                                                  size_t __len )  __attribute__((__nonnull__(1,2))) ;
#line 49
__inline extern  __attribute__((__nothrow__)) void __attribute__((__artificial__))  *( __attribute__((__always_inline__)) memmove)(void *__dest ,
                                                                                                                                   void const   *__src ,
                                                                                                                                   size_t __len )  __attribute__((__nonnull__(1,2))) ;
#line 65
__inline extern  __attribute__((__nothrow__)) void __attribute__((__artificial__))  *( __attribute__((__always_inline__)) memset)(void *__dest ,
                                                                                                                                  int __ch ,
                                                                                                                                  size_t __len )  __attribute__((__nonnull__(1))) ;
#line 128
__inline extern  __attribute__((__nothrow__)) char __attribute__((__artificial__))  *( __attribute__((__always_inline__)) strcpy)(char * __restrict  __dest ,
                                                                                                                                  char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
#line 131
__inline extern  __attribute__((__nothrow__)) char __attribute__((__artificial__))  *( __attribute__((__always_inline__)) strncpy)(char * __restrict  __dest ,
                                                                                                                                   char const   * __restrict  __src ,
                                                                                                                                   size_t __len )  __attribute__((__nonnull__(1,2))) ;
#line 136
__inline extern  __attribute__((__nothrow__)) char __attribute__((__artificial__))  *( __attribute__((__always_inline__)) strcat)(char * __restrict  __dest ,
                                                                                                                                  char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
#line 139
__inline extern  __attribute__((__nothrow__)) char __attribute__((__artificial__))  *( __attribute__((__always_inline__)) strncat)(char * __restrict  __dest ,
                                                                                                                                   char const   * __restrict  __src ,
                                                                                                                                   size_t __len )  __attribute__((__nonnull__(1,2))) ;
#line 391
__inline extern  __attribute__((__nothrow__)) void __attribute__((__artificial__))  *( __attribute__((__always_inline__)) mempcpy)(void * __restrict  __dest ,
                                                                                                                                   void const   * __restrict  __src ,
                                                                                                                                   size_t __len )  __attribute__((__nonnull__(1,2))) ;
#line 455
__inline extern  __attribute__((__nothrow__)) void __attribute__((__artificial__))  ( __attribute__((__always_inline__)) bcopy)(void const   *__src ,
                                                                                                                                void *__dest ,
                                                                                                                                size_t __len )  __attribute__((__nonnull__(1,2))) ;
#line 459
__inline extern  __attribute__((__nothrow__)) void __attribute__((__artificial__))  ( __attribute__((__always_inline__)) bzero)(void *__dest ,
                                                                                                                                size_t __len )  __attribute__((__nonnull__(1))) ;
#line 571
__inline extern  __attribute__((__nothrow__)) char __attribute__((__artificial__))  *( __attribute__((__always_inline__)) stpcpy)(char * __restrict  __dest ,
                                                                                                                                  char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
#line 579
__inline extern  __attribute__((__nothrow__)) char __attribute__((__artificial__))  *( __attribute__((__always_inline__)) stpncpy)(char * __restrict  __dest ,
                                                                                                                                   char const   * __restrict  __src ,
                                                                                                                                   size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 969 "/usr/include/bits/string2.h"
__inline extern size_t __strcspn_c1(char const   *__s , int __reject ) ;
#line 970 "/usr/include/bits/string2.h"
__inline extern size_t __strcspn_c1(char const   *__s , int __reject ) 
{ register size_t __result ;

  {
#line 973
  __result = (size_t )0;
#line 974
  while (1) {
#line 974
    if ((int const   )*(__s + __result) != 0) {
#line 974
      if (! ((int const   )*(__s + __result) != (int const   )__reject)) {
#line 974
        break;
      }
    } else {
#line 974
      break;
    }
#line 975
    __result ++;
  }
#line 976
  return (__result);
}
}
#line 979
__inline extern size_t __strcspn_c2(char const   *__s , int __reject1 , int __reject2 ) ;
#line 981 "/usr/include/bits/string2.h"
__inline extern size_t __strcspn_c2(char const   *__s , int __reject1 , int __reject2 ) 
{ register size_t __result ;

  {
#line 984
  __result = (size_t )0;
#line 985
  while (1) {
#line 985
    if ((int const   )*(__s + __result) != 0) {
#line 985
      if ((int const   )*(__s + __result) != (int const   )__reject1) {
#line 985
        if (! ((int const   )*(__s + __result) != (int const   )__reject2)) {
#line 985
          break;
        }
      } else {
#line 985
        break;
      }
    } else {
#line 985
      break;
    }
#line 987
    __result ++;
  }
#line 988
  return (__result);
}
}
#line 991
__inline extern size_t __strcspn_c3(char const   *__s , int __reject1 , int __reject2 ,
                                    int __reject3 ) ;
#line 993 "/usr/include/bits/string2.h"
__inline extern size_t __strcspn_c3(char const   *__s , int __reject1 , int __reject2 ,
                                    int __reject3 ) 
{ register size_t __result ;

  {
#line 997
  __result = (size_t )0;
#line 998
  while (1) {
#line 998
    if ((int const   )*(__s + __result) != 0) {
#line 998
      if ((int const   )*(__s + __result) != (int const   )__reject1) {
#line 998
        if ((int const   )*(__s + __result) != (int const   )__reject2) {
#line 998
          if (! ((int const   )*(__s + __result) != (int const   )__reject3)) {
#line 998
            break;
          }
        } else {
#line 998
          break;
        }
      } else {
#line 998
        break;
      }
    } else {
#line 998
      break;
    }
#line 1000
    __result ++;
  }
#line 1001
  return (__result);
}
}
#line 1045
__inline extern size_t __strspn_c1(char const   *__s , int __accept ) ;
#line 1046 "/usr/include/bits/string2.h"
__inline extern size_t __strspn_c1(char const   *__s , int __accept ) 
{ register size_t __result ;

  {
#line 1049
  __result = (size_t )0;
#line 1051
  while ((int const   )*(__s + __result) == (int const   )__accept) {
#line 1052
    __result ++;
  }
#line 1053
  return (__result);
}
}
#line 1056
__inline extern size_t __strspn_c2(char const   *__s , int __accept1 , int __accept2 ) ;
#line 1058 "/usr/include/bits/string2.h"
__inline extern size_t __strspn_c2(char const   *__s , int __accept1 , int __accept2 ) 
{ register size_t __result ;

  {
#line 1061
  __result = (size_t )0;
#line 1063
  while (1) {
#line 1063
    if (! ((int const   )*(__s + __result) == (int const   )__accept1)) {
#line 1063
      if (! ((int const   )*(__s + __result) == (int const   )__accept2)) {
#line 1063
        break;
      }
    }
#line 1064
    __result ++;
  }
#line 1065
  return (__result);
}
}
#line 1068
__inline extern size_t __strspn_c3(char const   *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) ;
#line 1070 "/usr/include/bits/string2.h"
__inline extern size_t __strspn_c3(char const   *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) 
{ register size_t __result ;

  {
#line 1073
  __result = (size_t )0;
#line 1075
  while (1) {
#line 1075
    if (! ((int const   )*(__s + __result) == (int const   )__accept1)) {
#line 1075
      if (! ((int const   )*(__s + __result) == (int const   )__accept2)) {
#line 1075
        if (! ((int const   )*(__s + __result) == (int const   )__accept3)) {
#line 1075
          break;
        }
      }
    }
#line 1077
    __result ++;
  }
#line 1078
  return (__result);
}
}
#line 1121
__inline extern char *__strpbrk_c2(char const   *__s , int __accept1 , int __accept2 ) ;
#line 1123 "/usr/include/bits/string2.h"
__inline extern char *__strpbrk_c2(char const   *__s , int __accept1 , int __accept2 ) 
{ char *tmp ;

  {
#line 1127
  while (1) {
#line 1127
    if ((int const   )*__s != 0) {
#line 1127
      if ((int const   )*__s != (int const   )__accept1) {
#line 1127
        if (! ((int const   )*__s != (int const   )__accept2)) {
#line 1127
          break;
        }
      } else {
#line 1127
        break;
      }
    } else {
#line 1127
      break;
    }
#line 1128
    __s ++;
  }
#line 1129
  if ((int const   )*__s == 0) {
#line 1129
    tmp = (char *)((void *)0);
  } else {
#line 1129
    tmp = (char *)((size_t )__s);
  }
#line 1129
  return (tmp);
}
}
#line 1132
__inline extern char *__strpbrk_c3(char const   *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) ;
#line 1134 "/usr/include/bits/string2.h"
__inline extern char *__strpbrk_c3(char const   *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) 
{ char *tmp ;

  {
#line 1139
  while (1) {
#line 1139
    if ((int const   )*__s != 0) {
#line 1139
      if ((int const   )*__s != (int const   )__accept1) {
#line 1139
        if ((int const   )*__s != (int const   )__accept2) {
#line 1139
          if (! ((int const   )*__s != (int const   )__accept3)) {
#line 1139
            break;
          }
        } else {
#line 1139
          break;
        }
      } else {
#line 1139
        break;
      }
    } else {
#line 1139
      break;
    }
#line 1141
    __s ++;
  }
#line 1142
  if ((int const   )*__s == 0) {
#line 1142
    tmp = (char *)((void *)0);
  } else {
#line 1142
    tmp = (char *)((size_t )__s);
  }
#line 1142
  return (tmp);
}
}
#line 1172
__inline extern char *__strtok_r_1c(char *__s , char __sep , char **__nextp ) ;
#line 1173 "/usr/include/bits/string2.h"
__inline extern char *__strtok_r_1c(char *__s , char __sep , char **__nextp ) 
{ char *__result ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 1177
  if ((unsigned long )__s == (unsigned long )((void *)0)) {
#line 1178
    __s = *__nextp;
  }
#line 1179
  while ((int )*__s == (int )__sep) {
#line 1180
    __s ++;
  }
#line 1181
  __result = (char *)((void *)0);
#line 1182
  if ((int )*__s != 0) {
#line 1184
    tmp = __s;
#line 1184
    __s ++;
#line 1184
    __result = tmp;
#line 1185
    while ((int )*__s != 0) {
#line 1186
      tmp___0 = __s;
#line 1186
      __s ++;
#line 1186
      if ((int )*tmp___0 == (int )__sep) {
#line 1188
        *(__s + -1) = (char )'\000';
#line 1189
        break;
      }
    }
  }
#line 1192
  *__nextp = __s;
#line 1193
  return (__result);
}
}
#line 1222
__inline extern char *__strsep_1c(char **__s , char __reject ) ;
#line 1223 "/usr/include/bits/string2.h"
__inline extern char *__strsep_1c(char **__s , char __reject ) 
{ register char *__retval ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___2 ;

  {
#line 1226
  __retval = *__s;
#line 1227
  if ((unsigned long )__retval != (unsigned long )((void *)0)) {
#line 1227
    tmp___2 = __builtin_strchr(__retval, (int )__reject);
#line 1227
    tmp___0 = tmp___2;
#line 1227
    *__s = tmp___0;
#line 1227
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 1228
      tmp = *__s;
#line 1228
      (*__s) ++;
#line 1228
      *tmp = (char )'\000';
    }
  }
#line 1229
  return (__retval);
}
}
#line 1232
__inline extern char *__strsep_2c(char **__s , char __reject1 , char __reject2 ) ;
#line 1233 "/usr/include/bits/string2.h"
__inline extern char *__strsep_2c(char **__s , char __reject1 , char __reject2 ) 
{ register char *__retval ;
  register char *__cp ;
  char *tmp ;

  {
#line 1236
  __retval = *__s;
#line 1237
  if ((unsigned long )__retval != (unsigned long )((void *)0)) {
#line 1239
    __cp = __retval;
#line 1240
    while (1) {
#line 1242
      if ((int )*__cp == 0) {
#line 1244
        __cp = (char *)((void *)0);
#line 1245
        break;
      }
#line 1247
      if ((int )*__cp == (int )__reject1) {
#line 1249
        tmp = __cp;
#line 1249
        __cp ++;
#line 1249
        *tmp = (char )'\000';
#line 1250
        break;
      } else
#line 1247
      if ((int )*__cp == (int )__reject2) {
#line 1249
        tmp = __cp;
#line 1249
        __cp ++;
#line 1249
        *tmp = (char )'\000';
#line 1250
        break;
      }
#line 1252
      __cp ++;
    }
#line 1254
    *__s = __cp;
  }
#line 1256
  return (__retval);
}
}
#line 1259
__inline extern char *__strsep_3c(char **__s , char __reject1 , char __reject2 , char __reject3 ) ;
#line 1261 "/usr/include/bits/string2.h"
__inline extern char *__strsep_3c(char **__s , char __reject1 , char __reject2 , char __reject3 ) 
{ register char *__retval ;
  register char *__cp ;
  char *tmp ;

  {
#line 1264
  __retval = *__s;
#line 1265
  if ((unsigned long )__retval != (unsigned long )((void *)0)) {
#line 1267
    __cp = __retval;
#line 1268
    while (1) {
#line 1270
      if ((int )*__cp == 0) {
#line 1272
        __cp = (char *)((void *)0);
#line 1273
        break;
      }
#line 1275
      if ((int )*__cp == (int )__reject1) {
#line 1277
        tmp = __cp;
#line 1277
        __cp ++;
#line 1277
        *tmp = (char )'\000';
#line 1278
        break;
      } else
#line 1275
      if ((int )*__cp == (int )__reject2) {
#line 1277
        tmp = __cp;
#line 1277
        __cp ++;
#line 1277
        *tmp = (char )'\000';
#line 1278
        break;
      } else
#line 1275
      if ((int )*__cp == (int )__reject3) {
#line 1277
        tmp = __cp;
#line 1277
        __cp ++;
#line 1277
        *tmp = (char )'\000';
#line 1278
        break;
      }
#line 1280
      __cp ++;
    }
#line 1282
    *__s = __cp;
  }
#line 1284
  return (__retval);
}
}
#line 48 "/usr/include/bits/string3.h"
__inline extern  __attribute__((__nothrow__)) void __attribute__((__artificial__))  *( __attribute__((__always_inline__)) memcpy)(void * __restrict  __dest ,
                                                                                                                                  void const   * __restrict  __src ,
                                                                                                                                  size_t __len )  __attribute__((__nonnull__(1,2))) ;
#line 48 "/usr/include/bits/string3.h"
__inline extern void __attribute__((__artificial__))  *( __attribute__((__always_inline__)) memcpy)(void * __restrict  __dest ,
                                                                                                    void const   * __restrict  __src ,
                                                                                                    size_t __len ) 
{ unsigned long tmp ;
  void *tmp___0 ;

  {
#line 52
  tmp = __builtin_object_size((void *)__dest, 0);
#line 52
  tmp___0 = __builtin___memcpy_chk((void *)__dest, (void const   *)__src, __len, tmp);
#line 52
  return ((void __attribute__((__artificial__))  *)tmp___0);
}
}
#line 55
__inline extern  __attribute__((__nothrow__)) void __attribute__((__artificial__))  *( __attribute__((__always_inline__)) memmove)(void *__dest ,
                                                                                                                                   void const   *__src ,
                                                                                                                                   size_t __len )  __attribute__((__nonnull__(1,2))) ;
#line 55 "/usr/include/bits/string3.h"
__inline extern void __attribute__((__artificial__))  *( __attribute__((__always_inline__)) memmove)(void *__dest ,
                                                                                                     void const   *__src ,
                                                                                                     size_t __len ) 
{ unsigned long tmp ;
  void *tmp___0 ;

  {
#line 58
  tmp = __builtin_object_size(__dest, 0);
#line 58
  tmp___0 = __builtin___memmove_chk(__dest, __src, __len, tmp);
#line 58
  return ((void __attribute__((__artificial__))  *)tmp___0);
}
}
#line 62
__inline extern  __attribute__((__nothrow__)) void __attribute__((__artificial__))  *( __attribute__((__always_inline__)) mempcpy)(void * __restrict  __dest ,
                                                                                                                                   void const   * __restrict  __src ,
                                                                                                                                   size_t __len )  __attribute__((__nonnull__(1,2))) ;
#line 62 "/usr/include/bits/string3.h"
__inline extern void __attribute__((__artificial__))  *( __attribute__((__always_inline__)) mempcpy)(void * __restrict  __dest ,
                                                                                                     void const   * __restrict  __src ,
                                                                                                     size_t __len ) 
{ unsigned long tmp ;
  void *tmp___0 ;

  {
#line 66
  tmp = __builtin_object_size((void *)__dest, 0);
#line 66
  tmp___0 = __builtin___mempcpy_chk((void *)__dest, (void const   *)__src, __len,
                                    tmp);
#line 66
  return ((void __attribute__((__artificial__))  *)tmp___0);
}
}
#line 76
__inline extern  __attribute__((__nothrow__)) void __attribute__((__artificial__))  *( __attribute__((__always_inline__)) memset)(void *__dest ,
                                                                                                                                  int __ch ,
                                                                                                                                  size_t __len )  __attribute__((__nonnull__(1))) ;
#line 76 "/usr/include/bits/string3.h"
__inline extern void __attribute__((__artificial__))  *( __attribute__((__always_inline__)) memset)(void *__dest ,
                                                                                                    int __ch ,
                                                                                                    size_t __len ) 
{ unsigned long tmp ;
  void *tmp___0 ;

  {
#line 85
  tmp = __builtin_object_size(__dest, 0);
#line 85
  tmp___0 = __builtin___memset_chk(__dest, __ch, __len, tmp);
#line 85
  return ((void __attribute__((__artificial__))  *)tmp___0);
}
}
#line 89
__inline extern  __attribute__((__nothrow__)) void __attribute__((__artificial__))  ( __attribute__((__always_inline__)) bcopy)(void const   *__src ,
                                                                                                                                void *__dest ,
                                                                                                                                size_t __len )  __attribute__((__nonnull__(1,2))) ;
#line 89 "/usr/include/bits/string3.h"
__inline extern void __attribute__((__artificial__))  ( __attribute__((__always_inline__)) bcopy)(void const   *__src ,
                                                                                                  void *__dest ,
                                                                                                  size_t __len ) 
{ unsigned long tmp ;

  {
#line 92
  tmp = __builtin_object_size(__dest, 0);
#line 92
  __builtin___memmove_chk(__dest, __src, __len, tmp);
#line 93
  return;
}
}
#line 95
__inline extern  __attribute__((__nothrow__)) void __attribute__((__artificial__))  ( __attribute__((__always_inline__)) bzero)(void *__dest ,
                                                                                                                                size_t __len )  __attribute__((__nonnull__(1))) ;
#line 95 "/usr/include/bits/string3.h"
__inline extern void __attribute__((__artificial__))  ( __attribute__((__always_inline__)) bzero)(void *__dest ,
                                                                                                  size_t __len ) 
{ unsigned long tmp ;

  {
#line 98
  tmp = __builtin_object_size(__dest, 0);
#line 98
  __builtin___memset_chk(__dest, '\000', __len, tmp);
#line 99
  return;
}
}
#line 102
__inline extern  __attribute__((__nothrow__)) char __attribute__((__artificial__))  *( __attribute__((__always_inline__)) strcpy)(char * __restrict  __dest ,
                                                                                                                                  char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
#line 102 "/usr/include/bits/string3.h"
__inline extern char __attribute__((__artificial__))  *( __attribute__((__always_inline__)) strcpy)(char * __restrict  __dest ,
                                                                                                    char const   * __restrict  __src ) 
{ unsigned long tmp ;
  char *tmp___0 ;

  {
#line 105
  tmp = __builtin_object_size((void *)__dest, 1);
#line 105
  tmp___0 = __builtin___strcpy_chk((char *)__dest, (char const   *)__src, tmp);
#line 105
  return ((char __attribute__((__artificial__))  *)tmp___0);
}
}
#line 109
__inline extern  __attribute__((__nothrow__)) char __attribute__((__artificial__))  *( __attribute__((__always_inline__)) stpcpy)(char * __restrict  __dest ,
                                                                                                                                  char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
#line 109 "/usr/include/bits/string3.h"
__inline extern char __attribute__((__artificial__))  *( __attribute__((__always_inline__)) stpcpy)(char * __restrict  __dest ,
                                                                                                    char const   * __restrict  __src ) 
{ unsigned long tmp ;
  char *tmp___0 ;

  {
#line 112
  tmp = __builtin_object_size((void *)__dest, 1);
#line 112
  tmp___0 = __builtin___stpcpy_chk((char *)__dest, (char const   *)__src, tmp);
#line 112
  return ((char __attribute__((__artificial__))  *)tmp___0);
}
}
#line 117
__inline extern  __attribute__((__nothrow__)) char __attribute__((__artificial__))  *( __attribute__((__always_inline__)) strncpy)(char * __restrict  __dest ,
                                                                                                                                   char const   * __restrict  __src ,
                                                                                                                                   size_t __len )  __attribute__((__nonnull__(1,2))) ;
#line 117 "/usr/include/bits/string3.h"
__inline extern char __attribute__((__artificial__))  *( __attribute__((__always_inline__)) strncpy)(char * __restrict  __dest ,
                                                                                                     char const   * __restrict  __src ,
                                                                                                     size_t __len ) 
{ unsigned long tmp ;
  char *tmp___0 ;

  {
#line 121
  tmp = __builtin_object_size((void *)__dest, 1);
#line 121
  tmp___0 = __builtin___strncpy_chk((char *)__dest, (char const   *)__src, __len,
                                    tmp);
#line 121
  return ((char __attribute__((__artificial__))  *)tmp___0);
}
}
#line 125
extern  __attribute__((__nothrow__)) char *__stpncpy_chk(char *__dest , char const   *__src ,
                                                         size_t __n , size_t __destlen ) ;
#line 127
extern  __attribute__((__nothrow__)) char *__stpncpy_alias(char *__dest , char const   *__src ,
                                                           size_t __n )  __asm__("stpncpy")  ;
#line 131
__inline extern  __attribute__((__nothrow__)) char __attribute__((__artificial__))  *( __attribute__((__always_inline__)) stpncpy)(char * __restrict  __dest ,
                                                                                                                                   char const   * __restrict  __src ,
                                                                                                                                   size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 131 "/usr/include/bits/string3.h"
__inline extern char __attribute__((__artificial__))  *( __attribute__((__always_inline__)) stpncpy)(char * __restrict  __dest ,
                                                                                                     char const   * __restrict  __src ,
                                                                                                     size_t __n ) 
{ unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___3 ;

  {
#line 134
  tmp___1 = __builtin_object_size((void *)__dest, 1);
#line 134
  if (tmp___1 != 0xffffffffffffffffUL) {
#line 136
    tmp = __builtin_object_size((void *)__dest, 1);
#line 136
    tmp___0 = __stpncpy_chk((char *)__dest, (char const   *)__src, __n, tmp);
#line 136
    return ((char __attribute__((__artificial__))  *)tmp___0);
  }
#line 137
  tmp___3 = __stpncpy_alias((char *)__dest, (char const   *)__src, __n);
#line 137
  return ((char __attribute__((__artificial__))  *)tmp___3);
}
}
#line 141
__inline extern  __attribute__((__nothrow__)) char __attribute__((__artificial__))  *( __attribute__((__always_inline__)) strcat)(char * __restrict  __dest ,
                                                                                                                                  char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
#line 141 "/usr/include/bits/string3.h"
__inline extern char __attribute__((__artificial__))  *( __attribute__((__always_inline__)) strcat)(char * __restrict  __dest ,
                                                                                                    char const   * __restrict  __src ) 
{ unsigned long tmp ;
  char *tmp___0 ;

  {
#line 144
  tmp = __builtin_object_size((void *)__dest, 1);
#line 144
  tmp___0 = __builtin___strcat_chk((char *)__dest, (char const   *)__src, tmp);
#line 144
  return ((char __attribute__((__artificial__))  *)tmp___0);
}
}
#line 148
__inline extern  __attribute__((__nothrow__)) char __attribute__((__artificial__))  *( __attribute__((__always_inline__)) strncat)(char * __restrict  __dest ,
                                                                                                                                   char const   * __restrict  __src ,
                                                                                                                                   size_t __len )  __attribute__((__nonnull__(1,2))) ;
#line 148 "/usr/include/bits/string3.h"
__inline extern char __attribute__((__artificial__))  *( __attribute__((__always_inline__)) strncat)(char * __restrict  __dest ,
                                                                                                     char const   * __restrict  __src ,
                                                                                                     size_t __len ) 
{ unsigned long tmp ;
  char *tmp___0 ;

  {
#line 152
  tmp = __builtin_object_size((void *)__dest, 1);
#line 152
  tmp___0 = __builtin___strncat_chk((char *)__dest, (char const   *)__src, __len,
                                    tmp);
#line 152
  return ((char __attribute__((__artificial__))  *)tmp___0);
}
}
#line 36 "set-mode-acl.c"
int chmod_or_fchmod(char const   *name , int desc , mode_t mode ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 39
  if (desc != -1) {
#line 40
    tmp = fchmod(desc, mode);
#line 40
    return (tmp);
  } else {
#line 42
    tmp___0 = chmod(name, mode);
#line 42
    return (tmp___0);
  }
}
}
#line 53 "set-mode-acl.c"
int qset_acl(char const   *name , int desc , mode_t mode ) 
{ int tmp ;

  {
#line 671
  tmp = chmod_or_fchmod(name, desc, mode);
#line 671
  return (tmp);
}
}
#line 677 "set-mode-acl.c"
int set_acl(char const   *name , int desc , mode_t mode ) 
{ int r ;
  int tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;

  {
#line 680
  tmp = qset_acl(name, desc, mode);
#line 680
  r = tmp;
#line 681
  if (r != 0) {
#line 682
    tmp___0 = quote(name);
#line 682
    tmp___1 = dcgettext((char const   *)((void *)0), "setting permissions for %s",
                        5);
#line 682
    tmp___2 = __errno_location();
#line 682
    error(0, *tmp___2, (char const   *)tmp___1, tmp___0);
  }
#line 683
  return (r);
}
}
#line 1 "copy-acl.o"
#pragma merger(0,"/tmp/cil-4zEP0CVl.i","-g,-O2")
#line 24 "acl.h"
int copy_acl(char const   *src_name , int source_desc , char const   *dst_name , int dest_desc ,
             mode_t mode ) ;
#line 41 "copy-acl.c"
static int qcopy_acl(char const   *src_name , int source_desc , char const   *dst_name ,
                     int dest_desc , mode_t mode ) 
{ int tmp ;

  {
#line 611
  tmp = qset_acl(dst_name, dest_desc, mode);
#line 611
  return (tmp);
}
}
#line 626 "copy-acl.c"
int copy_acl(char const   *src_name , int source_desc , char const   *dst_name , int dest_desc ,
             mode_t mode ) 
{ int ret ;
  int tmp ;
  char const   *tmp___0 ;
  int *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;

  {
#line 630
  tmp = qcopy_acl(src_name, source_desc, dst_name, dest_desc, mode);
#line 630
  ret = tmp;
#line 631
  switch (ret) {
  case -2: 
#line 634
  tmp___0 = quote(src_name);
#line 634
  tmp___1 = __errno_location();
#line 634
  error(0, *tmp___1, "%s", tmp___0);
#line 635
  return (-1);
  case -1: 
#line 638
  tmp___2 = quote(dst_name);
#line 638
  tmp___3 = dcgettext((char const   *)((void *)0), "preserving permissions for %s",
                      5);
#line 638
  tmp___4 = __errno_location();
#line 638
  error(0, *tmp___4, (char const   *)tmp___3, tmp___2);
#line 639
  return (-1);
  default: 
#line 642
  return (0);
  }
}
}
#line 1 "file-has-acl.o"
#pragma merger(0,"/tmp/cil-otGs9Vbe.i","-g,-O2")
#line 23 "acl.h"
int file_has_acl(char const   *name , struct stat  const  *sb ) ;
#line 444 "file-has-acl.c"
int file_has_acl(char const   *name , struct stat  const  *sb ) 
{ 

  {
#line 845
  return (0);
}
}
#line 1 "allocator.o"
#pragma merger(0,"/tmp/cil-tq52fNIy.i","-g,-O2")
#line 56 "allocator.h"
struct allocator  const  stdlib_allocator ;
#line 471 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__warn_unused_result__,
__malloc__)) ;
#line 485
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size )  __attribute__((__warn_unused_result__)) ;
#line 488
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 5 "allocator.c"
struct allocator  const  stdlib_allocator  =    {& malloc, & realloc, & free, (void (*)(size_t  ))((void *)0)};
#line 1 "areadlink.o"
#pragma merger(0,"/tmp/cil-SWXekWD4.i","-g,-O2")
#line 23 "areadlink.h"
char *areadlink(char const   *filename ) ;
#line 119 "/usr/include/fcntl.h"
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) open)(char const   *__path ,
                                                                                                int __oflag 
                                                                                                , ...)  __attribute__((__nonnull__(1))) ;
#line 129
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) open64)(char const   *__path ,
                                                                                                  int __oflag 
                                                                                                  , ...)  __attribute__((__nonnull__(1))) ;
#line 143
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) openat)(int __fd ,
                                                                                                  char const   *__path ,
                                                                                                  int __oflag 
                                                                                                  , ...)  __attribute__((__nonnull__(2))) ;
#line 154
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) openat64)(int __fd ,
                                                                                                    char const   *__path ,
                                                                                                    int __oflag 
                                                                                                    , ...)  __attribute__((__nonnull__(2))) ;
#line 27 "/usr/include/bits/fcntl2.h"
extern int __open_2(char const   *__path , int __oflag )  __attribute__((__nonnull__(1))) ;
#line 28
extern int __open_alias(char const   *__path , int __oflag  , ...)  __asm__("open") __attribute__((__nonnull__(1))) ;
#line 41
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) open)(char const   *__path ,
                                                                                                int __oflag 
                                                                                                , ...)  __attribute__((__nonnull__(1))) ;
#line 41 "/usr/include/bits/fcntl2.h"
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) open)(char const   *__path ,
                                                                                                int __oflag 
                                                                                                , ...) 
{ int tmp ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 44
  tmp = __builtin_va_arg_pack_len();
#line 57
  tmp___4 = __builtin_va_arg_pack_len();
#line 57
  if (tmp___4 < 1) {
#line 58
    tmp___3 = __open_2(__path, __oflag);
#line 58
    return ((int __attribute__((__artificial__))  )tmp___3);
  }
#line 60
  tmp___5 = __open_alias(__path, __oflag, __builtin_va_arg_pack());
#line 60
  return ((int __attribute__((__artificial__))  )tmp___5);
}
}
#line 65
extern int __open64_2(char const   *__path , int __oflag )  __attribute__((__nonnull__(1))) ;
#line 66
extern int __open64_alias(char const   *__path , int __oflag  , ...)  __asm__("open64") __attribute__((__nonnull__(1))) ;
#line 68
extern void __open64_too_many_args(void)  __attribute__((__error__("open64 can be called either with 2 or 3 arguments, not more"))) ;
#line 73
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) open64)(char const   *__path ,
                                                                                                  int __oflag 
                                                                                                  , ...)  __attribute__((__nonnull__(1))) ;
#line 73 "/usr/include/bits/fcntl2.h"
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) open64)(char const   *__path ,
                                                                                                  int __oflag 
                                                                                                  , ...) 
{ int tmp ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 76
  tmp = __builtin_va_arg_pack_len();
#line 76
  if (tmp > 1) {
#line 77
    __open64_too_many_args();
  }
#line 89
  tmp___4 = __builtin_va_arg_pack_len();
#line 89
  if (tmp___4 < 1) {
#line 90
    tmp___3 = __open64_2(__path, __oflag);
#line 90
    return ((int __attribute__((__artificial__))  )tmp___3);
  }
#line 92
  tmp___5 = __open64_alias(__path, __oflag, __builtin_va_arg_pack());
#line 92
  return ((int __attribute__((__artificial__))  )tmp___5);
}
}
#line 99
extern int __openat_2(int __fd , char const   *__path , int __oflag )  __attribute__((__nonnull__(2))) ;
#line 101
extern int __openat_alias(int __fd , char const   *__path , int __oflag  , ...)  __asm__("openat") __attribute__((__nonnull__(2))) ;
#line 117
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) openat)(int __fd ,
                                                                                                  char const   *__path ,
                                                                                                  int __oflag 
                                                                                                  , ...)  __attribute__((__nonnull__(2))) ;
#line 117 "/usr/include/bits/fcntl2.h"
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) openat)(int __fd ,
                                                                                                  char const   *__path ,
                                                                                                  int __oflag 
                                                                                                  , ...) 
{ int tmp ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 120
  tmp = __builtin_va_arg_pack_len();
#line 133
  tmp___4 = __builtin_va_arg_pack_len();
#line 133
  if (tmp___4 < 1) {
#line 134
    tmp___3 = __openat_2(__fd, __path, __oflag);
#line 134
    return ((int __attribute__((__artificial__))  )tmp___3);
  }
#line 136
  tmp___5 = __openat_alias(__fd, __path, __oflag, __builtin_va_arg_pack());
#line 136
  return ((int __attribute__((__artificial__))  )tmp___5);
}
}
#line 141
extern int __openat64_2(int __fd , char const   *__path , int __oflag )  __attribute__((__nonnull__(2))) ;
#line 143
extern int __openat64_alias(int __fd , char const   *__path , int __oflag  , ...)  __asm__("openat64") __attribute__((__nonnull__(2))) ;
#line 146
extern void __openat64_too_many_args(void)  __attribute__((__error__("openat64 can be called either with 3 or 4 arguments, not more"))) ;
#line 151
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) openat64)(int __fd ,
                                                                                                    char const   *__path ,
                                                                                                    int __oflag 
                                                                                                    , ...)  __attribute__((__nonnull__(2))) ;
#line 151 "/usr/include/bits/fcntl2.h"
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) openat64)(int __fd ,
                                                                                                    char const   *__path ,
                                                                                                    int __oflag 
                                                                                                    , ...) 
{ int tmp ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 154
  tmp = __builtin_va_arg_pack_len();
#line 154
  if (tmp > 1) {
#line 155
    __openat64_too_many_args();
  }
#line 167
  tmp___4 = __builtin_va_arg_pack_len();
#line 167
  if (tmp___4 < 1) {
#line 168
    tmp___3 = __openat64_2(__fd, __path, __oflag);
#line 168
    return ((int __attribute__((__artificial__))  )tmp___3);
  }
#line 170
  tmp___5 = __openat64_alias(__fd, __path, __oflag, __builtin_va_arg_pack());
#line 170
  return ((int __attribute__((__artificial__))  )tmp___5);
}
}
#line 357 "/usr/include/unistd.h"
__inline extern ssize_t __attribute__((__warn_unused_result__, __artificial__))  ( __attribute__((__always_inline__)) read)(int __fd ,
                                                                                                                            void *__buf ,
                                                                                                                            size_t __nbytes )  __attribute__((__warn_unused_result__)) ;
#line 373
__inline extern ssize_t __attribute__((__warn_unused_result__, __artificial__))  ( __attribute__((__always_inline__)) pread)(int __fd ,
                                                                                                                             void *__buf ,
                                                                                                                             size_t __nbytes ,
                                                                                                                             __off_t __offset )  __attribute__((__warn_unused_result__)) ;
#line 401
__inline extern ssize_t __attribute__((__warn_unused_result__, __artificial__))  ( __attribute__((__always_inline__)) pread64)(int __fd ,
                                                                                                                               void *__buf ,
                                                                                                                               size_t __nbytes ,
                                                                                                                               __off64_t __offset )  __attribute__((__warn_unused_result__)) ;
#line 508
__inline extern  __attribute__((__nothrow__)) char __attribute__((__warn_unused_result__,
__artificial__))  *( __attribute__((__always_inline__)) getcwd)(char *__buf , size_t __size )  __attribute__((__warn_unused_result__)) ;
#line 522
__inline extern  __attribute__((__nothrow__)) char __attribute__((__warn_unused_result__,
__nonnull__(1), __deprecated__, __artificial__))  *( __attribute__((__always_inline__)) getwd)(char *__buf )  __attribute__((__warn_unused_result__,
__nonnull__(1), __deprecated__)) ;
#line 620
__inline extern  __attribute__((__nothrow__)) size_t __attribute__((__artificial__))  ( __attribute__((__always_inline__)) confstr)(int __name ,
                                                                                                                                    char *__buf ,
                                                                                                                                    size_t __len ) ;
#line 708
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) getgroups)(int __size ,
                                                                                                                                   __gid_t *__list )  __attribute__((__warn_unused_result__)) ;
#line 793
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) ttyname_r)(int __fd ,
                                                                                                                                   char *__buf ,
                                                                                                                                   size_t __buflen )  __attribute__((__warn_unused_result__,
__nonnull__(2))) ;
#line 828
__inline extern  __attribute__((__nothrow__)) ssize_t __attribute__((__warn_unused_result__,
__nonnull__(1,2), __artificial__))  ( __attribute__((__always_inline__)) readlink)(char const   * __restrict  __path ,
                                                                                   char * __restrict  __buf ,
                                                                                   size_t __len )  __attribute__((__warn_unused_result__,
__nonnull__(1,2))) ;
#line 839
__inline extern  __attribute__((__nothrow__)) ssize_t __attribute__((__warn_unused_result__,
__nonnull__(2,3), __artificial__))  ( __attribute__((__always_inline__)) readlinkat)(int __fd ,
                                                                                     char const   * __restrict  __path ,
                                                                                     char * __restrict  __buf ,
                                                                                     size_t __len )  __attribute__((__warn_unused_result__,
__nonnull__(2,3))) ;
#line 876
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) getlogin_r)(char *__buf ,
                                                                                                      size_t __buflen )  __attribute__((__nonnull__(1))) ;
#line 898
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) gethostname)(char *__buf ,
                                                                                                                                     size_t __buflen )  __attribute__((__nonnull__(1))) ;
#line 916
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) getdomainname)(char *__buf ,
                                                                                                                                       size_t __buflen )  __attribute__((__warn_unused_result__,
__nonnull__(1))) ;
#line 24 "/usr/include/bits/unistd.h"
extern ssize_t __read_chk(int __fd , void *__buf , size_t __nbytes , size_t __buflen )  __attribute__((__warn_unused_result__)) ;
#line 26
extern ssize_t __read_alias(int __fd , void *__buf , size_t __nbytes )  __asm__("read") __attribute__((__warn_unused_result__)) ;
#line 28
extern ssize_t __read_chk_warn(int __fd , void *__buf , size_t __nbytes , size_t __buflen )  __asm__("__read_chk") __attribute__((__warning__("read called with bigger length than size of the destination buffer"),
__warn_unused_result__)) ;
#line 34
__inline extern ssize_t __attribute__((__warn_unused_result__, __artificial__))  ( __attribute__((__always_inline__)) read)(int __fd ,
                                                                                                                            void *__buf ,
                                                                                                                            size_t __nbytes )  __attribute__((__warn_unused_result__)) ;
#line 34 "/usr/include/bits/unistd.h"
__inline extern ssize_t __attribute__((__warn_unused_result__, __artificial__))  ( __attribute__((__always_inline__)) read)(int __fd ,
                                                                                                                            void *__buf ,
                                                                                                                            size_t __nbytes ) 
{ unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 37
  tmp___4 = __builtin_object_size(__buf, 0);
#line 37
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 40
    tmp = __builtin_object_size(__buf, 0);
#line 40
    tmp___0 = __read_chk(__fd, __buf, __nbytes, tmp);
#line 40
    return ((ssize_t __attribute__((__artificial__))  )tmp___0);
#line 42
    tmp___3 = __builtin_object_size(__buf, 0);
#line 42
    if (__nbytes > tmp___3) {
#line 43
      tmp___1 = __builtin_object_size(__buf, 0);
#line 43
      tmp___2 = __read_chk_warn(__fd, __buf, __nbytes, tmp___1);
#line 43
      return ((ssize_t __attribute__((__artificial__))  )tmp___2);
    }
  }
#line 45
  tmp___5 = __read_alias(__fd, __buf, __nbytes);
#line 45
  return ((ssize_t __attribute__((__artificial__))  )tmp___5);
}
}
#line 49
extern ssize_t __pread_chk(int __fd , void *__buf , size_t __nbytes , __off_t __offset ,
                           size_t __bufsize )  __attribute__((__warn_unused_result__)) ;
#line 51
extern ssize_t __pread64_chk(int __fd , void *__buf , size_t __nbytes , __off64_t __offset ,
                             size_t __bufsize )  __attribute__((__warn_unused_result__)) ;
#line 53
extern ssize_t __pread_alias(int __fd , void *__buf , size_t __nbytes , __off_t __offset )  __asm__("pread") __attribute__((__warn_unused_result__)) ;
#line 56
extern ssize_t __pread64_alias(int __fd , void *__buf , size_t __nbytes , __off64_t __offset )  __asm__("pread64") __attribute__((__warn_unused_result__)) ;
#line 59
extern ssize_t __pread_chk_warn(int __fd , void *__buf , size_t __nbytes , __off_t __offset ,
                                size_t __bufsize )  __asm__("__pread_chk") __attribute__((__warning__("pread called with bigger length than size of the destination buffer"),
__warn_unused_result__)) ;
#line 64
extern ssize_t __pread64_chk_warn(int __fd , void *__buf , size_t __nbytes , __off64_t __offset ,
                                  size_t __bufsize )  __asm__("__pread64_chk") __attribute__((__warning__("pread64 called with bigger length than size of the destination buffer"),
__warn_unused_result__)) ;
#line 72
__inline extern ssize_t __attribute__((__warn_unused_result__, __artificial__))  ( __attribute__((__always_inline__)) pread)(int __fd ,
                                                                                                                             void *__buf ,
                                                                                                                             size_t __nbytes ,
                                                                                                                             __off_t __offset )  __attribute__((__warn_unused_result__)) ;
#line 72 "/usr/include/bits/unistd.h"
__inline extern ssize_t __attribute__((__warn_unused_result__, __artificial__))  ( __attribute__((__always_inline__)) pread)(int __fd ,
                                                                                                                             void *__buf ,
                                                                                                                             size_t __nbytes ,
                                                                                                                             __off_t __offset ) 
{ unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 75
  tmp___4 = __builtin_object_size(__buf, 0);
#line 75
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 78
    tmp = __builtin_object_size(__buf, 0);
#line 78
    tmp___0 = __pread_chk(__fd, __buf, __nbytes, __offset, tmp);
#line 78
    return ((ssize_t __attribute__((__artificial__))  )tmp___0);
#line 80
    tmp___3 = __builtin_object_size(__buf, 0);
#line 80
    if (__nbytes > tmp___3) {
#line 81
      tmp___1 = __builtin_object_size(__buf, 0);
#line 81
      tmp___2 = __pread_chk_warn(__fd, __buf, __nbytes, __offset, tmp___1);
#line 81
      return ((ssize_t __attribute__((__artificial__))  )tmp___2);
    }
  }
#line 84
  tmp___5 = __pread_alias(__fd, __buf, __nbytes, __offset);
#line 84
  return ((ssize_t __attribute__((__artificial__))  )tmp___5);
}
}
#line 105
__inline extern ssize_t __attribute__((__warn_unused_result__, __artificial__))  ( __attribute__((__always_inline__)) pread64)(int __fd ,
                                                                                                                               void *__buf ,
                                                                                                                               size_t __nbytes ,
                                                                                                                               __off64_t __offset )  __attribute__((__warn_unused_result__)) ;
#line 105 "/usr/include/bits/unistd.h"
__inline extern ssize_t __attribute__((__warn_unused_result__, __artificial__))  ( __attribute__((__always_inline__)) pread64)(int __fd ,
                                                                                                                               void *__buf ,
                                                                                                                               size_t __nbytes ,
                                                                                                                               __off64_t __offset ) 
{ unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 108
  tmp___4 = __builtin_object_size(__buf, 0);
#line 108
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 111
    tmp = __builtin_object_size(__buf, 0);
#line 111
    tmp___0 = __pread64_chk(__fd, __buf, __nbytes, __offset, tmp);
#line 111
    return ((ssize_t __attribute__((__artificial__))  )tmp___0);
#line 113
    tmp___3 = __builtin_object_size(__buf, 0);
#line 113
    if (__nbytes > tmp___3) {
#line 114
      tmp___1 = __builtin_object_size(__buf, 0);
#line 114
      tmp___2 = __pread64_chk_warn(__fd, __buf, __nbytes, __offset, tmp___1);
#line 114
      return ((ssize_t __attribute__((__artificial__))  )tmp___2);
    }
  }
#line 118
  tmp___5 = __pread64_alias(__fd, __buf, __nbytes, __offset);
#line 118
  return ((ssize_t __attribute__((__artificial__))  )tmp___5);
}
}
#line 124
extern  __attribute__((__nothrow__)) ssize_t __readlink_chk(char const   * __restrict  __path ,
                                                            char * __restrict  __buf ,
                                                            size_t __len , size_t __buflen )  __attribute__((__warn_unused_result__,
__nonnull__(1,2))) ;
#line 128
extern  __attribute__((__nothrow__)) ssize_t __readlink_alias(char const   * __restrict  __path ,
                                                              char * __restrict  __buf ,
                                                              size_t __len )  __asm__("readlink") __attribute__((__warn_unused_result__,
__nonnull__(1,2))) ;
#line 132
extern  __attribute__((__nothrow__)) ssize_t __readlink_chk_warn(char const   * __restrict  __path ,
                                                                 char * __restrict  __buf ,
                                                                 size_t __len , size_t __buflen )  __asm__("__readlink_chk") __attribute__((__warning__("readlink called with bigger length than size of destination buffer"),
__warn_unused_result__, __nonnull__(1,2))) ;
#line 139
__inline extern  __attribute__((__nothrow__)) ssize_t __attribute__((__warn_unused_result__,
__nonnull__(1,2), __artificial__))  ( __attribute__((__always_inline__)) readlink)(char const   * __restrict  __path ,
                                                                                   char * __restrict  __buf ,
                                                                                   size_t __len )  __attribute__((__warn_unused_result__,
__nonnull__(1,2))) ;
#line 139 "/usr/include/bits/unistd.h"
__inline extern ssize_t __attribute__((__warn_unused_result__, __nonnull__(1,2), __artificial__))  ( __attribute__((__always_inline__)) readlink)(char const   * __restrict  __path ,
                                                                                                                                                  char * __restrict  __buf ,
                                                                                                                                                  size_t __len ) 
{ unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 143
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 143
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 146
    tmp = __builtin_object_size((void *)__buf, 1);
#line 146
    tmp___0 = __readlink_chk(__path, __buf, __len, tmp);
#line 146
    return ((ssize_t __attribute__((__nonnull__(1,2), __artificial__))  )tmp___0);
#line 148
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 148
    if (__len > tmp___3) {
#line 149
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 149
      tmp___2 = __readlink_chk_warn(__path, __buf, __len, tmp___1);
#line 149
      return ((ssize_t __attribute__((__nonnull__(1,2), __artificial__))  )tmp___2);
    }
  }
#line 151
  tmp___5 = __readlink_alias(__path, __buf, __len);
#line 151
  return ((ssize_t __attribute__((__nonnull__(1,2), __artificial__))  )tmp___5);
}
}
#line 156
extern  __attribute__((__nothrow__)) ssize_t __readlinkat_chk(int __fd , char const   * __restrict  __path ,
                                                              char * __restrict  __buf ,
                                                              size_t __len , size_t __buflen )  __attribute__((__warn_unused_result__,
__nonnull__(2,3))) ;
#line 160
extern  __attribute__((__nothrow__)) ssize_t __readlinkat_alias(int __fd , char const   * __restrict  __path ,
                                                                char * __restrict  __buf ,
                                                                size_t __len )  __asm__("readlinkat") __attribute__((__warn_unused_result__,
__nonnull__(2,3))) ;
#line 165
extern  __attribute__((__nothrow__)) ssize_t __readlinkat_chk_warn(int __fd , char const   * __restrict  __path ,
                                                                   char * __restrict  __buf ,
                                                                   size_t __len ,
                                                                   size_t __buflen )  __asm__("__readlinkat_chk") __attribute__((__warning__("readlinkat called with bigger length than size of destination buffer"),
__warn_unused_result__, __nonnull__(2,3))) ;
#line 173
__inline extern  __attribute__((__nothrow__)) ssize_t __attribute__((__warn_unused_result__,
__nonnull__(2,3), __artificial__))  ( __attribute__((__always_inline__)) readlinkat)(int __fd ,
                                                                                     char const   * __restrict  __path ,
                                                                                     char * __restrict  __buf ,
                                                                                     size_t __len )  __attribute__((__warn_unused_result__,
__nonnull__(2,3))) ;
#line 173 "/usr/include/bits/unistd.h"
__inline extern ssize_t __attribute__((__warn_unused_result__, __nonnull__(2,3), __artificial__))  ( __attribute__((__always_inline__)) readlinkat)(int __fd ,
                                                                                                                                                    char const   * __restrict  __path ,
                                                                                                                                                    char * __restrict  __buf ,
                                                                                                                                                    size_t __len ) 
{ unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 177
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 177
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 180
    tmp = __builtin_object_size((void *)__buf, 1);
#line 180
    tmp___0 = __readlinkat_chk(__fd, __path, __buf, __len, tmp);
#line 180
    return ((ssize_t __attribute__((__nonnull__(2,3), __artificial__))  )tmp___0);
#line 182
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 182
    if (__len > tmp___3) {
#line 183
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 183
      tmp___2 = __readlinkat_chk_warn(__fd, __path, __buf, __len, tmp___1);
#line 183
      return ((ssize_t __attribute__((__nonnull__(2,3), __artificial__))  )tmp___2);
    }
  }
#line 186
  tmp___5 = __readlinkat_alias(__fd, __path, __buf, __len);
#line 186
  return ((ssize_t __attribute__((__nonnull__(2,3), __artificial__))  )tmp___5);
}
}
#line 190
extern  __attribute__((__nothrow__)) char *__getcwd_chk(char *__buf , size_t __size ,
                                                        size_t __buflen )  __attribute__((__warn_unused_result__)) ;
#line 192
extern  __attribute__((__nothrow__)) char *__getcwd_alias(char *__buf , size_t __size )  __asm__("getcwd") __attribute__((__warn_unused_result__)) ;
#line 194
extern  __attribute__((__nothrow__)) char *__getcwd_chk_warn(char *__buf , size_t __size ,
                                                             size_t __buflen )  __asm__("__getcwd_chk") __attribute__((__warning__("getcwd caller with bigger length than size of destination buffer"),
__warn_unused_result__)) ;
#line 200
__inline extern  __attribute__((__nothrow__)) char __attribute__((__warn_unused_result__,
__artificial__))  *( __attribute__((__always_inline__)) getcwd)(char *__buf , size_t __size )  __attribute__((__warn_unused_result__)) ;
#line 200 "/usr/include/bits/unistd.h"
__inline extern char __attribute__((__warn_unused_result__, __artificial__))  *( __attribute__((__always_inline__)) getcwd)(char *__buf ,
                                                                                                                            size_t __size ) 
{ unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  char *tmp___5 ;

  {
#line 203
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 203
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 206
    tmp = __builtin_object_size((void *)__buf, 1);
#line 206
    tmp___0 = __getcwd_chk(__buf, __size, tmp);
#line 206
    return ((char __attribute__((__warn_unused_result__, __artificial__))  *)tmp___0);
#line 208
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 208
    if (__size > tmp___3) {
#line 209
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 209
      tmp___2 = __getcwd_chk_warn(__buf, __size, tmp___1);
#line 209
      return ((char __attribute__((__warn_unused_result__, __artificial__))  *)tmp___2);
    }
  }
#line 211
  tmp___5 = __getcwd_alias(__buf, __size);
#line 211
  return ((char __attribute__((__warn_unused_result__, __artificial__))  *)tmp___5);
}
}
#line 215
extern  __attribute__((__nothrow__)) char *__getwd_chk(char *__buf , size_t buflen )  __attribute__((__warn_unused_result__,
__nonnull__(1))) ;
#line 217
extern  __attribute__((__nothrow__)) char *__getwd_warn(char *__buf )  __asm__("getwd") __attribute__((__warning__("please use getcwd instead, as getwd doesn\'t specify buffer size"),
__warn_unused_result__, __nonnull__(1))) ;
#line 221
__inline extern  __attribute__((__nothrow__)) char __attribute__((__warn_unused_result__,
__nonnull__(1), __deprecated__, __artificial__))  *( __attribute__((__always_inline__)) getwd)(char *__buf )  __attribute__((__warn_unused_result__,
__nonnull__(1), __deprecated__)) ;
#line 221 "/usr/include/bits/unistd.h"
__inline extern char __attribute__((__warn_unused_result__, __nonnull__(1), __deprecated__,
__artificial__))  *( __attribute__((__always_inline__)) getwd)(char *__buf ) 
{ unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;

  {
#line 224
  tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 224
  if (tmp___1 != 0xffffffffffffffffUL) {
#line 225
    tmp = __builtin_object_size((void *)__buf, 1);
#line 225
    tmp___0 = __getwd_chk(__buf, tmp);
#line 225
    return ((char __attribute__((__warn_unused_result__, __nonnull__(1), __deprecated__,
    __artificial__))  *)tmp___0);
  }
#line 226
  tmp___2 = __getwd_warn(__buf);
#line 226
  return ((char __attribute__((__warn_unused_result__, __nonnull__(1), __deprecated__,
  __artificial__))  *)tmp___2);
}
}
#line 230
extern  __attribute__((__nothrow__)) size_t __confstr_chk(int __name , char *__buf ,
                                                          size_t __len , size_t __buflen ) ;
#line 232
extern  __attribute__((__nothrow__)) size_t __confstr_alias(int __name , char *__buf ,
                                                            size_t __len )  __asm__("confstr")  ;
#line 234
extern  __attribute__((__nothrow__)) size_t __confstr_chk_warn(int __name , char *__buf ,
                                                               size_t __len , size_t __buflen )  __asm__("__confstr_chk") __attribute__((__warning__("confstr called with bigger length than size of destination buffer"))) ;
#line 240
__inline extern  __attribute__((__nothrow__)) size_t __attribute__((__artificial__))  ( __attribute__((__always_inline__)) confstr)(int __name ,
                                                                                                                                    char *__buf ,
                                                                                                                                    size_t __len ) ;
#line 240 "/usr/include/bits/unistd.h"
__inline extern size_t __attribute__((__artificial__))  ( __attribute__((__always_inline__)) confstr)(int __name ,
                                                                                                      char *__buf ,
                                                                                                      size_t __len ) 
{ unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
#line 243
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 243
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 246
    tmp = __builtin_object_size((void *)__buf, 1);
#line 246
    tmp___0 = __confstr_chk(__name, __buf, __len, tmp);
#line 246
    return ((size_t __attribute__((__artificial__))  )tmp___0);
#line 248
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 248
    if (tmp___3 < __len) {
#line 249
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 249
      tmp___2 = __confstr_chk_warn(__name, __buf, __len, tmp___1);
#line 249
      return ((size_t __attribute__((__artificial__))  )tmp___2);
    }
  }
#line 251
  tmp___5 = __confstr_alias(__name, __buf, __len);
#line 251
  return ((size_t __attribute__((__artificial__))  )tmp___5);
}
}
#line 255
extern  __attribute__((__nothrow__)) int __getgroups_chk(int __size , __gid_t *__list ,
                                                         size_t __listlen )  __attribute__((__warn_unused_result__)) ;
#line 257
extern  __attribute__((__nothrow__)) int __getgroups_alias(int __size , __gid_t *__list )  __asm__("getgroups") __attribute__((__warn_unused_result__)) ;
#line 259
extern  __attribute__((__nothrow__)) int __getgroups_chk_warn(int __size , __gid_t *__list ,
                                                              size_t __listlen )  __asm__("__getgroups_chk") __attribute__((__warning__("getgroups called with bigger group count than what can fit into destination buffer"),
__warn_unused_result__)) ;
#line 265
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) getgroups)(int __size ,
                                                                                                                                   __gid_t *__list )  __attribute__((__warn_unused_result__)) ;
#line 265 "/usr/include/bits/unistd.h"
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) getgroups)(int __size ,
                                                                                                     __gid_t *__list ) 
{ unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
#line 268
  tmp___4 = __builtin_object_size((void *)__list, 1);
#line 268
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 271
    tmp = __builtin_object_size((void *)__list, 1);
#line 271
    tmp___0 = __getgroups_chk(__size, __list, tmp);
#line 271
    return ((int __attribute__((__artificial__))  )tmp___0);
#line 273
    tmp___3 = __builtin_object_size((void *)__list, 1);
#line 273
    if ((unsigned long )__size * sizeof(__gid_t ) > tmp___3) {
#line 274
      tmp___1 = __builtin_object_size((void *)__list, 1);
#line 274
      tmp___2 = __getgroups_chk_warn(__size, __list, tmp___1);
#line 274
      return ((int __attribute__((__artificial__))  )tmp___2);
    }
  }
#line 276
  tmp___5 = __getgroups_alias(__size, __list);
#line 276
  return ((int __attribute__((__artificial__))  )tmp___5);
}
}
#line 280
extern  __attribute__((__nothrow__)) int __ttyname_r_chk(int __fd , char *__buf ,
                                                         size_t __buflen , size_t __nreal )  __attribute__((__nonnull__(2))) ;
#line 282
extern  __attribute__((__nothrow__)) int __ttyname_r_alias(int __fd , char *__buf ,
                                                           size_t __buflen )  __asm__("ttyname_r") __attribute__((__nonnull__(2))) ;
#line 285
extern  __attribute__((__nothrow__)) int __ttyname_r_chk_warn(int __fd , char *__buf ,
                                                              size_t __buflen , size_t __nreal )  __asm__("__ttyname_r_chk") __attribute__((__warning__("ttyname_r called with bigger buflen than size of destination buffer"),
__nonnull__(2))) ;
#line 291
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) ttyname_r)(int __fd ,
                                                                                                                                   char *__buf ,
                                                                                                                                   size_t __buflen )  __attribute__((__warn_unused_result__,
__nonnull__(2))) ;
#line 291 "/usr/include/bits/unistd.h"
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) ttyname_r)(int __fd ,
                                                                                                     char *__buf ,
                                                                                                     size_t __buflen ) 
{ unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
#line 294
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 294
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 297
    tmp = __builtin_object_size((void *)__buf, 1);
#line 297
    tmp___0 = __ttyname_r_chk(__fd, __buf, __buflen, tmp);
#line 297
    return ((int __attribute__((__artificial__))  )tmp___0);
#line 299
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 299
    if (__buflen > tmp___3) {
#line 300
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 300
      tmp___2 = __ttyname_r_chk_warn(__fd, __buf, __buflen, tmp___1);
#line 300
      return ((int __attribute__((__artificial__))  )tmp___2);
    }
  }
#line 302
  tmp___5 = __ttyname_r_alias(__fd, __buf, __buflen);
#line 302
  return ((int __attribute__((__artificial__))  )tmp___5);
}
}
#line 307
extern int __getlogin_r_chk(char *__buf , size_t __buflen , size_t __nreal )  __attribute__((__nonnull__(1))) ;
#line 309
extern int __getlogin_r_alias(char *__buf , size_t __buflen )  __asm__("getlogin_r") __attribute__((__nonnull__(1))) ;
#line 311
extern int __getlogin_r_chk_warn(char *__buf , size_t __buflen , size_t __nreal )  __asm__("__getlogin_r_chk") __attribute__((__warning__("getlogin_r called with bigger buflen than size of destination buffer"),
__nonnull__(1))) ;
#line 317
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) getlogin_r)(char *__buf ,
                                                                                                      size_t __buflen )  __attribute__((__nonnull__(1))) ;
#line 317 "/usr/include/bits/unistd.h"
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) getlogin_r)(char *__buf ,
                                                                                                      size_t __buflen ) 
{ unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
#line 320
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 320
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 323
    tmp = __builtin_object_size((void *)__buf, 1);
#line 323
    tmp___0 = __getlogin_r_chk(__buf, __buflen, tmp);
#line 323
    return ((int __attribute__((__artificial__))  )tmp___0);
#line 325
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 325
    if (__buflen > tmp___3) {
#line 326
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 326
      tmp___2 = __getlogin_r_chk_warn(__buf, __buflen, tmp___1);
#line 326
      return ((int __attribute__((__artificial__))  )tmp___2);
    }
  }
#line 328
  tmp___5 = __getlogin_r_alias(__buf, __buflen);
#line 328
  return ((int __attribute__((__artificial__))  )tmp___5);
}
}
#line 334
extern  __attribute__((__nothrow__)) int __gethostname_chk(char *__buf , size_t __buflen ,
                                                           size_t __nreal )  __attribute__((__nonnull__(1))) ;
#line 336
extern  __attribute__((__nothrow__)) int __gethostname_alias(char *__buf , size_t __buflen )  __asm__("gethostname") __attribute__((__nonnull__(1))) ;
#line 338
extern  __attribute__((__nothrow__)) int __gethostname_chk_warn(char *__buf , size_t __buflen ,
                                                                size_t __nreal )  __asm__("__gethostname_chk") __attribute__((__warning__("gethostname called with bigger buflen than size of destination buffer"),
__nonnull__(1))) ;
#line 344
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) gethostname)(char *__buf ,
                                                                                                                                     size_t __buflen )  __attribute__((__nonnull__(1))) ;
#line 344 "/usr/include/bits/unistd.h"
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) gethostname)(char *__buf ,
                                                                                                       size_t __buflen ) 
{ unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
#line 347
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 347
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 350
    tmp = __builtin_object_size((void *)__buf, 1);
#line 350
    tmp___0 = __gethostname_chk(__buf, __buflen, tmp);
#line 350
    return ((int __attribute__((__artificial__))  )tmp___0);
#line 352
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 352
    if (__buflen > tmp___3) {
#line 353
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 353
      tmp___2 = __gethostname_chk_warn(__buf, __buflen, tmp___1);
#line 353
      return ((int __attribute__((__artificial__))  )tmp___2);
    }
  }
#line 355
  tmp___5 = __gethostname_alias(__buf, __buflen);
#line 355
  return ((int __attribute__((__artificial__))  )tmp___5);
}
}
#line 361
extern  __attribute__((__nothrow__)) int __getdomainname_chk(char *__buf , size_t __buflen ,
                                                             size_t __nreal )  __attribute__((__warn_unused_result__,
__nonnull__(1))) ;
#line 363
extern  __attribute__((__nothrow__)) int __getdomainname_alias(char *__buf , size_t __buflen )  __asm__("getdomainname") __attribute__((__warn_unused_result__,
__nonnull__(1))) ;
#line 366
extern  __attribute__((__nothrow__)) int __getdomainname_chk_warn(char *__buf , size_t __buflen ,
                                                                  size_t __nreal )  __asm__("__getdomainname_chk") __attribute__((__warning__("getdomainname called with bigger buflen than size of destination buffer"),
__warn_unused_result__, __nonnull__(1))) ;
#line 373
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) getdomainname)(char *__buf ,
                                                                                                                                       size_t __buflen )  __attribute__((__warn_unused_result__,
__nonnull__(1))) ;
#line 373 "/usr/include/bits/unistd.h"
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) getdomainname)(char *__buf ,
                                                                                                         size_t __buflen ) 
{ unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
#line 376
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 376
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 379
    tmp = __builtin_object_size((void *)__buf, 1);
#line 379
    tmp___0 = __getdomainname_chk(__buf, __buflen, tmp);
#line 379
    return ((int __attribute__((__artificial__))  )tmp___0);
#line 381
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 381
    if (__buflen > tmp___3) {
#line 382
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 382
      tmp___2 = __getdomainname_chk_warn(__buf, __buflen, tmp___1);
#line 382
      return ((int __attribute__((__artificial__))  )tmp___2);
    }
  }
#line 384
  tmp___5 = __getdomainname_alias(__buf, __buflen);
#line 384
  return ((int __attribute__((__artificial__))  )tmp___5);
}
}
#line 49 "careadlinkat.h"
char *careadlinkat(int fd , char const   *filename , char *buffer , size_t buffer_size ,
                   struct allocator  const  *alloc , ssize_t (*preadlinkat)(int  ,
                                                                            char const   * ,
                                                                            char * ,
                                                                            size_t  ) ) ;
#line 69
ssize_t careadlinkatcwd(int fd , char const   *filename , char *buffer , size_t buffer_size ) ;
#line 35 "areadlink.c"
char *areadlink(char const   *filename ) 
{ char *tmp ;

  {
#line 38
  tmp = careadlinkat(-100, filename, (char *)((void *)0), (size_t )0, (struct allocator  const  *)((void *)0),
                     & careadlinkatcwd);
#line 38
  return (tmp);
}
}
#line 1 "areadlink-with-size.o"
#pragma merger(0,"/tmp/cil-kDu7uLPM.i","-g,-O2")
#line 24 "areadlink.h"
char *areadlink_with_size(char const   *file , size_t size ) ;
#line 51 "areadlink-with-size.c"
char *areadlink_with_size(char const   *file , size_t size ) 
{ size_t symlink_max ;
  size_t INITIAL_LIMIT_BOUND ;
  size_t initial_limit ;
  size_t tmp ;
  size_t buf_size ;
  size_t tmp___0 ;
  ssize_t r ;
  size_t link_length ;
  char *buffer ;
  void *tmp___1 ;
  ssize_t __attribute__((__nonnull__(1,2), __artificial__))  tmp___2 ;
  int saved_errno ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  ssize_t __attribute__((__nonnull__(1,2), __artificial__))  tmp___7 ;

  {
#line 57
  symlink_max = (size_t )1024;
#line 58
  INITIAL_LIMIT_BOUND = (size_t )8192;
#line 59
  if (symlink_max < INITIAL_LIMIT_BOUND) {
#line 59
    tmp = symlink_max + 1UL;
  } else {
#line 59
    tmp = INITIAL_LIMIT_BOUND;
  }
#line 59
  initial_limit = tmp;
#line 64
  if (size < initial_limit) {
#line 64
    tmp___0 = size + 1UL;
  } else {
#line 64
    tmp___0 = initial_limit;
  }
#line 64
  buf_size = tmp___0;
#line 66
  while (1) {
#line 70
    tmp___1 = malloc(buf_size);
#line 70
    buffer = (char *)tmp___1;
#line 72
    if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 73
      return ((char *)((void *)0));
    }
#line 74
    tmp___7 = (ssize_t __attribute__((__nonnull__(1,2), __artificial__))  )readlink((char const   * __restrict  )file,
                                                                                    (char * __restrict  )buffer,
                                                                                    buf_size);
#line 74
    tmp___2 = tmp___7;
#line 74
    r = (ssize_t )tmp___2;
#line 75
    link_length = (size_t )r;
#line 79
    if (r < 0L) {
#line 79
      tmp___5 = __errno_location();
#line 79
      if (*tmp___5 != 34) {
#line 81
        tmp___3 = __errno_location();
#line 81
        saved_errno = *tmp___3;
#line 82
        free((void *)buffer);
#line 83
        tmp___4 = __errno_location();
#line 83
        *tmp___4 = saved_errno;
#line 84
        return ((char *)((void *)0));
      }
    }
#line 87
    if (link_length < buf_size) {
#line 89
      *(buffer + link_length) = (char)0;
#line 90
      return (buffer);
    }
#line 93
    free((void *)buffer);
#line 94
    if (buf_size <= 4611686018427387903UL) {
#line 95
      buf_size *= 2UL;
    } else
#line 96
    if (buf_size < 9223372036854775807UL) {
#line 97
      buf_size = 9223372036854775807UL;
    } else {
#line 100
      tmp___6 = __errno_location();
#line 100
      *tmp___6 = 12;
#line 101
      return ((char *)((void *)0));
    }
  }
}
}
#line 1 "areadlinkat.o"
#pragma merger(0,"/tmp/cil-oseHcCTq.i","-g,-O2")
#line 27 "areadlink.h"
char *areadlinkat(int fd , char const   *filename ) ;
#line 39 "areadlinkat.c"
char *areadlinkat(int fd , char const   *filename ) 
{ char *tmp ;

  {
#line 42
  tmp = careadlinkat(fd, filename, (char *)((void *)0), (size_t )0, (struct allocator  const  *)((void *)0),
                     (ssize_t (*)(int  , char const   * , char * , size_t  ))(& readlinkat));
#line 42
  return (tmp);
}
}
#line 1 "argmatch.o"
#pragma merger(0,"/tmp/cil-AKmgpeKh.i","-g,-O2")
#line 42 "argmatch.h"
ptrdiff_t argmatch(char const   *arg , char const   * const  *arglist , char const   *vallist ,
                   size_t valsize ) ;
#line 52
void (*argmatch_die)(void) ;
#line 56
void argmatch_invalid(char const   *context , char const   *value , ptrdiff_t problem ) ;
#line 68
void argmatch_valid(char const   * const  *arglist , char const   *vallist , size_t valsize ) ;
#line 79
ptrdiff_t __xargmatch_internal(char const   *context , char const   *arg , char const   * const  *arglist ,
                               char const   *vallist , size_t valsize , void (*exit_fn)(void) ) ;
#line 94
char const   *argmatch_to_argument(char const   *value , char const   * const  *arglist ,
                                   char const   *vallist , size_t valsize ) ;
#line 417 "/usr/include/libio.h"
extern int __uflow(_IO_FILE * ) ;
#line 418
extern int __overflow(_IO_FILE * , int  ) ;
#line 460
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 461
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 165 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 166
extern struct _IO_FILE *stdout ;
#line 167
extern struct _IO_FILE *stderr ;
#line 353
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) fprintf)(FILE * __restrict  __stream ,
                                                                                                   char const   * __restrict  __fmt 
                                                                                                   , ...) ;
#line 359
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) printf)(char const   * __restrict  __fmt 
                                                                                                  , ...) ;
#line 361
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) sprintf)(char * __restrict  __s ,
                                                                                                                                 char const   * __restrict  __fmt 
                                                                                                                                 , ...) ;
#line 368
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) vfprintf)(FILE * __restrict  __stream ,
                                                                                                    char const   * __restrict  __fmt ,
                                                                                                    __gnuc_va_list __ap ) ;
#line 374
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                                                                   __gnuc_va_list __ap ) ;
#line 376
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) vsprintf)(char * __restrict  __s ,
                                                                                                                                  char const   * __restrict  __fmt ,
                                                                                                                                  __gnuc_va_list __ap ) ;
#line 383
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) snprintf)(char * __restrict  __s ,
                                                                                                                                  size_t __n ,
                                                                                                                                  char const   * __restrict  __fmt 
                                                                                                                                  , ...) ;
#line 387
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) vsnprintf)(char * __restrict  __s ,
                                                                                                                                   size_t __n ,
                                                                                                                                   char const   * __restrict  __fmt ,
                                                                                                                                   __gnuc_va_list __ap ) ;
#line 396
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) vasprintf)(char ** __restrict  __ptr ,
                                                                                                                                   char const   * __restrict  __fmt ,
                                                                                                                                   __gnuc_va_list __ap )  __attribute__((__warn_unused_result__)) ;
#line 402
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) asprintf)(char ** __restrict  __ptr ,
                                                                                                                                  char const   * __restrict  __fmt 
                                                                                                                                  , ...)  __attribute__((__warn_unused_result__)) ;
#line 414
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) vdprintf)(int __fd ,
                                                                                                    char const   * __restrict  __fmt ,
                                                                                                    __gnuc_va_list __ap ) ;
#line 417
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) dprintf)(int __fd ,
                                                                                                   char const   * __restrict  __fmt 
                                                                                                   , ...) ;
#line 540
__inline extern int getchar(void) ;
#line 552
extern int getc_unlocked(FILE *__fp ) ;
#line 553
__inline extern int getchar_unlocked(void) ;
#line 563
__inline extern int fgetc_unlocked(FILE *__fp ) ;
#line 582
__inline extern int putchar(int __c ) ;
#line 596
__inline extern int fputc_unlocked(int __c , FILE *__stream ) ;
#line 605
__inline extern int putchar_unlocked(int __c ) ;
#line 624
__inline extern char __attribute__((__warn_unused_result__, __artificial__))  *( __attribute__((__always_inline__)) fgets)(char * __restrict  __s ,
                                                                                                                           int __n ,
                                                                                                                           FILE * __restrict  __stream )  __attribute__((__warn_unused_result__)) ;
#line 642
__inline extern char __attribute__((__warn_unused_result__, __artificial__))  *( __attribute__((__always_inline__)) fgets_unlocked)(char * __restrict  __s ,
                                                                                                                                    int __n ,
                                                                                                                                    FILE * __restrict  __stream )  __attribute__((__warn_unused_result__)) ;
#line 658
extern __ssize_t __getdelim(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                            int __delimiter , FILE * __restrict  __stream )  __attribute__((__warn_unused_result__)) ;
#line 671
__inline extern __ssize_t getline(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                                  FILE * __restrict  __stream )  __attribute__((__warn_unused_result__)) ;
#line 702
__inline extern size_t __attribute__((__warn_unused_result__, __artificial__))  ( __attribute__((__always_inline__)) fread)(void * __restrict  __ptr ,
                                                                                                                            size_t __size ,
                                                                                                                            size_t __n ,
                                                                                                                            FILE * __restrict  __stream )  __attribute__((__warn_unused_result__)) ;
#line 730
__inline extern size_t __attribute__((__warn_unused_result__, __artificial__))  ( __attribute__((__always_inline__)) fread_unlocked)(void * __restrict  __ptr ,
                                                                                                                                     size_t __size ,
                                                                                                                                     size_t __n ,
                                                                                                                                     FILE * __restrict  __stream )  __attribute__((__warn_unused_result__)) ;
#line 829
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream )  __attribute__((__warn_unused_result__)) ;
#line 830
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream )  __attribute__((__warn_unused_result__)) ;
#line 892
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) obstack_printf)(struct obstack * __restrict  __obstack ,
                                                                                                                                        char const   * __restrict  __fmt 
                                                                                                                                        , ...) ;
#line 895
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) obstack_vprintf)(struct obstack * __restrict  __obstack ,
                                                                                                                                         char const   * __restrict  __fmt ,
                                                                                                                                         __gnuc_va_list __ap ) ;
#line 44 "/usr/include/bits/stdio.h"
__inline extern int getchar(void) 
{ int tmp ;

  {
#line 47
  tmp = _IO_getc(stdin);
#line 47
  return (tmp);
}
}
#line 53 "/usr/include/bits/stdio.h"
__inline extern int fgetc_unlocked(FILE *__fp ) 
{ int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
#line 56
  tmp___3 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                             0L);
#line 56
  if (tmp___3) {
#line 56
    tmp___0 = __uflow(__fp);
#line 56
    tmp___2 = tmp___0;
  } else {
#line 56
    tmp___1 = __fp->_IO_read_ptr;
#line 56
    (__fp->_IO_read_ptr) ++;
#line 56
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
#line 56
  return (tmp___2);
}
}
#line 70 "/usr/include/bits/stdio.h"
__inline extern int getchar_unlocked(void) 
{ int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
#line 73
  tmp___3 = __builtin_expect((long )((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end),
                             0L);
#line 73
  if (tmp___3) {
#line 73
    tmp___0 = __uflow(stdin);
#line 73
    tmp___2 = tmp___0;
  } else {
#line 73
    tmp___1 = stdin->_IO_read_ptr;
#line 73
    (stdin->_IO_read_ptr) ++;
#line 73
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
#line 73
  return (tmp___2);
}
}
#line 79 "/usr/include/bits/stdio.h"
__inline extern int putchar(int __c ) 
{ int tmp ;

  {
#line 82
  tmp = _IO_putc(__c, stdout);
#line 82
  return (tmp);
}
}
#line 88 "/usr/include/bits/stdio.h"
__inline extern int fputc_unlocked(int __c , FILE *__stream ) 
{ int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
#line 91
  tmp___4 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                             0L);
#line 91
  if (tmp___4) {
#line 91
    tmp___0 = __overflow(__stream, (int )((unsigned char )__c));
#line 91
    tmp___3 = tmp___0;
  } else {
#line 91
    tmp___1 = __stream->_IO_write_ptr;
#line 91
    (__stream->_IO_write_ptr) ++;
#line 91
    tmp___2 = (char )__c;
#line 91
    *tmp___1 = tmp___2;
#line 91
    tmp___3 = (int )((unsigned char )tmp___2);
  }
#line 91
  return (tmp___3);
}
}
#line 105 "/usr/include/bits/stdio.h"
__inline extern int putchar_unlocked(int __c ) 
{ int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
#line 108
  tmp___4 = __builtin_expect((long )((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end),
                             0L);
#line 108
  if (tmp___4) {
#line 108
    tmp___0 = __overflow(stdout, (int )((unsigned char )__c));
#line 108
    tmp___3 = tmp___0;
  } else {
#line 108
    tmp___1 = stdout->_IO_write_ptr;
#line 108
    (stdout->_IO_write_ptr) ++;
#line 108
    tmp___2 = (char )__c;
#line 108
    *tmp___1 = tmp___2;
#line 108
    tmp___3 = (int )((unsigned char )tmp___2);
  }
#line 108
  return (tmp___3);
}
}
#line 115
__inline extern __ssize_t getline(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                                  FILE * __restrict  __stream )  __attribute__((__warn_unused_result__)) ;
#line 115 "/usr/include/bits/stdio.h"
__inline extern __ssize_t getline(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                                  FILE * __restrict  __stream ) 
{ __ssize_t tmp ;

  {
#line 118
  tmp = __getdelim(__lineptr, __n, '\n', __stream);
#line 118
  return (tmp);
}
}
#line 125
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream )  __attribute__((__warn_unused_result__)) ;
#line 125 "/usr/include/bits/stdio.h"
__inline extern int feof_unlocked(FILE *__stream ) 
{ 

  {
#line 128
  return ((__stream->_flags & 16) != 0);
}
}
#line 132
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream )  __attribute__((__warn_unused_result__)) ;
#line 132 "/usr/include/bits/stdio.h"
__inline extern int ferror_unlocked(FILE *__stream ) 
{ 

  {
#line 135
  return ((__stream->_flags & 32) != 0);
}
}
#line 31 "/usr/include/bits/stdio2.h"
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) sprintf)(char * __restrict  __s ,
                                                                                                                                 char const   * __restrict  __fmt 
                                                                                                                                 , ...) ;
#line 31 "/usr/include/bits/stdio2.h"
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) sprintf)(char * __restrict  __s ,
                                                                                                   char const   * __restrict  __fmt 
                                                                                                   , ...) 
{ unsigned long tmp ;
  int tmp___0 ;

  {
#line 34
  tmp = __builtin_object_size((void *)__s, 1);
#line 34
  tmp___0 = __builtin___sprintf_chk((char *)__s, 1, tmp, (char const   *)__fmt, __builtin_va_arg_pack());
#line 34
  return ((int __attribute__((__artificial__))  )tmp___0);
}
}
#line 43
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) vsprintf)(char * __restrict  __s ,
                                                                                                                                  char const   * __restrict  __fmt ,
                                                                                                                                  __gnuc_va_list __ap ) ;
#line 43 "/usr/include/bits/stdio2.h"
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) vsprintf)(char * __restrict  __s ,
                                                                                                    char const   * __restrict  __fmt ,
                                                                                                    __gnuc_va_list __ap ) 
{ unsigned long tmp ;
  int tmp___0 ;

  {
#line 47
  tmp = __builtin_object_size((void *)__s, 1);
#line 47
  tmp___0 = __builtin___vsprintf_chk((char *)__s, 1, tmp, (char const   *)__fmt, __ap);
#line 47
  return ((int __attribute__((__artificial__))  )tmp___0);
}
}
#line 61
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) snprintf)(char * __restrict  __s ,
                                                                                                                                  size_t __n ,
                                                                                                                                  char const   * __restrict  __fmt 
                                                                                                                                  , ...) ;
#line 61 "/usr/include/bits/stdio2.h"
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) snprintf)(char * __restrict  __s ,
                                                                                                    size_t __n ,
                                                                                                    char const   * __restrict  __fmt 
                                                                                                    , ...) 
{ unsigned long tmp ;
  int tmp___0 ;

  {
#line 65
  tmp = __builtin_object_size((void *)__s, 1);
#line 65
  tmp___0 = __builtin___snprintf_chk((char *)__s, __n, 1, tmp, (char const   *)__fmt,
                                     __builtin_va_arg_pack());
#line 65
  return ((int __attribute__((__artificial__))  )tmp___0);
}
}
#line 74
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) vsnprintf)(char * __restrict  __s ,
                                                                                                                                   size_t __n ,
                                                                                                                                   char const   * __restrict  __fmt ,
                                                                                                                                   __gnuc_va_list __ap ) ;
#line 74 "/usr/include/bits/stdio2.h"
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) vsnprintf)(char * __restrict  __s ,
                                                                                                     size_t __n ,
                                                                                                     char const   * __restrict  __fmt ,
                                                                                                     __gnuc_va_list __ap ) 
{ unsigned long tmp ;
  int tmp___0 ;

  {
#line 78
  tmp = __builtin_object_size((void *)__s, 1);
#line 78
  tmp___0 = __builtin___vsnprintf_chk((char *)__s, __n, 1, tmp, (char const   *)__fmt,
                                      __ap);
#line 78
  return ((int __attribute__((__artificial__))  )tmp___0);
}
}
#line 86
extern int __fprintf_chk(FILE * __restrict  __stream , int __flag , char const   * __restrict  __format 
                         , ...) ;
#line 88
extern int __printf_chk(int __flag , char const   * __restrict  __format  , ...) ;
#line 89
extern int __vfprintf_chk(FILE * __restrict  __stream , int __flag , char const   * __restrict  __format ,
                          __gnuc_va_list __ap ) ;
#line 95 "/usr/include/bits/stdio2.h"
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) fprintf)(FILE * __restrict  __stream ,
                                                                                                   char const   * __restrict  __fmt 
                                                                                                   , ...) 
{ int tmp ;

  {
#line 98
  tmp = __fprintf_chk(__stream, 1, __fmt, __builtin_va_arg_pack());
#line 98
  return ((int __attribute__((__artificial__))  )tmp);
}
}
#line 102 "/usr/include/bits/stdio2.h"
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) printf)(char const   * __restrict  __fmt 
                                                                                                  , ...) 
{ int tmp ;

  {
#line 105
  tmp = __printf_chk(1, __fmt, __builtin_va_arg_pack());
#line 105
  return ((int __attribute__((__artificial__))  )tmp);
}
}
#line 114 "/usr/include/bits/stdio2.h"
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                                                                   __gnuc_va_list __ap ) 
{ int tmp ;

  {
#line 118
  tmp = __vfprintf_chk((FILE * __restrict  )stdout, 1, __fmt, __ap);
#line 118
  return ((int __attribute__((__artificial__))  )tmp);
}
}
#line 124 "/usr/include/bits/stdio2.h"
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) vfprintf)(FILE * __restrict  __stream ,
                                                                                                    char const   * __restrict  __fmt ,
                                                                                                    __gnuc_va_list __ap ) 
{ int tmp ;

  {
#line 128
  tmp = __vfprintf_chk(__stream, 1, __fmt, __ap);
#line 128
  return ((int __attribute__((__artificial__))  )tmp);
}
}
#line 133
extern  __attribute__((__nothrow__)) int __asprintf_chk(char ** __restrict  __ptr ,
                                                        int __flag , char const   * __restrict  __fmt 
                                                        , ...)  __attribute__((__warn_unused_result__)) ;
#line 136
extern  __attribute__((__nothrow__)) int __vasprintf_chk(char ** __restrict  __ptr ,
                                                         int __flag , char const   * __restrict  __fmt ,
                                                         __gnuc_va_list __arg )  __attribute__((__warn_unused_result__)) ;
#line 139
extern int __dprintf_chk(int __fd , int __flag , char const   * __restrict  __fmt 
                         , ...) ;
#line 141
extern int __vdprintf_chk(int __fd , int __flag , char const   * __restrict  __fmt ,
                          __gnuc_va_list __arg ) ;
#line 144
extern  __attribute__((__nothrow__)) int __obstack_printf_chk(struct obstack * __restrict  __obstack ,
                                                              int __flag , char const   * __restrict  __format 
                                                              , ...) ;
#line 148
extern  __attribute__((__nothrow__)) int __obstack_vprintf_chk(struct obstack * __restrict  __obstack ,
                                                               int __flag , char const   * __restrict  __format ,
                                                               __gnuc_va_list __args ) ;
#line 155
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) asprintf)(char ** __restrict  __ptr ,
                                                                                                                                  char const   * __restrict  __fmt 
                                                                                                                                  , ...)  __attribute__((__warn_unused_result__)) ;
#line 155 "/usr/include/bits/stdio2.h"
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) asprintf)(char ** __restrict  __ptr ,
                                                                                                    char const   * __restrict  __fmt 
                                                                                                    , ...) 
{ int tmp ;

  {
#line 158
  tmp = __asprintf_chk(__ptr, 1, __fmt, __builtin_va_arg_pack());
#line 158
  return ((int __attribute__((__artificial__))  )tmp);
}
}
#line 170 "/usr/include/bits/stdio2.h"
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) dprintf)(int __fd ,
                                                                                                   char const   * __restrict  __fmt 
                                                                                                   , ...) 
{ int tmp ;

  {
#line 173
  tmp = __dprintf_chk(__fd, 1, __fmt, __builtin_va_arg_pack());
#line 173
  return ((int __attribute__((__artificial__))  )tmp);
}
}
#line 177
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) obstack_printf)(struct obstack * __restrict  __obstack ,
                                                                                                                                        char const   * __restrict  __fmt 
                                                                                                                                        , ...) ;
#line 177 "/usr/include/bits/stdio2.h"
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) obstack_printf)(struct obstack * __restrict  __obstack ,
                                                                                                          char const   * __restrict  __fmt 
                                                                                                          , ...) 
{ int tmp ;

  {
#line 181
  tmp = __obstack_printf_chk(__obstack, 1, __fmt, __builtin_va_arg_pack());
#line 181
  return ((int __attribute__((__artificial__))  )tmp);
}
}
#line 195
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) vasprintf)(char ** __restrict  __ptr ,
                                                                                                                                   char const   * __restrict  __fmt ,
                                                                                                                                   __gnuc_va_list __ap )  __attribute__((__warn_unused_result__)) ;
#line 195 "/usr/include/bits/stdio2.h"
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) vasprintf)(char ** __restrict  __ptr ,
                                                                                                     char const   * __restrict  __fmt ,
                                                                                                     __gnuc_va_list __ap ) 
{ int tmp ;

  {
#line 199
  tmp = __vasprintf_chk(__ptr, 1, __fmt, __ap);
#line 199
  return ((int __attribute__((__artificial__))  )tmp);
}
}
#line 202 "/usr/include/bits/stdio2.h"
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) vdprintf)(int __fd ,
                                                                                                    char const   * __restrict  __fmt ,
                                                                                                    __gnuc_va_list __ap ) 
{ int tmp ;

  {
#line 205
  tmp = __vdprintf_chk(__fd, 1, __fmt, __ap);
#line 205
  return ((int __attribute__((__artificial__))  )tmp);
}
}
#line 208
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) obstack_vprintf)(struct obstack * __restrict  __obstack ,
                                                                                                                                         char const   * __restrict  __fmt ,
                                                                                                                                         __gnuc_va_list __ap ) ;
#line 208 "/usr/include/bits/stdio2.h"
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) obstack_vprintf)(struct obstack * __restrict  __obstack ,
                                                                                                           char const   * __restrict  __fmt ,
                                                                                                           __gnuc_va_list __ap ) 
{ int tmp ;

  {
#line 212
  tmp = __obstack_vprintf_chk(__obstack, 1, __fmt, __ap);
#line 212
  return ((int __attribute__((__artificial__))  )tmp);
}
}
#line 233
extern char *__fgets_chk(char * __restrict  __s , size_t __size , int __n , FILE * __restrict  __stream )  __attribute__((__warn_unused_result__)) ;
#line 235
extern char *__fgets_alias(char * __restrict  __s , int __n , FILE * __restrict  __stream )  __asm__("fgets") __attribute__((__warn_unused_result__)) ;
#line 238
extern char *__fgets_chk_warn(char * __restrict  __s , size_t __size , int __n , FILE * __restrict  __stream )  __asm__("__fgets_chk") __attribute__((__warning__("fgets called with bigger size than length of destination buffer"),
__warn_unused_result__)) ;
#line 244
__inline extern char __attribute__((__warn_unused_result__, __artificial__))  *( __attribute__((__always_inline__)) fgets)(char * __restrict  __s ,
                                                                                                                           int __n ,
                                                                                                                           FILE * __restrict  __stream )  __attribute__((__warn_unused_result__)) ;
#line 244 "/usr/include/bits/stdio2.h"
__inline extern char __attribute__((__warn_unused_result__, __artificial__))  *( __attribute__((__always_inline__)) fgets)(char * __restrict  __s ,
                                                                                                                           int __n ,
                                                                                                                           FILE * __restrict  __stream ) 
{ unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  char *tmp___5 ;

  {
#line 247
  tmp___4 = __builtin_object_size((void *)__s, 1);
#line 247
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 250
    tmp = __builtin_object_size((void *)__s, 1);
#line 250
    tmp___0 = __fgets_chk(__s, tmp, __n, __stream);
#line 250
    return ((char __attribute__((__warn_unused_result__, __artificial__))  *)tmp___0);
#line 252
    tmp___3 = __builtin_object_size((void *)__s, 1);
#line 252
    if ((size_t )__n > tmp___3) {
#line 253
      tmp___1 = __builtin_object_size((void *)__s, 1);
#line 253
      tmp___2 = __fgets_chk_warn(__s, tmp___1, __n, __stream);
#line 253
      return ((char __attribute__((__warn_unused_result__, __artificial__))  *)tmp___2);
    }
  }
#line 255
  tmp___5 = __fgets_alias(__s, __n, __stream);
#line 255
  return ((char __attribute__((__warn_unused_result__, __artificial__))  *)tmp___5);
}
}
#line 258
extern size_t __fread_chk(void * __restrict  __ptr , size_t __ptrlen , size_t __size ,
                          size_t __n , FILE * __restrict  __stream )  __attribute__((__warn_unused_result__)) ;
#line 261
extern size_t __fread_alias(void * __restrict  __ptr , size_t __size , size_t __n ,
                            FILE * __restrict  __stream )  __asm__("fread") __attribute__((__warn_unused_result__)) ;
#line 265
extern size_t __fread_chk_warn(void * __restrict  __ptr , size_t __ptrlen , size_t __size ,
                               size_t __n , FILE * __restrict  __stream )  __asm__("__fread_chk") __attribute__((__warning__("fread called with bigger size * nmemb than length of destination buffer"),
__warn_unused_result__)) ;
#line 273
__inline extern size_t __attribute__((__warn_unused_result__, __artificial__))  ( __attribute__((__always_inline__)) fread)(void * __restrict  __ptr ,
                                                                                                                            size_t __size ,
                                                                                                                            size_t __n ,
                                                                                                                            FILE * __restrict  __stream )  __attribute__((__warn_unused_result__)) ;
#line 273 "/usr/include/bits/stdio2.h"
__inline extern size_t __attribute__((__warn_unused_result__, __artificial__))  ( __attribute__((__always_inline__)) fread)(void * __restrict  __ptr ,
                                                                                                                            size_t __size ,
                                                                                                                            size_t __n ,
                                                                                                                            FILE * __restrict  __stream ) 
{ unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
#line 277
  tmp___4 = __builtin_object_size((void *)__ptr, 0);
#line 277
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 282
    tmp = __builtin_object_size((void *)__ptr, 0);
#line 282
    tmp___0 = __fread_chk(__ptr, tmp, __size, __n, __stream);
#line 282
    return ((size_t __attribute__((__artificial__))  )tmp___0);
#line 284
    tmp___3 = __builtin_object_size((void *)__ptr, 0);
#line 284
    if (__size * __n > tmp___3) {
#line 285
      tmp___1 = __builtin_object_size((void *)__ptr, 0);
#line 285
      tmp___2 = __fread_chk_warn(__ptr, tmp___1, __size, __n, __stream);
#line 285
      return ((size_t __attribute__((__artificial__))  )tmp___2);
    }
  }
#line 287
  tmp___5 = __fread_alias(__ptr, __size, __n, __stream);
#line 287
  return ((size_t __attribute__((__artificial__))  )tmp___5);
}
}
#line 291
extern char *__fgets_unlocked_chk(char * __restrict  __s , size_t __size , int __n ,
                                  FILE * __restrict  __stream )  __attribute__((__warn_unused_result__)) ;
#line 293
extern char *__fgets_unlocked_alias(char * __restrict  __s , int __n , FILE * __restrict  __stream )  __asm__("fgets_unlocked") __attribute__((__warn_unused_result__)) ;
#line 296
extern char *__fgets_unlocked_chk_warn(char * __restrict  __s , size_t __size , int __n ,
                                       FILE * __restrict  __stream )  __asm__("__fgets_unlocked_chk") __attribute__((__warning__("fgets_unlocked called with bigger size than length of destination buffer"),
__warn_unused_result__)) ;
#line 302
__inline extern char __attribute__((__warn_unused_result__, __artificial__))  *( __attribute__((__always_inline__)) fgets_unlocked)(char * __restrict  __s ,
                                                                                                                                    int __n ,
                                                                                                                                    FILE * __restrict  __stream )  __attribute__((__warn_unused_result__)) ;
#line 302 "/usr/include/bits/stdio2.h"
__inline extern char __attribute__((__warn_unused_result__, __artificial__))  *( __attribute__((__always_inline__)) fgets_unlocked)(char * __restrict  __s ,
                                                                                                                                    int __n ,
                                                                                                                                    FILE * __restrict  __stream ) 
{ unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  char *tmp___5 ;

  {
#line 305
  tmp___4 = __builtin_object_size((void *)__s, 1);
#line 305
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 308
    tmp = __builtin_object_size((void *)__s, 1);
#line 308
    tmp___0 = __fgets_unlocked_chk(__s, tmp, __n, __stream);
#line 308
    return ((char __attribute__((__warn_unused_result__, __artificial__))  *)tmp___0);
#line 310
    tmp___3 = __builtin_object_size((void *)__s, 1);
#line 310
    if ((size_t )__n > tmp___3) {
#line 311
      tmp___1 = __builtin_object_size((void *)__s, 1);
#line 311
      tmp___2 = __fgets_unlocked_chk_warn(__s, tmp___1, __n, __stream);
#line 311
      return ((char __attribute__((__warn_unused_result__, __artificial__))  *)tmp___2);
    }
  }
#line 313
  tmp___5 = __fgets_unlocked_alias(__s, __n, __stream);
#line 313
  return ((char __attribute__((__warn_unused_result__, __artificial__))  *)tmp___5);
}
}
#line 319
extern size_t __fread_unlocked_chk(void * __restrict  __ptr , size_t __ptrlen , size_t __size ,
                                   size_t __n , FILE * __restrict  __stream )  __attribute__((__warn_unused_result__)) ;
#line 322
extern size_t __fread_unlocked_alias(void * __restrict  __ptr , size_t __size , size_t __n ,
                                     FILE * __restrict  __stream )  __asm__("fread_unlocked") __attribute__((__warn_unused_result__)) ;
#line 326
extern size_t __fread_unlocked_chk_warn(void * __restrict  __ptr , size_t __ptrlen ,
                                        size_t __size , size_t __n , FILE * __restrict  __stream )  __asm__("__fread_unlocked_chk") __attribute__((__warning__("fread_unlocked called with bigger size * nmemb than length of destination buffer"),
__warn_unused_result__)) ;
#line 334
__inline extern size_t __attribute__((__warn_unused_result__, __artificial__))  ( __attribute__((__always_inline__)) fread_unlocked)(void * __restrict  __ptr ,
                                                                                                                                     size_t __size ,
                                                                                                                                     size_t __n ,
                                                                                                                                     FILE * __restrict  __stream )  __attribute__((__warn_unused_result__)) ;
#line 334 "/usr/include/bits/stdio2.h"
__inline extern size_t __attribute__((__warn_unused_result__, __artificial__))  ( __attribute__((__always_inline__)) fread_unlocked)(void * __restrict  __ptr ,
                                                                                                                                     size_t __size ,
                                                                                                                                     size_t __n ,
                                                                                                                                     FILE * __restrict  __stream ) 
{ unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___11 ;

  {
#line 338
  tmp___4 = __builtin_object_size((void *)__ptr, 0);
#line 338
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 343
    tmp = __builtin_object_size((void *)__ptr, 0);
#line 343
    tmp___0 = __fread_unlocked_chk(__ptr, tmp, __size, __n, __stream);
#line 343
    return ((size_t __attribute__((__artificial__))  )tmp___0);
#line 346
    tmp___3 = __builtin_object_size((void *)__ptr, 0);
#line 346
    if (__size * __n > tmp___3) {
#line 347
      tmp___1 = __builtin_object_size((void *)__ptr, 0);
#line 347
      tmp___2 = __fread_unlocked_chk_warn(__ptr, tmp___1, __size, __n, __stream);
#line 347
      return ((size_t __attribute__((__artificial__))  )tmp___2);
    }
  }
#line 372
  tmp___11 = __fread_unlocked_alias(__ptr, __size, __n, __stream);
#line 372
  return ((size_t __attribute__((__artificial__))  )tmp___11);
}
}
#line 68 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 146
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 399
extern  __attribute__((__nothrow__)) size_t strlen(char const   *__s )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 335 "quotearg.h"
char *quotearg_n_style(int n , enum quoting_style s , char const   *arg ) ;
#line 19 "quote.h"
char const   *quote_n(int n , char const   *name ) ;
#line 57 "argmatch.c"
 __attribute__((__noreturn__)) void usage(int status ) ;
#line 60 "argmatch.c"
static void __argmatch_die(void) 
{ 

  {
#line 63
  usage(1);
#line 64
  return;
}
}
#line 68 "argmatch.c"
void (*argmatch_die)(void)  =    & __argmatch_die;
#line 82 "argmatch.c"
ptrdiff_t argmatch(char const   *arg , char const   * const  *arglist , char const   *vallist ,
                   size_t valsize ) 
{ size_t i ;
  size_t arglen ;
  ptrdiff_t matchind ;
  _Bool ambiguous ;
  int tmp ;
  size_t tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 88
  matchind = (ptrdiff_t )-1;
#line 89
  ambiguous = (_Bool)0;
#line 91
  arglen = strlen(arg);
#line 94
  i = (size_t )0;
#line 94
  while (*(arglist + i)) {
#line 96
    if (0) {
#line 96
      if (0) {
#line 96
        __s1_len = __builtin_strlen((char const   *)*(arglist + i));
#line 96
        __s2_len = __builtin_strlen(arg);
#line 96
        if (! ((size_t )((void const   *)(*(arglist + i) + 1)) - (size_t )((void const   *)*(arglist + i)) == 1UL)) {
#line 96
          goto _L___0;
        } else
#line 96
        if (__s1_len >= 4UL) {
          _L___0: 
#line 96
          if (! ((size_t )((void const   *)(arg + 1)) - (size_t )((void const   *)arg) == 1UL)) {
#line 96
            tmp___9 = 1;
          } else
#line 96
          if (__s2_len >= 4UL) {
#line 96
            tmp___9 = 1;
          } else {
#line 96
            tmp___9 = 0;
          }
        } else {
#line 96
          tmp___9 = 0;
        }
#line 96
        if (tmp___9) {
#line 96
          tmp___4 = __builtin_strcmp((char const   *)*(arglist + i), arg);
#line 96
          tmp___8 = tmp___4;
        } else {
#line 96
          tmp___7 = __builtin_strcmp((char const   *)*(arglist + i), arg);
#line 96
          tmp___8 = tmp___7;
        }
      } else {
#line 96
        tmp___7 = __builtin_strcmp((char const   *)*(arglist + i), arg);
#line 96
        tmp___8 = tmp___7;
      }
#line 96
      tmp___11 = tmp___8;
    } else {
#line 96
      tmp___10 = strncmp((char const   *)*(arglist + i), arg, arglen);
#line 96
      tmp___11 = tmp___10;
    }
#line 96
    if (! tmp___11) {
#line 98
      tmp___0 = strlen((char const   *)*(arglist + i));
#line 98
      if (tmp___0 == arglen) {
#line 100
        return ((ptrdiff_t )i);
      } else
#line 101
      if (matchind == -1L) {
#line 103
        matchind = (ptrdiff_t )i;
      } else
#line 107
      if ((unsigned long )vallist == (unsigned long )((void *)0)) {
#line 113
        ambiguous = (_Bool)1;
      } else {
#line 107
        tmp = memcmp((void const   *)(vallist + valsize * (size_t )matchind), (void const   *)(vallist + valsize * i),
                     valsize);
#line 107
        if (tmp) {
#line 113
          ambiguous = (_Bool)1;
        }
      }
    }
#line 94
    i ++;
  }
#line 118
  if (ambiguous) {
#line 119
    return ((ptrdiff_t )-2);
  } else {
#line 121
    return (matchind);
  }
}
}
#line 129 "argmatch.c"
void argmatch_invalid(char const   *context , char const   *value , ptrdiff_t problem ) 
{ char const   *format ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;

  {
#line 132
  if (problem == -1L) {
#line 132
    tmp = dcgettext((char const   *)((void *)0), "invalid argument %s for %s", 5);
#line 132
    tmp___1 = tmp;
  } else {
#line 132
    tmp___0 = dcgettext((char const   *)((void *)0), "ambiguous argument %s for %s",
                        5);
#line 132
    tmp___1 = tmp___0;
  }
#line 132
  format = (char const   *)tmp___1;
#line 136
  tmp___2 = quote_n(1, context);
#line 136
  tmp___3 = quotearg_n_style(0, (enum quoting_style )6, value);
#line 136
  error(0, 0, format, tmp___3, tmp___2);
#line 138
  return;
}
}
#line 144 "argmatch.c"
void argmatch_valid(char const   * const  *arglist , char const   *vallist , size_t valsize ) 
{ size_t i ;
  char const   *last_val ;
  char *tmp ;
  int tmp___0 ;

  {
#line 149
  last_val = (char const   *)((void *)0);
#line 153
  tmp = dcgettext((char const   *)((void *)0), "Valid arguments are:", 5);
#line 153
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp);
#line 154
  i = (size_t )0;
#line 154
  while (*(arglist + i)) {
#line 155
    if (i == 0UL) {
#line 158
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n  - `%s\'",
              *(arglist + i));
#line 159
      last_val = vallist + valsize * i;
    } else {
#line 155
      tmp___0 = memcmp((void const   *)last_val, (void const   *)(vallist + valsize * i),
                       valsize);
#line 155
      if (tmp___0) {
#line 158
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n  - `%s\'",
                *(arglist + i));
#line 159
        last_val = vallist + valsize * i;
      } else {
#line 163
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )", `%s\'",
                *(arglist + i));
      }
    }
#line 154
    i ++;
  }
#line 165
  fputc_unlocked('\n', stderr);
#line 166
  return;
}
}
#line 174 "argmatch.c"
ptrdiff_t __xargmatch_internal(char const   *context , char const   *arg , char const   * const  *arglist ,
                               char const   *vallist , size_t valsize , void (*exit_fn)(void) ) 
{ ptrdiff_t res ;
  ptrdiff_t tmp ;

  {
#line 180
  tmp = argmatch(arg, arglist, vallist, valsize);
#line 180
  res = tmp;
#line 181
  if (res >= 0L) {
#line 183
    return (res);
  }
#line 186
  argmatch_invalid(context, arg, res);
#line 187
  argmatch_valid(arglist, vallist, valsize);
#line 188
  (*exit_fn)();
#line 190
  return ((ptrdiff_t )-1);
}
}
#line 195 "argmatch.c"
char const   *argmatch_to_argument(char const   *value , char const   * const  *arglist ,
                                   char const   *vallist , size_t valsize ) 
{ size_t i ;
  int tmp ;

  {
#line 202
  i = (size_t )0;
#line 202
  while (*(arglist + i)) {
#line 203
    tmp = memcmp((void const   *)value, (void const   *)(vallist + valsize * i), valsize);
#line 203
    if (! tmp) {
#line 204
      return ((char const   *)*(arglist + i));
    }
#line 202
    i ++;
  }
#line 205
  return ((char const   *)((void *)0));
}
}
#line 1 "argv-iter.o"
#pragma merger(0,"/tmp/cil-cjsl91iM.i","-g,-O2")
#line 661 "/usr/include/stdio.h"
extern __ssize_t getdelim(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                          int __delimiter , FILE * __restrict  __stream )  __attribute__((__warn_unused_result__)) ;
#line 821
extern  __attribute__((__nothrow__)) int feof(FILE *__stream )  __attribute__((__warn_unused_result__)) ;
#line 33 "argv-iter.h"
struct argv_iterator *argv_iter_init_argv(char **argv )  __attribute__((__nonnull__(1))) ;
#line 35
struct argv_iterator *argv_iter_init_stream(FILE *fp )  __attribute__((__nonnull__(1))) ;
#line 37
char *argv_iter(struct argv_iterator *ai , enum argv_iter_err *err )  __attribute__((__nonnull__(1,2))) ;
#line 39
size_t argv_iter_n_args(struct argv_iterator  const  *ai )  __attribute__((__nonnull__(1))) ;
#line 41
void argv_iter_free(struct argv_iterator *ai )  __attribute__((__nonnull__(1))) ;
#line 39 "argv-iter.c"
struct argv_iterator *argv_iter_init_argv(char **argv )  __attribute__((__nonnull__(1))) ;
#line 39 "argv-iter.c"
struct argv_iterator *argv_iter_init_argv(char **argv ) 
{ struct argv_iterator *ai ;
  void *tmp ;

  {
#line 42
  tmp = malloc(sizeof(*ai));
#line 42
  ai = (struct argv_iterator *)tmp;
#line 43
  if (! ai) {
#line 44
    return ((struct argv_iterator *)((void *)0));
  }
#line 45
  ai->fp = (FILE *)((void *)0);
#line 46
  ai->arg_list = argv;
#line 47
  ai->p = argv;
#line 48
  return (ai);
}
}
#line 53
struct argv_iterator *argv_iter_init_stream(FILE *fp )  __attribute__((__nonnull__(1))) ;
#line 53 "argv-iter.c"
struct argv_iterator *argv_iter_init_stream(FILE *fp ) 
{ struct argv_iterator *ai ;
  void *tmp ;

  {
#line 56
  tmp = malloc(sizeof(*ai));
#line 56
  ai = (struct argv_iterator *)tmp;
#line 57
  if (! ai) {
#line 58
    return ((struct argv_iterator *)((void *)0));
  }
#line 59
  ai->fp = fp;
#line 60
  ai->tok = (char *)((void *)0);
#line 61
  ai->buf_len = (size_t )0;
#line 63
  ai->item_idx = (size_t )0;
#line 64
  ai->arg_list = (char **)((void *)0);
#line 65
  return (ai);
}
}
#line 68
char *argv_iter(struct argv_iterator *ai , enum argv_iter_err *err )  __attribute__((__nonnull__(1,2))) ;
#line 68 "argv-iter.c"
char *argv_iter(struct argv_iterator *ai , enum argv_iter_err *err ) 
{ ssize_t len ;
  __ssize_t tmp ;
  int tmp___1 ;
  char **tmp___2 ;

  {
#line 71
  if (ai->fp) {
#line 73
    tmp = getdelim((char ** __restrict  )(& ai->tok), (size_t * __restrict  )(& ai->buf_len),
                   '\000', (FILE * __restrict  )ai->fp);
#line 73
    len = tmp;
#line 74
    if (len < 0L) {
#line 76
      tmp___1 = feof(ai->fp);
#line 76
      if (tmp___1) {
#line 76
        *err = (enum argv_iter_err )2;
      } else {
#line 76
        *err = (enum argv_iter_err )4;
      }
#line 77
      return ((char *)((void *)0));
    }
#line 80
    *err = (enum argv_iter_err )1;
#line 81
    (ai->item_idx) ++;
#line 82
    return (ai->tok);
  } else
#line 86
  if ((unsigned long )*(ai->p) == (unsigned long )((void *)0)) {
#line 88
    *err = (enum argv_iter_err )2;
#line 89
    return ((char *)((void *)0));
  } else {
#line 93
    *err = (enum argv_iter_err )1;
#line 94
    tmp___2 = ai->p;
#line 94
    (ai->p) ++;
#line 94
    return (*tmp___2);
  }
}
}
#line 99
size_t argv_iter_n_args(struct argv_iterator  const  *ai )  __attribute__((__nonnull__(1))) ;
#line 99 "argv-iter.c"
size_t argv_iter_n_args(struct argv_iterator  const  *ai ) 
{ size_t tmp ;

  {
#line 102
  if (ai->fp) {
#line 102
    tmp = (size_t )ai->item_idx;
  } else {
#line 102
    tmp = (size_t )((size_t const   )(ai->p - ai->arg_list));
  }
#line 102
  return (tmp);
}
}
#line 105
void argv_iter_free(struct argv_iterator *ai )  __attribute__((__nonnull__(1))) ;
#line 105 "argv-iter.c"
void argv_iter_free(struct argv_iterator *ai ) 
{ 

  {
#line 108
  if (ai->fp) {
#line 109
    free((void *)ai->tok);
  }
#line 110
  free((void *)ai);
#line 111
  return;
}
}
#line 1 "backupfile.o"
#pragma merger(0,"/tmp/cil-RXNDjJn4.i","-g,-O2")
#line 47 "backupfile.h"
char const   *simple_backup_suffix ;
#line 49
char *find_backup_file_name(char const   *file , enum backup_type backup_type ) ;
#line 50
enum backup_type get_version(char const   *context , char const   *version ) ;
#line 51
enum backup_type xget_version(char const   *context , char const   *version ) ;
#line 40 "dirname.h"
size_t base_len(char const   *name ) ;
#line 42
char *last_component(char const   *name ) ;
#line 47 "xalloc.h"
 __attribute__((__noreturn__)) void xalloc_die(void) ;
#line 49
void *xmalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 55
void *xrealloc(void *p , size_t n )  __attribute__((__alloc_size__(2))) ;
#line 119
__inline static void *xnrealloc(void *p , size_t n , size_t s )  __attribute__((__alloc_size__(2,3))) ;
#line 121
__inline static void *xnrealloc(void *p , size_t n , size_t s )  __attribute__((__alloc_size__(2,3))) ;
#line 121 "xalloc.h"
__inline static void *xnrealloc(void *p , size_t n , size_t s ) 
{ int tmp ;
  void *tmp___0 ;

  {
#line 124
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 124
    tmp = -1;
  } else {
#line 124
    tmp = -2;
  }
#line 124
  if ((size_t )tmp / s < n) {
#line 125
    xalloc_die();
  }
#line 126
  tmp___0 = xrealloc(p, n * s);
#line 126
  return (tmp___0);
}
}
#line 567 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name )  __attribute__((__warn_unused_result__,
__nonnull__(1))) ;
#line 609 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) long pathconf(char const   *__path , int __name )  __attribute__((__nonnull__(1))) ;
#line 150 "/usr/include/dirent.h"
extern int closedir(DIR *__dirp )  __attribute__((__nonnull__(1))) ;
#line 163
extern struct dirent *readdir(DIR *__dirp )  __attribute__((__nonnull__(1))) ;
#line 22 "dirent-safer.h"
DIR *opendir_safer(char const   *name ) ;
#line 83 "backupfile.c"
char const   *simple_backup_suffix  =    "~";
#line 91 "backupfile.c"
static void check_extension(char *file , size_t filelen , char e ) 
{ char *base ;
  char *tmp ;
  size_t baselen ;
  size_t tmp___0 ;
  size_t baselen_max ;
  long name_max ;
  char tmp___1[sizeof(".")] ;
  int *tmp___2 ;
  long size ;
  int *tmp___3 ;

  {
#line 94
  tmp = last_component((char const   *)file);
#line 94
  base = tmp;
#line 95
  tmp___0 = base_len((char const   *)base);
#line 95
  baselen = tmp___0;
#line 96
  baselen_max = (size_t )255;
#line 98
  if (14UL < baselen) {
#line 106
    memcpy((void * __restrict  )(tmp___1), (void const   * __restrict  )base, sizeof("."));
#line 107
    strcpy((char * __restrict  )base, (char const   * __restrict  )".");
#line 108
    tmp___2 = __errno_location();
#line 108
    *tmp___2 = 0;
#line 109
    name_max = pathconf((char const   *)file, 3);
#line 110
    if (0L <= name_max) {
#line 110
      goto _L;
    } else {
#line 110
      tmp___3 = __errno_location();
#line 110
      if (*tmp___3 == 0) {
        _L: 
#line 112
        baselen_max = (size_t )name_max;
#line 112
        size = (long )baselen_max;
#line 113
        if (name_max != size) {
#line 114
          baselen_max = (size_t )-1;
        }
      }
    }
#line 116
    memcpy((void * __restrict  )base, (void const   * __restrict  )(tmp___1), sizeof("."));
  }
#line 134
  if (baselen_max < baselen) {
#line 136
    baselen = (size_t )((file + filelen) - base);
#line 137
    if (baselen_max <= baselen) {
#line 138
      baselen = baselen_max - 1UL;
    }
#line 139
    *(base + baselen) = e;
#line 140
    *(base + (baselen + 1UL)) = (char )'\000';
  }
#line 142
  return;
}
}
#line 171 "backupfile.c"
static enum numbered_backup_result numbered_backup(char **buffer , size_t buffer_size ,
                                                   size_t filelen ) 
{ enum numbered_backup_result result ;
  DIR *dirp ;
  struct dirent *dp ;
  char *buf___1 ;
  size_t versionlenmax ;
  char *base ;
  char *tmp ;
  size_t base_offset ;
  size_t baselen ;
  size_t tmp___0 ;
  char tmp___1[sizeof(".")] ;
  char const   *p ;
  char *q ;
  _Bool all_9s ;
  size_t versionlen ;
  size_t new_buflen ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
#line 174
  result = (enum numbered_backup_result )2;
#line 177
  buf___1 = *buffer;
#line 178
  versionlenmax = (size_t )1;
#line 179
  tmp = last_component((char const   *)buf___1);
#line 179
  base = tmp;
#line 180
  base_offset = (size_t )(base - buf___1);
#line 181
  tmp___0 = base_len((char const   *)base);
#line 181
  baselen = tmp___0;
#line 186
  memcpy((void * __restrict  )(tmp___1), (void const   * __restrict  )base, sizeof("."));
#line 187
  strcpy((char * __restrict  )base, (char const   * __restrict  )".");
#line 188
  dirp = opendir_safer((char const   *)buf___1);
#line 189
  memcpy((void * __restrict  )base, (void const   * __restrict  )(tmp___1), sizeof("."));
#line 190
  strcpy((char * __restrict  )(base + baselen), (char const   * __restrict  )".~1~");
#line 192
  if (! dirp) {
#line 193
    return (result);
  }
#line 195
  while (1) {
#line 195
    dp = readdir(dirp);
#line 195
    if (! ((unsigned long )dp != (unsigned long )((void *)0))) {
#line 195
      break;
    }
#line 203
    if (! (dp->d_ino != 0UL)) {
#line 204
      continue;
    } else {
#line 203
      tmp___2 = strlen((char const   *)(dp->d_name));
#line 203
      if (tmp___2 < baselen + 4UL) {
#line 204
        continue;
      }
    }
#line 206
    tmp___3 = memcmp((void const   *)(buf___1 + base_offset), (void const   *)(dp->d_name),
                     baselen + 2UL);
#line 206
    if (tmp___3 != 0) {
#line 207
      continue;
    }
#line 209
    p = (char const   *)((dp->d_name + baselen) + 2);
#line 215
    if (49 <= (int )*p) {
#line 215
      if (! ((int const   )*p <= 57)) {
#line 216
        continue;
      }
    } else {
#line 216
      continue;
    }
#line 217
    all_9s = (_Bool )((int const   )*p == 57);
#line 218
    versionlen = (size_t )1;
#line 218
    while ((unsigned int )*(p + versionlen) - 48U <= 9U) {
#line 219
      all_9s = (_Bool )((int )all_9s & ((int const   )*(p + versionlen) == 57));
#line 218
      versionlen ++;
    }
#line 221
    if ((int const   )*(p + versionlen) == 126) {
#line 221
      if (! *(p + (versionlen + 1UL))) {
#line 221
        if (! (versionlenmax < versionlen)) {
#line 221
          if (versionlenmax == versionlen) {
#line 221
            tmp___4 = memcmp((void const   *)((buf___1 + filelen) + 2), (void const   *)p,
                             versionlen);
#line 221
            if (! (tmp___4 <= 0)) {
#line 225
              continue;
            }
          } else {
#line 225
            continue;
          }
        }
      } else {
#line 225
        continue;
      }
    } else {
#line 225
      continue;
    }
#line 231
    versionlenmax = (size_t )all_9s + versionlen;
#line 232
    if (all_9s) {
#line 232
      result = (enum numbered_backup_result )1;
    } else {
#line 232
      result = (enum numbered_backup_result )0;
    }
#line 233
    new_buflen = ((filelen + 2UL) + versionlenmax) + 1UL;
#line 234
    if (buffer_size <= new_buflen) {
#line 236
      tmp___5 = xnrealloc((void *)buf___1, (size_t )2, new_buflen);
#line 236
      buf___1 = (char *)tmp___5;
#line 237
      buffer_size = new_buflen * 2UL;
    }
#line 239
    q = buf___1 + filelen;
#line 240
    tmp___6 = q;
#line 240
    q ++;
#line 240
    *tmp___6 = (char )'.';
#line 241
    tmp___7 = q;
#line 241
    q ++;
#line 241
    *tmp___7 = (char )'~';
#line 242
    *q = (char )'0';
#line 243
    q += (int )all_9s;
#line 244
    memcpy((void * __restrict  )q, (void const   * __restrict  )p, versionlen + 2UL);
#line 248
    q += versionlen;
#line 249
    while (1) {
#line 249
      q --;
#line 249
      if (! ((int )*q == 57)) {
#line 249
        break;
      }
#line 250
      *q = (char )'0';
    }
#line 251
    *q = (char )((int )*q + 1);
  }
#line 254
  closedir(dirp);
#line 255
  *buffer = buf___1;
#line 256
  return (result);
}
}
#line 263 "backupfile.c"
char *find_backup_file_name(char const   *file , enum backup_type backup_type ) 
{ size_t filelen ;
  size_t tmp ;
  char *s ;
  size_t ssize ;
  _Bool simple ;
  size_t simple_backup_suffix_size ;
  size_t tmp___0 ;
  size_t backup_suffix_size_guess ;
  void *tmp___1 ;
  enum numbered_backup_result tmp___2 ;

  {
#line 266
  tmp = strlen(file);
#line 266
  filelen = tmp;
#line 269
  simple = (_Bool)1;
#line 273
  tmp___0 = strlen(simple_backup_suffix);
#line 273
  simple_backup_suffix_size = tmp___0 + 1UL;
#line 274
  backup_suffix_size_guess = simple_backup_suffix_size;
#line 276
  if (backup_suffix_size_guess < 9UL) {
#line 277
    backup_suffix_size_guess = (size_t )9;
  }
#line 279
  ssize = (filelen + backup_suffix_size_guess) + 1UL;
#line 280
  tmp___1 = xmalloc(ssize);
#line 280
  s = (char *)tmp___1;
#line 281
  memcpy((void * __restrict  )s, (void const   * __restrict  )file, filelen + 1UL);
#line 283
  if ((unsigned int )backup_type != 1U) {
#line 284
    tmp___2 = numbered_backup(& s, ssize, filelen);
#line 284
    switch ((int )tmp___2) {
    case 0: 
#line 287
    return (s);
    case 1: 
#line 290
    simple = (_Bool)0;
#line 291
    break;
    case 2: 
#line 294
    simple = (_Bool )((unsigned int )backup_type == 2U);
#line 295
    break;
    }
  }
#line 298
  if (simple) {
#line 299
    memcpy((void * __restrict  )(s + filelen), (void const   * __restrict  )simple_backup_suffix,
           simple_backup_suffix_size);
  }
#line 300
  check_extension(s, filelen, (char )'~');
#line 301
  return (s);
}
}
#line 304 "backupfile.c"
static char const   * const  backup_args[9]  = 
#line 304
  {      (char const   * const  )"none",      (char const   * const  )"off",      (char const   * const  )"simple",      (char const   * const  )"never", 
        (char const   * const  )"existing",      (char const   * const  )"nil",      (char const   * const  )"numbered",      (char const   * const  )"t", 
        (char const   * const  )((void *)0)};
#line 315 "backupfile.c"
static enum backup_type  const  backup_types[8]  = 
#line 315
  {      (enum backup_type  const  )0,      (enum backup_type  const  )0,      (enum backup_type  const  )1,      (enum backup_type  const  )1, 
        (enum backup_type  const  )2,      (enum backup_type  const  )2,      (enum backup_type  const  )3,      (enum backup_type  const  )3};
#line 332 "backupfile.c"
enum backup_type get_version(char const   *context , char const   *version ) 
{ ptrdiff_t tmp ;

  {
#line 335
  if ((unsigned long )version == (unsigned long )((char const   *)0)) {
#line 336
    return ((enum backup_type )2);
  } else
#line 335
  if ((int const   )*version == 0) {
#line 336
    return ((enum backup_type )2);
  } else {
#line 338
    tmp = __xargmatch_internal(context, version, backup_args, (char const   *)(backup_types),
                               sizeof(backup_types[0]), argmatch_die);
#line 338
    return ((enum backup_type )backup_types[tmp]);
  }
}
}
#line 348 "backupfile.c"
enum backup_type xget_version(char const   *context , char const   *version ) 
{ enum backup_type tmp ;
  char *tmp___0 ;
  enum backup_type tmp___1 ;

  {
#line 351
  if (version) {
#line 351
    if (*version) {
#line 352
      tmp = get_version(context, version);
#line 352
      return (tmp);
    } else {
#line 354
      tmp___0 = getenv("VERSION_CONTROL");
#line 354
      tmp___1 = get_version("$VERSION_CONTROL", (char const   *)tmp___0);
#line 354
      return (tmp___1);
    }
  } else {
#line 354
    tmp___0 = getenv("VERSION_CONTROL");
#line 354
    tmp___1 = get_version("$VERSION_CONTROL", (char const   *)tmp___0);
#line 354
    return (tmp___1);
  }
}
}
#line 1 "base64.o"
#pragma merger(0,"/tmp/cil-cX6h4v4p.i","-g,-O2")
#line 40 "base64.h"
_Bool isbase64(char ch ) ;
#line 42
void base64_encode(char const   * __restrict  in , size_t inlen , char * __restrict  out ,
                   size_t outlen ) ;
#line 45
size_t base64_encode_alloc(char const   *in , size_t inlen , char **out ) ;
#line 47
void base64_decode_ctx_init(struct base64_decode_context *ctx ) ;
#line 49
_Bool base64_decode_ctx(struct base64_decode_context *ctx , char const   * __restrict  in ,
                        size_t inlen , char * __restrict  out , size_t *outlen ) ;
#line 53
_Bool base64_decode_alloc_ctx(struct base64_decode_context *ctx , char const   *in ,
                              size_t inlen , char **out , size_t *outlen ) ;
#line 95 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memchr(void const   *__s , int __c , size_t __n )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 59 "base64.c"
__inline static unsigned char to_uchar(char ch ) 
{ 

  {
#line 62
  return ((unsigned char )ch);
}
}
#line 73 "base64.c"
static char const   b64str[64]  = 
#line 73
  {      (char const   )'A',      (char const   )'B',      (char const   )'C',      (char const   )'D', 
        (char const   )'E',      (char const   )'F',      (char const   )'G',      (char const   )'H', 
        (char const   )'I',      (char const   )'J',      (char const   )'K',      (char const   )'L', 
        (char const   )'M',      (char const   )'N',      (char const   )'O',      (char const   )'P', 
        (char const   )'Q',      (char const   )'R',      (char const   )'S',      (char const   )'T', 
        (char const   )'U',      (char const   )'V',      (char const   )'W',      (char const   )'X', 
        (char const   )'Y',      (char const   )'Z',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'g',      (char const   )'h',      (char const   )'i',      (char const   )'j', 
        (char const   )'k',      (char const   )'l',      (char const   )'m',      (char const   )'n', 
        (char const   )'o',      (char const   )'p',      (char const   )'q',      (char const   )'r', 
        (char const   )'s',      (char const   )'t',      (char const   )'u',      (char const   )'v', 
        (char const   )'w',      (char const   )'x',      (char const   )'y',      (char const   )'z', 
        (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'+',      (char const   )'/'};
#line 69 "base64.c"
void base64_encode(char const   * __restrict  in , size_t inlen , char * __restrict  out ,
                   size_t outlen ) 
{ char * __restrict  tmp ;
  unsigned char tmp___0 ;
  char * __restrict  tmp___1 ;
  unsigned char tmp___2 ;
  unsigned char tmp___3 ;
  int tmp___4 ;
  char * __restrict  tmp___5 ;
  unsigned char tmp___6 ;
  unsigned char tmp___7 ;
  int tmp___8 ;
  char * __restrict  tmp___9 ;
  unsigned char tmp___10 ;

  {
#line 76
  while (1) {
#line 76
    if (inlen) {
#line 76
      if (! outlen) {
#line 76
        break;
      }
    } else {
#line 76
      break;
    }
#line 78
    tmp = out;
#line 78
    out ++;
#line 78
    tmp___0 = to_uchar((char )*(in + 0));
#line 78
    *tmp = (char )b64str[((int )tmp___0 >> 2) & 63];
#line 79
    outlen --;
#line 79
    if (! outlen) {
#line 80
      break;
    }
#line 81
    tmp___1 = out;
#line 81
    out ++;
#line 81
    tmp___2 = to_uchar((char )*(in + 0));
#line 81
    inlen --;
#line 81
    if (inlen) {
#line 81
      tmp___3 = to_uchar((char )*(in + 1));
#line 81
      tmp___4 = (int )tmp___3 >> 4;
    } else {
#line 81
      tmp___4 = 0;
    }
#line 81
    *tmp___1 = (char )b64str[(((int )tmp___2 << 4) + tmp___4) & 63];
#line 84
    outlen --;
#line 84
    if (! outlen) {
#line 85
      break;
    }
#line 86
    tmp___5 = out;
#line 86
    out ++;
#line 86
    if (inlen) {
#line 86
      tmp___6 = to_uchar((char )*(in + 1));
#line 86
      inlen --;
#line 86
      if (inlen) {
#line 86
        tmp___7 = to_uchar((char )*(in + 2));
#line 86
        tmp___8 = (int )tmp___7 >> 6;
      } else {
#line 86
        tmp___8 = 0;
      }
#line 86
      *tmp___5 = (char )b64str[(((int )tmp___6 << 2) + tmp___8) & 63];
    } else {
#line 86
      *tmp___5 = (char )'=';
    }
#line 92
    outlen --;
#line 92
    if (! outlen) {
#line 93
      break;
    }
#line 94
    tmp___9 = out;
#line 94
    out ++;
#line 94
    if (inlen) {
#line 94
      tmp___10 = to_uchar((char )*(in + 2));
#line 94
      *tmp___9 = (char )b64str[(int )tmp___10 & 63];
    } else {
#line 94
      *tmp___9 = (char )'=';
    }
#line 95
    outlen --;
#line 95
    if (! outlen) {
#line 96
      break;
    }
#line 97
    if (inlen) {
#line 98
      inlen --;
    }
#line 99
    if (inlen) {
#line 100
      in += 3;
    }
  }
#line 103
  if (outlen) {
#line 104
    *out = (char )'\000';
  }
#line 105
  return;
}
}
#line 116 "base64.c"
size_t base64_encode_alloc(char const   *in , size_t inlen , char **out ) 
{ size_t outlen ;
  void *tmp ;

  {
#line 119
  outlen = 1UL + ((inlen + 2UL) / 3UL) * 4UL;
#line 133
  if (inlen > outlen) {
#line 135
    *out = (char *)((void *)0);
#line 136
    return ((size_t )0);
  }
#line 139
  tmp = malloc(outlen);
#line 139
  *out = (char *)tmp;
#line 140
  if (! *out) {
#line 141
    return (outlen);
  }
#line 143
  base64_encode((char const   * __restrict  )in, inlen, (char * __restrict  )*out,
                outlen);
#line 145
  return (outlen - 1UL);
}
}
#line 224 "base64.c"
static signed char const   b64[256]  = 
#line 224
  {      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )62, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )63, 
        (signed char const   )52,      (signed char const   )53,      (signed char const   )54,      (signed char const   )55, 
        (signed char const   )56,      (signed char const   )57,      (signed char const   )58,      (signed char const   )59, 
        (signed char const   )60,      (signed char const   )61,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )0,      (signed char const   )1,      (signed char const   )2, 
        (signed char const   )3,      (signed char const   )4,      (signed char const   )5,      (signed char const   )6, 
        (signed char const   )7,      (signed char const   )8,      (signed char const   )9,      (signed char const   )10, 
        (signed char const   )11,      (signed char const   )12,      (signed char const   )13,      (signed char const   )14, 
        (signed char const   )15,      (signed char const   )16,      (signed char const   )17,      (signed char const   )18, 
        (signed char const   )19,      (signed char const   )20,      (signed char const   )21,      (signed char const   )22, 
        (signed char const   )23,      (signed char const   )24,      (signed char const   )25,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )26,      (signed char const   )27,      (signed char const   )28, 
        (signed char const   )29,      (signed char const   )30,      (signed char const   )31,      (signed char const   )32, 
        (signed char const   )33,      (signed char const   )34,      (signed char const   )35,      (signed char const   )36, 
        (signed char const   )37,      (signed char const   )38,      (signed char const   )39,      (signed char const   )40, 
        (signed char const   )41,      (signed char const   )42,      (signed char const   )43,      (signed char const   )44, 
        (signed char const   )45,      (signed char const   )46,      (signed char const   )47,      (signed char const   )48, 
        (signed char const   )49,      (signed char const   )50,      (signed char const   )51,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1};
#line 300 "base64.c"
_Bool isbase64(char ch ) 
{ unsigned char tmp ;

  {
#line 303
  tmp = to_uchar(ch);
#line 303
  return ((_Bool )(0 <= (int )b64[tmp]));
}
}
#line 307 "base64.c"
void base64_decode_ctx_init(struct base64_decode_context *ctx ) 
{ 

  {
#line 310
  ctx->i = 0U;
#line 311
  return;
}
}
#line 320 "base64.c"
__inline static char *get_4(struct base64_decode_context *ctx , char const   * __restrict  *in ,
                            char const   * __restrict  in_end , size_t *n_non_newline ) 
{ char const   *t ;
  void *tmp ;
  char const   *p ;
  char c ;
  char const   *tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 325
  if (ctx->i == 4U) {
#line 326
    ctx->i = 0U;
  }
#line 328
  if (ctx->i == 0U) {
#line 330
    t = (char const   *)*in;
#line 331
    if (4 <= in_end - *in) {
#line 331
      tmp = memchr((void const   *)t, '\n', (size_t )4);
#line 331
      if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 334
        *in += 4;
#line 335
        *n_non_newline = (size_t )4;
#line 336
        return ((char *)t);
      }
    }
  }
#line 342
  p = (char const   *)*in;
#line 343
  while ((unsigned long )p < (unsigned long )in_end) {
#line 345
    tmp___0 = p;
#line 345
    p ++;
#line 345
    c = (char )*tmp___0;
#line 346
    if ((int )c != 10) {
#line 348
      tmp___1 = ctx->i;
#line 348
      (ctx->i) ++;
#line 348
      ctx->buf[tmp___1] = c;
#line 349
      if (ctx->i == 4U) {
#line 350
        break;
      }
    }
  }
#line 354
  *in = (char const   * __restrict  )p;
#line 355
  *n_non_newline = (size_t )ctx->i;
#line 356
  return (ctx->buf);
}
}
#line 374 "base64.c"
__inline static _Bool decode_4(char const   * __restrict  in , size_t inlen , char * __restrict  *outp ,
                               size_t *outleft ) 
{ char *out ;
  _Bool tmp ;
  _Bool tmp___0 ;
  char *tmp___1 ;
  unsigned char tmp___2 ;
  unsigned char tmp___3 ;
  _Bool tmp___4 ;
  char *tmp___5 ;
  unsigned char tmp___6 ;
  unsigned char tmp___7 ;
  _Bool tmp___8 ;
  char *tmp___9 ;
  unsigned char tmp___10 ;
  unsigned char tmp___11 ;

  {
#line 378
  out = (char *)*outp;
#line 379
  if (inlen < 2UL) {
#line 380
    return ((_Bool)0);
  }
#line 382
  tmp = isbase64((char )*(in + 0));
#line 382
  if (tmp) {
#line 382
    tmp___0 = isbase64((char )*(in + 1));
#line 382
    if (! tmp___0) {
#line 383
      return ((_Bool)0);
    }
  } else {
#line 383
    return ((_Bool)0);
  }
#line 385
  if (*outleft) {
#line 387
    tmp___1 = out;
#line 387
    out ++;
#line 387
    tmp___2 = to_uchar((char )*(in + 0));
#line 387
    tmp___3 = to_uchar((char )*(in + 1));
#line 387
    *tmp___1 = (char )(((int const   )b64[tmp___2] << 2) | ((int const   )b64[tmp___3] >> 4));
#line 389
    (*outleft) --;
  }
#line 392
  if (inlen == 2UL) {
#line 393
    while (1) {
#line 393
      *outp = (char * __restrict  )out;
#line 393
      return ((_Bool)0);
#line 393
      break;
    }
  }
#line 395
  if ((int const   )*(in + 2) == 61) {
#line 397
    if (inlen != 4UL) {
#line 398
      while (1) {
#line 398
        *outp = (char * __restrict  )out;
#line 398
        return ((_Bool)0);
#line 398
        break;
      }
    }
#line 400
    if ((int const   )*(in + 3) != 61) {
#line 401
      while (1) {
#line 401
        *outp = (char * __restrict  )out;
#line 401
        return ((_Bool)0);
#line 401
        break;
      }
    }
  } else {
#line 405
    tmp___4 = isbase64((char )*(in + 2));
#line 405
    if (! tmp___4) {
#line 406
      while (1) {
#line 406
        *outp = (char * __restrict  )out;
#line 406
        return ((_Bool)0);
#line 406
        break;
      }
    }
#line 408
    if (*outleft) {
#line 410
      tmp___5 = out;
#line 410
      out ++;
#line 410
      tmp___6 = to_uchar((char )*(in + 1));
#line 410
      tmp___7 = to_uchar((char )*(in + 2));
#line 410
      *tmp___5 = (char )((((int const   )b64[tmp___6] << 4) & 240) | ((int const   )b64[tmp___7] >> 2));
#line 412
      (*outleft) --;
    }
#line 415
    if (inlen == 3UL) {
#line 416
      while (1) {
#line 416
        *outp = (char * __restrict  )out;
#line 416
        return ((_Bool)0);
#line 416
        break;
      }
    }
#line 418
    if ((int const   )*(in + 3) == 61) {
#line 420
      if (inlen != 4UL) {
#line 421
        while (1) {
#line 421
          *outp = (char * __restrict  )out;
#line 421
          return ((_Bool)0);
#line 421
          break;
        }
      }
    } else {
#line 425
      tmp___8 = isbase64((char )*(in + 3));
#line 425
      if (! tmp___8) {
#line 426
        while (1) {
#line 426
          *outp = (char * __restrict  )out;
#line 426
          return ((_Bool)0);
#line 426
          break;
        }
      }
#line 428
      if (*outleft) {
#line 430
        tmp___9 = out;
#line 430
        out ++;
#line 430
        tmp___10 = to_uchar((char )*(in + 2));
#line 430
        tmp___11 = to_uchar((char )*(in + 3));
#line 430
        *tmp___9 = (char )((((int const   )b64[tmp___10] << 6) & 192) | (int const   )b64[tmp___11]);
#line 432
        (*outleft) --;
      }
    }
  }
#line 437
  *outp = (char * __restrict  )out;
#line 438
  return ((_Bool)1);
}
}
#line 459 "base64.c"
_Bool base64_decode_ctx(struct base64_decode_context *ctx , char const   * __restrict  in ,
                        size_t inlen , char * __restrict  out , size_t *outlen ) 
{ size_t outleft ;
  _Bool ignore_newlines ;
  _Bool flush_ctx ;
  unsigned int ctx_i ;
  size_t outleft_save ;
  _Bool tmp ;
  char const   *in_end ;
  char const   *non_nl ;
  char *tmp___0 ;
  _Bool tmp___1 ;

  {
#line 464
  outleft = *outlen;
#line 465
  ignore_newlines = (_Bool )((unsigned long )ctx != (unsigned long )((void *)0));
#line 466
  flush_ctx = (_Bool)0;
#line 467
  ctx_i = 0U;
#line 469
  if (ignore_newlines) {
#line 471
    ctx_i = ctx->i;
#line 472
    flush_ctx = (_Bool )(inlen == 0UL);
  }
#line 476
  while (1) {
#line 478
    outleft_save = outleft;
#line 479
    if (ctx_i == 0U) {
#line 479
      if (! flush_ctx) {
#line 481
        while (1) {
#line 485
          outleft_save = outleft;
#line 486
          tmp = decode_4(in, inlen, & out, & outleft);
#line 486
          if (! tmp) {
#line 487
            break;
          }
#line 489
          in += 4;
#line 490
          inlen -= 4UL;
        }
      }
    }
#line 494
    if (inlen == 0UL) {
#line 494
      if (! flush_ctx) {
#line 495
        break;
      }
    }
#line 499
    if (inlen) {
#line 499
      if ((int const   )*in == 10) {
#line 499
        if (ignore_newlines) {
#line 501
          in ++;
#line 502
          inlen --;
#line 503
          continue;
        }
      }
    }
#line 507
    out -= outleft_save - outleft;
#line 508
    outleft = outleft_save;
#line 511
    in_end = (char const   *)(in + inlen);
#line 514
    if (ignore_newlines) {
#line 515
      tmp___0 = get_4(ctx, & in, (char const   * __restrict  )in_end, & inlen);
#line 515
      non_nl = (char const   *)tmp___0;
    } else {
#line 517
      non_nl = (char const   *)in;
    }
#line 522
    if (inlen == 0UL) {
#line 524
      inlen = (size_t )0;
#line 525
      break;
    } else
#line 522
    if (inlen < 4UL) {
#line 522
      if (! flush_ctx) {
#line 522
        if (ignore_newlines) {
#line 524
          inlen = (size_t )0;
#line 525
          break;
        }
      }
    }
#line 527
    tmp___1 = decode_4((char const   * __restrict  )non_nl, inlen, & out, & outleft);
#line 527
    if (! tmp___1) {
#line 528
      break;
    }
#line 530
    inlen = (size_t )(in_end - (char const   *)in);
  }
#line 534
  *outlen -= outleft;
#line 536
  return ((_Bool )(inlen == 0UL));
}
}
#line 550 "base64.c"
_Bool base64_decode_alloc_ctx(struct base64_decode_context *ctx , char const   *in ,
                              size_t inlen , char **out , size_t *outlen ) 
{ size_t needlen ;
  void *tmp ;
  _Bool tmp___0 ;

  {
#line 560
  needlen = 3UL * (inlen / 4UL) + 3UL;
#line 562
  tmp = malloc(needlen);
#line 562
  *out = (char *)tmp;
#line 563
  if (! *out) {
#line 564
    return ((_Bool)1);
  }
#line 566
  tmp___0 = base64_decode_ctx(ctx, (char const   * __restrict  )in, inlen, (char * __restrict  )*out,
                              & needlen);
#line 566
  if (! tmp___0) {
#line 568
    free((void *)*out);
#line 569
    *out = (char *)((void *)0);
#line 570
    return ((_Bool)0);
  }
#line 573
  if (outlen) {
#line 574
    *outlen = needlen;
  }
#line 576
  return ((_Bool)1);
}
}
#line 1 "c-ctype.o"
#pragma merger(0,"/tmp/cil-YBceyscx.i","-g,-O2")
#line 123 "c-ctype.h"
_Bool c_isascii(int c ) ;
#line 125
_Bool c_isalnum(int c ) ;
#line 126
_Bool c_isalpha(int c ) ;
#line 127
_Bool c_isblank(int c ) ;
#line 128
_Bool c_iscntrl(int c ) ;
#line 129
_Bool c_isdigit(int c ) ;
#line 130
_Bool c_islower(int c ) ;
#line 131
_Bool c_isgraph(int c ) ;
#line 132
_Bool c_isprint(int c ) ;
#line 133
_Bool c_ispunct(int c ) ;
#line 134
_Bool c_isspace(int c ) ;
#line 135
_Bool c_isupper(int c ) ;
#line 136
_Bool c_isxdigit(int c ) ;
#line 138
int c_tolower(int c ) ;
#line 139
int c_toupper(int c ) ;
#line 29 "c-ctype.c"
_Bool c_isascii(int c ) 
{ int tmp ;

  {
#line 32
  if (c >= 0) {
#line 32
    if (c <= 127) {
#line 32
      tmp = 1;
    } else {
#line 32
      tmp = 0;
    }
  } else {
#line 32
    tmp = 0;
  }
#line 32
  return ((_Bool )tmp);
}
}
#line 35 "c-ctype.c"
_Bool c_isalnum(int c ) 
{ int tmp ;

  {
#line 41
  if (c >= 48) {
#line 41
    if (c <= 57) {
#line 41
      tmp = 1;
    } else {
#line 41
      goto _L;
    }
  } else
  _L: 
#line 41
  if ((c & -33) >= 65) {
#line 41
    if ((c & -33) <= 90) {
#line 41
      tmp = 1;
    } else {
#line 41
      tmp = 0;
    }
  } else {
#line 41
    tmp = 0;
  }
#line 41
  return ((_Bool )tmp);
}
}
#line 70 "c-ctype.c"
_Bool c_isalpha(int c ) 
{ int tmp ;

  {
#line 75
  if ((c & -33) >= 65) {
#line 75
    if ((c & -33) <= 90) {
#line 75
      tmp = 1;
    } else {
#line 75
      tmp = 0;
    }
  } else {
#line 75
    tmp = 0;
  }
#line 75
  return ((_Bool )tmp);
}
}
#line 99 "c-ctype.c"
_Bool c_isblank(int c ) 
{ int tmp ;

  {
#line 102
  if (c == 32) {
#line 102
    tmp = 1;
  } else
#line 102
  if (c == 9) {
#line 102
    tmp = 1;
  } else {
#line 102
    tmp = 0;
  }
#line 102
  return ((_Bool )tmp);
}
}
#line 105 "c-ctype.c"
_Bool c_iscntrl(int c ) 
{ int tmp ;

  {
#line 109
  if ((c & -32) == 0) {
#line 109
    tmp = 1;
  } else
#line 109
  if (c == 127) {
#line 109
    tmp = 1;
  } else {
#line 109
    tmp = 0;
  }
#line 109
  return ((_Bool )tmp);
}
}
#line 139 "c-ctype.c"
_Bool c_isdigit(int c ) 
{ int tmp ;

  {
#line 143
  if (c >= 48) {
#line 143
    if (c <= 57) {
#line 143
      tmp = 1;
    } else {
#line 143
      tmp = 0;
    }
  } else {
#line 143
    tmp = 0;
  }
#line 143
  return ((_Bool )tmp);
}
}
#line 156 "c-ctype.c"
_Bool c_islower(int c ) 
{ int tmp ;

  {
#line 160
  if (c >= 97) {
#line 160
    if (c <= 122) {
#line 160
      tmp = 1;
    } else {
#line 160
      tmp = 0;
    }
  } else {
#line 160
    tmp = 0;
  }
#line 160
  return ((_Bool )tmp);
}
}
#line 176 "c-ctype.c"
_Bool c_isgraph(int c ) 
{ int tmp ;

  {
#line 180
  if (c >= 33) {
#line 180
    if (c <= 126) {
#line 180
      tmp = 1;
    } else {
#line 180
      tmp = 0;
    }
  } else {
#line 180
    tmp = 0;
  }
#line 180
  return ((_Bool )tmp);
}
}
#line 210 "c-ctype.c"
_Bool c_isprint(int c ) 
{ int tmp ;

  {
#line 214
  if (c >= 32) {
#line 214
    if (c <= 126) {
#line 214
      tmp = 1;
    } else {
#line 214
      tmp = 0;
    }
  } else {
#line 214
    tmp = 0;
  }
#line 214
  return ((_Bool )tmp);
}
}
#line 244 "c-ctype.c"
_Bool c_ispunct(int c ) 
{ int tmp ;

  {
#line 248
  if (c >= 33) {
#line 248
    if (c <= 126) {
#line 248
      if (c >= 48) {
#line 248
        if (c <= 57) {
#line 248
          tmp = 0;
        } else {
#line 248
          goto _L;
        }
      } else
      _L: 
#line 248
      if ((c & -33) >= 65) {
#line 248
        if ((c & -33) <= 90) {
#line 248
          tmp = 0;
        } else {
#line 248
          tmp = 1;
        }
      } else {
#line 248
        tmp = 1;
      }
    } else {
#line 248
      tmp = 0;
    }
  } else {
#line 248
    tmp = 0;
  }
#line 248
  return ((_Bool )tmp);
}
}
#line 268 "c-ctype.c"
_Bool c_isspace(int c ) 
{ int tmp ;

  {
#line 271
  if (c == 32) {
#line 271
    tmp = 1;
  } else
#line 271
  if (c == 9) {
#line 271
    tmp = 1;
  } else
#line 271
  if (c == 10) {
#line 271
    tmp = 1;
  } else
#line 271
  if (c == 11) {
#line 271
    tmp = 1;
  } else
#line 271
  if (c == 12) {
#line 271
    tmp = 1;
  } else
#line 271
  if (c == 13) {
#line 271
    tmp = 1;
  } else {
#line 271
    tmp = 0;
  }
#line 271
  return ((_Bool )tmp);
}
}
#line 275 "c-ctype.c"
_Bool c_isupper(int c ) 
{ int tmp ;

  {
#line 279
  if (c >= 65) {
#line 279
    if (c <= 90) {
#line 279
      tmp = 1;
    } else {
#line 279
      tmp = 0;
    }
  } else {
#line 279
    tmp = 0;
  }
#line 279
  return ((_Bool )tmp);
}
}
#line 295 "c-ctype.c"
_Bool c_isxdigit(int c ) 
{ int tmp ;

  {
#line 301
  if (c >= 48) {
#line 301
    if (c <= 57) {
#line 301
      tmp = 1;
    } else {
#line 301
      goto _L;
    }
  } else
  _L: 
#line 301
  if ((c & -33) >= 65) {
#line 301
    if ((c & -33) <= 70) {
#line 301
      tmp = 1;
    } else {
#line 301
      tmp = 0;
    }
  } else {
#line 301
    tmp = 0;
  }
#line 301
  return ((_Bool )tmp);
}
}
#line 322 "c-ctype.c"
int c_tolower(int c ) 
{ int tmp ;

  {
#line 326
  if (c >= 65) {
#line 326
    if (c <= 90) {
#line 326
      tmp = (c - 65) + 97;
    } else {
#line 326
      tmp = c;
    }
  } else {
#line 326
    tmp = c;
  }
#line 326
  return (tmp);
}
}
#line 361 "c-ctype.c"
int c_toupper(int c ) 
{ int tmp ;

  {
#line 365
  if (c >= 97) {
#line 365
    if (c <= 122) {
#line 365
      tmp = (c - 97) + 65;
    } else {
#line 365
      tmp = c;
    }
  } else {
#line 365
    tmp = c;
  }
#line 365
  return (tmp);
}
}
#line 1 "c-strcasecmp.o"
#pragma merger(0,"/tmp/cil-4RmVUeLS.i","-g,-O2")
#line 45 "c-strcase.h"
int c_strcasecmp(char const   *s1 , char const   *s2 ) ;
#line 29 "c-strcasecmp.c"
int c_strcasecmp(char const   *s1 , char const   *s2 ) 
{ register unsigned char const   *p1 ;
  register unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int __c ;
  int tmp ;
  int __c___0 ;
  int tmp___0 ;

  {
#line 32
  p1 = (unsigned char const   *)s1;
#line 33
  p2 = (unsigned char const   *)s2;
#line 36
  if ((unsigned long )p1 == (unsigned long )p2) {
#line 37
    return (0);
  }
#line 39
  while (1) {
#line 41
    __c = (int )*p1;
#line 41
    if (__c >= 65) {
#line 41
      if (__c <= 90) {
#line 41
        tmp = (__c - 65) + 97;
      } else {
#line 41
        tmp = __c;
      }
    } else {
#line 41
      tmp = __c;
    }
#line 41
    c1 = (unsigned char )tmp;
#line 42
    __c___0 = (int )*p2;
#line 42
    if (__c___0 >= 65) {
#line 42
      if (__c___0 <= 90) {
#line 42
        tmp___0 = (__c___0 - 65) + 97;
      } else {
#line 42
        tmp___0 = __c___0;
      }
    } else {
#line 42
      tmp___0 = __c___0;
    }
#line 42
    c2 = (unsigned char )tmp___0;
#line 44
    if ((int )c1 == 0) {
#line 45
      break;
    }
#line 47
    p1 ++;
#line 48
    p2 ++;
#line 39
    if (! ((int )c1 == (int )c2)) {
#line 39
      break;
    }
  }
#line 53
  return ((int )c1 - (int )c2);
}
}
#line 1 "c-strncasecmp.o"
#pragma merger(0,"/tmp/cil-4osLdqOA.i","-g,-O2")
#line 50 "c-strcase.h"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n ) ;
#line 29 "c-strncasecmp.c"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n ) 
{ register unsigned char const   *p1 ;
  register unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int __c ;
  int tmp ;
  int __c___0 ;
  int tmp___0 ;

  {
#line 32
  p1 = (unsigned char const   *)s1;
#line 33
  p2 = (unsigned char const   *)s2;
#line 36
  if ((unsigned long )p1 == (unsigned long )p2) {
#line 37
    return (0);
  } else
#line 36
  if (n == 0UL) {
#line 37
    return (0);
  }
#line 39
  while (1) {
#line 41
    __c = (int )*p1;
#line 41
    if (__c >= 65) {
#line 41
      if (__c <= 90) {
#line 41
        tmp = (__c - 65) + 97;
      } else {
#line 41
        tmp = __c;
      }
    } else {
#line 41
      tmp = __c;
    }
#line 41
    c1 = (unsigned char )tmp;
#line 42
    __c___0 = (int )*p2;
#line 42
    if (__c___0 >= 65) {
#line 42
      if (__c___0 <= 90) {
#line 42
        tmp___0 = (__c___0 - 65) + 97;
      } else {
#line 42
        tmp___0 = __c___0;
      }
    } else {
#line 42
      tmp___0 = __c___0;
    }
#line 42
    c2 = (unsigned char )tmp___0;
#line 44
    n --;
#line 44
    if (n == 0UL) {
#line 45
      break;
    } else
#line 44
    if ((int )c1 == 0) {
#line 45
      break;
    }
#line 47
    p1 ++;
#line 48
    p2 ++;
#line 39
    if (! ((int )c1 == (int )c2)) {
#line 39
      break;
    }
  }
#line 53
  return ((int )c1 - (int )c2);
}
}
#line 1 "c-strtod.o"
#pragma merger(0,"/tmp/cil-BW_QBIa7.i","-g,-O2")
#line 36 "c-strtod.h"
double c_strtod(char const   *nptr , char **endptr ) ;
#line 152 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) __locale_t newlocale(int __category_mask , char const   *__locale ,
                                                          __locale_t __base ) ;
#line 261 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double strtod_l(char const   * __restrict  __nptr ,
                                                     char ** __restrict  __endptr ,
                                                     __locale_t __loc )  __attribute__((__warn_unused_result__,
__nonnull__(1,3))) ;
#line 51 "c-strtod.c"
static locale_t volatile   c_locale_cache  ;
#line 55 "c-strtod.c"
__inline static locale_t c_locale(void) 
{ __locale_t tmp ;

  {
#line 58
  if (! c_locale_cache) {
#line 59
    tmp = newlocale(((((((((((1 | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5)) | (1 << 7)) | (1 << 8)) | (1 << 9)) | (1 << 10)) | (1 << 11)) | (1 << 12),
                    "C", (locale_t )0);
#line 59
    c_locale_cache = (locale_t volatile   )tmp;
  }
#line 60
  return ((locale_t )c_locale_cache);
}
}
#line 65 "c-strtod.c"
double c_strtod(char const   *nptr , char **endptr ) 
{ double r ;
  locale_t locale ;
  locale_t tmp ;

  {
#line 72
  tmp = c_locale();
#line 72
  locale = tmp;
#line 73
  if (! locale) {
#line 75
    if (endptr) {
#line 76
      *endptr = (char *)nptr;
    }
#line 77
    return ((double )0);
  }
#line 80
  r = strtod_l((char const   * __restrict  )nptr, (char ** __restrict  )endptr, locale);
#line 111
  return (r);
}
}
#line 1 "c-strtold.o"
#pragma merger(0,"/tmp/cil-2g0yZ0wy.i","-g,-O2")
#line 37 "c-strtod.h"
long double c_strtold(char const   *nptr , char **endptr ) ;
#line 269 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long double strtold_l(char const   * __restrict  __nptr ,
                                                           char ** __restrict  __endptr ,
                                                           __locale_t __loc )  __attribute__((__warn_unused_result__,
__nonnull__(1,3))) ;
#line 51 "c-strtod.c"
static locale_t volatile   c_locale_cache___0  ;
#line 55 "c-strtod.c"
__inline static locale_t c_locale___0(void) 
{ __locale_t tmp ;

  {
#line 58
  if (! c_locale_cache___0) {
#line 59
    tmp = newlocale(((((((((((1 | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5)) | (1 << 7)) | (1 << 8)) | (1 << 9)) | (1 << 10)) | (1 << 11)) | (1 << 12),
                    "C", (locale_t )0);
#line 59
    c_locale_cache___0 = (locale_t volatile   )tmp;
  }
#line 60
  return ((locale_t )c_locale_cache___0);
}
}
#line 65 "c-strtod.c"
long double c_strtold(char const   *nptr , char **endptr ) 
{ long double r ;
  locale_t locale ;
  locale_t tmp ;

  {
#line 72
  tmp = c_locale___0();
#line 72
  locale = tmp;
#line 73
  if (! locale) {
#line 75
    if (endptr) {
#line 76
      *endptr = (char *)nptr;
    }
#line 77
    return ((long double )0);
  }
#line 80
  r = strtold_l((char const   * __restrict  )nptr, (char ** __restrict  )endptr, locale);
#line 111
  return (r);
}
}
#line 1 "canon-host.o"
#pragma merger(0,"/tmp/cil-du72BYyE.i","-g,-O2")
#line 23 "canon-host.h"
char *canon_host(char const   *host ) ;
#line 24
char *canon_host_r(char const   *host , int *cherror ) ;
#line 26
char const   *ch_strerror(void) ;
#line 1303 "/usr/include/bits/string2.h"
extern  __attribute__((__nothrow__)) char *__strdup(char const   *__string )  __attribute__((__malloc__)) ;
#line 308 "/usr/include/bits/socket.h"
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr ,
                                                                            struct cmsghdr *__cmsg ) ;
#line 314
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr ,
                                                                            struct cmsghdr *__cmsg ) ;
#line 314 "/usr/include/bits/socket.h"
__inline extern struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr , struct cmsghdr *__cmsg ) 
{ 

  {
#line 317
  if (__cmsg->cmsg_len < sizeof(struct cmsghdr )) {
#line 319
    return ((struct cmsghdr *)0);
  }
#line 321
  __cmsg = (struct cmsghdr *)((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)));
#line 323
  if ((unsigned long )((unsigned char *)(__cmsg + 1)) > (unsigned long )((unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen)) {
#line 328
    return ((struct cmsghdr *)0);
  } else
#line 323
  if ((unsigned long )((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL))) > (unsigned long )((unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen)) {
#line 328
    return ((struct cmsghdr *)0);
  }
#line 329
  return (__cmsg);
}
}
#line 148 "/usr/include/sys/socket.h"
__inline extern ssize_t __attribute__((__artificial__))  ( __attribute__((__always_inline__)) recv)(int __fd ,
                                                                                                    void *__buf ,
                                                                                                    size_t __n ,
                                                                                                    int __flags ) ;
#line 166
__inline extern ssize_t __attribute__((__artificial__))  ( __attribute__((__always_inline__)) recvfrom)(int __fd ,
                                                                                                        void * __restrict  __buf ,
                                                                                                        size_t __n ,
                                                                                                        int __flags ,
                                                                                                        struct sockaddr * __restrict  __cil_tmp14 ,
                                                                                                        socklen_t * __restrict  __addr_len ) ;
#line 24 "/usr/include/bits/socket2.h"
extern ssize_t __recv_chk(int __fd , void *__buf , size_t __n , size_t __buflen ,
                          int __flags ) ;
#line 26
extern ssize_t __recv_alias(int __fd , void *__buf , size_t __n , int __flags )  __asm__("recv")  ;
#line 28
extern ssize_t __recv_chk_warn(int __fd , void *__buf , size_t __n , size_t __buflen ,
                               int __flags )  __asm__("__recv_chk") __attribute__((__warning__("recv called with bigger length than size of destination buffer"))) ;
#line 34 "/usr/include/bits/socket2.h"
__inline extern ssize_t __attribute__((__artificial__))  ( __attribute__((__always_inline__)) recv)(int __fd ,
                                                                                                    void *__buf ,
                                                                                                    size_t __n ,
                                                                                                    int __flags ) 
{ unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 37
  tmp___4 = __builtin_object_size(__buf, 0);
#line 37
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 40
    tmp = __builtin_object_size(__buf, 0);
#line 40
    tmp___0 = __recv_chk(__fd, __buf, __n, tmp, __flags);
#line 40
    return ((ssize_t __attribute__((__artificial__))  )tmp___0);
#line 42
    tmp___3 = __builtin_object_size(__buf, 0);
#line 42
    if (__n > tmp___3) {
#line 43
      tmp___1 = __builtin_object_size(__buf, 0);
#line 43
      tmp___2 = __recv_chk_warn(__fd, __buf, __n, tmp___1, __flags);
#line 43
      return ((ssize_t __attribute__((__artificial__))  )tmp___2);
    }
  }
#line 45
  tmp___5 = __recv_alias(__fd, __buf, __n, __flags);
#line 45
  return ((ssize_t __attribute__((__artificial__))  )tmp___5);
}
}
#line 48
extern ssize_t __recvfrom_chk(int __fd , void * __restrict  __buf , size_t __n , size_t __buflen ,
                              int __flags , struct sockaddr * __restrict  __addr ,
                              socklen_t * __restrict  __addr_len ) ;
#line 52
extern ssize_t __recvfrom_alias(int __fd , void * __restrict  __buf , size_t __n ,
                                int __flags , struct sockaddr * __restrict  __addr ,
                                socklen_t * __restrict  __addr_len )  __asm__("recvfrom")  ;
#line 56
extern ssize_t __recvfrom_chk_warn(int __fd , void * __restrict  __buf , size_t __n ,
                                   size_t __buflen , int __flags , struct sockaddr * __restrict  __addr ,
                                   socklen_t * __restrict  __addr_len )  __asm__("__recvfrom_chk") __attribute__((__warning__("recvfrom called with bigger length than size of destination buffer"))) ;
#line 64 "/usr/include/bits/socket2.h"
__inline extern ssize_t __attribute__((__artificial__))  ( __attribute__((__always_inline__)) recvfrom)(int __fd ,
                                                                                                        void * __restrict  __buf ,
                                                                                                        size_t __n ,
                                                                                                        int __flags ,
                                                                                                        struct sockaddr * __restrict  __cil_tmp14 ,
                                                                                                        socklen_t * __restrict  __addr_len ) 
{ __SOCKADDR_ARG __addr ;
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 77
  __addr.__sockaddr__ = __cil_tmp14;
#line 68
  tmp___4 = __builtin_object_size((void *)__buf, 0);
#line 68
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 71
    tmp = __builtin_object_size((void *)__buf, 0);
#line 71
    tmp___0 = __recvfrom_chk(__fd, __buf, __n, tmp, __flags, __addr.__sockaddr__,
                             __addr_len);
#line 71
    return ((ssize_t __attribute__((__artificial__))  )tmp___0);
#line 73
    tmp___3 = __builtin_object_size((void *)__buf, 0);
#line 73
    if (__n > tmp___3) {
#line 74
      tmp___1 = __builtin_object_size((void *)__buf, 0);
#line 74
      tmp___2 = __recvfrom_chk_warn(__fd, __buf, __n, tmp___1, __flags, __addr.__sockaddr__,
                                    __addr_len);
#line 74
      return ((ssize_t __attribute__((__artificial__))  )tmp___2);
    }
  }
#line 77
  tmp___5 = __recvfrom_alias(__fd, __buf, __n, __flags, __addr.__sockaddr__, __addr_len);
#line 77
  return ((ssize_t __attribute__((__artificial__))  )tmp___5);
}
}
#line 664 "/usr/include/netdb.h"
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 670
extern  __attribute__((__nothrow__)) void freeaddrinfo(struct addrinfo *__ai ) ;
#line 673
extern  __attribute__((__nothrow__)) char const   *gai_strerror(int __ecode ) ;
#line 28 "canon-host.c"
static int last_cherror  ;
#line 32 "canon-host.c"
char *canon_host(char const   *host ) 
{ char *tmp ;

  {
#line 35
  tmp = canon_host_r(host, & last_cherror);
#line 35
  return (tmp);
}
}
#line 63 "canon-host.c"
static struct addrinfo hints  ;
#line 59 "canon-host.c"
char *canon_host_r(char const   *host , int *cherror ) 
{ char *retval ;
  struct addrinfo *res ;
  int status ;
  char const   *tmp___11 ;
  char *tmp___12 ;

  {
#line 62
  retval = (char *)((void *)0);
#line 64
  res = (struct addrinfo *)((void *)0);
#line 67
  hints.ai_flags = 2;
#line 68
  status = getaddrinfo((char const   * __restrict  )host, (char const   * __restrict  )((void *)0),
                       (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& res));
#line 69
  if (! status) {
#line 74
    if (res->ai_canonname) {
#line 74
      tmp___11 = (char const   *)res->ai_canonname;
    } else {
#line 74
      tmp___11 = host;
    }
#line 74
    tmp___12 = __strdup(tmp___11);
#line 74
    retval = tmp___12;
#line 75
    if (! retval) {
#line 75
      if (cherror) {
#line 76
        *cherror = -10;
      }
    }
#line 77
    freeaddrinfo(res);
  } else
#line 79
  if (cherror) {
#line 80
    *cherror = status;
  }
#line 82
  return (retval);
}
}
#line 86 "canon-host.c"
char const   *ch_strerror(void) 
{ char const   *tmp ;

  {
#line 89
  tmp = gai_strerror(last_cherror);
#line 89
  return (tmp);
}
}
#line 1 "canonicalize.o"
#pragma merger(0,"/tmp/cil-CM8cDkCw.i","-g,-O2")
#line 39 "canonicalize.h"
char *canonicalize_filename_mode(char const   *name , canonicalize_mode_t can_mode ) ;
#line 394 "/usr/include/bits/string2.h"
extern void *__rawmemchr(void const   *__s , int __c ) ;
#line 79 "hash.h"
Hash_table *hash_initialize(size_t candidate , Hash_tuning const   *tuning , size_t (*hasher)(void const   * ,
                                                                                              size_t  ) ,
                            _Bool (*comparator)(void const   * , void const   * ) ,
                            void (*data_freer)(void * ) )  __attribute__((__warn_unused_result__)) ;
#line 83
void hash_free(Hash_table *table___0 ) ;
#line 7 "file-set.h"
void record_file(Hash_table *ht___0 , char const   *file , struct stat  const  *stats )  __attribute__((__nonnull__(2,3))) ;
#line 14
_Bool seen_file(Hash_table const   *ht___0 , char const   *file , struct stat  const  *stats ) ;
#line 16 "hash-triple.h"
size_t triple_hash(void const   *x , size_t table_size ) ;
#line 19
_Bool triple_compare_ino_str(void const   *x , void const   *y ) ;
#line 20
void triple_free(void *x ) ;
#line 17 "xgetcwd.h"
char *xgetcwd(void) ;
#line 60 "canonicalize.c"
static _Bool seen_triple(Hash_table **ht___0 , char const   *filename , struct stat  const  *st ) 
{ size_t initial_capacity ;
  _Bool tmp ;

  {
#line 63
  if ((unsigned long )*ht___0 == (unsigned long )((void *)0)) {
#line 65
    initial_capacity = (size_t )7;
#line 66
    *ht___0 = hash_initialize(initial_capacity, (Hash_tuning const   *)((void *)0),
                              & triple_hash, & triple_compare_ino_str, & triple_free);
#line 71
    if ((unsigned long )*ht___0 == (unsigned long )((void *)0)) {
#line 72
      xalloc_die();
    }
  }
#line 75
  tmp = seen_file((Hash_table const   *)*ht___0, filename, st);
#line 75
  if (tmp) {
#line 76
    return ((_Bool)1);
  }
#line 78
  record_file(*ht___0, filename, st);
#line 79
  return ((_Bool)0);
}
}
#line 88 "canonicalize.c"
char *canonicalize_filename_mode(char const   *name , canonicalize_mode_t can_mode ) 
{ char *rname ;
  char *dest ;
  char *extra_buf ;
  char const   *start ;
  char const   *end ;
  char const   *rname_limit ;
  size_t extra_len ;
  Hash_table *ht___0 ;
  int saved_errno ;
  int *tmp ;
  int *tmp___0 ;
  void *tmp___1 ;
  char *p ;
  void *tmp___3 ;
  void *tmp___4 ;
  struct stat st ;
  char *tmp___6 ;
  ptrdiff_t dest_offset ;
  size_t new_size ;
  void *tmp___7 ;
  void __attribute__((__artificial__))  *tmp___8 ;
  int *tmp___9 ;
  unsigned long tmp___19 ;
  int tmp___20 ;
  char *buf___1 ;
  size_t n ;
  size_t len ;
  _Bool tmp___21 ;
  int *tmp___22 ;
  int *tmp___23 ;
  void *tmp___24 ;
  void *tmp___25 ;
  void __attribute__((__artificial__))  *tmp___26 ;
  void *tmp___28 ;
  int *tmp___29 ;

  {
#line 91
  extra_buf = (char *)((void *)0);
#line 95
  extra_len = (size_t )0;
#line 96
  ht___0 = (Hash_table *)((void *)0);
#line 99
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 101
    tmp = __errno_location();
#line 101
    *tmp = 22;
#line 102
    return ((char *)((void *)0));
  }
#line 105
  if ((int const   )*(name + 0) == 0) {
#line 107
    tmp___0 = __errno_location();
#line 107
    *tmp___0 = 2;
#line 108
    return ((char *)((void *)0));
  }
#line 111
  if ((int const   )*(name + 0) != 47) {
#line 113
    rname = xgetcwd();
#line 114
    if (! rname) {
#line 115
      return ((char *)((void *)0));
    }
#line 116
    tmp___1 = __rawmemchr((void const   *)rname, '\000');
#line 116
    dest = (char *)tmp___1;
#line 117
    if (dest - rname < 4096) {
#line 119
      tmp___3 = xrealloc((void *)rname, (size_t )4096);
#line 119
      p = (char *)tmp___3;
#line 120
      dest = p + (dest - rname);
#line 121
      rname = p;
#line 122
      rname_limit = (char const   *)(rname + 4096);
    } else {
#line 126
      rname_limit = (char const   *)dest;
    }
  } else {
#line 131
    tmp___4 = xmalloc((size_t )4096);
#line 131
    rname = (char *)tmp___4;
#line 132
    rname_limit = (char const   *)(rname + 4096);
#line 133
    *(rname + 0) = (char )'/';
#line 134
    dest = rname + 1;
  }
#line 139
  start = name;
#line 139
  while (*start) {
#line 142
    while ((int const   )*start == 47) {
#line 143
      start ++;
    }
#line 146
    end = start;
#line 146
    while (1) {
#line 146
      if (*end) {
#line 146
        if (! ((int const   )*end != 47)) {
#line 146
          break;
        }
      } else {
#line 146
        break;
      }
#line 146
      end ++;
    }
#line 149
    if (end - start == 0) {
#line 150
      break;
    } else
#line 151
    if (end - start == 1) {
#line 151
      if (! ((int const   )*(start + 0) == 46)) {
#line 151
        goto _L___1;
      }
    } else
    _L___1: 
#line 153
    if (end - start == 2) {
#line 153
      if ((int const   )*(start + 0) == 46) {
#line 153
        if ((int const   )*(start + 1) == 46) {
#line 156
          if ((unsigned long )dest > (unsigned long )(rname + 1)) {
#line 157
            while (1) {
#line 157
              dest --;
#line 157
              if (! ((int )*(dest + -1) != 47)) {
#line 157
                break;
              }
            }
          }
        } else {
#line 153
          goto _L___0;
        }
      } else {
#line 153
        goto _L___0;
      }
    } else {
      _L___0: 
#line 166
      if ((int )*(dest + -1) != 47) {
#line 167
        tmp___6 = dest;
#line 167
        dest ++;
#line 167
        *tmp___6 = (char )'/';
      }
#line 169
      if ((unsigned long )(dest + (end - start)) >= (unsigned long )rname_limit) {
#line 171
        dest_offset = (ptrdiff_t )(dest - rname);
#line 172
        new_size = (size_t )(rname_limit - (char const   *)rname);
#line 174
        if ((end - start) + 1 > 4096) {
#line 175
          new_size += (size_t )((end - start) + 1);
        } else {
#line 177
          new_size += 4096UL;
        }
#line 178
        tmp___7 = xrealloc((void *)rname, new_size);
#line 178
        rname = (char *)tmp___7;
#line 179
        rname_limit = (char const   *)(rname + new_size);
#line 181
        dest = rname + dest_offset;
      }
#line 184
      tmp___8 = memcpy((void * __restrict  )dest, (void const   * __restrict  )start,
                       (size_t )(end - start));
#line 184
      dest = (char *)tmp___8;
#line 185
      dest += end - start;
#line 186
      *dest = (char )'\000';
#line 188
      tmp___20 = lstat((char const   * __restrict  )rname, (struct stat * __restrict  )(& st));
#line 188
      if (tmp___20 != 0) {
#line 190
        tmp___9 = __errno_location();
#line 190
        saved_errno = *tmp___9;
#line 191
        if ((unsigned int )can_mode == 0U) {
#line 192
          goto error;
        }
#line 193
        if ((unsigned int )can_mode == 1U) {
#line 195
          tmp___19 = __builtin_strspn(end, "/");
#line 195
          if (*(end + tmp___19)) {
#line 196
            goto error;
          } else
#line 195
          if (saved_errno != 2) {
#line 196
            goto error;
          }
#line 197
          goto __Cont;
        }
#line 199
        st.st_mode = (__mode_t )0;
      }
#line 202
      if ((st.st_mode & 61440U) == 40960U) {
#line 211
        tmp___21 = seen_triple(& ht___0, name, (struct stat  const  *)(& st));
#line 211
        if (tmp___21) {
#line 213
          if ((unsigned int )can_mode == 2U) {
#line 214
            goto __Cont;
          }
#line 215
          saved_errno = 40;
#line 216
          goto error;
        }
#line 219
        buf___1 = areadlink_with_size((char const   *)rname, (size_t )st.st_size);
#line 220
        if (! buf___1) {
#line 222
          if ((unsigned int )can_mode == 2U) {
#line 222
            tmp___22 = __errno_location();
#line 222
            if (*tmp___22 != 12) {
#line 223
              goto __Cont;
            }
          }
#line 224
          tmp___23 = __errno_location();
#line 224
          saved_errno = *tmp___23;
#line 225
          goto error;
        }
#line 228
        n = strlen((char const   *)buf___1);
#line 229
        len = strlen(end);
#line 231
        if (! extra_len) {
#line 233
          if ((n + len) + 1UL > 4096UL) {
#line 233
            extra_len = (n + len) + 1UL;
          } else {
#line 233
            extra_len = (size_t )4096;
          }
#line 235
          tmp___24 = xmalloc(extra_len);
#line 235
          extra_buf = (char *)tmp___24;
        } else
#line 237
        if ((n + len) + 1UL > extra_len) {
#line 239
          extra_len = (n + len) + 1UL;
#line 240
          tmp___25 = xrealloc((void *)extra_buf, extra_len);
#line 240
          extra_buf = (char *)tmp___25;
        }
#line 244
        memmove((void *)(extra_buf + n), (void const   *)end, len + 1UL);
#line 245
        tmp___26 = memcpy((void * __restrict  )extra_buf, (void const   * __restrict  )buf___1,
                          n);
#line 245
        end = (char const   *)tmp___26;
#line 245
        name = end;
#line 247
        if ((int )*(buf___1 + 0) == 47) {
#line 249
          dest = rname + 1;
        } else
#line 257
        if ((unsigned long )dest > (unsigned long )(rname + 1)) {
#line 258
          while (1) {
#line 258
            dest --;
#line 258
            if (! ((int )*(dest + -1) != 47)) {
#line 258
              break;
            }
          }
        }
#line 264
        free((void *)buf___1);
      } else
#line 268
      if (! ((st.st_mode & 61440U) == 16384U)) {
#line 268
        if (*end) {
#line 268
          if ((unsigned int )can_mode != 2U) {
#line 270
            saved_errno = 20;
#line 271
            goto error;
          }
        }
      }
    }
    __Cont: 
#line 139
    start = end;
  }
#line 276
  if ((unsigned long )dest > (unsigned long )(rname + 1)) {
#line 276
    if ((int )*(dest + -1) == 47) {
#line 277
      dest --;
    }
  }
#line 280
  *dest = (char )'\000';
#line 281
  if ((unsigned long )rname_limit != (unsigned long )(dest + 1)) {
#line 282
    tmp___28 = xrealloc((void *)rname, (size_t )((dest - rname) + 1));
#line 282
    rname = (char *)tmp___28;
  }
#line 284
  free((void *)extra_buf);
#line 285
  if (ht___0) {
#line 286
    hash_free(ht___0);
  }
#line 287
  return (rname);
  error: 
#line 290
  free((void *)extra_buf);
#line 291
  free((void *)rname);
#line 292
  if (ht___0) {
#line 293
    hash_free(ht___0);
  }
#line 294
  tmp___29 = __errno_location();
#line 294
  *tmp___29 = saved_errno;
#line 295
  return ((char *)((void *)0));
}
}
#line 1 "careadlinkat.o"
#pragma merger(0,"/tmp/cil-2LOrzFgC.i","-g,-O2")
#line 514 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
#line 45 "careadlinkat.c"
ssize_t careadlinkatcwd(int fd , char const   *filename , char *buffer , size_t buffer_size ) 
{ ssize_t __attribute__((__nonnull__(1,2), __artificial__))  tmp ;
  ssize_t __attribute__((__nonnull__(1,2), __artificial__))  tmp___0 ;

  {
#line 51
  if (fd != -100) {
#line 52
    abort();
  }
#line 53
  tmp___0 = (ssize_t __attribute__((__nonnull__(1,2), __artificial__))  )readlink((char const   * __restrict  )filename,
                                                                                  (char * __restrict  )buffer,
                                                                                  buffer_size);
#line 53
  tmp = tmp___0;
#line 53
  return ((ssize_t )tmp);
}
}
#line 78 "careadlinkat.c"
char *careadlinkat(int fd , char const   *filename , char *buffer , size_t buffer_size ,
                   struct allocator  const  *alloc , ssize_t (*preadlinkat)(int  ,
                                                                            char const   * ,
                                                                            char * ,
                                                                            size_t  ) ) 
{ char *buf___1 ;
  size_t buf_size ;
  size_t buf_size_max ;
  char stack_buf[1024] ;
  ssize_t link_length ;
  ssize_t tmp ;
  size_t link_size ;
  int readlinkat_errno ;
  int *tmp___0 ;
  int *tmp___1 ;
  size_t tmp___2 ;
  char *b ;
  void *tmp___3 ;
  char *b___0 ;
  void *tmp___4 ;
  int *tmp___5 ;
  void *tmp___6 ;
  int *tmp___7 ;

  {
#line 86
  buf_size_max = 0x8000000000000000UL;
#line 90
  if (! alloc) {
#line 91
    alloc = & stdlib_allocator;
  }
#line 93
  if (! buffer_size) {
#line 99
    buffer = stack_buf;
#line 100
    buffer_size = sizeof(stack_buf);
  }
#line 103
  buf___1 = buffer;
#line 104
  buf_size = buffer_size;
#line 106
  while (1) {
#line 109
    tmp = (*preadlinkat)(fd, filename, buf___1, buf_size);
#line 109
    link_length = tmp;
#line 111
    if (link_length < 0L) {
#line 115
      tmp___0 = __errno_location();
#line 115
      readlinkat_errno = *tmp___0;
#line 116
      if (readlinkat_errno != 34) {
#line 118
        if ((unsigned long )buf___1 != (unsigned long )buffer) {
#line 120
          (*(alloc->free))((void *)buf___1);
#line 121
          tmp___1 = __errno_location();
#line 121
          *tmp___1 = readlinkat_errno;
        }
#line 123
        return ((char *)((void *)0));
      }
    }
#line 127
    link_size = (size_t )link_length;
#line 129
    if (link_size < buf_size) {
#line 131
      tmp___2 = link_size;
#line 131
      link_size ++;
#line 131
      *(buf___1 + tmp___2) = (char )'\000';
#line 133
      if ((unsigned long )buf___1 == (unsigned long )(stack_buf)) {
#line 135
        tmp___3 = (*(alloc->allocate))(link_size);
#line 135
        b = (char *)tmp___3;
#line 136
        buf_size = link_size;
#line 137
        if (! b) {
#line 138
          break;
        }
#line 139
        memcpy((void * __restrict  )b, (void const   * __restrict  )buf___1, link_size);
#line 140
        buf___1 = b;
      } else
#line 142
      if (link_size < buf_size) {
#line 142
        if ((unsigned long )buf___1 != (unsigned long )buffer) {
#line 142
          if (alloc->reallocate) {
#line 145
            tmp___4 = (*(alloc->reallocate))((void *)buf___1, link_size);
#line 145
            b___0 = (char *)tmp___4;
#line 146
            if (b___0) {
#line 147
              buf___1 = b___0;
            }
          }
        }
      }
#line 150
      return (buf___1);
    }
#line 153
    if ((unsigned long )buf___1 != (unsigned long )buffer) {
#line 154
      (*(alloc->free))((void *)buf___1);
    }
#line 156
    if (buf_size <= buf_size_max / 2UL) {
#line 157
      buf_size *= 2UL;
    } else
#line 158
    if (buf_size < buf_size_max) {
#line 159
      buf_size = buf_size_max;
    } else
#line 160
    if (buf_size_max < 0xffffffffffffffffUL) {
#line 162
      tmp___5 = __errno_location();
#line 162
      *tmp___5 = 36;
#line 163
      return ((char *)((void *)0));
    } else {
#line 166
      break;
    }
#line 167
    tmp___6 = (*(alloc->allocate))(buf_size);
#line 167
    buf___1 = (char *)tmp___6;
#line 106
    if (! buf___1) {
#line 106
      break;
    }
  }
#line 171
  if (alloc->die) {
#line 172
    (*(alloc->die))(buf_size);
  }
#line 173
  tmp___7 = __errno_location();
#line 173
  *tmp___7 = 12;
#line 174
  return ((char *)((void *)0));
}
}
#line 1 "cloexec.o"
#pragma merger(0,"/tmp/cil-GIolek74.i","-g,-O2")
#line 32 "cloexec.h"
int set_cloexec_flag(int desc , _Bool value ) ;
#line 38
int dup_cloexec(int fd ) ;
#line 393 "./fcntl.h"
int rpl_fcntl(int fd , int action  , ...) ;
#line 38 "cloexec.c"
int set_cloexec_flag(int desc , _Bool value ) 
{ int flags ;
  int tmp ;
  int newflags ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 43
  tmp = rpl_fcntl(desc, 1, 0);
#line 43
  flags = tmp;
#line 45
  if (0 <= flags) {
#line 47
    if (value) {
#line 47
      tmp___0 = flags | 1;
    } else {
#line 47
      tmp___0 = flags & -2;
    }
#line 47
    newflags = tmp___0;
#line 49
    if (flags == newflags) {
#line 51
      return (0);
    } else {
#line 49
      tmp___1 = rpl_fcntl(desc, 2, newflags);
#line 49
      if (tmp___1 != -1) {
#line 51
        return (0);
      }
    }
  }
#line 54
  return (-1);
}
}
#line 79 "cloexec.c"
int dup_cloexec(int fd ) 
{ int tmp ;

  {
#line 82
  tmp = rpl_fcntl(fd, 1030, 0);
#line 82
  return (tmp);
}
}
#line 1 "close-stream.o"
#pragma merger(0,"/tmp/cil-LMWJr_aV.i","-g,-O2")
#line 474 "./stdio.h"
int rpl_fclose(FILE *fp )  __attribute__((__nonnull__(1))) ;
#line 2 "close-stream.h"
int close_stream(FILE *stream ) ;
#line 76 "/usr/include/stdio_ext.h"
extern  __attribute__((__nothrow__)) size_t __fpending(FILE *__fp ) ;
#line 55 "close-stream.c"
int close_stream(FILE *stream ) 
{ _Bool some_pending ;
  size_t tmp ;
  _Bool prev_fail ;
  int tmp___0 ;
  _Bool fclose_fail ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
#line 58
  tmp = __fpending(stream);
#line 58
  some_pending = (_Bool )(tmp != 0UL);
#line 59
  tmp___0 = ferror_unlocked(stream);
#line 59
  prev_fail = (_Bool )(tmp___0 != 0);
#line 60
  tmp___1 = rpl_fclose(stream);
#line 60
  fclose_fail = (_Bool )(tmp___1 != 0);
#line 70
  if (prev_fail) {
#line 70
    goto _L___0;
  } else
#line 70
  if (fclose_fail) {
#line 70
    if (some_pending) {
#line 70
      goto _L___0;
    } else {
#line 70
      tmp___3 = __errno_location();
#line 70
      if (*tmp___3 != 9) {
        _L___0: 
#line 72
        if (! fclose_fail) {
#line 73
          tmp___2 = __errno_location();
#line 73
          *tmp___2 = 0;
        }
#line 74
        return (-1);
      }
    }
  }
#line 77
  return (0);
}
}
#line 1 "closein.o"
#pragma merger(0,"/tmp/cil-xGB33bni.i","-g,-O2")
#line 25 "closein.h"
void close_stdin_set_file_name(char const   *file ) ;
#line 26
void close_stdin(void) ;
#line 498 "./stdio.h"
int rpl_fflush(FILE *stream ) ;
#line 767
int rpl_fseeko(FILE *fp , off_t offset , int whence )  __attribute__((__nonnull__(1))) ;
#line 600 "/usr/include/unistd.h"
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 30 "closeout.h"
void close_stdout(void) ;
#line 18 "exitfail.h"
int volatile   exit_failure ;
#line 34 "freadahead.h"
size_t freadahead(FILE *fp ) ;
#line 358 "quotearg.h"
char *quotearg_colon(char const   *arg ) ;
#line 37 "closein.c"
static char const   *file_name  ;
#line 42 "closein.c"
void close_stdin_set_file_name(char const   *file ) 
{ 

  {
#line 45
  file_name = file;
#line 46
  return;
}
}
#line 78 "closein.c"
void close_stdin(void) 
{ _Bool fail ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  char const   *close_error ;
  char *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;

  {
#line 81
  fail = (_Bool)0;
#line 87
  tmp___1 = freadahead(stdin);
#line 87
  if (tmp___1 > 0UL) {
#line 91
    tmp = rpl_fseeko(stdin, (off_t )0, 1);
#line 91
    if (tmp == 0) {
#line 91
      tmp___0 = rpl_fflush(stdin);
#line 91
      if (tmp___0 != 0) {
#line 92
        fail = (_Bool)1;
      }
    }
  }
#line 94
  tmp___2 = close_stream(stdin);
#line 94
  if (tmp___2 != 0) {
#line 95
    fail = (_Bool)1;
  }
#line 96
  if (fail) {
#line 100
    tmp___3 = dcgettext((char const   *)((void *)0), "error closing file", 5);
#line 100
    close_error = (char const   *)tmp___3;
#line 101
    if (file_name) {
#line 102
      tmp___4 = quotearg_colon(file_name);
#line 102
      tmp___5 = __errno_location();
#line 102
      error(0, *tmp___5, "%s: %s", tmp___4, close_error);
    } else {
#line 105
      tmp___6 = __errno_location();
#line 105
      error(0, *tmp___6, "%s", close_error);
    }
  }
#line 108
  close_stdout();
#line 110
  if (fail) {
#line 111
    _exit((int )exit_failure);
  }
#line 112
  return;
}
}
#line 1 "closeout.o"
#pragma merger(0,"/tmp/cil-7wdVAxsF.i","-g,-O2")
#line 28 "closeout.h"
void close_stdout_set_file_name(char const   *file ) ;
#line 29
void close_stdout_set_ignore_EPIPE(_Bool ignore ) ;
#line 36 "closeout.c"
static char const   *file_name___0  ;
#line 40 "closeout.c"
void close_stdout_set_file_name(char const   *file ) 
{ 

  {
#line 43
  file_name___0 = file;
#line 44
  return;
}
}
#line 46 "closeout.c"
static _Bool ignore_EPIPE  ;
#line 77 "closeout.c"
void close_stdout_set_ignore_EPIPE(_Bool ignore ) 
{ 

  {
#line 80
  ignore_EPIPE = ignore;
#line 81
  return;
}
}
#line 106 "closeout.c"
void close_stdout(void) 
{ char const   *write_error ;
  char *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
#line 109
  tmp___3 = close_stream(stdout);
#line 109
  if (tmp___3 != 0) {
#line 109
    if (ignore_EPIPE) {
#line 109
      tmp___4 = __errno_location();
#line 109
      if (! (*tmp___4 == 32)) {
#line 109
        goto _L;
      }
    } else {
      _L: 
#line 112
      tmp = dcgettext((char const   *)((void *)0), "write error", 5);
#line 112
      write_error = (char const   *)tmp;
#line 113
      if (file_name___0) {
#line 114
        tmp___0 = quotearg_colon(file_name___0);
#line 114
        tmp___1 = __errno_location();
#line 114
        error(0, *tmp___1, "%s: %s", tmp___0, write_error);
      } else {
#line 117
        tmp___2 = __errno_location();
#line 117
        error(0, *tmp___2, "%s", write_error);
      }
#line 119
      _exit((int )exit_failure);
    }
  }
#line 122
  tmp___5 = close_stream(stderr);
#line 122
  if (tmp___5 != 0) {
#line 123
    _exit((int )exit_failure);
  }
#line 124
  return;
}
}
#line 1 "md5.o"
#pragma merger(0,"/tmp/cil-F8TMknQP.i","-g,-O2")
#line 83 "md5.h"
 __attribute__((__nothrow__)) void md5_init_ctx(struct md5_ctx *ctx ) ;
#line 89
 __attribute__((__nothrow__)) void md5_process_block(void const   *buffer , size_t len ,
                                                     struct md5_ctx *ctx ) ;
#line 96
 __attribute__((__nothrow__)) void md5_process_bytes(void const   *buffer , size_t len ,
                                                     struct md5_ctx *ctx ) ;
#line 103
 __attribute__((__nothrow__)) void *md5_finish_ctx(struct md5_ctx *ctx , void *resbuf ) ;
#line 109
 __attribute__((__nothrow__)) void *md5_read_ctx(struct md5_ctx  const  *ctx , void *resbuf ) ;
#line 115
 __attribute__((__nothrow__)) int md5_stream(FILE *stream , void *resblock ) ;
#line 121
 __attribute__((__nothrow__)) void *md5_buffer(char const   *buffer , size_t len ,
                                               void *resblock ) ;
#line 68 "md5.c"
static unsigned char const   fillbuf[64]  = {      (unsigned char const   )128,      (unsigned char const   )0};
#line 73
 __attribute__((__nothrow__)) void md5_init_ctx(struct md5_ctx *ctx ) ;
#line 73 "md5.c"
void md5_init_ctx(struct md5_ctx *ctx ) 
{ uint32_t tmp ;

  {
#line 76
  ctx->A = (uint32_t )1732584193;
#line 77
  ctx->B = 4023233417U;
#line 78
  ctx->C = 2562383102U;
#line 79
  ctx->D = (uint32_t )271733878;
#line 81
  tmp = (uint32_t )0;
#line 81
  ctx->total[1] = tmp;
#line 81
  ctx->total[0] = tmp;
#line 82
  ctx->buflen = (uint32_t )0;
#line 83
  return;
}
}
#line 88 "md5.c"
__inline static void set_uint32(char *cp , uint32_t v ) 
{ 

  {
#line 91
  memcpy((void * __restrict  )cp, (void const   * __restrict  )(& v), sizeof(v));
#line 92
  return;
}
}
#line 96
 __attribute__((__nothrow__)) void *md5_read_ctx(struct md5_ctx  const  *ctx , void *resbuf ) ;
#line 96 "md5.c"
void *md5_read_ctx(struct md5_ctx  const  *ctx , void *resbuf ) 
{ char *r ;

  {
#line 99
  r = (char *)resbuf;
#line 100
  set_uint32(r + 0UL, (uint32_t )ctx->A);
#line 101
  set_uint32(r + sizeof(ctx->B), (uint32_t )ctx->B);
#line 102
  set_uint32(r + 2UL * sizeof(ctx->C), (uint32_t )ctx->C);
#line 103
  set_uint32(r + 3UL * sizeof(ctx->D), (uint32_t )ctx->D);
#line 105
  return (resbuf);
}
}
#line 110
 __attribute__((__nothrow__)) void *md5_finish_ctx(struct md5_ctx *ctx , void *resbuf ) ;
#line 110 "md5.c"
void *md5_finish_ctx(struct md5_ctx *ctx , void *resbuf ) 
{ uint32_t bytes ;
  size_t size ;
  int tmp ;
  void *tmp___0 ;

  {
#line 114
  bytes = ctx->buflen;
#line 115
  if (bytes < 56U) {
#line 115
    tmp = 16;
  } else {
#line 115
    tmp = 32;
  }
#line 115
  size = (size_t )tmp;
#line 118
  ctx->total[0] += bytes;
#line 119
  if (ctx->total[0] < bytes) {
#line 120
    (ctx->total[1]) ++;
  }
#line 123
  ctx->buffer[size - 2UL] = ctx->total[0] << 3;
#line 124
  ctx->buffer[size - 1UL] = (ctx->total[1] << 3) | (ctx->total[0] >> 29);
#line 126
  memcpy((void * __restrict  )((char *)(ctx->buffer) + bytes), (void const   * __restrict  )(fillbuf),
         (size - 2UL) * 4UL - (size_t )bytes);
#line 129
  md5_process_block((void const   *)(ctx->buffer), size * 4UL, ctx);
#line 131
  tmp___0 = md5_read_ctx((struct md5_ctx  const  *)ctx, resbuf);
#line 131
  return (tmp___0);
}
}
#line 137
 __attribute__((__nothrow__)) int md5_stream(FILE *stream , void *resblock ) ;
#line 137 "md5.c"
int md5_stream(FILE *stream , void *resblock ) 
{ struct md5_ctx ctx ;
  size_t sum ;
  char *buffer ;
  void *tmp ;
  size_t n ;
  size_t __attribute__((__artificial__))  tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t __attribute__((__artificial__))  tmp___3 ;

  {
#line 143
  tmp = malloc((size_t )32840);
#line 143
  buffer = (char *)tmp;
#line 144
  if (! buffer) {
#line 145
    return (1);
  }
#line 148
  md5_init_ctx(& ctx);
#line 151
  while (1) {
#line 157
    sum = (size_t )0;
#line 160
    while (1) {
#line 162
      tmp___3 = (size_t __attribute__((__artificial__))  )fread_unlocked((void * __restrict  )(buffer + sum),
                                                                         (size_t )1,
                                                                         32768UL - sum,
                                                                         (FILE * __restrict  )stream);
#line 162
      tmp___0 = tmp___3;
#line 162
      n = (size_t )tmp___0;
#line 164
      sum += n;
#line 166
      if (sum == 32768UL) {
#line 167
        break;
      }
#line 169
      if (n == 0UL) {
#line 174
        tmp___1 = ferror_unlocked(stream);
#line 174
        if (tmp___1) {
#line 176
          free((void *)buffer);
#line 177
          return (1);
        }
#line 179
        goto process_partial_block;
      }
#line 185
      tmp___2 = feof_unlocked(stream);
#line 185
      if (tmp___2) {
#line 186
        goto process_partial_block;
      }
    }
#line 192
    md5_process_block((void const   *)buffer, (size_t )32768, & ctx);
  }
  process_partial_block: 
#line 198
  if (sum > 0UL) {
#line 199
    md5_process_bytes((void const   *)buffer, sum, & ctx);
  }
#line 202
  md5_finish_ctx(& ctx, resblock);
#line 203
  free((void *)buffer);
#line 204
  return (0);
}
}
#line 211
 __attribute__((__nothrow__)) void *md5_buffer(char const   *buffer , size_t len ,
                                               void *resblock ) ;
#line 211 "md5.c"
void *md5_buffer(char const   *buffer , size_t len , void *resblock ) 
{ struct md5_ctx ctx ;
  void *tmp ;

  {
#line 217
  md5_init_ctx(& ctx);
#line 220
  md5_process_bytes((void const   *)buffer, len, & ctx);
#line 223
  tmp = md5_finish_ctx(& ctx, resblock);
#line 223
  return (tmp);
}
}
#line 227
 __attribute__((__nothrow__)) void md5_process_bytes(void const   *buffer , size_t len ,
                                                     struct md5_ctx *ctx ) ;
#line 227 "md5.c"
void md5_process_bytes(void const   *buffer , size_t len , struct md5_ctx *ctx ) 
{ size_t left_over ;
  size_t add ;
  size_t tmp ;
  size_t left_over___0 ;

  {
#line 232
  if (ctx->buflen != 0U) {
#line 234
    left_over = (size_t )ctx->buflen;
#line 235
    if (128UL - left_over > len) {
#line 235
      tmp = len;
    } else {
#line 235
      tmp = 128UL - left_over;
    }
#line 235
    add = tmp;
#line 237
    memcpy((void * __restrict  )((char *)(ctx->buffer) + left_over), (void const   * __restrict  )buffer,
           add);
#line 238
    ctx->buflen = (uint32_t )((size_t )ctx->buflen + add);
#line 240
    if (ctx->buflen > 64U) {
#line 242
      md5_process_block((void const   *)(ctx->buffer), (size_t )(ctx->buflen & 4294967232U),
                        ctx);
#line 244
      ctx->buflen &= 63U;
#line 246
      memcpy((void * __restrict  )(ctx->buffer), (void const   * __restrict  )((char *)(ctx->buffer) + ((left_over + add) & 0xffffffffffffffc0UL)),
             (size_t )ctx->buflen);
    }
#line 251
    buffer = (void const   *)((char const   *)buffer + add);
#line 252
    len -= add;
  }
#line 256
  if (len >= 64UL) {
#line 271
    md5_process_block(buffer, len & 0xffffffffffffffc0UL, ctx);
#line 272
    buffer = (void const   *)((char const   *)buffer + (len & 0xffffffffffffffc0UL));
#line 273
    len &= 63UL;
  }
#line 278
  if (len > 0UL) {
#line 280
    left_over___0 = (size_t )ctx->buflen;
#line 282
    memcpy((void * __restrict  )((char *)(ctx->buffer) + left_over___0), (void const   * __restrict  )buffer,
           len);
#line 283
    left_over___0 += len;
#line 284
    if (left_over___0 >= 64UL) {
#line 286
      md5_process_block((void const   *)(ctx->buffer), (size_t )64, ctx);
#line 287
      left_over___0 -= 64UL;
#line 288
      memcpy((void * __restrict  )(ctx->buffer), (void const   * __restrict  )(& ctx->buffer[16]),
             left_over___0);
    }
#line 290
    ctx->buflen = (uint32_t )left_over___0;
  }
#line 292
  return;
}
}
#line 307
 __attribute__((__nothrow__)) void md5_process_block(void const   *buffer , size_t len ,
                                                     struct md5_ctx *ctx ) ;
#line 307 "md5.c"
void md5_process_block(void const   *buffer , size_t len , struct md5_ctx *ctx ) 
{ uint32_t correct_words[16] ;
  uint32_t const   *words ;
  size_t nwords ;
  uint32_t const   *endp ;
  uint32_t A ;
  uint32_t B ;
  uint32_t C ;
  uint32_t D ;
  uint32_t *cwp ;
  uint32_t A_save ;
  uint32_t B_save ;
  uint32_t C_save ;
  uint32_t D_save ;
  uint32_t *tmp ;
  uint32_t tmp___0 ;
  uint32_t *tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t *tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t *tmp___5 ;
  uint32_t tmp___6 ;
  uint32_t *tmp___7 ;
  uint32_t tmp___8 ;
  uint32_t *tmp___9 ;
  uint32_t tmp___10 ;
  uint32_t *tmp___11 ;
  uint32_t tmp___12 ;
  uint32_t *tmp___13 ;
  uint32_t tmp___14 ;
  uint32_t *tmp___15 ;
  uint32_t tmp___16 ;
  uint32_t *tmp___17 ;
  uint32_t tmp___18 ;
  uint32_t *tmp___19 ;
  uint32_t tmp___20 ;
  uint32_t *tmp___21 ;
  uint32_t tmp___22 ;
  uint32_t *tmp___23 ;
  uint32_t tmp___24 ;
  uint32_t *tmp___25 ;
  uint32_t tmp___26 ;
  uint32_t *tmp___27 ;
  uint32_t tmp___28 ;
  uint32_t *tmp___29 ;
  uint32_t tmp___30 ;

  {
#line 311
  words = (uint32_t const   *)buffer;
#line 312
  nwords = len / sizeof(uint32_t );
#line 313
  endp = words + nwords;
#line 314
  A = ctx->A;
#line 315
  B = ctx->B;
#line 316
  C = ctx->C;
#line 317
  D = ctx->D;
#line 322
  ctx->total[0] = (uint32_t )((size_t )ctx->total[0] + len);
#line 323
  if ((size_t )ctx->total[0] < len) {
#line 324
    (ctx->total[1]) ++;
  }
#line 328
  while ((unsigned long )words < (unsigned long )endp) {
#line 330
    cwp = correct_words;
#line 331
    A_save = A;
#line 332
    B_save = B;
#line 333
    C_save = C;
#line 334
    D_save = D;
#line 368
    while (1) {
#line 368
      tmp = cwp;
#line 368
      cwp ++;
#line 368
      tmp___0 = (uint32_t )*words;
#line 368
      *tmp = tmp___0;
#line 368
      A += ((D ^ (B & (C ^ D))) + tmp___0) + 3614090360U;
#line 368
      words ++;
#line 368
      A = (A << 7) | (A >> 25);
#line 368
      A += B;
#line 368
      break;
    }
#line 369
    while (1) {
#line 369
      tmp___1 = cwp;
#line 369
      cwp ++;
#line 369
      tmp___2 = (uint32_t )*words;
#line 369
      *tmp___1 = tmp___2;
#line 369
      D += ((C ^ (A & (B ^ C))) + tmp___2) + 3905402710U;
#line 369
      words ++;
#line 369
      D = (D << 12) | (D >> 20);
#line 369
      D += A;
#line 369
      break;
    }
#line 370
    while (1) {
#line 370
      tmp___3 = cwp;
#line 370
      cwp ++;
#line 370
      tmp___4 = (uint32_t )*words;
#line 370
      *tmp___3 = tmp___4;
#line 370
      C += ((B ^ (D & (A ^ B))) + tmp___4) + 606105819U;
#line 370
      words ++;
#line 370
      C = (C << 17) | (C >> 15);
#line 370
      C += D;
#line 370
      break;
    }
#line 371
    while (1) {
#line 371
      tmp___5 = cwp;
#line 371
      cwp ++;
#line 371
      tmp___6 = (uint32_t )*words;
#line 371
      *tmp___5 = tmp___6;
#line 371
      B += ((A ^ (C & (D ^ A))) + tmp___6) + 3250441966U;
#line 371
      words ++;
#line 371
      B = (B << 22) | (B >> 10);
#line 371
      B += C;
#line 371
      break;
    }
#line 372
    while (1) {
#line 372
      tmp___7 = cwp;
#line 372
      cwp ++;
#line 372
      tmp___8 = (uint32_t )*words;
#line 372
      *tmp___7 = tmp___8;
#line 372
      A += ((D ^ (B & (C ^ D))) + tmp___8) + 4118548399U;
#line 372
      words ++;
#line 372
      A = (A << 7) | (A >> 25);
#line 372
      A += B;
#line 372
      break;
    }
#line 373
    while (1) {
#line 373
      tmp___9 = cwp;
#line 373
      cwp ++;
#line 373
      tmp___10 = (uint32_t )*words;
#line 373
      *tmp___9 = tmp___10;
#line 373
      D += ((C ^ (A & (B ^ C))) + tmp___10) + 1200080426U;
#line 373
      words ++;
#line 373
      D = (D << 12) | (D >> 20);
#line 373
      D += A;
#line 373
      break;
    }
#line 374
    while (1) {
#line 374
      tmp___11 = cwp;
#line 374
      cwp ++;
#line 374
      tmp___12 = (uint32_t )*words;
#line 374
      *tmp___11 = tmp___12;
#line 374
      C += ((B ^ (D & (A ^ B))) + tmp___12) + 2821735955U;
#line 374
      words ++;
#line 374
      C = (C << 17) | (C >> 15);
#line 374
      C += D;
#line 374
      break;
    }
#line 375
    while (1) {
#line 375
      tmp___13 = cwp;
#line 375
      cwp ++;
#line 375
      tmp___14 = (uint32_t )*words;
#line 375
      *tmp___13 = tmp___14;
#line 375
      B += ((A ^ (C & (D ^ A))) + tmp___14) + 4249261313U;
#line 375
      words ++;
#line 375
      B = (B << 22) | (B >> 10);
#line 375
      B += C;
#line 375
      break;
    }
#line 376
    while (1) {
#line 376
      tmp___15 = cwp;
#line 376
      cwp ++;
#line 376
      tmp___16 = (uint32_t )*words;
#line 376
      *tmp___15 = tmp___16;
#line 376
      A += ((D ^ (B & (C ^ D))) + tmp___16) + 1770035416U;
#line 376
      words ++;
#line 376
      A = (A << 7) | (A >> 25);
#line 376
      A += B;
#line 376
      break;
    }
#line 377
    while (1) {
#line 377
      tmp___17 = cwp;
#line 377
      cwp ++;
#line 377
      tmp___18 = (uint32_t )*words;
#line 377
      *tmp___17 = tmp___18;
#line 377
      D += ((C ^ (A & (B ^ C))) + tmp___18) + 2336552879U;
#line 377
      words ++;
#line 377
      D = (D << 12) | (D >> 20);
#line 377
      D += A;
#line 377
      break;
    }
#line 378
    while (1) {
#line 378
      tmp___19 = cwp;
#line 378
      cwp ++;
#line 378
      tmp___20 = (uint32_t )*words;
#line 378
      *tmp___19 = tmp___20;
#line 378
      C += ((B ^ (D & (A ^ B))) + tmp___20) + 4294925233U;
#line 378
      words ++;
#line 378
      C = (C << 17) | (C >> 15);
#line 378
      C += D;
#line 378
      break;
    }
#line 379
    while (1) {
#line 379
      tmp___21 = cwp;
#line 379
      cwp ++;
#line 379
      tmp___22 = (uint32_t )*words;
#line 379
      *tmp___21 = tmp___22;
#line 379
      B += ((A ^ (C & (D ^ A))) + tmp___22) + 2304563134U;
#line 379
      words ++;
#line 379
      B = (B << 22) | (B >> 10);
#line 379
      B += C;
#line 379
      break;
    }
#line 380
    while (1) {
#line 380
      tmp___23 = cwp;
#line 380
      cwp ++;
#line 380
      tmp___24 = (uint32_t )*words;
#line 380
      *tmp___23 = tmp___24;
#line 380
      A += ((D ^ (B & (C ^ D))) + tmp___24) + 1804603682U;
#line 380
      words ++;
#line 380
      A = (A << 7) | (A >> 25);
#line 380
      A += B;
#line 380
      break;
    }
#line 381
    while (1) {
#line 381
      tmp___25 = cwp;
#line 381
      cwp ++;
#line 381
      tmp___26 = (uint32_t )*words;
#line 381
      *tmp___25 = tmp___26;
#line 381
      D += ((C ^ (A & (B ^ C))) + tmp___26) + 4254626195U;
#line 381
      words ++;
#line 381
      D = (D << 12) | (D >> 20);
#line 381
      D += A;
#line 381
      break;
    }
#line 382
    while (1) {
#line 382
      tmp___27 = cwp;
#line 382
      cwp ++;
#line 382
      tmp___28 = (uint32_t )*words;
#line 382
      *tmp___27 = tmp___28;
#line 382
      C += ((B ^ (D & (A ^ B))) + tmp___28) + 2792965006U;
#line 382
      words ++;
#line 382
      C = (C << 17) | (C >> 15);
#line 382
      C += D;
#line 382
      break;
    }
#line 383
    while (1) {
#line 383
      tmp___29 = cwp;
#line 383
      cwp ++;
#line 383
      tmp___30 = (uint32_t )*words;
#line 383
      *tmp___29 = tmp___30;
#line 383
      B += ((A ^ (C & (D ^ A))) + tmp___30) + 1236535329U;
#line 383
      words ++;
#line 383
      B = (B << 22) | (B >> 10);
#line 383
      B += C;
#line 383
      break;
    }
#line 399
    while (1) {
#line 399
      A += ((C ^ (D & (B ^ C))) + correct_words[1]) + 4129170786U;
#line 399
      A = (A << 5) | (A >> 27);
#line 399
      A += B;
#line 399
      break;
    }
#line 400
    while (1) {
#line 400
      D += ((B ^ (C & (A ^ B))) + correct_words[6]) + 3225465664U;
#line 400
      D = (D << 9) | (D >> 23);
#line 400
      D += A;
#line 400
      break;
    }
#line 401
    while (1) {
#line 401
      C += ((A ^ (B & (D ^ A))) + correct_words[11]) + 643717713U;
#line 401
      C = (C << 14) | (C >> 18);
#line 401
      C += D;
#line 401
      break;
    }
#line 402
    while (1) {
#line 402
      B += ((D ^ (A & (C ^ D))) + correct_words[0]) + 3921069994U;
#line 402
      B = (B << 20) | (B >> 12);
#line 402
      B += C;
#line 402
      break;
    }
#line 403
    while (1) {
#line 403
      A += ((C ^ (D & (B ^ C))) + correct_words[5]) + 3593408605U;
#line 403
      A = (A << 5) | (A >> 27);
#line 403
      A += B;
#line 403
      break;
    }
#line 404
    while (1) {
#line 404
      D += ((B ^ (C & (A ^ B))) + correct_words[10]) + 38016083U;
#line 404
      D = (D << 9) | (D >> 23);
#line 404
      D += A;
#line 404
      break;
    }
#line 405
    while (1) {
#line 405
      C += ((A ^ (B & (D ^ A))) + correct_words[15]) + 3634488961U;
#line 405
      C = (C << 14) | (C >> 18);
#line 405
      C += D;
#line 405
      break;
    }
#line 406
    while (1) {
#line 406
      B += ((D ^ (A & (C ^ D))) + correct_words[4]) + 3889429448U;
#line 406
      B = (B << 20) | (B >> 12);
#line 406
      B += C;
#line 406
      break;
    }
#line 407
    while (1) {
#line 407
      A += ((C ^ (D & (B ^ C))) + correct_words[9]) + 568446438U;
#line 407
      A = (A << 5) | (A >> 27);
#line 407
      A += B;
#line 407
      break;
    }
#line 408
    while (1) {
#line 408
      D += ((B ^ (C & (A ^ B))) + correct_words[14]) + 3275163606U;
#line 408
      D = (D << 9) | (D >> 23);
#line 408
      D += A;
#line 408
      break;
    }
#line 409
    while (1) {
#line 409
      C += ((A ^ (B & (D ^ A))) + correct_words[3]) + 4107603335U;
#line 409
      C = (C << 14) | (C >> 18);
#line 409
      C += D;
#line 409
      break;
    }
#line 410
    while (1) {
#line 410
      B += ((D ^ (A & (C ^ D))) + correct_words[8]) + 1163531501U;
#line 410
      B = (B << 20) | (B >> 12);
#line 410
      B += C;
#line 410
      break;
    }
#line 411
    while (1) {
#line 411
      A += ((C ^ (D & (B ^ C))) + correct_words[13]) + 2850285829U;
#line 411
      A = (A << 5) | (A >> 27);
#line 411
      A += B;
#line 411
      break;
    }
#line 412
    while (1) {
#line 412
      D += ((B ^ (C & (A ^ B))) + correct_words[2]) + 4243563512U;
#line 412
      D = (D << 9) | (D >> 23);
#line 412
      D += A;
#line 412
      break;
    }
#line 413
    while (1) {
#line 413
      C += ((A ^ (B & (D ^ A))) + correct_words[7]) + 1735328473U;
#line 413
      C = (C << 14) | (C >> 18);
#line 413
      C += D;
#line 413
      break;
    }
#line 414
    while (1) {
#line 414
      B += ((D ^ (A & (C ^ D))) + correct_words[12]) + 2368359562U;
#line 414
      B = (B << 20) | (B >> 12);
#line 414
      B += C;
#line 414
      break;
    }
#line 417
    while (1) {
#line 417
      A += (((B ^ C) ^ D) + correct_words[5]) + 4294588738U;
#line 417
      A = (A << 4) | (A >> 28);
#line 417
      A += B;
#line 417
      break;
    }
#line 418
    while (1) {
#line 418
      D += (((A ^ B) ^ C) + correct_words[8]) + 2272392833U;
#line 418
      D = (D << 11) | (D >> 21);
#line 418
      D += A;
#line 418
      break;
    }
#line 419
    while (1) {
#line 419
      C += (((D ^ A) ^ B) + correct_words[11]) + 1839030562U;
#line 419
      C = (C << 16) | (C >> 16);
#line 419
      C += D;
#line 419
      break;
    }
#line 420
    while (1) {
#line 420
      B += (((C ^ D) ^ A) + correct_words[14]) + 4259657740U;
#line 420
      B = (B << 23) | (B >> 9);
#line 420
      B += C;
#line 420
      break;
    }
#line 421
    while (1) {
#line 421
      A += (((B ^ C) ^ D) + correct_words[1]) + 2763975236U;
#line 421
      A = (A << 4) | (A >> 28);
#line 421
      A += B;
#line 421
      break;
    }
#line 422
    while (1) {
#line 422
      D += (((A ^ B) ^ C) + correct_words[4]) + 1272893353U;
#line 422
      D = (D << 11) | (D >> 21);
#line 422
      D += A;
#line 422
      break;
    }
#line 423
    while (1) {
#line 423
      C += (((D ^ A) ^ B) + correct_words[7]) + 4139469664U;
#line 423
      C = (C << 16) | (C >> 16);
#line 423
      C += D;
#line 423
      break;
    }
#line 424
    while (1) {
#line 424
      B += (((C ^ D) ^ A) + correct_words[10]) + 3200236656U;
#line 424
      B = (B << 23) | (B >> 9);
#line 424
      B += C;
#line 424
      break;
    }
#line 425
    while (1) {
#line 425
      A += (((B ^ C) ^ D) + correct_words[13]) + 681279174U;
#line 425
      A = (A << 4) | (A >> 28);
#line 425
      A += B;
#line 425
      break;
    }
#line 426
    while (1) {
#line 426
      D += (((A ^ B) ^ C) + correct_words[0]) + 3936430074U;
#line 426
      D = (D << 11) | (D >> 21);
#line 426
      D += A;
#line 426
      break;
    }
#line 427
    while (1) {
#line 427
      C += (((D ^ A) ^ B) + correct_words[3]) + 3572445317U;
#line 427
      C = (C << 16) | (C >> 16);
#line 427
      C += D;
#line 427
      break;
    }
#line 428
    while (1) {
#line 428
      B += (((C ^ D) ^ A) + correct_words[6]) + 76029189U;
#line 428
      B = (B << 23) | (B >> 9);
#line 428
      B += C;
#line 428
      break;
    }
#line 429
    while (1) {
#line 429
      A += (((B ^ C) ^ D) + correct_words[9]) + 3654602809U;
#line 429
      A = (A << 4) | (A >> 28);
#line 429
      A += B;
#line 429
      break;
    }
#line 430
    while (1) {
#line 430
      D += (((A ^ B) ^ C) + correct_words[12]) + 3873151461U;
#line 430
      D = (D << 11) | (D >> 21);
#line 430
      D += A;
#line 430
      break;
    }
#line 431
    while (1) {
#line 431
      C += (((D ^ A) ^ B) + correct_words[15]) + 530742520U;
#line 431
      C = (C << 16) | (C >> 16);
#line 431
      C += D;
#line 431
      break;
    }
#line 432
    while (1) {
#line 432
      B += (((C ^ D) ^ A) + correct_words[2]) + 3299628645U;
#line 432
      B = (B << 23) | (B >> 9);
#line 432
      B += C;
#line 432
      break;
    }
#line 435
    while (1) {
#line 435
      A += ((C ^ (B | ~ D)) + correct_words[0]) + 4096336452U;
#line 435
      A = (A << 6) | (A >> 26);
#line 435
      A += B;
#line 435
      break;
    }
#line 436
    while (1) {
#line 436
      D += ((B ^ (A | ~ C)) + correct_words[7]) + 1126891415U;
#line 436
      D = (D << 10) | (D >> 22);
#line 436
      D += A;
#line 436
      break;
    }
#line 437
    while (1) {
#line 437
      C += ((A ^ (D | ~ B)) + correct_words[14]) + 2878612391U;
#line 437
      C = (C << 15) | (C >> 17);
#line 437
      C += D;
#line 437
      break;
    }
#line 438
    while (1) {
#line 438
      B += ((D ^ (C | ~ A)) + correct_words[5]) + 4237533241U;
#line 438
      B = (B << 21) | (B >> 11);
#line 438
      B += C;
#line 438
      break;
    }
#line 439
    while (1) {
#line 439
      A += ((C ^ (B | ~ D)) + correct_words[12]) + 1700485571U;
#line 439
      A = (A << 6) | (A >> 26);
#line 439
      A += B;
#line 439
      break;
    }
#line 440
    while (1) {
#line 440
      D += ((B ^ (A | ~ C)) + correct_words[3]) + 2399980690U;
#line 440
      D = (D << 10) | (D >> 22);
#line 440
      D += A;
#line 440
      break;
    }
#line 441
    while (1) {
#line 441
      C += ((A ^ (D | ~ B)) + correct_words[10]) + 4293915773U;
#line 441
      C = (C << 15) | (C >> 17);
#line 441
      C += D;
#line 441
      break;
    }
#line 442
    while (1) {
#line 442
      B += ((D ^ (C | ~ A)) + correct_words[1]) + 2240044497U;
#line 442
      B = (B << 21) | (B >> 11);
#line 442
      B += C;
#line 442
      break;
    }
#line 443
    while (1) {
#line 443
      A += ((C ^ (B | ~ D)) + correct_words[8]) + 1873313359U;
#line 443
      A = (A << 6) | (A >> 26);
#line 443
      A += B;
#line 443
      break;
    }
#line 444
    while (1) {
#line 444
      D += ((B ^ (A | ~ C)) + correct_words[15]) + 4264355552U;
#line 444
      D = (D << 10) | (D >> 22);
#line 444
      D += A;
#line 444
      break;
    }
#line 445
    while (1) {
#line 445
      C += ((A ^ (D | ~ B)) + correct_words[6]) + 2734768916U;
#line 445
      C = (C << 15) | (C >> 17);
#line 445
      C += D;
#line 445
      break;
    }
#line 446
    while (1) {
#line 446
      B += ((D ^ (C | ~ A)) + correct_words[13]) + 1309151649U;
#line 446
      B = (B << 21) | (B >> 11);
#line 446
      B += C;
#line 446
      break;
    }
#line 447
    while (1) {
#line 447
      A += ((C ^ (B | ~ D)) + correct_words[4]) + 4149444226U;
#line 447
      A = (A << 6) | (A >> 26);
#line 447
      A += B;
#line 447
      break;
    }
#line 448
    while (1) {
#line 448
      D += ((B ^ (A | ~ C)) + correct_words[11]) + 3174756917U;
#line 448
      D = (D << 10) | (D >> 22);
#line 448
      D += A;
#line 448
      break;
    }
#line 449
    while (1) {
#line 449
      C += ((A ^ (D | ~ B)) + correct_words[2]) + 718787259U;
#line 449
      C = (C << 15) | (C >> 17);
#line 449
      C += D;
#line 449
      break;
    }
#line 450
    while (1) {
#line 450
      B += ((D ^ (C | ~ A)) + correct_words[9]) + 3951481745U;
#line 450
      B = (B << 21) | (B >> 11);
#line 450
      B += C;
#line 450
      break;
    }
#line 453
    A += A_save;
#line 454
    B += B_save;
#line 455
    C += C_save;
#line 456
    D += D_save;
  }
#line 460
  ctx->A = A;
#line 461
  ctx->B = B;
#line 462
  ctx->C = C;
#line 463
  ctx->D = D;
#line 464
  return;
}
}
#line 1 "sha1.o"
#pragma merger(0,"/tmp/cil-V2GVRCyz.i","-g,-O2")
#line 50 "sha1.h"
void sha1_init_ctx(struct sha1_ctx *ctx ) ;
#line 56
void sha1_process_block(void const   *buffer , size_t len , struct sha1_ctx *ctx ) ;
#line 63
void sha1_process_bytes(void const   *buffer , size_t len , struct sha1_ctx *ctx ) ;
#line 70
void *sha1_finish_ctx(struct sha1_ctx *ctx , void *resbuf ) ;
#line 76
void *sha1_read_ctx(struct sha1_ctx  const  *ctx , void *resbuf ) ;
#line 82
int sha1_stream(FILE *stream , void *resblock ) ;
#line 88
void *sha1_buffer(char const   *buffer , size_t len , void *resblock ) ;
#line 53 "sha1.c"
static unsigned char const   fillbuf___0[64]  = {      (unsigned char const   )128,      (unsigned char const   )0};
#line 59 "sha1.c"
void sha1_init_ctx(struct sha1_ctx *ctx ) 
{ uint32_t tmp ;

  {
#line 62
  ctx->A = (uint32_t )1732584193;
#line 63
  ctx->B = 4023233417U;
#line 64
  ctx->C = 2562383102U;
#line 65
  ctx->D = (uint32_t )271733878;
#line 66
  ctx->E = 3285377520U;
#line 68
  tmp = (uint32_t )0;
#line 68
  ctx->total[1] = tmp;
#line 68
  ctx->total[0] = tmp;
#line 69
  ctx->buflen = (uint32_t )0;
#line 70
  return;
}
}
#line 83 "sha1.c"
void *sha1_read_ctx(struct sha1_ctx  const  *ctx , void *resbuf ) 
{ char *r ;

  {
#line 86
  r = (char *)resbuf;
#line 87
  set_uint32(r + 0UL, (uint32_t )((((ctx->A << 24) | ((ctx->A & 65280U) << 8)) | ((ctx->A >> 8) & 65280U)) | (ctx->A >> 24)));
#line 88
  set_uint32(r + sizeof(ctx->B), (uint32_t )((((ctx->B << 24) | ((ctx->B & 65280U) << 8)) | ((ctx->B >> 8) & 65280U)) | (ctx->B >> 24)));
#line 89
  set_uint32(r + 2UL * sizeof(ctx->C), (uint32_t )((((ctx->C << 24) | ((ctx->C & 65280U) << 8)) | ((ctx->C >> 8) & 65280U)) | (ctx->C >> 24)));
#line 90
  set_uint32(r + 3UL * sizeof(ctx->D), (uint32_t )((((ctx->D << 24) | ((ctx->D & 65280U) << 8)) | ((ctx->D >> 8) & 65280U)) | (ctx->D >> 24)));
#line 91
  set_uint32(r + 4UL * sizeof(ctx->E), (uint32_t )((((ctx->E << 24) | ((ctx->E & 65280U) << 8)) | ((ctx->E >> 8) & 65280U)) | (ctx->E >> 24)));
#line 93
  return (resbuf);
}
}
#line 98 "sha1.c"
void *sha1_finish_ctx(struct sha1_ctx *ctx , void *resbuf ) 
{ uint32_t bytes ;
  size_t size ;
  int tmp ;
  void *tmp___0 ;

  {
#line 102
  bytes = ctx->buflen;
#line 103
  if (bytes < 56U) {
#line 103
    tmp = 16;
  } else {
#line 103
    tmp = 32;
  }
#line 103
  size = (size_t )tmp;
#line 106
  ctx->total[0] += bytes;
#line 107
  if (ctx->total[0] < bytes) {
#line 108
    (ctx->total[1]) ++;
  }
#line 111
  ctx->buffer[size - 2UL] = (((((ctx->total[1] << 3) | (ctx->total[0] >> 29)) << 24) | ((((ctx->total[1] << 3) | (ctx->total[0] >> 29)) & 65280U) << 8)) | ((((ctx->total[1] << 3) | (ctx->total[0] >> 29)) >> 8) & 65280U)) | (((ctx->total[1] << 3) | (ctx->total[0] >> 29)) >> 24);
#line 112
  ctx->buffer[size - 1UL] = ((((ctx->total[0] << 3) << 24) | (((ctx->total[0] << 3) & 65280U) << 8)) | (((ctx->total[0] << 3) >> 8) & 65280U)) | ((ctx->total[0] << 3) >> 24);
#line 114
  memcpy((void * __restrict  )((char *)(ctx->buffer) + bytes), (void const   * __restrict  )(fillbuf___0),
         (size - 2UL) * 4UL - (size_t )bytes);
#line 117
  sha1_process_block((void const   *)(ctx->buffer), size * 4UL, ctx);
#line 119
  tmp___0 = sha1_read_ctx((struct sha1_ctx  const  *)ctx, resbuf);
#line 119
  return (tmp___0);
}
}
#line 125 "sha1.c"
int sha1_stream(FILE *stream , void *resblock ) 
{ struct sha1_ctx ctx ;
  size_t sum ;
  char *buffer ;
  void *tmp ;
  size_t n ;
  size_t __attribute__((__artificial__))  tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t __attribute__((__artificial__))  tmp___3 ;

  {
#line 131
  tmp = malloc((size_t )32840);
#line 131
  buffer = (char *)tmp;
#line 132
  if (! buffer) {
#line 133
    return (1);
  }
#line 136
  sha1_init_ctx(& ctx);
#line 139
  while (1) {
#line 145
    sum = (size_t )0;
#line 148
    while (1) {
#line 150
      tmp___3 = (size_t __attribute__((__artificial__))  )fread_unlocked((void * __restrict  )(buffer + sum),
                                                                         (size_t )1,
                                                                         32768UL - sum,
                                                                         (FILE * __restrict  )stream);
#line 150
      tmp___0 = tmp___3;
#line 150
      n = (size_t )tmp___0;
#line 152
      sum += n;
#line 154
      if (sum == 32768UL) {
#line 155
        break;
      }
#line 157
      if (n == 0UL) {
#line 162
        tmp___1 = ferror_unlocked(stream);
#line 162
        if (tmp___1) {
#line 164
          free((void *)buffer);
#line 165
          return (1);
        }
#line 167
        goto process_partial_block;
      }
#line 173
      tmp___2 = feof_unlocked(stream);
#line 173
      if (tmp___2) {
#line 174
        goto process_partial_block;
      }
    }
#line 180
    sha1_process_block((void const   *)buffer, (size_t )32768, & ctx);
  }
  process_partial_block: ;
#line 186
  if (sum > 0UL) {
#line 187
    sha1_process_bytes((void const   *)buffer, sum, & ctx);
  }
#line 190
  sha1_finish_ctx(& ctx, resblock);
#line 191
  free((void *)buffer);
#line 192
  return (0);
}
}
#line 199 "sha1.c"
void *sha1_buffer(char const   *buffer , size_t len , void *resblock ) 
{ struct sha1_ctx ctx ;
  void *tmp ;

  {
#line 205
  sha1_init_ctx(& ctx);
#line 208
  sha1_process_bytes((void const   *)buffer, len, & ctx);
#line 211
  tmp = sha1_finish_ctx(& ctx, resblock);
#line 211
  return (tmp);
}
}
#line 214 "sha1.c"
void sha1_process_bytes(void const   *buffer , size_t len , struct sha1_ctx *ctx ) 
{ size_t left_over ;
  size_t add ;
  size_t tmp ;
  size_t left_over___0 ;

  {
#line 219
  if (ctx->buflen != 0U) {
#line 221
    left_over = (size_t )ctx->buflen;
#line 222
    if (128UL - left_over > len) {
#line 222
      tmp = len;
    } else {
#line 222
      tmp = 128UL - left_over;
    }
#line 222
    add = tmp;
#line 224
    memcpy((void * __restrict  )((char *)(ctx->buffer) + left_over), (void const   * __restrict  )buffer,
           add);
#line 225
    ctx->buflen = (uint32_t )((size_t )ctx->buflen + add);
#line 227
    if (ctx->buflen > 64U) {
#line 229
      sha1_process_block((void const   *)(ctx->buffer), (size_t )(ctx->buflen & 4294967232U),
                         ctx);
#line 231
      ctx->buflen &= 63U;
#line 233
      memcpy((void * __restrict  )(ctx->buffer), (void const   * __restrict  )((char *)(ctx->buffer) + ((left_over + add) & 0xffffffffffffffc0UL)),
             (size_t )ctx->buflen);
    }
#line 238
    buffer = (void const   *)((char const   *)buffer + add);
#line 239
    len -= add;
  }
#line 243
  if (len >= 64UL) {
#line 258
    sha1_process_block(buffer, len & 0xffffffffffffffc0UL, ctx);
#line 259
    buffer = (void const   *)((char const   *)buffer + (len & 0xffffffffffffffc0UL));
#line 260
    len &= 63UL;
  }
#line 265
  if (len > 0UL) {
#line 267
    left_over___0 = (size_t )ctx->buflen;
#line 269
    memcpy((void * __restrict  )((char *)(ctx->buffer) + left_over___0), (void const   * __restrict  )buffer,
           len);
#line 270
    left_over___0 += len;
#line 271
    if (left_over___0 >= 64UL) {
#line 273
      sha1_process_block((void const   *)(ctx->buffer), (size_t )64, ctx);
#line 274
      left_over___0 -= 64UL;
#line 275
      memcpy((void * __restrict  )(ctx->buffer), (void const   * __restrict  )(& ctx->buffer[16]),
             left_over___0);
    }
#line 277
    ctx->buflen = (uint32_t )left_over___0;
  }
#line 279
  return;
}
}
#line 299 "sha1.c"
void sha1_process_block(void const   *buffer , size_t len , struct sha1_ctx *ctx ) 
{ uint32_t const   *words ;
  size_t nwords ;
  uint32_t const   *endp ;
  uint32_t x[16] ;
  uint32_t a ;
  uint32_t b ;
  uint32_t c ;
  uint32_t d ;
  uint32_t e ;
  uint32_t tm ;
  int t ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;

  {
#line 302
  words = (uint32_t const   *)buffer;
#line 303
  nwords = len / sizeof(uint32_t );
#line 304
  endp = words + nwords;
#line 306
  a = ctx->A;
#line 307
  b = ctx->B;
#line 308
  c = ctx->C;
#line 309
  d = ctx->D;
#line 310
  e = ctx->E;
#line 315
  ctx->total[0] = (uint32_t )((size_t )ctx->total[0] + len);
#line 316
  if ((size_t )ctx->total[0] < len) {
#line 317
    (ctx->total[1]) ++;
  }
#line 332
  while ((unsigned long )words < (unsigned long )endp) {
#line 336
    t = 0;
#line 336
    while (t < 16) {
#line 338
      x[t] = (uint32_t )((((*words << 24) | ((*words & 65280U) << 8)) | ((*words >> 8) & 65280U)) | (*words >> 24));
#line 339
      words ++;
#line 336
      t ++;
    }
#line 342
    while (1) {
#line 342
      e += ((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + 1518500249U) + x[0];
#line 342
      b = (b << 30) | (b >> 2);
#line 342
      break;
    }
#line 343
    while (1) {
#line 343
      d += ((((e << 5) | (e >> 27)) + (c ^ (a & (b ^ c)))) + 1518500249U) + x[1];
#line 343
      a = (a << 30) | (a >> 2);
#line 343
      break;
    }
#line 344
    while (1) {
#line 344
      c += ((((d << 5) | (d >> 27)) + (b ^ (e & (a ^ b)))) + 1518500249U) + x[2];
#line 344
      e = (e << 30) | (e >> 2);
#line 344
      break;
    }
#line 345
    while (1) {
#line 345
      b += ((((c << 5) | (c >> 27)) + (a ^ (d & (e ^ a)))) + 1518500249U) + x[3];
#line 345
      d = (d << 30) | (d >> 2);
#line 345
      break;
    }
#line 346
    while (1) {
#line 346
      a += ((((b << 5) | (b >> 27)) + (e ^ (c & (d ^ e)))) + 1518500249U) + x[4];
#line 346
      c = (c << 30) | (c >> 2);
#line 346
      break;
    }
#line 347
    while (1) {
#line 347
      e += ((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + 1518500249U) + x[5];
#line 347
      b = (b << 30) | (b >> 2);
#line 347
      break;
    }
#line 348
    while (1) {
#line 348
      d += ((((e << 5) | (e >> 27)) + (c ^ (a & (b ^ c)))) + 1518500249U) + x[6];
#line 348
      a = (a << 30) | (a >> 2);
#line 348
      break;
    }
#line 349
    while (1) {
#line 349
      c += ((((d << 5) | (d >> 27)) + (b ^ (e & (a ^ b)))) + 1518500249U) + x[7];
#line 349
      e = (e << 30) | (e >> 2);
#line 349
      break;
    }
#line 350
    while (1) {
#line 350
      b += ((((c << 5) | (c >> 27)) + (a ^ (d & (e ^ a)))) + 1518500249U) + x[8];
#line 350
      d = (d << 30) | (d >> 2);
#line 350
      break;
    }
#line 351
    while (1) {
#line 351
      a += ((((b << 5) | (b >> 27)) + (e ^ (c & (d ^ e)))) + 1518500249U) + x[9];
#line 351
      c = (c << 30) | (c >> 2);
#line 351
      break;
    }
#line 352
    while (1) {
#line 352
      e += ((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + 1518500249U) + x[10];
#line 352
      b = (b << 30) | (b >> 2);
#line 352
      break;
    }
#line 353
    while (1) {
#line 353
      d += ((((e << 5) | (e >> 27)) + (c ^ (a & (b ^ c)))) + 1518500249U) + x[11];
#line 353
      a = (a << 30) | (a >> 2);
#line 353
      break;
    }
#line 354
    while (1) {
#line 354
      c += ((((d << 5) | (d >> 27)) + (b ^ (e & (a ^ b)))) + 1518500249U) + x[12];
#line 354
      e = (e << 30) | (e >> 2);
#line 354
      break;
    }
#line 355
    while (1) {
#line 355
      b += ((((c << 5) | (c >> 27)) + (a ^ (d & (e ^ a)))) + 1518500249U) + x[13];
#line 355
      d = (d << 30) | (d >> 2);
#line 355
      break;
    }
#line 356
    while (1) {
#line 356
      a += ((((b << 5) | (b >> 27)) + (e ^ (c & (d ^ e)))) + 1518500249U) + x[14];
#line 356
      c = (c << 30) | (c >> 2);
#line 356
      break;
    }
#line 357
    while (1) {
#line 357
      e += ((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + 1518500249U) + x[15];
#line 357
      b = (b << 30) | (b >> 2);
#line 357
      break;
    }
#line 358
    while (1) {
#line 358
      tm = ((x[0] ^ x[2]) ^ x[8]) ^ x[13];
#line 358
      x[0] = (tm << 1) | (tm >> 31);
#line 358
      d += ((((e << 5) | (e >> 27)) + (c ^ (a & (b ^ c)))) + 1518500249U) + x[0];
#line 358
      a = (a << 30) | (a >> 2);
#line 358
      break;
    }
#line 359
    while (1) {
#line 359
      tm = ((x[1] ^ x[3]) ^ x[9]) ^ x[14];
#line 359
      x[1] = (tm << 1) | (tm >> 31);
#line 359
      c += ((((d << 5) | (d >> 27)) + (b ^ (e & (a ^ b)))) + 1518500249U) + x[1];
#line 359
      e = (e << 30) | (e >> 2);
#line 359
      break;
    }
#line 360
    while (1) {
#line 360
      tm = ((x[2] ^ x[4]) ^ x[10]) ^ x[15];
#line 360
      x[2] = (tm << 1) | (tm >> 31);
#line 360
      b += ((((c << 5) | (c >> 27)) + (a ^ (d & (e ^ a)))) + 1518500249U) + x[2];
#line 360
      d = (d << 30) | (d >> 2);
#line 360
      break;
    }
#line 361
    while (1) {
#line 361
      tm = ((x[3] ^ x[5]) ^ x[11]) ^ x[0];
#line 361
      x[3] = (tm << 1) | (tm >> 31);
#line 361
      a += ((((b << 5) | (b >> 27)) + (e ^ (c & (d ^ e)))) + 1518500249U) + x[3];
#line 361
      c = (c << 30) | (c >> 2);
#line 361
      break;
    }
#line 362
    while (1) {
#line 362
      tm = ((x[4] ^ x[6]) ^ x[12]) ^ x[1];
#line 362
      x[4] = (tm << 1) | (tm >> 31);
#line 362
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 1859775393U) + x[4];
#line 362
      b = (b << 30) | (b >> 2);
#line 362
      break;
    }
#line 363
    while (1) {
#line 363
      tm = ((x[5] ^ x[7]) ^ x[13]) ^ x[2];
#line 363
      x[5] = (tm << 1) | (tm >> 31);
#line 363
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 1859775393U) + x[5];
#line 363
      a = (a << 30) | (a >> 2);
#line 363
      break;
    }
#line 364
    while (1) {
#line 364
      tm = ((x[6] ^ x[8]) ^ x[14]) ^ x[3];
#line 364
      x[6] = (tm << 1) | (tm >> 31);
#line 364
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 1859775393U) + x[6];
#line 364
      e = (e << 30) | (e >> 2);
#line 364
      break;
    }
#line 365
    while (1) {
#line 365
      tm = ((x[7] ^ x[9]) ^ x[15]) ^ x[4];
#line 365
      x[7] = (tm << 1) | (tm >> 31);
#line 365
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 1859775393U) + x[7];
#line 365
      d = (d << 30) | (d >> 2);
#line 365
      break;
    }
#line 366
    while (1) {
#line 366
      tm = ((x[8] ^ x[10]) ^ x[0]) ^ x[5];
#line 366
      x[8] = (tm << 1) | (tm >> 31);
#line 366
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 1859775393U) + x[8];
#line 366
      c = (c << 30) | (c >> 2);
#line 366
      break;
    }
#line 367
    while (1) {
#line 367
      tm = ((x[9] ^ x[11]) ^ x[1]) ^ x[6];
#line 367
      x[9] = (tm << 1) | (tm >> 31);
#line 367
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 1859775393U) + x[9];
#line 367
      b = (b << 30) | (b >> 2);
#line 367
      break;
    }
#line 368
    while (1) {
#line 368
      tm = ((x[10] ^ x[12]) ^ x[2]) ^ x[7];
#line 368
      x[10] = (tm << 1) | (tm >> 31);
#line 368
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 1859775393U) + x[10];
#line 368
      a = (a << 30) | (a >> 2);
#line 368
      break;
    }
#line 369
    while (1) {
#line 369
      tm = ((x[11] ^ x[13]) ^ x[3]) ^ x[8];
#line 369
      x[11] = (tm << 1) | (tm >> 31);
#line 369
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 1859775393U) + x[11];
#line 369
      e = (e << 30) | (e >> 2);
#line 369
      break;
    }
#line 370
    while (1) {
#line 370
      tm = ((x[12] ^ x[14]) ^ x[4]) ^ x[9];
#line 370
      x[12] = (tm << 1) | (tm >> 31);
#line 370
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 1859775393U) + x[12];
#line 370
      d = (d << 30) | (d >> 2);
#line 370
      break;
    }
#line 371
    while (1) {
#line 371
      tm = ((x[13] ^ x[15]) ^ x[5]) ^ x[10];
#line 371
      x[13] = (tm << 1) | (tm >> 31);
#line 371
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 1859775393U) + x[13];
#line 371
      c = (c << 30) | (c >> 2);
#line 371
      break;
    }
#line 372
    while (1) {
#line 372
      tm = ((x[14] ^ x[0]) ^ x[6]) ^ x[11];
#line 372
      x[14] = (tm << 1) | (tm >> 31);
#line 372
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 1859775393U) + x[14];
#line 372
      b = (b << 30) | (b >> 2);
#line 372
      break;
    }
#line 373
    while (1) {
#line 373
      tm = ((x[15] ^ x[1]) ^ x[7]) ^ x[12];
#line 373
      x[15] = (tm << 1) | (tm >> 31);
#line 373
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 1859775393U) + x[15];
#line 373
      a = (a << 30) | (a >> 2);
#line 373
      break;
    }
#line 374
    while (1) {
#line 374
      tm = ((x[0] ^ x[2]) ^ x[8]) ^ x[13];
#line 374
      x[0] = (tm << 1) | (tm >> 31);
#line 374
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 1859775393U) + x[0];
#line 374
      e = (e << 30) | (e >> 2);
#line 374
      break;
    }
#line 375
    while (1) {
#line 375
      tm = ((x[1] ^ x[3]) ^ x[9]) ^ x[14];
#line 375
      x[1] = (tm << 1) | (tm >> 31);
#line 375
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 1859775393U) + x[1];
#line 375
      d = (d << 30) | (d >> 2);
#line 375
      break;
    }
#line 376
    while (1) {
#line 376
      tm = ((x[2] ^ x[4]) ^ x[10]) ^ x[15];
#line 376
      x[2] = (tm << 1) | (tm >> 31);
#line 376
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 1859775393U) + x[2];
#line 376
      c = (c << 30) | (c >> 2);
#line 376
      break;
    }
#line 377
    while (1) {
#line 377
      tm = ((x[3] ^ x[5]) ^ x[11]) ^ x[0];
#line 377
      x[3] = (tm << 1) | (tm >> 31);
#line 377
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 1859775393U) + x[3];
#line 377
      b = (b << 30) | (b >> 2);
#line 377
      break;
    }
#line 378
    while (1) {
#line 378
      tm = ((x[4] ^ x[6]) ^ x[12]) ^ x[1];
#line 378
      x[4] = (tm << 1) | (tm >> 31);
#line 378
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 1859775393U) + x[4];
#line 378
      a = (a << 30) | (a >> 2);
#line 378
      break;
    }
#line 379
    while (1) {
#line 379
      tm = ((x[5] ^ x[7]) ^ x[13]) ^ x[2];
#line 379
      x[5] = (tm << 1) | (tm >> 31);
#line 379
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 1859775393U) + x[5];
#line 379
      e = (e << 30) | (e >> 2);
#line 379
      break;
    }
#line 380
    while (1) {
#line 380
      tm = ((x[6] ^ x[8]) ^ x[14]) ^ x[3];
#line 380
      x[6] = (tm << 1) | (tm >> 31);
#line 380
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 1859775393U) + x[6];
#line 380
      d = (d << 30) | (d >> 2);
#line 380
      break;
    }
#line 381
    while (1) {
#line 381
      tm = ((x[7] ^ x[9]) ^ x[15]) ^ x[4];
#line 381
      x[7] = (tm << 1) | (tm >> 31);
#line 381
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 1859775393U) + x[7];
#line 381
      c = (c << 30) | (c >> 2);
#line 381
      break;
    }
#line 382
    while (1) {
#line 382
      tm = ((x[8] ^ x[10]) ^ x[0]) ^ x[5];
#line 382
      x[8] = (tm << 1) | (tm >> 31);
#line 382
      e += ((((a << 5) | (a >> 27)) + ((b & c) | (d & (b | c)))) + 2400959708U) + x[8];
#line 382
      b = (b << 30) | (b >> 2);
#line 382
      break;
    }
#line 383
    while (1) {
#line 383
      tm = ((x[9] ^ x[11]) ^ x[1]) ^ x[6];
#line 383
      x[9] = (tm << 1) | (tm >> 31);
#line 383
      d += ((((e << 5) | (e >> 27)) + ((a & b) | (c & (a | b)))) + 2400959708U) + x[9];
#line 383
      a = (a << 30) | (a >> 2);
#line 383
      break;
    }
#line 384
    while (1) {
#line 384
      tm = ((x[10] ^ x[12]) ^ x[2]) ^ x[7];
#line 384
      x[10] = (tm << 1) | (tm >> 31);
#line 384
      c += ((((d << 5) | (d >> 27)) + ((e & a) | (b & (e | a)))) + 2400959708U) + x[10];
#line 384
      e = (e << 30) | (e >> 2);
#line 384
      break;
    }
#line 385
    while (1) {
#line 385
      tm = ((x[11] ^ x[13]) ^ x[3]) ^ x[8];
#line 385
      x[11] = (tm << 1) | (tm >> 31);
#line 385
      b += ((((c << 5) | (c >> 27)) + ((d & e) | (a & (d | e)))) + 2400959708U) + x[11];
#line 385
      d = (d << 30) | (d >> 2);
#line 385
      break;
    }
#line 386
    while (1) {
#line 386
      tm = ((x[12] ^ x[14]) ^ x[4]) ^ x[9];
#line 386
      x[12] = (tm << 1) | (tm >> 31);
#line 386
      a += ((((b << 5) | (b >> 27)) + ((c & d) | (e & (c | d)))) + 2400959708U) + x[12];
#line 386
      c = (c << 30) | (c >> 2);
#line 386
      break;
    }
#line 387
    while (1) {
#line 387
      tm = ((x[13] ^ x[15]) ^ x[5]) ^ x[10];
#line 387
      x[13] = (tm << 1) | (tm >> 31);
#line 387
      e += ((((a << 5) | (a >> 27)) + ((b & c) | (d & (b | c)))) + 2400959708U) + x[13];
#line 387
      b = (b << 30) | (b >> 2);
#line 387
      break;
    }
#line 388
    while (1) {
#line 388
      tm = ((x[14] ^ x[0]) ^ x[6]) ^ x[11];
#line 388
      x[14] = (tm << 1) | (tm >> 31);
#line 388
      d += ((((e << 5) | (e >> 27)) + ((a & b) | (c & (a | b)))) + 2400959708U) + x[14];
#line 388
      a = (a << 30) | (a >> 2);
#line 388
      break;
    }
#line 389
    while (1) {
#line 389
      tm = ((x[15] ^ x[1]) ^ x[7]) ^ x[12];
#line 389
      x[15] = (tm << 1) | (tm >> 31);
#line 389
      c += ((((d << 5) | (d >> 27)) + ((e & a) | (b & (e | a)))) + 2400959708U) + x[15];
#line 389
      e = (e << 30) | (e >> 2);
#line 389
      break;
    }
#line 390
    while (1) {
#line 390
      tm = ((x[0] ^ x[2]) ^ x[8]) ^ x[13];
#line 390
      x[0] = (tm << 1) | (tm >> 31);
#line 390
      b += ((((c << 5) | (c >> 27)) + ((d & e) | (a & (d | e)))) + 2400959708U) + x[0];
#line 390
      d = (d << 30) | (d >> 2);
#line 390
      break;
    }
#line 391
    while (1) {
#line 391
      tm = ((x[1] ^ x[3]) ^ x[9]) ^ x[14];
#line 391
      x[1] = (tm << 1) | (tm >> 31);
#line 391
      a += ((((b << 5) | (b >> 27)) + ((c & d) | (e & (c | d)))) + 2400959708U) + x[1];
#line 391
      c = (c << 30) | (c >> 2);
#line 391
      break;
    }
#line 392
    while (1) {
#line 392
      tm = ((x[2] ^ x[4]) ^ x[10]) ^ x[15];
#line 392
      x[2] = (tm << 1) | (tm >> 31);
#line 392
      e += ((((a << 5) | (a >> 27)) + ((b & c) | (d & (b | c)))) + 2400959708U) + x[2];
#line 392
      b = (b << 30) | (b >> 2);
#line 392
      break;
    }
#line 393
    while (1) {
#line 393
      tm = ((x[3] ^ x[5]) ^ x[11]) ^ x[0];
#line 393
      x[3] = (tm << 1) | (tm >> 31);
#line 393
      d += ((((e << 5) | (e >> 27)) + ((a & b) | (c & (a | b)))) + 2400959708U) + x[3];
#line 393
      a = (a << 30) | (a >> 2);
#line 393
      break;
    }
#line 394
    while (1) {
#line 394
      tm = ((x[4] ^ x[6]) ^ x[12]) ^ x[1];
#line 394
      x[4] = (tm << 1) | (tm >> 31);
#line 394
      c += ((((d << 5) | (d >> 27)) + ((e & a) | (b & (e | a)))) + 2400959708U) + x[4];
#line 394
      e = (e << 30) | (e >> 2);
#line 394
      break;
    }
#line 395
    while (1) {
#line 395
      tm = ((x[5] ^ x[7]) ^ x[13]) ^ x[2];
#line 395
      x[5] = (tm << 1) | (tm >> 31);
#line 395
      b += ((((c << 5) | (c >> 27)) + ((d & e) | (a & (d | e)))) + 2400959708U) + x[5];
#line 395
      d = (d << 30) | (d >> 2);
#line 395
      break;
    }
#line 396
    while (1) {
#line 396
      tm = ((x[6] ^ x[8]) ^ x[14]) ^ x[3];
#line 396
      x[6] = (tm << 1) | (tm >> 31);
#line 396
      a += ((((b << 5) | (b >> 27)) + ((c & d) | (e & (c | d)))) + 2400959708U) + x[6];
#line 396
      c = (c << 30) | (c >> 2);
#line 396
      break;
    }
#line 397
    while (1) {
#line 397
      tm = ((x[7] ^ x[9]) ^ x[15]) ^ x[4];
#line 397
      x[7] = (tm << 1) | (tm >> 31);
#line 397
      e += ((((a << 5) | (a >> 27)) + ((b & c) | (d & (b | c)))) + 2400959708U) + x[7];
#line 397
      b = (b << 30) | (b >> 2);
#line 397
      break;
    }
#line 398
    while (1) {
#line 398
      tm = ((x[8] ^ x[10]) ^ x[0]) ^ x[5];
#line 398
      x[8] = (tm << 1) | (tm >> 31);
#line 398
      d += ((((e << 5) | (e >> 27)) + ((a & b) | (c & (a | b)))) + 2400959708U) + x[8];
#line 398
      a = (a << 30) | (a >> 2);
#line 398
      break;
    }
#line 399
    while (1) {
#line 399
      tm = ((x[9] ^ x[11]) ^ x[1]) ^ x[6];
#line 399
      x[9] = (tm << 1) | (tm >> 31);
#line 399
      c += ((((d << 5) | (d >> 27)) + ((e & a) | (b & (e | a)))) + 2400959708U) + x[9];
#line 399
      e = (e << 30) | (e >> 2);
#line 399
      break;
    }
#line 400
    while (1) {
#line 400
      tm = ((x[10] ^ x[12]) ^ x[2]) ^ x[7];
#line 400
      x[10] = (tm << 1) | (tm >> 31);
#line 400
      b += ((((c << 5) | (c >> 27)) + ((d & e) | (a & (d | e)))) + 2400959708U) + x[10];
#line 400
      d = (d << 30) | (d >> 2);
#line 400
      break;
    }
#line 401
    while (1) {
#line 401
      tm = ((x[11] ^ x[13]) ^ x[3]) ^ x[8];
#line 401
      x[11] = (tm << 1) | (tm >> 31);
#line 401
      a += ((((b << 5) | (b >> 27)) + ((c & d) | (e & (c | d)))) + 2400959708U) + x[11];
#line 401
      c = (c << 30) | (c >> 2);
#line 401
      break;
    }
#line 402
    while (1) {
#line 402
      tm = ((x[12] ^ x[14]) ^ x[4]) ^ x[9];
#line 402
      x[12] = (tm << 1) | (tm >> 31);
#line 402
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 3395469782U) + x[12];
#line 402
      b = (b << 30) | (b >> 2);
#line 402
      break;
    }
#line 403
    while (1) {
#line 403
      tm = ((x[13] ^ x[15]) ^ x[5]) ^ x[10];
#line 403
      x[13] = (tm << 1) | (tm >> 31);
#line 403
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 3395469782U) + x[13];
#line 403
      a = (a << 30) | (a >> 2);
#line 403
      break;
    }
#line 404
    while (1) {
#line 404
      tm = ((x[14] ^ x[0]) ^ x[6]) ^ x[11];
#line 404
      x[14] = (tm << 1) | (tm >> 31);
#line 404
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 3395469782U) + x[14];
#line 404
      e = (e << 30) | (e >> 2);
#line 404
      break;
    }
#line 405
    while (1) {
#line 405
      tm = ((x[15] ^ x[1]) ^ x[7]) ^ x[12];
#line 405
      x[15] = (tm << 1) | (tm >> 31);
#line 405
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 3395469782U) + x[15];
#line 405
      d = (d << 30) | (d >> 2);
#line 405
      break;
    }
#line 406
    while (1) {
#line 406
      tm = ((x[0] ^ x[2]) ^ x[8]) ^ x[13];
#line 406
      x[0] = (tm << 1) | (tm >> 31);
#line 406
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 3395469782U) + x[0];
#line 406
      c = (c << 30) | (c >> 2);
#line 406
      break;
    }
#line 407
    while (1) {
#line 407
      tm = ((x[1] ^ x[3]) ^ x[9]) ^ x[14];
#line 407
      x[1] = (tm << 1) | (tm >> 31);
#line 407
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 3395469782U) + x[1];
#line 407
      b = (b << 30) | (b >> 2);
#line 407
      break;
    }
#line 408
    while (1) {
#line 408
      tm = ((x[2] ^ x[4]) ^ x[10]) ^ x[15];
#line 408
      x[2] = (tm << 1) | (tm >> 31);
#line 408
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 3395469782U) + x[2];
#line 408
      a = (a << 30) | (a >> 2);
#line 408
      break;
    }
#line 409
    while (1) {
#line 409
      tm = ((x[3] ^ x[5]) ^ x[11]) ^ x[0];
#line 409
      x[3] = (tm << 1) | (tm >> 31);
#line 409
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 3395469782U) + x[3];
#line 409
      e = (e << 30) | (e >> 2);
#line 409
      break;
    }
#line 410
    while (1) {
#line 410
      tm = ((x[4] ^ x[6]) ^ x[12]) ^ x[1];
#line 410
      x[4] = (tm << 1) | (tm >> 31);
#line 410
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 3395469782U) + x[4];
#line 410
      d = (d << 30) | (d >> 2);
#line 410
      break;
    }
#line 411
    while (1) {
#line 411
      tm = ((x[5] ^ x[7]) ^ x[13]) ^ x[2];
#line 411
      x[5] = (tm << 1) | (tm >> 31);
#line 411
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 3395469782U) + x[5];
#line 411
      c = (c << 30) | (c >> 2);
#line 411
      break;
    }
#line 412
    while (1) {
#line 412
      tm = ((x[6] ^ x[8]) ^ x[14]) ^ x[3];
#line 412
      x[6] = (tm << 1) | (tm >> 31);
#line 412
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 3395469782U) + x[6];
#line 412
      b = (b << 30) | (b >> 2);
#line 412
      break;
    }
#line 413
    while (1) {
#line 413
      tm = ((x[7] ^ x[9]) ^ x[15]) ^ x[4];
#line 413
      x[7] = (tm << 1) | (tm >> 31);
#line 413
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 3395469782U) + x[7];
#line 413
      a = (a << 30) | (a >> 2);
#line 413
      break;
    }
#line 414
    while (1) {
#line 414
      tm = ((x[8] ^ x[10]) ^ x[0]) ^ x[5];
#line 414
      x[8] = (tm << 1) | (tm >> 31);
#line 414
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 3395469782U) + x[8];
#line 414
      e = (e << 30) | (e >> 2);
#line 414
      break;
    }
#line 415
    while (1) {
#line 415
      tm = ((x[9] ^ x[11]) ^ x[1]) ^ x[6];
#line 415
      x[9] = (tm << 1) | (tm >> 31);
#line 415
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 3395469782U) + x[9];
#line 415
      d = (d << 30) | (d >> 2);
#line 415
      break;
    }
#line 416
    while (1) {
#line 416
      tm = ((x[10] ^ x[12]) ^ x[2]) ^ x[7];
#line 416
      x[10] = (tm << 1) | (tm >> 31);
#line 416
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 3395469782U) + x[10];
#line 416
      c = (c << 30) | (c >> 2);
#line 416
      break;
    }
#line 417
    while (1) {
#line 417
      tm = ((x[11] ^ x[13]) ^ x[3]) ^ x[8];
#line 417
      x[11] = (tm << 1) | (tm >> 31);
#line 417
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 3395469782U) + x[11];
#line 417
      b = (b << 30) | (b >> 2);
#line 417
      break;
    }
#line 418
    while (1) {
#line 418
      tm = ((x[12] ^ x[14]) ^ x[4]) ^ x[9];
#line 418
      x[12] = (tm << 1) | (tm >> 31);
#line 418
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 3395469782U) + x[12];
#line 418
      a = (a << 30) | (a >> 2);
#line 418
      break;
    }
#line 419
    while (1) {
#line 419
      tm = ((x[13] ^ x[15]) ^ x[5]) ^ x[10];
#line 419
      x[13] = (tm << 1) | (tm >> 31);
#line 419
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 3395469782U) + x[13];
#line 419
      e = (e << 30) | (e >> 2);
#line 419
      break;
    }
#line 420
    while (1) {
#line 420
      tm = ((x[14] ^ x[0]) ^ x[6]) ^ x[11];
#line 420
      x[14] = (tm << 1) | (tm >> 31);
#line 420
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 3395469782U) + x[14];
#line 420
      d = (d << 30) | (d >> 2);
#line 420
      break;
    }
#line 421
    while (1) {
#line 421
      tm = ((x[15] ^ x[1]) ^ x[7]) ^ x[12];
#line 421
      x[15] = (tm << 1) | (tm >> 31);
#line 421
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 3395469782U) + x[15];
#line 421
      c = (c << 30) | (c >> 2);
#line 421
      break;
    }
#line 423
    tmp = ctx->A + a;
#line 423
    ctx->A = tmp;
#line 423
    a = tmp;
#line 424
    tmp___0 = ctx->B + b;
#line 424
    ctx->B = tmp___0;
#line 424
    b = tmp___0;
#line 425
    tmp___1 = ctx->C + c;
#line 425
    ctx->C = tmp___1;
#line 425
    c = tmp___1;
#line 426
    tmp___2 = ctx->D + d;
#line 426
    ctx->D = tmp___2;
#line 426
    d = tmp___2;
#line 427
    tmp___3 = ctx->E + e;
#line 427
    ctx->E = tmp___3;
#line 427
    e = tmp___3;
  }
#line 429
  return;
}
}
#line 1 "sha256.o"
#pragma merger(0,"/tmp/cil-N0C5u41g.i","-g,-O2")
#line 42 "sha256.h"
void sha256_init_ctx(struct sha256_ctx *ctx ) ;
#line 43
void sha224_init_ctx(struct sha256_ctx *ctx ) ;
#line 49
void sha256_process_block(void const   *buffer , size_t len , struct sha256_ctx *ctx ) ;
#line 56
void sha256_process_bytes(void const   *buffer , size_t len , struct sha256_ctx *ctx ) ;
#line 63
void *sha256_finish_ctx(struct sha256_ctx *ctx , void *resbuf ) ;
#line 64
void *sha224_finish_ctx(struct sha256_ctx *ctx , void *resbuf ) ;
#line 70
void *sha256_read_ctx(struct sha256_ctx  const  *ctx , void *resbuf ) ;
#line 71
void *sha224_read_ctx(struct sha256_ctx  const  *ctx , void *resbuf ) ;
#line 77
int sha256_stream(FILE *stream , void *resblock ) ;
#line 78
int sha224_stream(FILE *stream , void *resblock ) ;
#line 84
void *sha256_buffer(char const   *buffer , size_t len , void *resblock ) ;
#line 85
void *sha224_buffer(char const   *buffer , size_t len , void *resblock ) ;
#line 49 "sha256.c"
static unsigned char const   fillbuf___1[64]  = {      (unsigned char const   )128,      (unsigned char const   )0};
#line 57 "sha256.c"
void sha256_init_ctx(struct sha256_ctx *ctx ) 
{ uint32_t tmp ;

  {
#line 60
  ctx->state[0] = (uint32_t )1779033703UL;
#line 61
  ctx->state[1] = (uint32_t )3144134277UL;
#line 62
  ctx->state[2] = (uint32_t )1013904242UL;
#line 63
  ctx->state[3] = (uint32_t )2773480762UL;
#line 64
  ctx->state[4] = (uint32_t )1359893119UL;
#line 65
  ctx->state[5] = (uint32_t )2600822924UL;
#line 66
  ctx->state[6] = (uint32_t )528734635UL;
#line 67
  ctx->state[7] = (uint32_t )1541459225UL;
#line 69
  tmp = (uint32_t )0;
#line 69
  ctx->total[1] = tmp;
#line 69
  ctx->total[0] = tmp;
#line 70
  ctx->buflen = (size_t )0;
#line 71
  return;
}
}
#line 73 "sha256.c"
void sha224_init_ctx(struct sha256_ctx *ctx ) 
{ uint32_t tmp ;

  {
#line 76
  ctx->state[0] = (uint32_t )3238371032UL;
#line 77
  ctx->state[1] = (uint32_t )914150663UL;
#line 78
  ctx->state[2] = (uint32_t )812702999UL;
#line 79
  ctx->state[3] = (uint32_t )4144912697UL;
#line 80
  ctx->state[4] = (uint32_t )4290775857UL;
#line 81
  ctx->state[5] = (uint32_t )1750603025UL;
#line 82
  ctx->state[6] = (uint32_t )1694076839UL;
#line 83
  ctx->state[7] = (uint32_t )3204075428UL;
#line 85
  tmp = (uint32_t )0;
#line 85
  ctx->total[1] = tmp;
#line 85
  ctx->total[0] = tmp;
#line 86
  ctx->buflen = (size_t )0;
#line 87
  return;
}
}
#line 100 "sha256.c"
void *sha256_read_ctx(struct sha256_ctx  const  *ctx , void *resbuf ) 
{ int i ;
  char *r ;

  {
#line 104
  r = (char *)resbuf;
#line 106
  i = 0;
#line 106
  while (i < 8) {
#line 107
    set_uint32(r + (unsigned long )i * sizeof(ctx->state[0]), (((ctx->state[i] << 24) | ((ctx->state[i] & 65280U) << 8)) | ((ctx->state[i] >> 8) & 65280U)) | (ctx->state[i] >> 24));
#line 106
    i ++;
  }
#line 109
  return (resbuf);
}
}
#line 112 "sha256.c"
void *sha224_read_ctx(struct sha256_ctx  const  *ctx , void *resbuf ) 
{ int i ;
  char *r ;

  {
#line 116
  r = (char *)resbuf;
#line 118
  i = 0;
#line 118
  while (i < 7) {
#line 119
    set_uint32(r + (unsigned long )i * sizeof(ctx->state[0]), (((ctx->state[i] << 24) | ((ctx->state[i] & 65280U) << 8)) | ((ctx->state[i] >> 8) & 65280U)) | (ctx->state[i] >> 24));
#line 118
    i ++;
  }
#line 121
  return (resbuf);
}
}
#line 126 "sha256.c"
static void sha256_conclude_ctx(struct sha256_ctx *ctx ) 
{ size_t bytes ;
  size_t size ;
  int tmp ;

  {
#line 130
  bytes = ctx->buflen;
#line 131
  if (bytes < 56UL) {
#line 131
    tmp = 16;
  } else {
#line 131
    tmp = 32;
  }
#line 131
  size = (size_t )tmp;
#line 134
  ctx->total[0] = (uint32_t )((size_t )ctx->total[0] + bytes);
#line 135
  if ((size_t )ctx->total[0] < bytes) {
#line 136
    (ctx->total[1]) ++;
  }
#line 141
  set_uint32((char *)(& ctx->buffer[size - 2UL]), (((((ctx->total[1] << 3) | (ctx->total[0] >> 29)) << 24) | ((((ctx->total[1] << 3) | (ctx->total[0] >> 29)) & 65280U) << 8)) | ((((ctx->total[1] << 3) | (ctx->total[0] >> 29)) >> 8) & 65280U)) | (((ctx->total[1] << 3) | (ctx->total[0] >> 29)) >> 24));
#line 143
  set_uint32((char *)(& ctx->buffer[size - 1UL]), ((((ctx->total[0] << 3) << 24) | (((ctx->total[0] << 3) & 65280U) << 8)) | (((ctx->total[0] << 3) >> 8) & 65280U)) | ((ctx->total[0] << 3) >> 24));
#line 146
  memcpy((void * __restrict  )((char *)(ctx->buffer) + bytes), (void const   * __restrict  )(fillbuf___1),
         (size - 2UL) * 4UL - bytes);
#line 149
  sha256_process_block((void const   *)(ctx->buffer), size * 4UL, ctx);
#line 150
  return;
}
}
#line 152 "sha256.c"
void *sha256_finish_ctx(struct sha256_ctx *ctx , void *resbuf ) 
{ void *tmp ;

  {
#line 155
  sha256_conclude_ctx(ctx);
#line 156
  tmp = sha256_read_ctx((struct sha256_ctx  const  *)ctx, resbuf);
#line 156
  return (tmp);
}
}
#line 159 "sha256.c"
void *sha224_finish_ctx(struct sha256_ctx *ctx , void *resbuf ) 
{ void *tmp ;

  {
#line 162
  sha256_conclude_ctx(ctx);
#line 163
  tmp = sha224_read_ctx((struct sha256_ctx  const  *)ctx, resbuf);
#line 163
  return (tmp);
}
}
#line 169 "sha256.c"
int sha256_stream(FILE *stream , void *resblock ) 
{ struct sha256_ctx ctx ;
  size_t sum ;
  char *buffer ;
  void *tmp ;
  size_t n ;
  size_t __attribute__((__artificial__))  tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t __attribute__((__artificial__))  tmp___3 ;

  {
#line 175
  tmp = malloc((size_t )32840);
#line 175
  buffer = (char *)tmp;
#line 176
  if (! buffer) {
#line 177
    return (1);
  }
#line 180
  sha256_init_ctx(& ctx);
#line 183
  while (1) {
#line 189
    sum = (size_t )0;
#line 192
    while (1) {
#line 194
      tmp___3 = (size_t __attribute__((__artificial__))  )fread_unlocked((void * __restrict  )(buffer + sum),
                                                                         (size_t )1,
                                                                         32768UL - sum,
                                                                         (FILE * __restrict  )stream);
#line 194
      tmp___0 = tmp___3;
#line 194
      n = (size_t )tmp___0;
#line 196
      sum += n;
#line 198
      if (sum == 32768UL) {
#line 199
        break;
      }
#line 201
      if (n == 0UL) {
#line 206
        tmp___1 = ferror_unlocked(stream);
#line 206
        if (tmp___1) {
#line 208
          free((void *)buffer);
#line 209
          return (1);
        }
#line 211
        goto process_partial_block;
      }
#line 217
      tmp___2 = feof_unlocked(stream);
#line 217
      if (tmp___2) {
#line 218
        goto process_partial_block;
      }
    }
#line 224
    sha256_process_block((void const   *)buffer, (size_t )32768, & ctx);
  }
  process_partial_block: ;
#line 230
  if (sum > 0UL) {
#line 231
    sha256_process_bytes((void const   *)buffer, sum, & ctx);
  }
#line 234
  sha256_finish_ctx(& ctx, resblock);
#line 235
  free((void *)buffer);
#line 236
  return (0);
}
}
#line 240 "sha256.c"
int sha224_stream(FILE *stream , void *resblock ) 
{ struct sha256_ctx ctx ;
  size_t sum ;
  char *buffer ;
  void *tmp ;
  size_t n ;
  size_t __attribute__((__artificial__))  tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t __attribute__((__artificial__))  tmp___3 ;

  {
#line 246
  tmp = malloc((size_t )32840);
#line 246
  buffer = (char *)tmp;
#line 247
  if (! buffer) {
#line 248
    return (1);
  }
#line 251
  sha224_init_ctx(& ctx);
#line 254
  while (1) {
#line 260
    sum = (size_t )0;
#line 263
    while (1) {
#line 265
      tmp___3 = (size_t __attribute__((__artificial__))  )fread_unlocked((void * __restrict  )(buffer + sum),
                                                                         (size_t )1,
                                                                         32768UL - sum,
                                                                         (FILE * __restrict  )stream);
#line 265
      tmp___0 = tmp___3;
#line 265
      n = (size_t )tmp___0;
#line 267
      sum += n;
#line 269
      if (sum == 32768UL) {
#line 270
        break;
      }
#line 272
      if (n == 0UL) {
#line 277
        tmp___1 = ferror_unlocked(stream);
#line 277
        if (tmp___1) {
#line 279
          free((void *)buffer);
#line 280
          return (1);
        }
#line 282
        goto process_partial_block;
      }
#line 288
      tmp___2 = feof_unlocked(stream);
#line 288
      if (tmp___2) {
#line 289
        goto process_partial_block;
      }
    }
#line 295
    sha256_process_block((void const   *)buffer, (size_t )32768, & ctx);
  }
  process_partial_block: ;
#line 301
  if (sum > 0UL) {
#line 302
    sha256_process_bytes((void const   *)buffer, sum, & ctx);
  }
#line 305
  sha224_finish_ctx(& ctx, resblock);
#line 306
  free((void *)buffer);
#line 307
  return (0);
}
}
#line 314 "sha256.c"
void *sha256_buffer(char const   *buffer , size_t len , void *resblock ) 
{ struct sha256_ctx ctx ;
  void *tmp ;

  {
#line 320
  sha256_init_ctx(& ctx);
#line 323
  sha256_process_bytes((void const   *)buffer, len, & ctx);
#line 326
  tmp = sha256_finish_ctx(& ctx, resblock);
#line 326
  return (tmp);
}
}
#line 329 "sha256.c"
void *sha224_buffer(char const   *buffer , size_t len , void *resblock ) 
{ struct sha256_ctx ctx ;
  void *tmp ;

  {
#line 335
  sha224_init_ctx(& ctx);
#line 338
  sha256_process_bytes((void const   *)buffer, len, & ctx);
#line 341
  tmp = sha224_finish_ctx(& ctx, resblock);
#line 341
  return (tmp);
}
}
#line 344 "sha256.c"
void sha256_process_bytes(void const   *buffer , size_t len , struct sha256_ctx *ctx ) 
{ size_t left_over ;
  size_t add ;
  size_t tmp ;
  size_t left_over___0 ;

  {
#line 349
  if (ctx->buflen != 0UL) {
#line 351
    left_over = ctx->buflen;
#line 352
    if (128UL - left_over > len) {
#line 352
      tmp = len;
    } else {
#line 352
      tmp = 128UL - left_over;
    }
#line 352
    add = tmp;
#line 354
    memcpy((void * __restrict  )((char *)(ctx->buffer) + left_over), (void const   * __restrict  )buffer,
           add);
#line 355
    ctx->buflen += add;
#line 357
    if (ctx->buflen > 64UL) {
#line 359
      sha256_process_block((void const   *)(ctx->buffer), ctx->buflen & 0xffffffffffffffc0UL,
                           ctx);
#line 361
      ctx->buflen &= 63UL;
#line 363
      memcpy((void * __restrict  )(ctx->buffer), (void const   * __restrict  )((char *)(ctx->buffer) + ((left_over + add) & 0xffffffffffffffc0UL)),
             ctx->buflen);
    }
#line 368
    buffer = (void const   *)((char const   *)buffer + add);
#line 369
    len -= add;
  }
#line 373
  if (len >= 64UL) {
#line 388
    sha256_process_block(buffer, len & 0xffffffffffffffc0UL, ctx);
#line 389
    buffer = (void const   *)((char const   *)buffer + (len & 0xffffffffffffffc0UL));
#line 390
    len &= 63UL;
  }
#line 395
  if (len > 0UL) {
#line 397
    left_over___0 = ctx->buflen;
#line 399
    memcpy((void * __restrict  )((char *)(ctx->buffer) + left_over___0), (void const   * __restrict  )buffer,
           len);
#line 400
    left_over___0 += len;
#line 401
    if (left_over___0 >= 64UL) {
#line 403
      sha256_process_block((void const   *)(ctx->buffer), (size_t )64, ctx);
#line 404
      left_over___0 -= 64UL;
#line 405
      memcpy((void * __restrict  )(ctx->buffer), (void const   * __restrict  )(& ctx->buffer[16]),
             left_over___0);
    }
#line 407
    ctx->buflen = left_over___0;
  }
#line 409
  return;
}
}
#line 415 "sha256.c"
static uint32_t const   sha256_round_constants[64]  = 
#line 415
  {      (uint32_t const   )1116352408UL,      (uint32_t const   )1899447441UL,      (uint32_t const   )3049323471UL,      (uint32_t const   )3921009573UL, 
        (uint32_t const   )961987163UL,      (uint32_t const   )1508970993UL,      (uint32_t const   )2453635748UL,      (uint32_t const   )2870763221UL, 
        (uint32_t const   )3624381080UL,      (uint32_t const   )310598401UL,      (uint32_t const   )607225278UL,      (uint32_t const   )1426881987UL, 
        (uint32_t const   )1925078388UL,      (uint32_t const   )2162078206UL,      (uint32_t const   )2614888103UL,      (uint32_t const   )3248222580UL, 
        (uint32_t const   )3835390401UL,      (uint32_t const   )4022224774UL,      (uint32_t const   )264347078UL,      (uint32_t const   )604807628UL, 
        (uint32_t const   )770255983UL,      (uint32_t const   )1249150122UL,      (uint32_t const   )1555081692UL,      (uint32_t const   )1996064986UL, 
        (uint32_t const   )2554220882UL,      (uint32_t const   )2821834349UL,      (uint32_t const   )2952996808UL,      (uint32_t const   )3210313671UL, 
        (uint32_t const   )3336571891UL,      (uint32_t const   )3584528711UL,      (uint32_t const   )113926993UL,      (uint32_t const   )338241895UL, 
        (uint32_t const   )666307205UL,      (uint32_t const   )773529912UL,      (uint32_t const   )1294757372UL,      (uint32_t const   )1396182291UL, 
        (uint32_t const   )1695183700UL,      (uint32_t const   )1986661051UL,      (uint32_t const   )2177026350UL,      (uint32_t const   )2456956037UL, 
        (uint32_t const   )2730485921UL,      (uint32_t const   )2820302411UL,      (uint32_t const   )3259730800UL,      (uint32_t const   )3345764771UL, 
        (uint32_t const   )3516065817UL,      (uint32_t const   )3600352804UL,      (uint32_t const   )4094571909UL,      (uint32_t const   )275423344UL, 
        (uint32_t const   )430227734UL,      (uint32_t const   )506948616UL,      (uint32_t const   )659060556UL,      (uint32_t const   )883997877UL, 
        (uint32_t const   )958139571UL,      (uint32_t const   )1322822218UL,      (uint32_t const   )1537002063UL,      (uint32_t const   )1747873779UL, 
        (uint32_t const   )1955562222UL,      (uint32_t const   )2024104815UL,      (uint32_t const   )2227730452UL,      (uint32_t const   )2361852424UL, 
        (uint32_t const   )2428436474UL,      (uint32_t const   )2756734187UL,      (uint32_t const   )3204031479UL,      (uint32_t const   )3329325298UL};
#line 442 "sha256.c"
void sha256_process_block(void const   *buffer , size_t len , struct sha256_ctx *ctx ) 
{ uint32_t const   *words ;
  size_t nwords ;
  uint32_t const   *endp ;
  uint32_t x[16] ;
  uint32_t a ;
  uint32_t b ;
  uint32_t c ;
  uint32_t d ;
  uint32_t e ;
  uint32_t f ;
  uint32_t g ;
  uint32_t h ;
  uint32_t tm ;
  uint32_t t0 ;
  uint32_t t1 ;
  int t ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;
  uint32_t tmp___6 ;

  {
#line 445
  words = (uint32_t const   *)buffer;
#line 446
  nwords = len / sizeof(uint32_t );
#line 447
  endp = words + nwords;
#line 449
  a = ctx->state[0];
#line 450
  b = ctx->state[1];
#line 451
  c = ctx->state[2];
#line 452
  d = ctx->state[3];
#line 453
  e = ctx->state[4];
#line 454
  f = ctx->state[5];
#line 455
  g = ctx->state[6];
#line 456
  h = ctx->state[7];
#line 461
  ctx->total[0] = (uint32_t )((size_t )ctx->total[0] + len);
#line 462
  if ((size_t )ctx->total[0] < len) {
#line 463
    (ctx->total[1]) ++;
  }
#line 483
  while ((unsigned long )words < (unsigned long )endp) {
#line 489
    t = 0;
#line 489
    while (t < 16) {
#line 491
      x[t] = (uint32_t )((((*words << 24) | ((*words & 65280U) << 8)) | ((*words >> 8) & 65280U)) | (*words >> 24));
#line 492
      words ++;
#line 489
      t ++;
    }
#line 495
    while (1) {
#line 495
      t0 = ((((a << 30) | (a >> 2)) ^ ((a << 19) | (a >> 13))) ^ ((a << 10) | (a >> 22))) + ((a & b) | (c & (a | b)));
#line 495
      t1 = (((h + ((((e << 26) | (e >> 6)) ^ ((e << 21) | (e >> 11))) ^ ((e << 7) | (e >> 25)))) + (g ^ (e & (f ^ g)))) + (uint32_t )sha256_round_constants[0]) + x[0];
#line 495
      d += t1;
#line 495
      h = t0 + t1;
#line 495
      break;
    }
#line 496
    while (1) {
#line 496
      t0 = ((((h << 30) | (h >> 2)) ^ ((h << 19) | (h >> 13))) ^ ((h << 10) | (h >> 22))) + ((h & a) | (b & (h | a)));
#line 496
      t1 = (((g + ((((d << 26) | (d >> 6)) ^ ((d << 21) | (d >> 11))) ^ ((d << 7) | (d >> 25)))) + (f ^ (d & (e ^ f)))) + (uint32_t )sha256_round_constants[1]) + x[1];
#line 496
      c += t1;
#line 496
      g = t0 + t1;
#line 496
      break;
    }
#line 497
    while (1) {
#line 497
      t0 = ((((g << 30) | (g >> 2)) ^ ((g << 19) | (g >> 13))) ^ ((g << 10) | (g >> 22))) + ((g & h) | (a & (g | h)));
#line 497
      t1 = (((f + ((((c << 26) | (c >> 6)) ^ ((c << 21) | (c >> 11))) ^ ((c << 7) | (c >> 25)))) + (e ^ (c & (d ^ e)))) + (uint32_t )sha256_round_constants[2]) + x[2];
#line 497
      b += t1;
#line 497
      f = t0 + t1;
#line 497
      break;
    }
#line 498
    while (1) {
#line 498
      t0 = ((((f << 30) | (f >> 2)) ^ ((f << 19) | (f >> 13))) ^ ((f << 10) | (f >> 22))) + ((f & g) | (h & (f | g)));
#line 498
      t1 = (((e + ((((b << 26) | (b >> 6)) ^ ((b << 21) | (b >> 11))) ^ ((b << 7) | (b >> 25)))) + (d ^ (b & (c ^ d)))) + (uint32_t )sha256_round_constants[3]) + x[3];
#line 498
      a += t1;
#line 498
      e = t0 + t1;
#line 498
      break;
    }
#line 499
    while (1) {
#line 499
      t0 = ((((e << 30) | (e >> 2)) ^ ((e << 19) | (e >> 13))) ^ ((e << 10) | (e >> 22))) + ((e & f) | (g & (e | f)));
#line 499
      t1 = (((d + ((((a << 26) | (a >> 6)) ^ ((a << 21) | (a >> 11))) ^ ((a << 7) | (a >> 25)))) + (c ^ (a & (b ^ c)))) + (uint32_t )sha256_round_constants[4]) + x[4];
#line 499
      h += t1;
#line 499
      d = t0 + t1;
#line 499
      break;
    }
#line 500
    while (1) {
#line 500
      t0 = ((((d << 30) | (d >> 2)) ^ ((d << 19) | (d >> 13))) ^ ((d << 10) | (d >> 22))) + ((d & e) | (f & (d | e)));
#line 500
      t1 = (((c + ((((h << 26) | (h >> 6)) ^ ((h << 21) | (h >> 11))) ^ ((h << 7) | (h >> 25)))) + (b ^ (h & (a ^ b)))) + (uint32_t )sha256_round_constants[5]) + x[5];
#line 500
      g += t1;
#line 500
      c = t0 + t1;
#line 500
      break;
    }
#line 501
    while (1) {
#line 501
      t0 = ((((c << 30) | (c >> 2)) ^ ((c << 19) | (c >> 13))) ^ ((c << 10) | (c >> 22))) + ((c & d) | (e & (c | d)));
#line 501
      t1 = (((b + ((((g << 26) | (g >> 6)) ^ ((g << 21) | (g >> 11))) ^ ((g << 7) | (g >> 25)))) + (a ^ (g & (h ^ a)))) + (uint32_t )sha256_round_constants[6]) + x[6];
#line 501
      f += t1;
#line 501
      b = t0 + t1;
#line 501
      break;
    }
#line 502
    while (1) {
#line 502
      t0 = ((((b << 30) | (b >> 2)) ^ ((b << 19) | (b >> 13))) ^ ((b << 10) | (b >> 22))) + ((b & c) | (d & (b | c)));
#line 502
      t1 = (((a + ((((f << 26) | (f >> 6)) ^ ((f << 21) | (f >> 11))) ^ ((f << 7) | (f >> 25)))) + (h ^ (f & (g ^ h)))) + (uint32_t )sha256_round_constants[7]) + x[7];
#line 502
      e += t1;
#line 502
      a = t0 + t1;
#line 502
      break;
    }
#line 503
    while (1) {
#line 503
      t0 = ((((a << 30) | (a >> 2)) ^ ((a << 19) | (a >> 13))) ^ ((a << 10) | (a >> 22))) + ((a & b) | (c & (a | b)));
#line 503
      t1 = (((h + ((((e << 26) | (e >> 6)) ^ ((e << 21) | (e >> 11))) ^ ((e << 7) | (e >> 25)))) + (g ^ (e & (f ^ g)))) + (uint32_t )sha256_round_constants[8]) + x[8];
#line 503
      d += t1;
#line 503
      h = t0 + t1;
#line 503
      break;
    }
#line 504
    while (1) {
#line 504
      t0 = ((((h << 30) | (h >> 2)) ^ ((h << 19) | (h >> 13))) ^ ((h << 10) | (h >> 22))) + ((h & a) | (b & (h | a)));
#line 504
      t1 = (((g + ((((d << 26) | (d >> 6)) ^ ((d << 21) | (d >> 11))) ^ ((d << 7) | (d >> 25)))) + (f ^ (d & (e ^ f)))) + (uint32_t )sha256_round_constants[9]) + x[9];
#line 504
      c += t1;
#line 504
      g = t0 + t1;
#line 504
      break;
    }
#line 505
    while (1) {
#line 505
      t0 = ((((g << 30) | (g >> 2)) ^ ((g << 19) | (g >> 13))) ^ ((g << 10) | (g >> 22))) + ((g & h) | (a & (g | h)));
#line 505
      t1 = (((f + ((((c << 26) | (c >> 6)) ^ ((c << 21) | (c >> 11))) ^ ((c << 7) | (c >> 25)))) + (e ^ (c & (d ^ e)))) + (uint32_t )sha256_round_constants[10]) + x[10];
#line 505
      b += t1;
#line 505
      f = t0 + t1;
#line 505
      break;
    }
#line 506
    while (1) {
#line 506
      t0 = ((((f << 30) | (f >> 2)) ^ ((f << 19) | (f >> 13))) ^ ((f << 10) | (f >> 22))) + ((f & g) | (h & (f | g)));
#line 506
      t1 = (((e + ((((b << 26) | (b >> 6)) ^ ((b << 21) | (b >> 11))) ^ ((b << 7) | (b >> 25)))) + (d ^ (b & (c ^ d)))) + (uint32_t )sha256_round_constants[11]) + x[11];
#line 506
      a += t1;
#line 506
      e = t0 + t1;
#line 506
      break;
    }
#line 507
    while (1) {
#line 507
      t0 = ((((e << 30) | (e >> 2)) ^ ((e << 19) | (e >> 13))) ^ ((e << 10) | (e >> 22))) + ((e & f) | (g & (e | f)));
#line 507
      t1 = (((d + ((((a << 26) | (a >> 6)) ^ ((a << 21) | (a >> 11))) ^ ((a << 7) | (a >> 25)))) + (c ^ (a & (b ^ c)))) + (uint32_t )sha256_round_constants[12]) + x[12];
#line 507
      h += t1;
#line 507
      d = t0 + t1;
#line 507
      break;
    }
#line 508
    while (1) {
#line 508
      t0 = ((((d << 30) | (d >> 2)) ^ ((d << 19) | (d >> 13))) ^ ((d << 10) | (d >> 22))) + ((d & e) | (f & (d | e)));
#line 508
      t1 = (((c + ((((h << 26) | (h >> 6)) ^ ((h << 21) | (h >> 11))) ^ ((h << 7) | (h >> 25)))) + (b ^ (h & (a ^ b)))) + (uint32_t )sha256_round_constants[13]) + x[13];
#line 508
      g += t1;
#line 508
      c = t0 + t1;
#line 508
      break;
    }
#line 509
    while (1) {
#line 509
      t0 = ((((c << 30) | (c >> 2)) ^ ((c << 19) | (c >> 13))) ^ ((c << 10) | (c >> 22))) + ((c & d) | (e & (c | d)));
#line 509
      t1 = (((b + ((((g << 26) | (g >> 6)) ^ ((g << 21) | (g >> 11))) ^ ((g << 7) | (g >> 25)))) + (a ^ (g & (h ^ a)))) + (uint32_t )sha256_round_constants[14]) + x[14];
#line 509
      f += t1;
#line 509
      b = t0 + t1;
#line 509
      break;
    }
#line 510
    while (1) {
#line 510
      t0 = ((((b << 30) | (b >> 2)) ^ ((b << 19) | (b >> 13))) ^ ((b << 10) | (b >> 22))) + ((b & c) | (d & (b | c)));
#line 510
      t1 = (((a + ((((f << 26) | (f >> 6)) ^ ((f << 21) | (f >> 11))) ^ ((f << 7) | (f >> 25)))) + (h ^ (f & (g ^ h)))) + (uint32_t )sha256_round_constants[15]) + x[15];
#line 510
      e += t1;
#line 510
      a = t0 + t1;
#line 510
      break;
    }
#line 511
    while (1) {
#line 511
      t0 = ((((a << 30) | (a >> 2)) ^ ((a << 19) | (a >> 13))) ^ ((a << 10) | (a >> 22))) + ((a & b) | (c & (a | b)));
#line 511
      tm = ((((((x[14] << 15) | (x[14] >> 17)) ^ ((x[14] << 13) | (x[14] >> 19))) ^ (x[14] >> 10)) + x[9]) + ((((x[1] << 25) | (x[1] >> 7)) ^ ((x[1] << 14) | (x[1] >> 18))) ^ (x[1] >> 3))) + x[0];
#line 511
      x[0] = tm;
#line 511
      t1 = (((h + ((((e << 26) | (e >> 6)) ^ ((e << 21) | (e >> 11))) ^ ((e << 7) | (e >> 25)))) + (g ^ (e & (f ^ g)))) + (uint32_t )sha256_round_constants[16]) + x[0];
#line 511
      d += t1;
#line 511
      h = t0 + t1;
#line 511
      break;
    }
#line 512
    while (1) {
#line 512
      t0 = ((((h << 30) | (h >> 2)) ^ ((h << 19) | (h >> 13))) ^ ((h << 10) | (h >> 22))) + ((h & a) | (b & (h | a)));
#line 512
      tm = ((((((x[15] << 15) | (x[15] >> 17)) ^ ((x[15] << 13) | (x[15] >> 19))) ^ (x[15] >> 10)) + x[10]) + ((((x[2] << 25) | (x[2] >> 7)) ^ ((x[2] << 14) | (x[2] >> 18))) ^ (x[2] >> 3))) + x[1];
#line 512
      x[1] = tm;
#line 512
      t1 = (((g + ((((d << 26) | (d >> 6)) ^ ((d << 21) | (d >> 11))) ^ ((d << 7) | (d >> 25)))) + (f ^ (d & (e ^ f)))) + (uint32_t )sha256_round_constants[17]) + x[1];
#line 512
      c += t1;
#line 512
      g = t0 + t1;
#line 512
      break;
    }
#line 513
    while (1) {
#line 513
      t0 = ((((g << 30) | (g >> 2)) ^ ((g << 19) | (g >> 13))) ^ ((g << 10) | (g >> 22))) + ((g & h) | (a & (g | h)));
#line 513
      tm = ((((((x[0] << 15) | (x[0] >> 17)) ^ ((x[0] << 13) | (x[0] >> 19))) ^ (x[0] >> 10)) + x[11]) + ((((x[3] << 25) | (x[3] >> 7)) ^ ((x[3] << 14) | (x[3] >> 18))) ^ (x[3] >> 3))) + x[2];
#line 513
      x[2] = tm;
#line 513
      t1 = (((f + ((((c << 26) | (c >> 6)) ^ ((c << 21) | (c >> 11))) ^ ((c << 7) | (c >> 25)))) + (e ^ (c & (d ^ e)))) + (uint32_t )sha256_round_constants[18]) + x[2];
#line 513
      b += t1;
#line 513
      f = t0 + t1;
#line 513
      break;
    }
#line 514
    while (1) {
#line 514
      t0 = ((((f << 30) | (f >> 2)) ^ ((f << 19) | (f >> 13))) ^ ((f << 10) | (f >> 22))) + ((f & g) | (h & (f | g)));
#line 514
      tm = ((((((x[1] << 15) | (x[1] >> 17)) ^ ((x[1] << 13) | (x[1] >> 19))) ^ (x[1] >> 10)) + x[12]) + ((((x[4] << 25) | (x[4] >> 7)) ^ ((x[4] << 14) | (x[4] >> 18))) ^ (x[4] >> 3))) + x[3];
#line 514
      x[3] = tm;
#line 514
      t1 = (((e + ((((b << 26) | (b >> 6)) ^ ((b << 21) | (b >> 11))) ^ ((b << 7) | (b >> 25)))) + (d ^ (b & (c ^ d)))) + (uint32_t )sha256_round_constants[19]) + x[3];
#line 514
      a += t1;
#line 514
      e = t0 + t1;
#line 514
      break;
    }
#line 515
    while (1) {
#line 515
      t0 = ((((e << 30) | (e >> 2)) ^ ((e << 19) | (e >> 13))) ^ ((e << 10) | (e >> 22))) + ((e & f) | (g & (e | f)));
#line 515
      tm = ((((((x[2] << 15) | (x[2] >> 17)) ^ ((x[2] << 13) | (x[2] >> 19))) ^ (x[2] >> 10)) + x[13]) + ((((x[5] << 25) | (x[5] >> 7)) ^ ((x[5] << 14) | (x[5] >> 18))) ^ (x[5] >> 3))) + x[4];
#line 515
      x[4] = tm;
#line 515
      t1 = (((d + ((((a << 26) | (a >> 6)) ^ ((a << 21) | (a >> 11))) ^ ((a << 7) | (a >> 25)))) + (c ^ (a & (b ^ c)))) + (uint32_t )sha256_round_constants[20]) + x[4];
#line 515
      h += t1;
#line 515
      d = t0 + t1;
#line 515
      break;
    }
#line 516
    while (1) {
#line 516
      t0 = ((((d << 30) | (d >> 2)) ^ ((d << 19) | (d >> 13))) ^ ((d << 10) | (d >> 22))) + ((d & e) | (f & (d | e)));
#line 516
      tm = ((((((x[3] << 15) | (x[3] >> 17)) ^ ((x[3] << 13) | (x[3] >> 19))) ^ (x[3] >> 10)) + x[14]) + ((((x[6] << 25) | (x[6] >> 7)) ^ ((x[6] << 14) | (x[6] >> 18))) ^ (x[6] >> 3))) + x[5];
#line 516
      x[5] = tm;
#line 516
      t1 = (((c + ((((h << 26) | (h >> 6)) ^ ((h << 21) | (h >> 11))) ^ ((h << 7) | (h >> 25)))) + (b ^ (h & (a ^ b)))) + (uint32_t )sha256_round_constants[21]) + x[5];
#line 516
      g += t1;
#line 516
      c = t0 + t1;
#line 516
      break;
    }
#line 517
    while (1) {
#line 517
      t0 = ((((c << 30) | (c >> 2)) ^ ((c << 19) | (c >> 13))) ^ ((c << 10) | (c >> 22))) + ((c & d) | (e & (c | d)));
#line 517
      tm = ((((((x[4] << 15) | (x[4] >> 17)) ^ ((x[4] << 13) | (x[4] >> 19))) ^ (x[4] >> 10)) + x[15]) + ((((x[7] << 25) | (x[7] >> 7)) ^ ((x[7] << 14) | (x[7] >> 18))) ^ (x[7] >> 3))) + x[6];
#line 517
      x[6] = tm;
#line 517
      t1 = (((b + ((((g << 26) | (g >> 6)) ^ ((g << 21) | (g >> 11))) ^ ((g << 7) | (g >> 25)))) + (a ^ (g & (h ^ a)))) + (uint32_t )sha256_round_constants[22]) + x[6];
#line 517
      f += t1;
#line 517
      b = t0 + t1;
#line 517
      break;
    }
#line 518
    while (1) {
#line 518
      t0 = ((((b << 30) | (b >> 2)) ^ ((b << 19) | (b >> 13))) ^ ((b << 10) | (b >> 22))) + ((b & c) | (d & (b | c)));
#line 518
      tm = ((((((x[5] << 15) | (x[5] >> 17)) ^ ((x[5] << 13) | (x[5] >> 19))) ^ (x[5] >> 10)) + x[0]) + ((((x[8] << 25) | (x[8] >> 7)) ^ ((x[8] << 14) | (x[8] >> 18))) ^ (x[8] >> 3))) + x[7];
#line 518
      x[7] = tm;
#line 518
      t1 = (((a + ((((f << 26) | (f >> 6)) ^ ((f << 21) | (f >> 11))) ^ ((f << 7) | (f >> 25)))) + (h ^ (f & (g ^ h)))) + (uint32_t )sha256_round_constants[23]) + x[7];
#line 518
      e += t1;
#line 518
      a = t0 + t1;
#line 518
      break;
    }
#line 519
    while (1) {
#line 519
      t0 = ((((a << 30) | (a >> 2)) ^ ((a << 19) | (a >> 13))) ^ ((a << 10) | (a >> 22))) + ((a & b) | (c & (a | b)));
#line 519
      tm = ((((((x[6] << 15) | (x[6] >> 17)) ^ ((x[6] << 13) | (x[6] >> 19))) ^ (x[6] >> 10)) + x[1]) + ((((x[9] << 25) | (x[9] >> 7)) ^ ((x[9] << 14) | (x[9] >> 18))) ^ (x[9] >> 3))) + x[8];
#line 519
      x[8] = tm;
#line 519
      t1 = (((h + ((((e << 26) | (e >> 6)) ^ ((e << 21) | (e >> 11))) ^ ((e << 7) | (e >> 25)))) + (g ^ (e & (f ^ g)))) + (uint32_t )sha256_round_constants[24]) + x[8];
#line 519
      d += t1;
#line 519
      h = t0 + t1;
#line 519
      break;
    }
#line 520
    while (1) {
#line 520
      t0 = ((((h << 30) | (h >> 2)) ^ ((h << 19) | (h >> 13))) ^ ((h << 10) | (h >> 22))) + ((h & a) | (b & (h | a)));
#line 520
      tm = ((((((x[7] << 15) | (x[7] >> 17)) ^ ((x[7] << 13) | (x[7] >> 19))) ^ (x[7] >> 10)) + x[2]) + ((((x[10] << 25) | (x[10] >> 7)) ^ ((x[10] << 14) | (x[10] >> 18))) ^ (x[10] >> 3))) + x[9];
#line 520
      x[9] = tm;
#line 520
      t1 = (((g + ((((d << 26) | (d >> 6)) ^ ((d << 21) | (d >> 11))) ^ ((d << 7) | (d >> 25)))) + (f ^ (d & (e ^ f)))) + (uint32_t )sha256_round_constants[25]) + x[9];
#line 520
      c += t1;
#line 520
      g = t0 + t1;
#line 520
      break;
    }
#line 521
    while (1) {
#line 521
      t0 = ((((g << 30) | (g >> 2)) ^ ((g << 19) | (g >> 13))) ^ ((g << 10) | (g >> 22))) + ((g & h) | (a & (g | h)));
#line 521
      tm = ((((((x[8] << 15) | (x[8] >> 17)) ^ ((x[8] << 13) | (x[8] >> 19))) ^ (x[8] >> 10)) + x[3]) + ((((x[11] << 25) | (x[11] >> 7)) ^ ((x[11] << 14) | (x[11] >> 18))) ^ (x[11] >> 3))) + x[10];
#line 521
      x[10] = tm;
#line 521
      t1 = (((f + ((((c << 26) | (c >> 6)) ^ ((c << 21) | (c >> 11))) ^ ((c << 7) | (c >> 25)))) + (e ^ (c & (d ^ e)))) + (uint32_t )sha256_round_constants[26]) + x[10];
#line 521
      b += t1;
#line 521
      f = t0 + t1;
#line 521
      break;
    }
#line 522
    while (1) {
#line 522
      t0 = ((((f << 30) | (f >> 2)) ^ ((f << 19) | (f >> 13))) ^ ((f << 10) | (f >> 22))) + ((f & g) | (h & (f | g)));
#line 522
      tm = ((((((x[9] << 15) | (x[9] >> 17)) ^ ((x[9] << 13) | (x[9] >> 19))) ^ (x[9] >> 10)) + x[4]) + ((((x[12] << 25) | (x[12] >> 7)) ^ ((x[12] << 14) | (x[12] >> 18))) ^ (x[12] >> 3))) + x[11];
#line 522
      x[11] = tm;
#line 522
      t1 = (((e + ((((b << 26) | (b >> 6)) ^ ((b << 21) | (b >> 11))) ^ ((b << 7) | (b >> 25)))) + (d ^ (b & (c ^ d)))) + (uint32_t )sha256_round_constants[27]) + x[11];
#line 522
      a += t1;
#line 522
      e = t0 + t1;
#line 522
      break;
    }
#line 523
    while (1) {
#line 523
      t0 = ((((e << 30) | (e >> 2)) ^ ((e << 19) | (e >> 13))) ^ ((e << 10) | (e >> 22))) + ((e & f) | (g & (e | f)));
#line 523
      tm = ((((((x[10] << 15) | (x[10] >> 17)) ^ ((x[10] << 13) | (x[10] >> 19))) ^ (x[10] >> 10)) + x[5]) + ((((x[13] << 25) | (x[13] >> 7)) ^ ((x[13] << 14) | (x[13] >> 18))) ^ (x[13] >> 3))) + x[12];
#line 523
      x[12] = tm;
#line 523
      t1 = (((d + ((((a << 26) | (a >> 6)) ^ ((a << 21) | (a >> 11))) ^ ((a << 7) | (a >> 25)))) + (c ^ (a & (b ^ c)))) + (uint32_t )sha256_round_constants[28]) + x[12];
#line 523
      h += t1;
#line 523
      d = t0 + t1;
#line 523
      break;
    }
#line 524
    while (1) {
#line 524
      t0 = ((((d << 30) | (d >> 2)) ^ ((d << 19) | (d >> 13))) ^ ((d << 10) | (d >> 22))) + ((d & e) | (f & (d | e)));
#line 524
      tm = ((((((x[11] << 15) | (x[11] >> 17)) ^ ((x[11] << 13) | (x[11] >> 19))) ^ (x[11] >> 10)) + x[6]) + ((((x[14] << 25) | (x[14] >> 7)) ^ ((x[14] << 14) | (x[14] >> 18))) ^ (x[14] >> 3))) + x[13];
#line 524
      x[13] = tm;
#line 524
      t1 = (((c + ((((h << 26) | (h >> 6)) ^ ((h << 21) | (h >> 11))) ^ ((h << 7) | (h >> 25)))) + (b ^ (h & (a ^ b)))) + (uint32_t )sha256_round_constants[29]) + x[13];
#line 524
      g += t1;
#line 524
      c = t0 + t1;
#line 524
      break;
    }
#line 525
    while (1) {
#line 525
      t0 = ((((c << 30) | (c >> 2)) ^ ((c << 19) | (c >> 13))) ^ ((c << 10) | (c >> 22))) + ((c & d) | (e & (c | d)));
#line 525
      tm = ((((((x[12] << 15) | (x[12] >> 17)) ^ ((x[12] << 13) | (x[12] >> 19))) ^ (x[12] >> 10)) + x[7]) + ((((x[15] << 25) | (x[15] >> 7)) ^ ((x[15] << 14) | (x[15] >> 18))) ^ (x[15] >> 3))) + x[14];
#line 525
      x[14] = tm;
#line 525
      t1 = (((b + ((((g << 26) | (g >> 6)) ^ ((g << 21) | (g >> 11))) ^ ((g << 7) | (g >> 25)))) + (a ^ (g & (h ^ a)))) + (uint32_t )sha256_round_constants[30]) + x[14];
#line 525
      f += t1;
#line 525
      b = t0 + t1;
#line 525
      break;
    }
#line 526
    while (1) {
#line 526
      t0 = ((((b << 30) | (b >> 2)) ^ ((b << 19) | (b >> 13))) ^ ((b << 10) | (b >> 22))) + ((b & c) | (d & (b | c)));
#line 526
      tm = ((((((x[13] << 15) | (x[13] >> 17)) ^ ((x[13] << 13) | (x[13] >> 19))) ^ (x[13] >> 10)) + x[8]) + ((((x[0] << 25) | (x[0] >> 7)) ^ ((x[0] << 14) | (x[0] >> 18))) ^ (x[0] >> 3))) + x[15];
#line 526
      x[15] = tm;
#line 526
      t1 = (((a + ((((f << 26) | (f >> 6)) ^ ((f << 21) | (f >> 11))) ^ ((f << 7) | (f >> 25)))) + (h ^ (f & (g ^ h)))) + (uint32_t )sha256_round_constants[31]) + x[15];
#line 526
      e += t1;
#line 526
      a = t0 + t1;
#line 526
      break;
    }
#line 527
    while (1) {
#line 527
      t0 = ((((a << 30) | (a >> 2)) ^ ((a << 19) | (a >> 13))) ^ ((a << 10) | (a >> 22))) + ((a & b) | (c & (a | b)));
#line 527
      tm = ((((((x[14] << 15) | (x[14] >> 17)) ^ ((x[14] << 13) | (x[14] >> 19))) ^ (x[14] >> 10)) + x[9]) + ((((x[1] << 25) | (x[1] >> 7)) ^ ((x[1] << 14) | (x[1] >> 18))) ^ (x[1] >> 3))) + x[0];
#line 527
      x[0] = tm;
#line 527
      t1 = (((h + ((((e << 26) | (e >> 6)) ^ ((e << 21) | (e >> 11))) ^ ((e << 7) | (e >> 25)))) + (g ^ (e & (f ^ g)))) + (uint32_t )sha256_round_constants[32]) + x[0];
#line 527
      d += t1;
#line 527
      h = t0 + t1;
#line 527
      break;
    }
#line 528
    while (1) {
#line 528
      t0 = ((((h << 30) | (h >> 2)) ^ ((h << 19) | (h >> 13))) ^ ((h << 10) | (h >> 22))) + ((h & a) | (b & (h | a)));
#line 528
      tm = ((((((x[15] << 15) | (x[15] >> 17)) ^ ((x[15] << 13) | (x[15] >> 19))) ^ (x[15] >> 10)) + x[10]) + ((((x[2] << 25) | (x[2] >> 7)) ^ ((x[2] << 14) | (x[2] >> 18))) ^ (x[2] >> 3))) + x[1];
#line 528
      x[1] = tm;
#line 528
      t1 = (((g + ((((d << 26) | (d >> 6)) ^ ((d << 21) | (d >> 11))) ^ ((d << 7) | (d >> 25)))) + (f ^ (d & (e ^ f)))) + (uint32_t )sha256_round_constants[33]) + x[1];
#line 528
      c += t1;
#line 528
      g = t0 + t1;
#line 528
      break;
    }
#line 529
    while (1) {
#line 529
      t0 = ((((g << 30) | (g >> 2)) ^ ((g << 19) | (g >> 13))) ^ ((g << 10) | (g >> 22))) + ((g & h) | (a & (g | h)));
#line 529
      tm = ((((((x[0] << 15) | (x[0] >> 17)) ^ ((x[0] << 13) | (x[0] >> 19))) ^ (x[0] >> 10)) + x[11]) + ((((x[3] << 25) | (x[3] >> 7)) ^ ((x[3] << 14) | (x[3] >> 18))) ^ (x[3] >> 3))) + x[2];
#line 529
      x[2] = tm;
#line 529
      t1 = (((f + ((((c << 26) | (c >> 6)) ^ ((c << 21) | (c >> 11))) ^ ((c << 7) | (c >> 25)))) + (e ^ (c & (d ^ e)))) + (uint32_t )sha256_round_constants[34]) + x[2];
#line 529
      b += t1;
#line 529
      f = t0 + t1;
#line 529
      break;
    }
#line 530
    while (1) {
#line 530
      t0 = ((((f << 30) | (f >> 2)) ^ ((f << 19) | (f >> 13))) ^ ((f << 10) | (f >> 22))) + ((f & g) | (h & (f | g)));
#line 530
      tm = ((((((x[1] << 15) | (x[1] >> 17)) ^ ((x[1] << 13) | (x[1] >> 19))) ^ (x[1] >> 10)) + x[12]) + ((((x[4] << 25) | (x[4] >> 7)) ^ ((x[4] << 14) | (x[4] >> 18))) ^ (x[4] >> 3))) + x[3];
#line 530
      x[3] = tm;
#line 530
      t1 = (((e + ((((b << 26) | (b >> 6)) ^ ((b << 21) | (b >> 11))) ^ ((b << 7) | (b >> 25)))) + (d ^ (b & (c ^ d)))) + (uint32_t )sha256_round_constants[35]) + x[3];
#line 530
      a += t1;
#line 530
      e = t0 + t1;
#line 530
      break;
    }
#line 531
    while (1) {
#line 531
      t0 = ((((e << 30) | (e >> 2)) ^ ((e << 19) | (e >> 13))) ^ ((e << 10) | (e >> 22))) + ((e & f) | (g & (e | f)));
#line 531
      tm = ((((((x[2] << 15) | (x[2] >> 17)) ^ ((x[2] << 13) | (x[2] >> 19))) ^ (x[2] >> 10)) + x[13]) + ((((x[5] << 25) | (x[5] >> 7)) ^ ((x[5] << 14) | (x[5] >> 18))) ^ (x[5] >> 3))) + x[4];
#line 531
      x[4] = tm;
#line 531
      t1 = (((d + ((((a << 26) | (a >> 6)) ^ ((a << 21) | (a >> 11))) ^ ((a << 7) | (a >> 25)))) + (c ^ (a & (b ^ c)))) + (uint32_t )sha256_round_constants[36]) + x[4];
#line 531
      h += t1;
#line 531
      d = t0 + t1;
#line 531
      break;
    }
#line 532
    while (1) {
#line 532
      t0 = ((((d << 30) | (d >> 2)) ^ ((d << 19) | (d >> 13))) ^ ((d << 10) | (d >> 22))) + ((d & e) | (f & (d | e)));
#line 532
      tm = ((((((x[3] << 15) | (x[3] >> 17)) ^ ((x[3] << 13) | (x[3] >> 19))) ^ (x[3] >> 10)) + x[14]) + ((((x[6] << 25) | (x[6] >> 7)) ^ ((x[6] << 14) | (x[6] >> 18))) ^ (x[6] >> 3))) + x[5];
#line 532
      x[5] = tm;
#line 532
      t1 = (((c + ((((h << 26) | (h >> 6)) ^ ((h << 21) | (h >> 11))) ^ ((h << 7) | (h >> 25)))) + (b ^ (h & (a ^ b)))) + (uint32_t )sha256_round_constants[37]) + x[5];
#line 532
      g += t1;
#line 532
      c = t0 + t1;
#line 532
      break;
    }
#line 533
    while (1) {
#line 533
      t0 = ((((c << 30) | (c >> 2)) ^ ((c << 19) | (c >> 13))) ^ ((c << 10) | (c >> 22))) + ((c & d) | (e & (c | d)));
#line 533
      tm = ((((((x[4] << 15) | (x[4] >> 17)) ^ ((x[4] << 13) | (x[4] >> 19))) ^ (x[4] >> 10)) + x[15]) + ((((x[7] << 25) | (x[7] >> 7)) ^ ((x[7] << 14) | (x[7] >> 18))) ^ (x[7] >> 3))) + x[6];
#line 533
      x[6] = tm;
#line 533
      t1 = (((b + ((((g << 26) | (g >> 6)) ^ ((g << 21) | (g >> 11))) ^ ((g << 7) | (g >> 25)))) + (a ^ (g & (h ^ a)))) + (uint32_t )sha256_round_constants[38]) + x[6];
#line 533
      f += t1;
#line 533
      b = t0 + t1;
#line 533
      break;
    }
#line 534
    while (1) {
#line 534
      t0 = ((((b << 30) | (b >> 2)) ^ ((b << 19) | (b >> 13))) ^ ((b << 10) | (b >> 22))) + ((b & c) | (d & (b | c)));
#line 534
      tm = ((((((x[5] << 15) | (x[5] >> 17)) ^ ((x[5] << 13) | (x[5] >> 19))) ^ (x[5] >> 10)) + x[0]) + ((((x[8] << 25) | (x[8] >> 7)) ^ ((x[8] << 14) | (x[8] >> 18))) ^ (x[8] >> 3))) + x[7];
#line 534
      x[7] = tm;
#line 534
      t1 = (((a + ((((f << 26) | (f >> 6)) ^ ((f << 21) | (f >> 11))) ^ ((f << 7) | (f >> 25)))) + (h ^ (f & (g ^ h)))) + (uint32_t )sha256_round_constants[39]) + x[7];
#line 534
      e += t1;
#line 534
      a = t0 + t1;
#line 534
      break;
    }
#line 535
    while (1) {
#line 535
      t0 = ((((a << 30) | (a >> 2)) ^ ((a << 19) | (a >> 13))) ^ ((a << 10) | (a >> 22))) + ((a & b) | (c & (a | b)));
#line 535
      tm = ((((((x[6] << 15) | (x[6] >> 17)) ^ ((x[6] << 13) | (x[6] >> 19))) ^ (x[6] >> 10)) + x[1]) + ((((x[9] << 25) | (x[9] >> 7)) ^ ((x[9] << 14) | (x[9] >> 18))) ^ (x[9] >> 3))) + x[8];
#line 535
      x[8] = tm;
#line 535
      t1 = (((h + ((((e << 26) | (e >> 6)) ^ ((e << 21) | (e >> 11))) ^ ((e << 7) | (e >> 25)))) + (g ^ (e & (f ^ g)))) + (uint32_t )sha256_round_constants[40]) + x[8];
#line 535
      d += t1;
#line 535
      h = t0 + t1;
#line 535
      break;
    }
#line 536
    while (1) {
#line 536
      t0 = ((((h << 30) | (h >> 2)) ^ ((h << 19) | (h >> 13))) ^ ((h << 10) | (h >> 22))) + ((h & a) | (b & (h | a)));
#line 536
      tm = ((((((x[7] << 15) | (x[7] >> 17)) ^ ((x[7] << 13) | (x[7] >> 19))) ^ (x[7] >> 10)) + x[2]) + ((((x[10] << 25) | (x[10] >> 7)) ^ ((x[10] << 14) | (x[10] >> 18))) ^ (x[10] >> 3))) + x[9];
#line 536
      x[9] = tm;
#line 536
      t1 = (((g + ((((d << 26) | (d >> 6)) ^ ((d << 21) | (d >> 11))) ^ ((d << 7) | (d >> 25)))) + (f ^ (d & (e ^ f)))) + (uint32_t )sha256_round_constants[41]) + x[9];
#line 536
      c += t1;
#line 536
      g = t0 + t1;
#line 536
      break;
    }
#line 537
    while (1) {
#line 537
      t0 = ((((g << 30) | (g >> 2)) ^ ((g << 19) | (g >> 13))) ^ ((g << 10) | (g >> 22))) + ((g & h) | (a & (g | h)));
#line 537
      tm = ((((((x[8] << 15) | (x[8] >> 17)) ^ ((x[8] << 13) | (x[8] >> 19))) ^ (x[8] >> 10)) + x[3]) + ((((x[11] << 25) | (x[11] >> 7)) ^ ((x[11] << 14) | (x[11] >> 18))) ^ (x[11] >> 3))) + x[10];
#line 537
      x[10] = tm;
#line 537
      t1 = (((f + ((((c << 26) | (c >> 6)) ^ ((c << 21) | (c >> 11))) ^ ((c << 7) | (c >> 25)))) + (e ^ (c & (d ^ e)))) + (uint32_t )sha256_round_constants[42]) + x[10];
#line 537
      b += t1;
#line 537
      f = t0 + t1;
#line 537
      break;
    }
#line 538
    while (1) {
#line 538
      t0 = ((((f << 30) | (f >> 2)) ^ ((f << 19) | (f >> 13))) ^ ((f << 10) | (f >> 22))) + ((f & g) | (h & (f | g)));
#line 538
      tm = ((((((x[9] << 15) | (x[9] >> 17)) ^ ((x[9] << 13) | (x[9] >> 19))) ^ (x[9] >> 10)) + x[4]) + ((((x[12] << 25) | (x[12] >> 7)) ^ ((x[12] << 14) | (x[12] >> 18))) ^ (x[12] >> 3))) + x[11];
#line 538
      x[11] = tm;
#line 538
      t1 = (((e + ((((b << 26) | (b >> 6)) ^ ((b << 21) | (b >> 11))) ^ ((b << 7) | (b >> 25)))) + (d ^ (b & (c ^ d)))) + (uint32_t )sha256_round_constants[43]) + x[11];
#line 538
      a += t1;
#line 538
      e = t0 + t1;
#line 538
      break;
    }
#line 539
    while (1) {
#line 539
      t0 = ((((e << 30) | (e >> 2)) ^ ((e << 19) | (e >> 13))) ^ ((e << 10) | (e >> 22))) + ((e & f) | (g & (e | f)));
#line 539
      tm = ((((((x[10] << 15) | (x[10] >> 17)) ^ ((x[10] << 13) | (x[10] >> 19))) ^ (x[10] >> 10)) + x[5]) + ((((x[13] << 25) | (x[13] >> 7)) ^ ((x[13] << 14) | (x[13] >> 18))) ^ (x[13] >> 3))) + x[12];
#line 539
      x[12] = tm;
#line 539
      t1 = (((d + ((((a << 26) | (a >> 6)) ^ ((a << 21) | (a >> 11))) ^ ((a << 7) | (a >> 25)))) + (c ^ (a & (b ^ c)))) + (uint32_t )sha256_round_constants[44]) + x[12];
#line 539
      h += t1;
#line 539
      d = t0 + t1;
#line 539
      break;
    }
#line 540
    while (1) {
#line 540
      t0 = ((((d << 30) | (d >> 2)) ^ ((d << 19) | (d >> 13))) ^ ((d << 10) | (d >> 22))) + ((d & e) | (f & (d | e)));
#line 540
      tm = ((((((x[11] << 15) | (x[11] >> 17)) ^ ((x[11] << 13) | (x[11] >> 19))) ^ (x[11] >> 10)) + x[6]) + ((((x[14] << 25) | (x[14] >> 7)) ^ ((x[14] << 14) | (x[14] >> 18))) ^ (x[14] >> 3))) + x[13];
#line 540
      x[13] = tm;
#line 540
      t1 = (((c + ((((h << 26) | (h >> 6)) ^ ((h << 21) | (h >> 11))) ^ ((h << 7) | (h >> 25)))) + (b ^ (h & (a ^ b)))) + (uint32_t )sha256_round_constants[45]) + x[13];
#line 540
      g += t1;
#line 540
      c = t0 + t1;
#line 540
      break;
    }
#line 541
    while (1) {
#line 541
      t0 = ((((c << 30) | (c >> 2)) ^ ((c << 19) | (c >> 13))) ^ ((c << 10) | (c >> 22))) + ((c & d) | (e & (c | d)));
#line 541
      tm = ((((((x[12] << 15) | (x[12] >> 17)) ^ ((x[12] << 13) | (x[12] >> 19))) ^ (x[12] >> 10)) + x[7]) + ((((x[15] << 25) | (x[15] >> 7)) ^ ((x[15] << 14) | (x[15] >> 18))) ^ (x[15] >> 3))) + x[14];
#line 541
      x[14] = tm;
#line 541
      t1 = (((b + ((((g << 26) | (g >> 6)) ^ ((g << 21) | (g >> 11))) ^ ((g << 7) | (g >> 25)))) + (a ^ (g & (h ^ a)))) + (uint32_t )sha256_round_constants[46]) + x[14];
#line 541
      f += t1;
#line 541
      b = t0 + t1;
#line 541
      break;
    }
#line 542
    while (1) {
#line 542
      t0 = ((((b << 30) | (b >> 2)) ^ ((b << 19) | (b >> 13))) ^ ((b << 10) | (b >> 22))) + ((b & c) | (d & (b | c)));
#line 542
      tm = ((((((x[13] << 15) | (x[13] >> 17)) ^ ((x[13] << 13) | (x[13] >> 19))) ^ (x[13] >> 10)) + x[8]) + ((((x[0] << 25) | (x[0] >> 7)) ^ ((x[0] << 14) | (x[0] >> 18))) ^ (x[0] >> 3))) + x[15];
#line 542
      x[15] = tm;
#line 542
      t1 = (((a + ((((f << 26) | (f >> 6)) ^ ((f << 21) | (f >> 11))) ^ ((f << 7) | (f >> 25)))) + (h ^ (f & (g ^ h)))) + (uint32_t )sha256_round_constants[47]) + x[15];
#line 542
      e += t1;
#line 542
      a = t0 + t1;
#line 542
      break;
    }
#line 543
    while (1) {
#line 543
      t0 = ((((a << 30) | (a >> 2)) ^ ((a << 19) | (a >> 13))) ^ ((a << 10) | (a >> 22))) + ((a & b) | (c & (a | b)));
#line 543
      tm = ((((((x[14] << 15) | (x[14] >> 17)) ^ ((x[14] << 13) | (x[14] >> 19))) ^ (x[14] >> 10)) + x[9]) + ((((x[1] << 25) | (x[1] >> 7)) ^ ((x[1] << 14) | (x[1] >> 18))) ^ (x[1] >> 3))) + x[0];
#line 543
      x[0] = tm;
#line 543
      t1 = (((h + ((((e << 26) | (e >> 6)) ^ ((e << 21) | (e >> 11))) ^ ((e << 7) | (e >> 25)))) + (g ^ (e & (f ^ g)))) + (uint32_t )sha256_round_constants[48]) + x[0];
#line 543
      d += t1;
#line 543
      h = t0 + t1;
#line 543
      break;
    }
#line 544
    while (1) {
#line 544
      t0 = ((((h << 30) | (h >> 2)) ^ ((h << 19) | (h >> 13))) ^ ((h << 10) | (h >> 22))) + ((h & a) | (b & (h | a)));
#line 544
      tm = ((((((x[15] << 15) | (x[15] >> 17)) ^ ((x[15] << 13) | (x[15] >> 19))) ^ (x[15] >> 10)) + x[10]) + ((((x[2] << 25) | (x[2] >> 7)) ^ ((x[2] << 14) | (x[2] >> 18))) ^ (x[2] >> 3))) + x[1];
#line 544
      x[1] = tm;
#line 544
      t1 = (((g + ((((d << 26) | (d >> 6)) ^ ((d << 21) | (d >> 11))) ^ ((d << 7) | (d >> 25)))) + (f ^ (d & (e ^ f)))) + (uint32_t )sha256_round_constants[49]) + x[1];
#line 544
      c += t1;
#line 544
      g = t0 + t1;
#line 544
      break;
    }
#line 545
    while (1) {
#line 545
      t0 = ((((g << 30) | (g >> 2)) ^ ((g << 19) | (g >> 13))) ^ ((g << 10) | (g >> 22))) + ((g & h) | (a & (g | h)));
#line 545
      tm = ((((((x[0] << 15) | (x[0] >> 17)) ^ ((x[0] << 13) | (x[0] >> 19))) ^ (x[0] >> 10)) + x[11]) + ((((x[3] << 25) | (x[3] >> 7)) ^ ((x[3] << 14) | (x[3] >> 18))) ^ (x[3] >> 3))) + x[2];
#line 545
      x[2] = tm;
#line 545
      t1 = (((f + ((((c << 26) | (c >> 6)) ^ ((c << 21) | (c >> 11))) ^ ((c << 7) | (c >> 25)))) + (e ^ (c & (d ^ e)))) + (uint32_t )sha256_round_constants[50]) + x[2];
#line 545
      b += t1;
#line 545
      f = t0 + t1;
#line 545
      break;
    }
#line 546
    while (1) {
#line 546
      t0 = ((((f << 30) | (f >> 2)) ^ ((f << 19) | (f >> 13))) ^ ((f << 10) | (f >> 22))) + ((f & g) | (h & (f | g)));
#line 546
      tm = ((((((x[1] << 15) | (x[1] >> 17)) ^ ((x[1] << 13) | (x[1] >> 19))) ^ (x[1] >> 10)) + x[12]) + ((((x[4] << 25) | (x[4] >> 7)) ^ ((x[4] << 14) | (x[4] >> 18))) ^ (x[4] >> 3))) + x[3];
#line 546
      x[3] = tm;
#line 546
      t1 = (((e + ((((b << 26) | (b >> 6)) ^ ((b << 21) | (b >> 11))) ^ ((b << 7) | (b >> 25)))) + (d ^ (b & (c ^ d)))) + (uint32_t )sha256_round_constants[51]) + x[3];
#line 546
      a += t1;
#line 546
      e = t0 + t1;
#line 546
      break;
    }
#line 547
    while (1) {
#line 547
      t0 = ((((e << 30) | (e >> 2)) ^ ((e << 19) | (e >> 13))) ^ ((e << 10) | (e >> 22))) + ((e & f) | (g & (e | f)));
#line 547
      tm = ((((((x[2] << 15) | (x[2] >> 17)) ^ ((x[2] << 13) | (x[2] >> 19))) ^ (x[2] >> 10)) + x[13]) + ((((x[5] << 25) | (x[5] >> 7)) ^ ((x[5] << 14) | (x[5] >> 18))) ^ (x[5] >> 3))) + x[4];
#line 547
      x[4] = tm;
#line 547
      t1 = (((d + ((((a << 26) | (a >> 6)) ^ ((a << 21) | (a >> 11))) ^ ((a << 7) | (a >> 25)))) + (c ^ (a & (b ^ c)))) + (uint32_t )sha256_round_constants[52]) + x[4];
#line 547
      h += t1;
#line 547
      d = t0 + t1;
#line 547
      break;
    }
#line 548
    while (1) {
#line 548
      t0 = ((((d << 30) | (d >> 2)) ^ ((d << 19) | (d >> 13))) ^ ((d << 10) | (d >> 22))) + ((d & e) | (f & (d | e)));
#line 548
      tm = ((((((x[3] << 15) | (x[3] >> 17)) ^ ((x[3] << 13) | (x[3] >> 19))) ^ (x[3] >> 10)) + x[14]) + ((((x[6] << 25) | (x[6] >> 7)) ^ ((x[6] << 14) | (x[6] >> 18))) ^ (x[6] >> 3))) + x[5];
#line 548
      x[5] = tm;
#line 548
      t1 = (((c + ((((h << 26) | (h >> 6)) ^ ((h << 21) | (h >> 11))) ^ ((h << 7) | (h >> 25)))) + (b ^ (h & (a ^ b)))) + (uint32_t )sha256_round_constants[53]) + x[5];
#line 548
      g += t1;
#line 548
      c = t0 + t1;
#line 548
      break;
    }
#line 549
    while (1) {
#line 549
      t0 = ((((c << 30) | (c >> 2)) ^ ((c << 19) | (c >> 13))) ^ ((c << 10) | (c >> 22))) + ((c & d) | (e & (c | d)));
#line 549
      tm = ((((((x[4] << 15) | (x[4] >> 17)) ^ ((x[4] << 13) | (x[4] >> 19))) ^ (x[4] >> 10)) + x[15]) + ((((x[7] << 25) | (x[7] >> 7)) ^ ((x[7] << 14) | (x[7] >> 18))) ^ (x[7] >> 3))) + x[6];
#line 549
      x[6] = tm;
#line 549
      t1 = (((b + ((((g << 26) | (g >> 6)) ^ ((g << 21) | (g >> 11))) ^ ((g << 7) | (g >> 25)))) + (a ^ (g & (h ^ a)))) + (uint32_t )sha256_round_constants[54]) + x[6];
#line 549
      f += t1;
#line 549
      b = t0 + t1;
#line 549
      break;
    }
#line 550
    while (1) {
#line 550
      t0 = ((((b << 30) | (b >> 2)) ^ ((b << 19) | (b >> 13))) ^ ((b << 10) | (b >> 22))) + ((b & c) | (d & (b | c)));
#line 550
      tm = ((((((x[5] << 15) | (x[5] >> 17)) ^ ((x[5] << 13) | (x[5] >> 19))) ^ (x[5] >> 10)) + x[0]) + ((((x[8] << 25) | (x[8] >> 7)) ^ ((x[8] << 14) | (x[8] >> 18))) ^ (x[8] >> 3))) + x[7];
#line 550
      x[7] = tm;
#line 550
      t1 = (((a + ((((f << 26) | (f >> 6)) ^ ((f << 21) | (f >> 11))) ^ ((f << 7) | (f >> 25)))) + (h ^ (f & (g ^ h)))) + (uint32_t )sha256_round_constants[55]) + x[7];
#line 550
      e += t1;
#line 550
      a = t0 + t1;
#line 550
      break;
    }
#line 551
    while (1) {
#line 551
      t0 = ((((a << 30) | (a >> 2)) ^ ((a << 19) | (a >> 13))) ^ ((a << 10) | (a >> 22))) + ((a & b) | (c & (a | b)));
#line 551
      tm = ((((((x[6] << 15) | (x[6] >> 17)) ^ ((x[6] << 13) | (x[6] >> 19))) ^ (x[6] >> 10)) + x[1]) + ((((x[9] << 25) | (x[9] >> 7)) ^ ((x[9] << 14) | (x[9] >> 18))) ^ (x[9] >> 3))) + x[8];
#line 551
      x[8] = tm;
#line 551
      t1 = (((h + ((((e << 26) | (e >> 6)) ^ ((e << 21) | (e >> 11))) ^ ((e << 7) | (e >> 25)))) + (g ^ (e & (f ^ g)))) + (uint32_t )sha256_round_constants[56]) + x[8];
#line 551
      d += t1;
#line 551
      h = t0 + t1;
#line 551
      break;
    }
#line 552
    while (1) {
#line 552
      t0 = ((((h << 30) | (h >> 2)) ^ ((h << 19) | (h >> 13))) ^ ((h << 10) | (h >> 22))) + ((h & a) | (b & (h | a)));
#line 552
      tm = ((((((x[7] << 15) | (x[7] >> 17)) ^ ((x[7] << 13) | (x[7] >> 19))) ^ (x[7] >> 10)) + x[2]) + ((((x[10] << 25) | (x[10] >> 7)) ^ ((x[10] << 14) | (x[10] >> 18))) ^ (x[10] >> 3))) + x[9];
#line 552
      x[9] = tm;
#line 552
      t1 = (((g + ((((d << 26) | (d >> 6)) ^ ((d << 21) | (d >> 11))) ^ ((d << 7) | (d >> 25)))) + (f ^ (d & (e ^ f)))) + (uint32_t )sha256_round_constants[57]) + x[9];
#line 552
      c += t1;
#line 552
      g = t0 + t1;
#line 552
      break;
    }
#line 553
    while (1) {
#line 553
      t0 = ((((g << 30) | (g >> 2)) ^ ((g << 19) | (g >> 13))) ^ ((g << 10) | (g >> 22))) + ((g & h) | (a & (g | h)));
#line 553
      tm = ((((((x[8] << 15) | (x[8] >> 17)) ^ ((x[8] << 13) | (x[8] >> 19))) ^ (x[8] >> 10)) + x[3]) + ((((x[11] << 25) | (x[11] >> 7)) ^ ((x[11] << 14) | (x[11] >> 18))) ^ (x[11] >> 3))) + x[10];
#line 553
      x[10] = tm;
#line 553
      t1 = (((f + ((((c << 26) | (c >> 6)) ^ ((c << 21) | (c >> 11))) ^ ((c << 7) | (c >> 25)))) + (e ^ (c & (d ^ e)))) + (uint32_t )sha256_round_constants[58]) + x[10];
#line 553
      b += t1;
#line 553
      f = t0 + t1;
#line 553
      break;
    }
#line 554
    while (1) {
#line 554
      t0 = ((((f << 30) | (f >> 2)) ^ ((f << 19) | (f >> 13))) ^ ((f << 10) | (f >> 22))) + ((f & g) | (h & (f | g)));
#line 554
      tm = ((((((x[9] << 15) | (x[9] >> 17)) ^ ((x[9] << 13) | (x[9] >> 19))) ^ (x[9] >> 10)) + x[4]) + ((((x[12] << 25) | (x[12] >> 7)) ^ ((x[12] << 14) | (x[12] >> 18))) ^ (x[12] >> 3))) + x[11];
#line 554
      x[11] = tm;
#line 554
      t1 = (((e + ((((b << 26) | (b >> 6)) ^ ((b << 21) | (b >> 11))) ^ ((b << 7) | (b >> 25)))) + (d ^ (b & (c ^ d)))) + (uint32_t )sha256_round_constants[59]) + x[11];
#line 554
      a += t1;
#line 554
      e = t0 + t1;
#line 554
      break;
    }
#line 555
    while (1) {
#line 555
      t0 = ((((e << 30) | (e >> 2)) ^ ((e << 19) | (e >> 13))) ^ ((e << 10) | (e >> 22))) + ((e & f) | (g & (e | f)));
#line 555
      tm = ((((((x[10] << 15) | (x[10] >> 17)) ^ ((x[10] << 13) | (x[10] >> 19))) ^ (x[10] >> 10)) + x[5]) + ((((x[13] << 25) | (x[13] >> 7)) ^ ((x[13] << 14) | (x[13] >> 18))) ^ (x[13] >> 3))) + x[12];
#line 555
      x[12] = tm;
#line 555
      t1 = (((d + ((((a << 26) | (a >> 6)) ^ ((a << 21) | (a >> 11))) ^ ((a << 7) | (a >> 25)))) + (c ^ (a & (b ^ c)))) + (uint32_t )sha256_round_constants[60]) + x[12];
#line 555
      h += t1;
#line 555
      d = t0 + t1;
#line 555
      break;
    }
#line 556
    while (1) {
#line 556
      t0 = ((((d << 30) | (d >> 2)) ^ ((d << 19) | (d >> 13))) ^ ((d << 10) | (d >> 22))) + ((d & e) | (f & (d | e)));
#line 556
      tm = ((((((x[11] << 15) | (x[11] >> 17)) ^ ((x[11] << 13) | (x[11] >> 19))) ^ (x[11] >> 10)) + x[6]) + ((((x[14] << 25) | (x[14] >> 7)) ^ ((x[14] << 14) | (x[14] >> 18))) ^ (x[14] >> 3))) + x[13];
#line 556
      x[13] = tm;
#line 556
      t1 = (((c + ((((h << 26) | (h >> 6)) ^ ((h << 21) | (h >> 11))) ^ ((h << 7) | (h >> 25)))) + (b ^ (h & (a ^ b)))) + (uint32_t )sha256_round_constants[61]) + x[13];
#line 556
      g += t1;
#line 556
      c = t0 + t1;
#line 556
      break;
    }
#line 557
    while (1) {
#line 557
      t0 = ((((c << 30) | (c >> 2)) ^ ((c << 19) | (c >> 13))) ^ ((c << 10) | (c >> 22))) + ((c & d) | (e & (c | d)));
#line 557
      tm = ((((((x[12] << 15) | (x[12] >> 17)) ^ ((x[12] << 13) | (x[12] >> 19))) ^ (x[12] >> 10)) + x[7]) + ((((x[15] << 25) | (x[15] >> 7)) ^ ((x[15] << 14) | (x[15] >> 18))) ^ (x[15] >> 3))) + x[14];
#line 557
      x[14] = tm;
#line 557
      t1 = (((b + ((((g << 26) | (g >> 6)) ^ ((g << 21) | (g >> 11))) ^ ((g << 7) | (g >> 25)))) + (a ^ (g & (h ^ a)))) + (uint32_t )sha256_round_constants[62]) + x[14];
#line 557
      f += t1;
#line 557
      b = t0 + t1;
#line 557
      break;
    }
#line 558
    while (1) {
#line 558
      t0 = ((((b << 30) | (b >> 2)) ^ ((b << 19) | (b >> 13))) ^ ((b << 10) | (b >> 22))) + ((b & c) | (d & (b | c)));
#line 558
      tm = ((((((x[13] << 15) | (x[13] >> 17)) ^ ((x[13] << 13) | (x[13] >> 19))) ^ (x[13] >> 10)) + x[8]) + ((((x[0] << 25) | (x[0] >> 7)) ^ ((x[0] << 14) | (x[0] >> 18))) ^ (x[0] >> 3))) + x[15];
#line 558
      x[15] = tm;
#line 558
      t1 = (((a + ((((f << 26) | (f >> 6)) ^ ((f << 21) | (f >> 11))) ^ ((f << 7) | (f >> 25)))) + (h ^ (f & (g ^ h)))) + (uint32_t )sha256_round_constants[63]) + x[15];
#line 558
      e += t1;
#line 558
      a = t0 + t1;
#line 558
      break;
    }
#line 560
    tmp = ctx->state[0] + a;
#line 560
    ctx->state[0] = tmp;
#line 560
    a = tmp;
#line 561
    tmp___0 = ctx->state[1] + b;
#line 561
    ctx->state[1] = tmp___0;
#line 561
    b = tmp___0;
#line 562
    tmp___1 = ctx->state[2] + c;
#line 562
    ctx->state[2] = tmp___1;
#line 562
    c = tmp___1;
#line 563
    tmp___2 = ctx->state[3] + d;
#line 563
    ctx->state[3] = tmp___2;
#line 563
    d = tmp___2;
#line 564
    tmp___3 = ctx->state[4] + e;
#line 564
    ctx->state[4] = tmp___3;
#line 564
    e = tmp___3;
#line 565
    tmp___4 = ctx->state[5] + f;
#line 565
    ctx->state[5] = tmp___4;
#line 565
    f = tmp___4;
#line 566
    tmp___5 = ctx->state[6] + g;
#line 566
    ctx->state[6] = tmp___5;
#line 566
    g = tmp___5;
#line 567
    tmp___6 = ctx->state[7] + h;
#line 567
    ctx->state[7] = tmp___6;
#line 567
    h = tmp___6;
  }
#line 569
  return;
}
}
#line 1 "sha512.o"
#pragma merger(0,"/tmp/cil-MC9W5KA8.i","-g,-O2")
#line 43 "sha512.h"
void sha512_init_ctx(struct sha512_ctx *ctx ) ;
#line 44
void sha384_init_ctx(struct sha512_ctx *ctx ) ;
#line 50
void sha512_process_block(void const   *buffer , size_t len , struct sha512_ctx *ctx ) ;
#line 57
void sha512_process_bytes(void const   *buffer , size_t len , struct sha512_ctx *ctx ) ;
#line 64
void *sha512_finish_ctx(struct sha512_ctx *ctx , void *resbuf ) ;
#line 65
void *sha384_finish_ctx(struct sha512_ctx *ctx , void *resbuf ) ;
#line 74
void *sha512_read_ctx(struct sha512_ctx  const  *ctx , void *resbuf ) ;
#line 75
void *sha384_read_ctx(struct sha512_ctx  const  *ctx , void *resbuf ) ;
#line 81
int sha512_stream(FILE *stream , void *resblock ) ;
#line 82
int sha384_stream(FILE *stream , void *resblock ) ;
#line 88
void *sha512_buffer(char const   *buffer , size_t len , void *resblock ) ;
#line 89
void *sha384_buffer(char const   *buffer , size_t len , void *resblock ) ;
#line 56 "sha512.c"
static unsigned char const   fillbuf___2[128]  = {      (unsigned char const   )128,      (unsigned char const   )0};
#line 64 "sha512.c"
void sha512_init_ctx(struct sha512_ctx *ctx ) 
{ u64 tmp ;

  {
#line 67
  ctx->state[0] = (1779033703UL << 32) + 4089235720UL;
#line 68
  ctx->state[1] = (3144134277UL << 32) + 2227873595UL;
#line 69
  ctx->state[2] = (1013904242UL << 32) + 4271175723UL;
#line 70
  ctx->state[3] = (2773480762UL << 32) + 1595750129UL;
#line 71
  ctx->state[4] = (1359893119UL << 32) + 2917565137UL;
#line 72
  ctx->state[5] = (2600822924UL << 32) + 725511199UL;
#line 73
  ctx->state[6] = (528734635UL << 32) + 4215389547UL;
#line 74
  ctx->state[7] = (1541459225UL << 32) + 327033209UL;
#line 76
  tmp = (u64 )0;
#line 76
  ctx->total[1] = tmp;
#line 76
  ctx->total[0] = tmp;
#line 77
  ctx->buflen = (size_t )0;
#line 78
  return;
}
}
#line 80 "sha512.c"
void sha384_init_ctx(struct sha512_ctx *ctx ) 
{ u64 tmp ;

  {
#line 83
  ctx->state[0] = (3418070365UL << 32) + 3238371032UL;
#line 84
  ctx->state[1] = (1654270250UL << 32) + 914150663UL;
#line 85
  ctx->state[2] = (2438529370UL << 32) + 812702999UL;
#line 86
  ctx->state[3] = (355462360UL << 32) + 4144912697UL;
#line 87
  ctx->state[4] = (1731405415UL << 32) + 4290775857UL;
#line 88
  ctx->state[5] = (2394180231UL << 32) + 1750603025UL;
#line 89
  ctx->state[6] = (3675008525UL << 32) + 1694076839UL;
#line 90
  ctx->state[7] = (1203062813UL << 32) + 3204075428UL;
#line 92
  tmp = (u64 )0;
#line 92
  ctx->total[1] = tmp;
#line 92
  ctx->total[0] = tmp;
#line 93
  ctx->buflen = (size_t )0;
#line 94
  return;
}
}
#line 99 "sha512.c"
__inline static void set_uint64(char *cp , u64 v ) 
{ 

  {
#line 102
  memcpy((void * __restrict  )cp, (void const   * __restrict  )(& v), sizeof(v));
#line 103
  return;
}
}
#line 107 "sha512.c"
void *sha512_read_ctx(struct sha512_ctx  const  *ctx , void *resbuf ) 
{ int i ;
  char *r ;

  {
#line 111
  r = (char *)resbuf;
#line 113
  i = 0;
#line 113
  while (i < 8) {
#line 114
    set_uint64(r + (unsigned long )i * sizeof(ctx->state[0]), (((ctx->state[i] << 56) | ((ctx->state[i] & 65280UL) << 40)) | (((ctx->state[i] & 16711680UL) << 24) | ((ctx->state[i] & 4278190080UL) << 8))) | ((((ctx->state[i] >> 8) & 4278190080UL) | ((ctx->state[i] >> 24) & 16711680UL)) | (((ctx->state[i] >> 40) & 65280UL) | (ctx->state[i] >> 56))));
#line 113
    i ++;
  }
#line 116
  return (resbuf);
}
}
#line 119 "sha512.c"
void *sha384_read_ctx(struct sha512_ctx  const  *ctx , void *resbuf ) 
{ int i ;
  char *r ;

  {
#line 123
  r = (char *)resbuf;
#line 125
  i = 0;
#line 125
  while (i < 6) {
#line 126
    set_uint64(r + (unsigned long )i * sizeof(ctx->state[0]), (((ctx->state[i] << 56) | ((ctx->state[i] & 65280UL) << 40)) | (((ctx->state[i] & 16711680UL) << 24) | ((ctx->state[i] & 4278190080UL) << 8))) | ((((ctx->state[i] >> 8) & 4278190080UL) | ((ctx->state[i] >> 24) & 16711680UL)) | (((ctx->state[i] >> 40) & 65280UL) | (ctx->state[i] >> 56))));
#line 125
    i ++;
  }
#line 128
  return (resbuf);
}
}
#line 133 "sha512.c"
static void sha512_conclude_ctx(struct sha512_ctx *ctx ) 
{ size_t bytes ;
  size_t size ;
  int tmp ;

  {
#line 137
  bytes = ctx->buflen;
#line 138
  if (bytes < 112UL) {
#line 138
    tmp = 16;
  } else {
#line 138
    tmp = 32;
  }
#line 138
  size = (size_t )tmp;
#line 141
  ctx->total[0] += bytes;
#line 142
  if (ctx->total[0] < bytes) {
#line 143
    (ctx->total[1]) ++;
  }
#line 148
  set_uint64((char *)(& ctx->buffer[size - 2UL]), (((((ctx->total[1] << 3) | (ctx->total[0] >> 61)) << 56) | ((((ctx->total[1] << 3) | (ctx->total[0] >> 61)) & 65280UL) << 40)) | (((((ctx->total[1] << 3) | (ctx->total[0] >> 61)) & 16711680UL) << 24) | ((((ctx->total[1] << 3) | (ctx->total[0] >> 61)) & 4278190080UL) << 8))) | ((((((ctx->total[1] << 3) | (ctx->total[0] >> 61)) >> 8) & 4278190080UL) | ((((ctx->total[1] << 3) | (ctx->total[0] >> 61)) >> 24) & 16711680UL)) | (((((ctx->total[1] << 3) | (ctx->total[0] >> 61)) >> 40) & 65280UL) | (((ctx->total[1] << 3) | (ctx->total[0] >> 61)) >> 56))));
#line 151
  set_uint64((char *)(& ctx->buffer[size - 1UL]), ((((ctx->total[0] << 3) << 56) | (((ctx->total[0] << 3) & 65280UL) << 40)) | ((((ctx->total[0] << 3) & 16711680UL) << 24) | (((ctx->total[0] << 3) & 4278190080UL) << 8))) | (((((ctx->total[0] << 3) >> 8) & 4278190080UL) | (((ctx->total[0] << 3) >> 24) & 16711680UL)) | ((((ctx->total[0] << 3) >> 40) & 65280UL) | ((ctx->total[0] << 3) >> 56))));
#line 154
  memcpy((void * __restrict  )((char *)(ctx->buffer) + bytes), (void const   * __restrict  )(fillbuf___2),
         (size - 2UL) * 8UL - bytes);
#line 157
  sha512_process_block((void const   *)(ctx->buffer), size * 8UL, ctx);
#line 158
  return;
}
}
#line 160 "sha512.c"
void *sha512_finish_ctx(struct sha512_ctx *ctx , void *resbuf ) 
{ void *tmp ;

  {
#line 163
  sha512_conclude_ctx(ctx);
#line 164
  tmp = sha512_read_ctx((struct sha512_ctx  const  *)ctx, resbuf);
#line 164
  return (tmp);
}
}
#line 167 "sha512.c"
void *sha384_finish_ctx(struct sha512_ctx *ctx , void *resbuf ) 
{ void *tmp ;

  {
#line 170
  sha512_conclude_ctx(ctx);
#line 171
  tmp = sha384_read_ctx((struct sha512_ctx  const  *)ctx, resbuf);
#line 171
  return (tmp);
}
}
#line 177 "sha512.c"
int sha512_stream(FILE *stream , void *resblock ) 
{ struct sha512_ctx ctx ;
  size_t sum ;
  char *buffer ;
  void *tmp ;
  size_t n ;
  size_t __attribute__((__artificial__))  tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t __attribute__((__artificial__))  tmp___3 ;

  {
#line 183
  tmp = malloc((size_t )32840);
#line 183
  buffer = (char *)tmp;
#line 184
  if (! buffer) {
#line 185
    return (1);
  }
#line 188
  sha512_init_ctx(& ctx);
#line 191
  while (1) {
#line 197
    sum = (size_t )0;
#line 200
    while (1) {
#line 202
      tmp___3 = (size_t __attribute__((__artificial__))  )fread_unlocked((void * __restrict  )(buffer + sum),
                                                                         (size_t )1,
                                                                         32768UL - sum,
                                                                         (FILE * __restrict  )stream);
#line 202
      tmp___0 = tmp___3;
#line 202
      n = (size_t )tmp___0;
#line 204
      sum += n;
#line 206
      if (sum == 32768UL) {
#line 207
        break;
      }
#line 209
      if (n == 0UL) {
#line 214
        tmp___1 = ferror_unlocked(stream);
#line 214
        if (tmp___1) {
#line 216
          free((void *)buffer);
#line 217
          return (1);
        }
#line 219
        goto process_partial_block;
      }
#line 225
      tmp___2 = feof_unlocked(stream);
#line 225
      if (tmp___2) {
#line 226
        goto process_partial_block;
      }
    }
#line 232
    sha512_process_block((void const   *)buffer, (size_t )32768, & ctx);
  }
  process_partial_block: ;
#line 238
  if (sum > 0UL) {
#line 239
    sha512_process_bytes((void const   *)buffer, sum, & ctx);
  }
#line 242
  sha512_finish_ctx(& ctx, resblock);
#line 243
  free((void *)buffer);
#line 244
  return (0);
}
}
#line 248 "sha512.c"
int sha384_stream(FILE *stream , void *resblock ) 
{ struct sha512_ctx ctx ;
  size_t sum ;
  char *buffer ;
  void *tmp ;
  size_t n ;
  size_t __attribute__((__artificial__))  tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t __attribute__((__artificial__))  tmp___3 ;

  {
#line 254
  tmp = malloc((size_t )32840);
#line 254
  buffer = (char *)tmp;
#line 255
  if (! buffer) {
#line 256
    return (1);
  }
#line 259
  sha384_init_ctx(& ctx);
#line 262
  while (1) {
#line 268
    sum = (size_t )0;
#line 271
    while (1) {
#line 273
      tmp___3 = (size_t __attribute__((__artificial__))  )fread_unlocked((void * __restrict  )(buffer + sum),
                                                                         (size_t )1,
                                                                         32768UL - sum,
                                                                         (FILE * __restrict  )stream);
#line 273
      tmp___0 = tmp___3;
#line 273
      n = (size_t )tmp___0;
#line 275
      sum += n;
#line 277
      if (sum == 32768UL) {
#line 278
        break;
      }
#line 280
      if (n == 0UL) {
#line 285
        tmp___1 = ferror_unlocked(stream);
#line 285
        if (tmp___1) {
#line 287
          free((void *)buffer);
#line 288
          return (1);
        }
#line 290
        goto process_partial_block;
      }
#line 296
      tmp___2 = feof_unlocked(stream);
#line 296
      if (tmp___2) {
#line 297
        goto process_partial_block;
      }
    }
#line 303
    sha512_process_block((void const   *)buffer, (size_t )32768, & ctx);
  }
  process_partial_block: ;
#line 309
  if (sum > 0UL) {
#line 310
    sha512_process_bytes((void const   *)buffer, sum, & ctx);
  }
#line 313
  sha384_finish_ctx(& ctx, resblock);
#line 314
  free((void *)buffer);
#line 315
  return (0);
}
}
#line 322 "sha512.c"
void *sha512_buffer(char const   *buffer , size_t len , void *resblock ) 
{ struct sha512_ctx ctx ;
  void *tmp ;

  {
#line 328
  sha512_init_ctx(& ctx);
#line 331
  sha512_process_bytes((void const   *)buffer, len, & ctx);
#line 334
  tmp = sha512_finish_ctx(& ctx, resblock);
#line 334
  return (tmp);
}
}
#line 337 "sha512.c"
void *sha384_buffer(char const   *buffer , size_t len , void *resblock ) 
{ struct sha512_ctx ctx ;
  void *tmp ;

  {
#line 343
  sha384_init_ctx(& ctx);
#line 346
  sha512_process_bytes((void const   *)buffer, len, & ctx);
#line 349
  tmp = sha384_finish_ctx(& ctx, resblock);
#line 349
  return (tmp);
}
}
#line 352 "sha512.c"
void sha512_process_bytes(void const   *buffer , size_t len , struct sha512_ctx *ctx ) 
{ size_t left_over ;
  size_t add ;
  size_t tmp ;
  size_t left_over___0 ;

  {
#line 357
  if (ctx->buflen != 0UL) {
#line 359
    left_over = ctx->buflen;
#line 360
    if (256UL - left_over > len) {
#line 360
      tmp = len;
    } else {
#line 360
      tmp = 256UL - left_over;
    }
#line 360
    add = tmp;
#line 362
    memcpy((void * __restrict  )((char *)(ctx->buffer) + left_over), (void const   * __restrict  )buffer,
           add);
#line 363
    ctx->buflen += add;
#line 365
    if (ctx->buflen > 128UL) {
#line 367
      sha512_process_block((void const   *)(ctx->buffer), ctx->buflen & 0xffffffffffffff80UL,
                           ctx);
#line 369
      ctx->buflen &= 127UL;
#line 371
      memcpy((void * __restrict  )(ctx->buffer), (void const   * __restrict  )((char *)(ctx->buffer) + ((left_over + add) & 0xffffffffffffff80UL)),
             ctx->buflen);
    }
#line 376
    buffer = (void const   *)((char const   *)buffer + add);
#line 377
    len -= add;
  }
#line 381
  if (len >= 128UL) {
#line 396
    sha512_process_block(buffer, len & 0xffffffffffffff80UL, ctx);
#line 397
    buffer = (void const   *)((char const   *)buffer + (len & 0xffffffffffffff80UL));
#line 398
    len &= 127UL;
  }
#line 403
  if (len > 0UL) {
#line 405
    left_over___0 = ctx->buflen;
#line 407
    memcpy((void * __restrict  )((char *)(ctx->buffer) + left_over___0), (void const   * __restrict  )buffer,
           len);
#line 408
    left_over___0 += len;
#line 409
    if (left_over___0 >= 128UL) {
#line 411
      sha512_process_block((void const   *)(ctx->buffer), (size_t )128, ctx);
#line 412
      left_over___0 -= 128UL;
#line 413
      memcpy((void * __restrict  )(ctx->buffer), (void const   * __restrict  )(& ctx->buffer[16]),
             left_over___0);
    }
#line 415
    ctx->buflen = left_over___0;
  }
#line 417
  return;
}
}
#line 423 "sha512.c"
static u64 const   sha512_round_constants[80]  = 
#line 423
  {      (u64 const   )((1116352408UL << 32) + 3609767458UL),      (u64 const   )((1899447441UL << 32) + 602891725UL),      (u64 const   )((3049323471UL << 32) + 3964484399UL),      (u64 const   )((3921009573UL << 32) + 2173295548UL), 
        (u64 const   )((961987163UL << 32) + 4081628472UL),      (u64 const   )((1508970993UL << 32) + 3053834265UL),      (u64 const   )((2453635748UL << 32) + 2937671579UL),      (u64 const   )((2870763221UL << 32) + 3664609560UL), 
        (u64 const   )((3624381080UL << 32) + 2734883394UL),      (u64 const   )((310598401UL << 32) + 1164996542UL),      (u64 const   )((607225278UL << 32) + 1323610764UL),      (u64 const   )((1426881987UL << 32) + 3590304994UL), 
        (u64 const   )((1925078388UL << 32) + 4068182383UL),      (u64 const   )((2162078206UL << 32) + 991336113UL),      (u64 const   )((2614888103UL << 32) + 633803317UL),      (u64 const   )((3248222580UL << 32) + 3479774868UL), 
        (u64 const   )((3835390401UL << 32) + 2666613458UL),      (u64 const   )((4022224774UL << 32) + 944711139UL),      (u64 const   )((264347078UL << 32) + 2341262773UL),      (u64 const   )((604807628UL << 32) + 2007800933UL), 
        (u64 const   )((770255983UL << 32) + 1495990901UL),      (u64 const   )((1249150122UL << 32) + 1856431235UL),      (u64 const   )((1555081692UL << 32) + 3175218132UL),      (u64 const   )((1996064986UL << 32) + 2198950837UL), 
        (u64 const   )((2554220882UL << 32) + 3999719339UL),      (u64 const   )((2821834349UL << 32) + 766784016UL),      (u64 const   )((2952996808UL << 32) + 2566594879UL),      (u64 const   )((3210313671UL << 32) + 3203337956UL), 
        (u64 const   )((3336571891UL << 32) + 1034457026UL),      (u64 const   )((3584528711UL << 32) + 2466948901UL),      (u64 const   )((113926993UL << 32) + 3758326383UL),      (u64 const   )((338241895UL << 32) + 168717936UL), 
        (u64 const   )((666307205UL << 32) + 1188179964UL),      (u64 const   )((773529912UL << 32) + 1546045734UL),      (u64 const   )((1294757372UL << 32) + 1522805485UL),      (u64 const   )((1396182291UL << 32) + 2643833823UL), 
        (u64 const   )((1695183700UL << 32) + 2343527390UL),      (u64 const   )((1986661051UL << 32) + 1014477480UL),      (u64 const   )((2177026350UL << 32) + 1206759142UL),      (u64 const   )((2456956037UL << 32) + 344077627UL), 
        (u64 const   )((2730485921UL << 32) + 1290863460UL),      (u64 const   )((2820302411UL << 32) + 3158454273UL),      (u64 const   )((3259730800UL << 32) + 3505952657UL),      (u64 const   )((3345764771UL << 32) + 106217008UL), 
        (u64 const   )((3516065817UL << 32) + 3606008344UL),      (u64 const   )((3600352804UL << 32) + 1432725776UL),      (u64 const   )((4094571909UL << 32) + 1467031594UL),      (u64 const   )((275423344UL << 32) + 851169720UL), 
        (u64 const   )((430227734UL << 32) + 3100823752UL),      (u64 const   )((506948616UL << 32) + 1363258195UL),      (u64 const   )((659060556UL << 32) + 3750685593UL),      (u64 const   )((883997877UL << 32) + 3785050280UL), 
        (u64 const   )((958139571UL << 32) + 3318307427UL),      (u64 const   )((1322822218UL << 32) + 3812723403UL),      (u64 const   )((1537002063UL << 32) + 2003034995UL),      (u64 const   )((1747873779UL << 32) + 3602036899UL), 
        (u64 const   )((1955562222UL << 32) + 1575990012UL),      (u64 const   )((2024104815UL << 32) + 1125592928UL),      (u64 const   )((2227730452UL << 32) + 2716904306UL),      (u64 const   )((2361852424UL << 32) + 442776044UL), 
        (u64 const   )((2428436474UL << 32) + 593698344UL),      (u64 const   )((2756734187UL << 32) + 3733110249UL),      (u64 const   )((3204031479UL << 32) + 2999351573UL),      (u64 const   )((3329325298UL << 32) + 3815920427UL), 
        (u64 const   )((3391569614UL << 32) + 3928383900UL),      (u64 const   )((3515267271UL << 32) + 566280711UL),      (u64 const   )((3940187606UL << 32) + 3454069534UL),      (u64 const   )((4118630271UL << 32) + 4000239992UL), 
        (u64 const   )((116418474UL << 32) + 1914138554UL),      (u64 const   )((174292421UL << 32) + 2731055270UL),      (u64 const   )((289380356UL << 32) + 3203993006UL),      (u64 const   )((460393269UL << 32) + 320620315UL), 
        (u64 const   )((685471733UL << 32) + 587496836UL),      (u64 const   )((852142971UL << 32) + 1086792851UL),      (u64 const   )((1017036298UL << 32) + 365543100UL),      (u64 const   )((1126000580UL << 32) + 2618297676UL), 
        (u64 const   )((1288033470UL << 32) + 3409855158UL),      (u64 const   )((1501505948UL << 32) + 4234509866UL),      (u64 const   )((1607167915UL << 32) + 987167468UL),      (u64 const   )((1816402316UL << 32) + 1246189591UL)};
#line 474 "sha512.c"
void sha512_process_block(void const   *buffer , size_t len , struct sha512_ctx *ctx ) 
{ u64 const   *words ;
  u64 const   *endp ;
  u64 x[16] ;
  u64 a ;
  u64 b ;
  u64 c ;
  u64 d ;
  u64 e ;
  u64 f ;
  u64 g ;
  u64 h ;
  int t ;
  u64 t0 ;
  u64 t1 ;
  u64 t0___0 ;
  u64 t1___0 ;
  u64 t0___1 ;
  u64 t1___1 ;
  u64 t0___2 ;
  u64 t1___2 ;
  u64 t0___3 ;
  u64 t1___3 ;
  u64 t0___4 ;
  u64 t1___4 ;
  u64 t0___5 ;
  u64 t1___5 ;
  u64 t0___6 ;
  u64 t1___6 ;
  u64 t0___7 ;
  u64 t1___7 ;
  u64 t0___8 ;
  u64 t1___8 ;
  u64 t0___9 ;
  u64 t1___9 ;
  u64 t0___10 ;
  u64 t1___10 ;
  u64 t0___11 ;
  u64 t1___11 ;
  u64 t0___12 ;
  u64 t1___12 ;
  u64 t0___13 ;
  u64 t1___13 ;
  u64 t0___14 ;
  u64 t1___14 ;
  u64 t0___15 ;
  u64 t1___15 ;
  u64 t0___16 ;
  u64 t1___16 ;
  u64 t0___17 ;
  u64 t1___17 ;
  u64 t0___18 ;
  u64 t1___18 ;
  u64 t0___19 ;
  u64 t1___19 ;
  u64 t0___20 ;
  u64 t1___20 ;
  u64 t0___21 ;
  u64 t1___21 ;
  u64 t0___22 ;
  u64 t1___22 ;
  u64 t0___23 ;
  u64 t1___23 ;
  u64 t0___24 ;
  u64 t1___24 ;
  u64 t0___25 ;
  u64 t1___25 ;
  u64 t0___26 ;
  u64 t1___26 ;
  u64 t0___27 ;
  u64 t1___27 ;
  u64 t0___28 ;
  u64 t1___28 ;
  u64 t0___29 ;
  u64 t1___29 ;
  u64 t0___30 ;
  u64 t1___30 ;
  u64 t0___31 ;
  u64 t1___31 ;
  u64 t0___32 ;
  u64 t1___32 ;
  u64 t0___33 ;
  u64 t1___33 ;
  u64 t0___34 ;
  u64 t1___34 ;
  u64 t0___35 ;
  u64 t1___35 ;
  u64 t0___36 ;
  u64 t1___36 ;
  u64 t0___37 ;
  u64 t1___37 ;
  u64 t0___38 ;
  u64 t1___38 ;
  u64 t0___39 ;
  u64 t1___39 ;
  u64 t0___40 ;
  u64 t1___40 ;
  u64 t0___41 ;
  u64 t1___41 ;
  u64 t0___42 ;
  u64 t1___42 ;
  u64 t0___43 ;
  u64 t1___43 ;
  u64 t0___44 ;
  u64 t1___44 ;
  u64 t0___45 ;
  u64 t1___45 ;
  u64 t0___46 ;
  u64 t1___46 ;
  u64 t0___47 ;
  u64 t1___47 ;
  u64 t0___48 ;
  u64 t1___48 ;
  u64 t0___49 ;
  u64 t1___49 ;
  u64 t0___50 ;
  u64 t1___50 ;
  u64 t0___51 ;
  u64 t1___51 ;
  u64 t0___52 ;
  u64 t1___52 ;
  u64 t0___53 ;
  u64 t1___53 ;
  u64 t0___54 ;
  u64 t1___54 ;
  u64 t0___55 ;
  u64 t1___55 ;
  u64 t0___56 ;
  u64 t1___56 ;
  u64 t0___57 ;
  u64 t1___57 ;
  u64 t0___58 ;
  u64 t1___58 ;
  u64 t0___59 ;
  u64 t1___59 ;
  u64 t0___60 ;
  u64 t1___60 ;
  u64 t0___61 ;
  u64 t1___61 ;
  u64 t0___62 ;
  u64 t1___62 ;
  u64 t0___63 ;
  u64 t1___63 ;
  u64 t0___64 ;
  u64 t1___64 ;
  u64 t0___65 ;
  u64 t1___65 ;
  u64 t0___66 ;
  u64 t1___66 ;
  u64 t0___67 ;
  u64 t1___67 ;
  u64 t0___68 ;
  u64 t1___68 ;
  u64 t0___69 ;
  u64 t1___69 ;
  u64 t0___70 ;
  u64 t1___70 ;
  u64 t0___71 ;
  u64 t1___71 ;
  u64 t0___72 ;
  u64 t1___72 ;
  u64 t0___73 ;
  u64 t1___73 ;
  u64 t0___74 ;
  u64 t1___74 ;
  u64 t0___75 ;
  u64 t1___75 ;
  u64 t0___76 ;
  u64 t1___76 ;
  u64 t0___77 ;
  u64 t1___77 ;
  u64 t0___78 ;
  u64 t1___78 ;
  u64 tmp ;
  u64 tmp___0 ;
  u64 tmp___1 ;
  u64 tmp___2 ;
  u64 tmp___3 ;
  u64 tmp___4 ;
  u64 tmp___5 ;
  u64 tmp___6 ;

  {
#line 477
  words = (u64 const   *)buffer;
#line 478
  endp = words + len / sizeof(u64 );
#line 480
  a = ctx->state[0];
#line 481
  b = ctx->state[1];
#line 482
  c = ctx->state[2];
#line 483
  d = ctx->state[3];
#line 484
  e = ctx->state[4];
#line 485
  f = ctx->state[5];
#line 486
  g = ctx->state[6];
#line 487
  h = ctx->state[7];
#line 492
  ctx->total[0] += len;
#line 493
  if (ctx->total[0] < len) {
#line 494
    (ctx->total[1]) ++;
  }
#line 519
  while ((unsigned long )words < (unsigned long )endp) {
#line 523
    t = 0;
#line 523
    while (t < 16) {
#line 525
      x[t] = (u64 )((((*words << 56) | ((*words & 65280UL) << 40)) | (((*words & 16711680UL) << 24) | ((*words & 4278190080UL) << 8))) | ((((*words >> 8) & 4278190080UL) | ((*words >> 24) & 16711680UL)) | (((*words >> 40) & 65280UL) | (*words >> 56))));
#line 526
      words ++;
#line 523
      t ++;
    }
#line 529
    while (1) {
#line 529
      t0 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
#line 529
      t1 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long )(sha512_round_constants[0] + (u64 const   )x[0])));
#line 529
      d += t1;
#line 529
      h = t0 + t1;
#line 529
      break;
    }
#line 530
    while (1) {
#line 530
      t0___0 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
#line 530
      t1___0 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long )(sha512_round_constants[1] + (u64 const   )x[1])));
#line 530
      c += t1___0;
#line 530
      g = t0___0 + t1___0;
#line 530
      break;
    }
#line 531
    while (1) {
#line 531
      t0___1 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
#line 531
      t1___1 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long )(sha512_round_constants[2] + (u64 const   )x[2])));
#line 531
      b += t1___1;
#line 531
      f = t0___1 + t1___1;
#line 531
      break;
    }
#line 532
    while (1) {
#line 532
      t0___2 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
#line 532
      t1___2 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long )(sha512_round_constants[3] + (u64 const   )x[3])));
#line 532
      a += t1___2;
#line 532
      e = t0___2 + t1___2;
#line 532
      break;
    }
#line 533
    while (1) {
#line 533
      t0___3 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
#line 533
      t1___3 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long )(sha512_round_constants[4] + (u64 const   )x[4])));
#line 533
      h += t1___3;
#line 533
      d = t0___3 + t1___3;
#line 533
      break;
    }
#line 534
    while (1) {
#line 534
      t0___4 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
#line 534
      t1___4 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long )(sha512_round_constants[5] + (u64 const   )x[5])));
#line 534
      g += t1___4;
#line 534
      c = t0___4 + t1___4;
#line 534
      break;
    }
#line 535
    while (1) {
#line 535
      t0___5 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
#line 535
      t1___5 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long )(sha512_round_constants[6] + (u64 const   )x[6])));
#line 535
      f += t1___5;
#line 535
      b = t0___5 + t1___5;
#line 535
      break;
    }
#line 536
    while (1) {
#line 536
      t0___6 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
#line 536
      t1___6 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long )(sha512_round_constants[7] + (u64 const   )x[7])));
#line 536
      e += t1___6;
#line 536
      a = t0___6 + t1___6;
#line 536
      break;
    }
#line 537
    while (1) {
#line 537
      t0___7 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
#line 537
      t1___7 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long )(sha512_round_constants[8] + (u64 const   )x[8])));
#line 537
      d += t1___7;
#line 537
      h = t0___7 + t1___7;
#line 537
      break;
    }
#line 538
    while (1) {
#line 538
      t0___8 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
#line 538
      t1___8 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long )(sha512_round_constants[9] + (u64 const   )x[9])));
#line 538
      c += t1___8;
#line 538
      g = t0___8 + t1___8;
#line 538
      break;
    }
#line 539
    while (1) {
#line 539
      t0___9 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
#line 539
      t1___9 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long )(sha512_round_constants[10] + (u64 const   )x[10])));
#line 539
      b += t1___9;
#line 539
      f = t0___9 + t1___9;
#line 539
      break;
    }
#line 540
    while (1) {
#line 540
      t0___10 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
#line 540
      t1___10 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long )(sha512_round_constants[11] + (u64 const   )x[11])));
#line 540
      a += t1___10;
#line 540
      e = t0___10 + t1___10;
#line 540
      break;
    }
#line 541
    while (1) {
#line 541
      t0___11 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
#line 541
      t1___11 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long )(sha512_round_constants[12] + (u64 const   )x[12])));
#line 541
      h += t1___11;
#line 541
      d = t0___11 + t1___11;
#line 541
      break;
    }
#line 542
    while (1) {
#line 542
      t0___12 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
#line 542
      t1___12 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long )(sha512_round_constants[13] + (u64 const   )x[13])));
#line 542
      g += t1___12;
#line 542
      c = t0___12 + t1___12;
#line 542
      break;
    }
#line 543
    while (1) {
#line 543
      t0___13 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
#line 543
      t1___13 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long )(sha512_round_constants[14] + (u64 const   )x[14])));
#line 543
      f += t1___13;
#line 543
      b = t0___13 + t1___13;
#line 543
      break;
    }
#line 544
    while (1) {
#line 544
      t0___14 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
#line 544
      t1___14 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long )(sha512_round_constants[15] + (u64 const   )x[15])));
#line 544
      e += t1___14;
#line 544
      a = t0___14 + t1___14;
#line 544
      break;
    }
#line 545
    while (1) {
#line 545
      t0___15 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
#line 545
      x[0] += (((x[14] << 45) | (x[14] >> 19)) ^ (((x[14] << 3) | (x[14] >> 61)) ^ (x[14] >> 6))) + (x[9] + (((x[1] << 63) | (x[1] >> 1)) ^ (((x[1] << 56) | (x[1] >> 8)) ^ (x[1] >> 7))));
#line 545
      t1___15 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long )(sha512_round_constants[16] + (u64 const   )x[0])));
#line 545
      d += t1___15;
#line 545
      h = t0___15 + t1___15;
#line 545
      break;
    }
#line 546
    while (1) {
#line 546
      t0___16 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
#line 546
      x[1] += (((x[15] << 45) | (x[15] >> 19)) ^ (((x[15] << 3) | (x[15] >> 61)) ^ (x[15] >> 6))) + (x[10] + (((x[2] << 63) | (x[2] >> 1)) ^ (((x[2] << 56) | (x[2] >> 8)) ^ (x[2] >> 7))));
#line 546
      t1___16 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long )(sha512_round_constants[17] + (u64 const   )x[1])));
#line 546
      c += t1___16;
#line 546
      g = t0___16 + t1___16;
#line 546
      break;
    }
#line 547
    while (1) {
#line 547
      t0___17 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
#line 547
      x[2] += (((x[0] << 45) | (x[0] >> 19)) ^ (((x[0] << 3) | (x[0] >> 61)) ^ (x[0] >> 6))) + (x[11] + (((x[3] << 63) | (x[3] >> 1)) ^ (((x[3] << 56) | (x[3] >> 8)) ^ (x[3] >> 7))));
#line 547
      t1___17 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long )(sha512_round_constants[18] + (u64 const   )x[2])));
#line 547
      b += t1___17;
#line 547
      f = t0___17 + t1___17;
#line 547
      break;
    }
#line 548
    while (1) {
#line 548
      t0___18 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
#line 548
      x[3] += (((x[1] << 45) | (x[1] >> 19)) ^ (((x[1] << 3) | (x[1] >> 61)) ^ (x[1] >> 6))) + (x[12] + (((x[4] << 63) | (x[4] >> 1)) ^ (((x[4] << 56) | (x[4] >> 8)) ^ (x[4] >> 7))));
#line 548
      t1___18 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long )(sha512_round_constants[19] + (u64 const   )x[3])));
#line 548
      a += t1___18;
#line 548
      e = t0___18 + t1___18;
#line 548
      break;
    }
#line 549
    while (1) {
#line 549
      t0___19 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
#line 549
      x[4] += (((x[2] << 45) | (x[2] >> 19)) ^ (((x[2] << 3) | (x[2] >> 61)) ^ (x[2] >> 6))) + (x[13] + (((x[5] << 63) | (x[5] >> 1)) ^ (((x[5] << 56) | (x[5] >> 8)) ^ (x[5] >> 7))));
#line 549
      t1___19 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long )(sha512_round_constants[20] + (u64 const   )x[4])));
#line 549
      h += t1___19;
#line 549
      d = t0___19 + t1___19;
#line 549
      break;
    }
#line 550
    while (1) {
#line 550
      t0___20 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
#line 550
      x[5] += (((x[3] << 45) | (x[3] >> 19)) ^ (((x[3] << 3) | (x[3] >> 61)) ^ (x[3] >> 6))) + (x[14] + (((x[6] << 63) | (x[6] >> 1)) ^ (((x[6] << 56) | (x[6] >> 8)) ^ (x[6] >> 7))));
#line 550
      t1___20 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long )(sha512_round_constants[21] + (u64 const   )x[5])));
#line 550
      g += t1___20;
#line 550
      c = t0___20 + t1___20;
#line 550
      break;
    }
#line 551
    while (1) {
#line 551
      t0___21 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
#line 551
      x[6] += (((x[4] << 45) | (x[4] >> 19)) ^ (((x[4] << 3) | (x[4] >> 61)) ^ (x[4] >> 6))) + (x[15] + (((x[7] << 63) | (x[7] >> 1)) ^ (((x[7] << 56) | (x[7] >> 8)) ^ (x[7] >> 7))));
#line 551
      t1___21 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long )(sha512_round_constants[22] + (u64 const   )x[6])));
#line 551
      f += t1___21;
#line 551
      b = t0___21 + t1___21;
#line 551
      break;
    }
#line 552
    while (1) {
#line 552
      t0___22 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
#line 552
      x[7] += (((x[5] << 45) | (x[5] >> 19)) ^ (((x[5] << 3) | (x[5] >> 61)) ^ (x[5] >> 6))) + (x[0] + (((x[8] << 63) | (x[8] >> 1)) ^ (((x[8] << 56) | (x[8] >> 8)) ^ (x[8] >> 7))));
#line 552
      t1___22 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long )(sha512_round_constants[23] + (u64 const   )x[7])));
#line 552
      e += t1___22;
#line 552
      a = t0___22 + t1___22;
#line 552
      break;
    }
#line 553
    while (1) {
#line 553
      t0___23 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
#line 553
      x[8] += (((x[6] << 45) | (x[6] >> 19)) ^ (((x[6] << 3) | (x[6] >> 61)) ^ (x[6] >> 6))) + (x[1] + (((x[9] << 63) | (x[9] >> 1)) ^ (((x[9] << 56) | (x[9] >> 8)) ^ (x[9] >> 7))));
#line 553
      t1___23 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long )(sha512_round_constants[24] + (u64 const   )x[8])));
#line 553
      d += t1___23;
#line 553
      h = t0___23 + t1___23;
#line 553
      break;
    }
#line 554
    while (1) {
#line 554
      t0___24 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
#line 554
      x[9] += (((x[7] << 45) | (x[7] >> 19)) ^ (((x[7] << 3) | (x[7] >> 61)) ^ (x[7] >> 6))) + (x[2] + (((x[10] << 63) | (x[10] >> 1)) ^ (((x[10] << 56) | (x[10] >> 8)) ^ (x[10] >> 7))));
#line 554
      t1___24 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long )(sha512_round_constants[25] + (u64 const   )x[9])));
#line 554
      c += t1___24;
#line 554
      g = t0___24 + t1___24;
#line 554
      break;
    }
#line 555
    while (1) {
#line 555
      t0___25 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
#line 555
      x[10] += (((x[8] << 45) | (x[8] >> 19)) ^ (((x[8] << 3) | (x[8] >> 61)) ^ (x[8] >> 6))) + (x[3] + (((x[11] << 63) | (x[11] >> 1)) ^ (((x[11] << 56) | (x[11] >> 8)) ^ (x[11] >> 7))));
#line 555
      t1___25 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long )(sha512_round_constants[26] + (u64 const   )x[10])));
#line 555
      b += t1___25;
#line 555
      f = t0___25 + t1___25;
#line 555
      break;
    }
#line 556
    while (1) {
#line 556
      t0___26 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
#line 556
      x[11] += (((x[9] << 45) | (x[9] >> 19)) ^ (((x[9] << 3) | (x[9] >> 61)) ^ (x[9] >> 6))) + (x[4] + (((x[12] << 63) | (x[12] >> 1)) ^ (((x[12] << 56) | (x[12] >> 8)) ^ (x[12] >> 7))));
#line 556
      t1___26 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long )(sha512_round_constants[27] + (u64 const   )x[11])));
#line 556
      a += t1___26;
#line 556
      e = t0___26 + t1___26;
#line 556
      break;
    }
#line 557
    while (1) {
#line 557
      t0___27 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
#line 557
      x[12] += (((x[10] << 45) | (x[10] >> 19)) ^ (((x[10] << 3) | (x[10] >> 61)) ^ (x[10] >> 6))) + (x[5] + (((x[13] << 63) | (x[13] >> 1)) ^ (((x[13] << 56) | (x[13] >> 8)) ^ (x[13] >> 7))));
#line 557
      t1___27 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long )(sha512_round_constants[28] + (u64 const   )x[12])));
#line 557
      h += t1___27;
#line 557
      d = t0___27 + t1___27;
#line 557
      break;
    }
#line 558
    while (1) {
#line 558
      t0___28 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
#line 558
      x[13] += (((x[11] << 45) | (x[11] >> 19)) ^ (((x[11] << 3) | (x[11] >> 61)) ^ (x[11] >> 6))) + (x[6] + (((x[14] << 63) | (x[14] >> 1)) ^ (((x[14] << 56) | (x[14] >> 8)) ^ (x[14] >> 7))));
#line 558
      t1___28 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long )(sha512_round_constants[29] + (u64 const   )x[13])));
#line 558
      g += t1___28;
#line 558
      c = t0___28 + t1___28;
#line 558
      break;
    }
#line 559
    while (1) {
#line 559
      t0___29 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
#line 559
      x[14] += (((x[12] << 45) | (x[12] >> 19)) ^ (((x[12] << 3) | (x[12] >> 61)) ^ (x[12] >> 6))) + (x[7] + (((x[15] << 63) | (x[15] >> 1)) ^ (((x[15] << 56) | (x[15] >> 8)) ^ (x[15] >> 7))));
#line 559
      t1___29 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long )(sha512_round_constants[30] + (u64 const   )x[14])));
#line 559
      f += t1___29;
#line 559
      b = t0___29 + t1___29;
#line 559
      break;
    }
#line 560
    while (1) {
#line 560
      t0___30 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
#line 560
      x[15] += (((x[13] << 45) | (x[13] >> 19)) ^ (((x[13] << 3) | (x[13] >> 61)) ^ (x[13] >> 6))) + (x[8] + (((x[0] << 63) | (x[0] >> 1)) ^ (((x[0] << 56) | (x[0] >> 8)) ^ (x[0] >> 7))));
#line 560
      t1___30 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long )(sha512_round_constants[31] + (u64 const   )x[15])));
#line 560
      e += t1___30;
#line 560
      a = t0___30 + t1___30;
#line 560
      break;
    }
#line 561
    while (1) {
#line 561
      t0___31 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
#line 561
      x[0] += (((x[14] << 45) | (x[14] >> 19)) ^ (((x[14] << 3) | (x[14] >> 61)) ^ (x[14] >> 6))) + (x[9] + (((x[1] << 63) | (x[1] >> 1)) ^ (((x[1] << 56) | (x[1] >> 8)) ^ (x[1] >> 7))));
#line 561
      t1___31 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long )(sha512_round_constants[32] + (u64 const   )x[0])));
#line 561
      d += t1___31;
#line 561
      h = t0___31 + t1___31;
#line 561
      break;
    }
#line 562
    while (1) {
#line 562
      t0___32 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
#line 562
      x[1] += (((x[15] << 45) | (x[15] >> 19)) ^ (((x[15] << 3) | (x[15] >> 61)) ^ (x[15] >> 6))) + (x[10] + (((x[2] << 63) | (x[2] >> 1)) ^ (((x[2] << 56) | (x[2] >> 8)) ^ (x[2] >> 7))));
#line 562
      t1___32 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long )(sha512_round_constants[33] + (u64 const   )x[1])));
#line 562
      c += t1___32;
#line 562
      g = t0___32 + t1___32;
#line 562
      break;
    }
#line 563
    while (1) {
#line 563
      t0___33 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
#line 563
      x[2] += (((x[0] << 45) | (x[0] >> 19)) ^ (((x[0] << 3) | (x[0] >> 61)) ^ (x[0] >> 6))) + (x[11] + (((x[3] << 63) | (x[3] >> 1)) ^ (((x[3] << 56) | (x[3] >> 8)) ^ (x[3] >> 7))));
#line 563
      t1___33 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long )(sha512_round_constants[34] + (u64 const   )x[2])));
#line 563
      b += t1___33;
#line 563
      f = t0___33 + t1___33;
#line 563
      break;
    }
#line 564
    while (1) {
#line 564
      t0___34 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
#line 564
      x[3] += (((x[1] << 45) | (x[1] >> 19)) ^ (((x[1] << 3) | (x[1] >> 61)) ^ (x[1] >> 6))) + (x[12] + (((x[4] << 63) | (x[4] >> 1)) ^ (((x[4] << 56) | (x[4] >> 8)) ^ (x[4] >> 7))));
#line 564
      t1___34 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long )(sha512_round_constants[35] + (u64 const   )x[3])));
#line 564
      a += t1___34;
#line 564
      e = t0___34 + t1___34;
#line 564
      break;
    }
#line 565
    while (1) {
#line 565
      t0___35 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
#line 565
      x[4] += (((x[2] << 45) | (x[2] >> 19)) ^ (((x[2] << 3) | (x[2] >> 61)) ^ (x[2] >> 6))) + (x[13] + (((x[5] << 63) | (x[5] >> 1)) ^ (((x[5] << 56) | (x[5] >> 8)) ^ (x[5] >> 7))));
#line 565
      t1___35 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long )(sha512_round_constants[36] + (u64 const   )x[4])));
#line 565
      h += t1___35;
#line 565
      d = t0___35 + t1___35;
#line 565
      break;
    }
#line 566
    while (1) {
#line 566
      t0___36 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
#line 566
      x[5] += (((x[3] << 45) | (x[3] >> 19)) ^ (((x[3] << 3) | (x[3] >> 61)) ^ (x[3] >> 6))) + (x[14] + (((x[6] << 63) | (x[6] >> 1)) ^ (((x[6] << 56) | (x[6] >> 8)) ^ (x[6] >> 7))));
#line 566
      t1___36 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long )(sha512_round_constants[37] + (u64 const   )x[5])));
#line 566
      g += t1___36;
#line 566
      c = t0___36 + t1___36;
#line 566
      break;
    }
#line 567
    while (1) {
#line 567
      t0___37 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
#line 567
      x[6] += (((x[4] << 45) | (x[4] >> 19)) ^ (((x[4] << 3) | (x[4] >> 61)) ^ (x[4] >> 6))) + (x[15] + (((x[7] << 63) | (x[7] >> 1)) ^ (((x[7] << 56) | (x[7] >> 8)) ^ (x[7] >> 7))));
#line 567
      t1___37 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long )(sha512_round_constants[38] + (u64 const   )x[6])));
#line 567
      f += t1___37;
#line 567
      b = t0___37 + t1___37;
#line 567
      break;
    }
#line 568
    while (1) {
#line 568
      t0___38 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
#line 568
      x[7] += (((x[5] << 45) | (x[5] >> 19)) ^ (((x[5] << 3) | (x[5] >> 61)) ^ (x[5] >> 6))) + (x[0] + (((x[8] << 63) | (x[8] >> 1)) ^ (((x[8] << 56) | (x[8] >> 8)) ^ (x[8] >> 7))));
#line 568
      t1___38 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long )(sha512_round_constants[39] + (u64 const   )x[7])));
#line 568
      e += t1___38;
#line 568
      a = t0___38 + t1___38;
#line 568
      break;
    }
#line 569
    while (1) {
#line 569
      t0___39 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
#line 569
      x[8] += (((x[6] << 45) | (x[6] >> 19)) ^ (((x[6] << 3) | (x[6] >> 61)) ^ (x[6] >> 6))) + (x[1] + (((x[9] << 63) | (x[9] >> 1)) ^ (((x[9] << 56) | (x[9] >> 8)) ^ (x[9] >> 7))));
#line 569
      t1___39 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long )(sha512_round_constants[40] + (u64 const   )x[8])));
#line 569
      d += t1___39;
#line 569
      h = t0___39 + t1___39;
#line 569
      break;
    }
#line 570
    while (1) {
#line 570
      t0___40 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
#line 570
      x[9] += (((x[7] << 45) | (x[7] >> 19)) ^ (((x[7] << 3) | (x[7] >> 61)) ^ (x[7] >> 6))) + (x[2] + (((x[10] << 63) | (x[10] >> 1)) ^ (((x[10] << 56) | (x[10] >> 8)) ^ (x[10] >> 7))));
#line 570
      t1___40 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long )(sha512_round_constants[41] + (u64 const   )x[9])));
#line 570
      c += t1___40;
#line 570
      g = t0___40 + t1___40;
#line 570
      break;
    }
#line 571
    while (1) {
#line 571
      t0___41 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
#line 571
      x[10] += (((x[8] << 45) | (x[8] >> 19)) ^ (((x[8] << 3) | (x[8] >> 61)) ^ (x[8] >> 6))) + (x[3] + (((x[11] << 63) | (x[11] >> 1)) ^ (((x[11] << 56) | (x[11] >> 8)) ^ (x[11] >> 7))));
#line 571
      t1___41 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long )(sha512_round_constants[42] + (u64 const   )x[10])));
#line 571
      b += t1___41;
#line 571
      f = t0___41 + t1___41;
#line 571
      break;
    }
#line 572
    while (1) {
#line 572
      t0___42 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
#line 572
      x[11] += (((x[9] << 45) | (x[9] >> 19)) ^ (((x[9] << 3) | (x[9] >> 61)) ^ (x[9] >> 6))) + (x[4] + (((x[12] << 63) | (x[12] >> 1)) ^ (((x[12] << 56) | (x[12] >> 8)) ^ (x[12] >> 7))));
#line 572
      t1___42 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long )(sha512_round_constants[43] + (u64 const   )x[11])));
#line 572
      a += t1___42;
#line 572
      e = t0___42 + t1___42;
#line 572
      break;
    }
#line 573
    while (1) {
#line 573
      t0___43 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
#line 573
      x[12] += (((x[10] << 45) | (x[10] >> 19)) ^ (((x[10] << 3) | (x[10] >> 61)) ^ (x[10] >> 6))) + (x[5] + (((x[13] << 63) | (x[13] >> 1)) ^ (((x[13] << 56) | (x[13] >> 8)) ^ (x[13] >> 7))));
#line 573
      t1___43 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long )(sha512_round_constants[44] + (u64 const   )x[12])));
#line 573
      h += t1___43;
#line 573
      d = t0___43 + t1___43;
#line 573
      break;
    }
#line 574
    while (1) {
#line 574
      t0___44 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
#line 574
      x[13] += (((x[11] << 45) | (x[11] >> 19)) ^ (((x[11] << 3) | (x[11] >> 61)) ^ (x[11] >> 6))) + (x[6] + (((x[14] << 63) | (x[14] >> 1)) ^ (((x[14] << 56) | (x[14] >> 8)) ^ (x[14] >> 7))));
#line 574
      t1___44 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long )(sha512_round_constants[45] + (u64 const   )x[13])));
#line 574
      g += t1___44;
#line 574
      c = t0___44 + t1___44;
#line 574
      break;
    }
#line 575
    while (1) {
#line 575
      t0___45 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
#line 575
      x[14] += (((x[12] << 45) | (x[12] >> 19)) ^ (((x[12] << 3) | (x[12] >> 61)) ^ (x[12] >> 6))) + (x[7] + (((x[15] << 63) | (x[15] >> 1)) ^ (((x[15] << 56) | (x[15] >> 8)) ^ (x[15] >> 7))));
#line 575
      t1___45 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long )(sha512_round_constants[46] + (u64 const   )x[14])));
#line 575
      f += t1___45;
#line 575
      b = t0___45 + t1___45;
#line 575
      break;
    }
#line 576
    while (1) {
#line 576
      t0___46 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
#line 576
      x[15] += (((x[13] << 45) | (x[13] >> 19)) ^ (((x[13] << 3) | (x[13] >> 61)) ^ (x[13] >> 6))) + (x[8] + (((x[0] << 63) | (x[0] >> 1)) ^ (((x[0] << 56) | (x[0] >> 8)) ^ (x[0] >> 7))));
#line 576
      t1___46 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long )(sha512_round_constants[47] + (u64 const   )x[15])));
#line 576
      e += t1___46;
#line 576
      a = t0___46 + t1___46;
#line 576
      break;
    }
#line 577
    while (1) {
#line 577
      t0___47 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
#line 577
      x[0] += (((x[14] << 45) | (x[14] >> 19)) ^ (((x[14] << 3) | (x[14] >> 61)) ^ (x[14] >> 6))) + (x[9] + (((x[1] << 63) | (x[1] >> 1)) ^ (((x[1] << 56) | (x[1] >> 8)) ^ (x[1] >> 7))));
#line 577
      t1___47 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long )(sha512_round_constants[48] + (u64 const   )x[0])));
#line 577
      d += t1___47;
#line 577
      h = t0___47 + t1___47;
#line 577
      break;
    }
#line 578
    while (1) {
#line 578
      t0___48 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
#line 578
      x[1] += (((x[15] << 45) | (x[15] >> 19)) ^ (((x[15] << 3) | (x[15] >> 61)) ^ (x[15] >> 6))) + (x[10] + (((x[2] << 63) | (x[2] >> 1)) ^ (((x[2] << 56) | (x[2] >> 8)) ^ (x[2] >> 7))));
#line 578
      t1___48 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long )(sha512_round_constants[49] + (u64 const   )x[1])));
#line 578
      c += t1___48;
#line 578
      g = t0___48 + t1___48;
#line 578
      break;
    }
#line 579
    while (1) {
#line 579
      t0___49 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
#line 579
      x[2] += (((x[0] << 45) | (x[0] >> 19)) ^ (((x[0] << 3) | (x[0] >> 61)) ^ (x[0] >> 6))) + (x[11] + (((x[3] << 63) | (x[3] >> 1)) ^ (((x[3] << 56) | (x[3] >> 8)) ^ (x[3] >> 7))));
#line 579
      t1___49 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long )(sha512_round_constants[50] + (u64 const   )x[2])));
#line 579
      b += t1___49;
#line 579
      f = t0___49 + t1___49;
#line 579
      break;
    }
#line 580
    while (1) {
#line 580
      t0___50 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
#line 580
      x[3] += (((x[1] << 45) | (x[1] >> 19)) ^ (((x[1] << 3) | (x[1] >> 61)) ^ (x[1] >> 6))) + (x[12] + (((x[4] << 63) | (x[4] >> 1)) ^ (((x[4] << 56) | (x[4] >> 8)) ^ (x[4] >> 7))));
#line 580
      t1___50 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long )(sha512_round_constants[51] + (u64 const   )x[3])));
#line 580
      a += t1___50;
#line 580
      e = t0___50 + t1___50;
#line 580
      break;
    }
#line 581
    while (1) {
#line 581
      t0___51 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
#line 581
      x[4] += (((x[2] << 45) | (x[2] >> 19)) ^ (((x[2] << 3) | (x[2] >> 61)) ^ (x[2] >> 6))) + (x[13] + (((x[5] << 63) | (x[5] >> 1)) ^ (((x[5] << 56) | (x[5] >> 8)) ^ (x[5] >> 7))));
#line 581
      t1___51 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long )(sha512_round_constants[52] + (u64 const   )x[4])));
#line 581
      h += t1___51;
#line 581
      d = t0___51 + t1___51;
#line 581
      break;
    }
#line 582
    while (1) {
#line 582
      t0___52 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
#line 582
      x[5] += (((x[3] << 45) | (x[3] >> 19)) ^ (((x[3] << 3) | (x[3] >> 61)) ^ (x[3] >> 6))) + (x[14] + (((x[6] << 63) | (x[6] >> 1)) ^ (((x[6] << 56) | (x[6] >> 8)) ^ (x[6] >> 7))));
#line 582
      t1___52 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long )(sha512_round_constants[53] + (u64 const   )x[5])));
#line 582
      g += t1___52;
#line 582
      c = t0___52 + t1___52;
#line 582
      break;
    }
#line 583
    while (1) {
#line 583
      t0___53 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
#line 583
      x[6] += (((x[4] << 45) | (x[4] >> 19)) ^ (((x[4] << 3) | (x[4] >> 61)) ^ (x[4] >> 6))) + (x[15] + (((x[7] << 63) | (x[7] >> 1)) ^ (((x[7] << 56) | (x[7] >> 8)) ^ (x[7] >> 7))));
#line 583
      t1___53 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long )(sha512_round_constants[54] + (u64 const   )x[6])));
#line 583
      f += t1___53;
#line 583
      b = t0___53 + t1___53;
#line 583
      break;
    }
#line 584
    while (1) {
#line 584
      t0___54 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
#line 584
      x[7] += (((x[5] << 45) | (x[5] >> 19)) ^ (((x[5] << 3) | (x[5] >> 61)) ^ (x[5] >> 6))) + (x[0] + (((x[8] << 63) | (x[8] >> 1)) ^ (((x[8] << 56) | (x[8] >> 8)) ^ (x[8] >> 7))));
#line 584
      t1___54 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long )(sha512_round_constants[55] + (u64 const   )x[7])));
#line 584
      e += t1___54;
#line 584
      a = t0___54 + t1___54;
#line 584
      break;
    }
#line 585
    while (1) {
#line 585
      t0___55 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
#line 585
      x[8] += (((x[6] << 45) | (x[6] >> 19)) ^ (((x[6] << 3) | (x[6] >> 61)) ^ (x[6] >> 6))) + (x[1] + (((x[9] << 63) | (x[9] >> 1)) ^ (((x[9] << 56) | (x[9] >> 8)) ^ (x[9] >> 7))));
#line 585
      t1___55 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long )(sha512_round_constants[56] + (u64 const   )x[8])));
#line 585
      d += t1___55;
#line 585
      h = t0___55 + t1___55;
#line 585
      break;
    }
#line 586
    while (1) {
#line 586
      t0___56 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
#line 586
      x[9] += (((x[7] << 45) | (x[7] >> 19)) ^ (((x[7] << 3) | (x[7] >> 61)) ^ (x[7] >> 6))) + (x[2] + (((x[10] << 63) | (x[10] >> 1)) ^ (((x[10] << 56) | (x[10] >> 8)) ^ (x[10] >> 7))));
#line 586
      t1___56 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long )(sha512_round_constants[57] + (u64 const   )x[9])));
#line 586
      c += t1___56;
#line 586
      g = t0___56 + t1___56;
#line 586
      break;
    }
#line 587
    while (1) {
#line 587
      t0___57 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
#line 587
      x[10] += (((x[8] << 45) | (x[8] >> 19)) ^ (((x[8] << 3) | (x[8] >> 61)) ^ (x[8] >> 6))) + (x[3] + (((x[11] << 63) | (x[11] >> 1)) ^ (((x[11] << 56) | (x[11] >> 8)) ^ (x[11] >> 7))));
#line 587
      t1___57 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long )(sha512_round_constants[58] + (u64 const   )x[10])));
#line 587
      b += t1___57;
#line 587
      f = t0___57 + t1___57;
#line 587
      break;
    }
#line 588
    while (1) {
#line 588
      t0___58 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
#line 588
      x[11] += (((x[9] << 45) | (x[9] >> 19)) ^ (((x[9] << 3) | (x[9] >> 61)) ^ (x[9] >> 6))) + (x[4] + (((x[12] << 63) | (x[12] >> 1)) ^ (((x[12] << 56) | (x[12] >> 8)) ^ (x[12] >> 7))));
#line 588
      t1___58 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long )(sha512_round_constants[59] + (u64 const   )x[11])));
#line 588
      a += t1___58;
#line 588
      e = t0___58 + t1___58;
#line 588
      break;
    }
#line 589
    while (1) {
#line 589
      t0___59 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
#line 589
      x[12] += (((x[10] << 45) | (x[10] >> 19)) ^ (((x[10] << 3) | (x[10] >> 61)) ^ (x[10] >> 6))) + (x[5] + (((x[13] << 63) | (x[13] >> 1)) ^ (((x[13] << 56) | (x[13] >> 8)) ^ (x[13] >> 7))));
#line 589
      t1___59 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long )(sha512_round_constants[60] + (u64 const   )x[12])));
#line 589
      h += t1___59;
#line 589
      d = t0___59 + t1___59;
#line 589
      break;
    }
#line 590
    while (1) {
#line 590
      t0___60 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
#line 590
      x[13] += (((x[11] << 45) | (x[11] >> 19)) ^ (((x[11] << 3) | (x[11] >> 61)) ^ (x[11] >> 6))) + (x[6] + (((x[14] << 63) | (x[14] >> 1)) ^ (((x[14] << 56) | (x[14] >> 8)) ^ (x[14] >> 7))));
#line 590
      t1___60 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long )(sha512_round_constants[61] + (u64 const   )x[13])));
#line 590
      g += t1___60;
#line 590
      c = t0___60 + t1___60;
#line 590
      break;
    }
#line 591
    while (1) {
#line 591
      t0___61 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
#line 591
      x[14] += (((x[12] << 45) | (x[12] >> 19)) ^ (((x[12] << 3) | (x[12] >> 61)) ^ (x[12] >> 6))) + (x[7] + (((x[15] << 63) | (x[15] >> 1)) ^ (((x[15] << 56) | (x[15] >> 8)) ^ (x[15] >> 7))));
#line 591
      t1___61 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long )(sha512_round_constants[62] + (u64 const   )x[14])));
#line 591
      f += t1___61;
#line 591
      b = t0___61 + t1___61;
#line 591
      break;
    }
#line 592
    while (1) {
#line 592
      t0___62 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
#line 592
      x[15] += (((x[13] << 45) | (x[13] >> 19)) ^ (((x[13] << 3) | (x[13] >> 61)) ^ (x[13] >> 6))) + (x[8] + (((x[0] << 63) | (x[0] >> 1)) ^ (((x[0] << 56) | (x[0] >> 8)) ^ (x[0] >> 7))));
#line 592
      t1___62 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long )(sha512_round_constants[63] + (u64 const   )x[15])));
#line 592
      e += t1___62;
#line 592
      a = t0___62 + t1___62;
#line 592
      break;
    }
#line 593
    while (1) {
#line 593
      t0___63 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
#line 593
      x[0] += (((x[14] << 45) | (x[14] >> 19)) ^ (((x[14] << 3) | (x[14] >> 61)) ^ (x[14] >> 6))) + (x[9] + (((x[1] << 63) | (x[1] >> 1)) ^ (((x[1] << 56) | (x[1] >> 8)) ^ (x[1] >> 7))));
#line 593
      t1___63 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long )(sha512_round_constants[64] + (u64 const   )x[0])));
#line 593
      d += t1___63;
#line 593
      h = t0___63 + t1___63;
#line 593
      break;
    }
#line 594
    while (1) {
#line 594
      t0___64 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
#line 594
      x[1] += (((x[15] << 45) | (x[15] >> 19)) ^ (((x[15] << 3) | (x[15] >> 61)) ^ (x[15] >> 6))) + (x[10] + (((x[2] << 63) | (x[2] >> 1)) ^ (((x[2] << 56) | (x[2] >> 8)) ^ (x[2] >> 7))));
#line 594
      t1___64 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long )(sha512_round_constants[65] + (u64 const   )x[1])));
#line 594
      c += t1___64;
#line 594
      g = t0___64 + t1___64;
#line 594
      break;
    }
#line 595
    while (1) {
#line 595
      t0___65 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
#line 595
      x[2] += (((x[0] << 45) | (x[0] >> 19)) ^ (((x[0] << 3) | (x[0] >> 61)) ^ (x[0] >> 6))) + (x[11] + (((x[3] << 63) | (x[3] >> 1)) ^ (((x[3] << 56) | (x[3] >> 8)) ^ (x[3] >> 7))));
#line 595
      t1___65 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long )(sha512_round_constants[66] + (u64 const   )x[2])));
#line 595
      b += t1___65;
#line 595
      f = t0___65 + t1___65;
#line 595
      break;
    }
#line 596
    while (1) {
#line 596
      t0___66 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
#line 596
      x[3] += (((x[1] << 45) | (x[1] >> 19)) ^ (((x[1] << 3) | (x[1] >> 61)) ^ (x[1] >> 6))) + (x[12] + (((x[4] << 63) | (x[4] >> 1)) ^ (((x[4] << 56) | (x[4] >> 8)) ^ (x[4] >> 7))));
#line 596
      t1___66 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long )(sha512_round_constants[67] + (u64 const   )x[3])));
#line 596
      a += t1___66;
#line 596
      e = t0___66 + t1___66;
#line 596
      break;
    }
#line 597
    while (1) {
#line 597
      t0___67 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
#line 597
      x[4] += (((x[2] << 45) | (x[2] >> 19)) ^ (((x[2] << 3) | (x[2] >> 61)) ^ (x[2] >> 6))) + (x[13] + (((x[5] << 63) | (x[5] >> 1)) ^ (((x[5] << 56) | (x[5] >> 8)) ^ (x[5] >> 7))));
#line 597
      t1___67 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long )(sha512_round_constants[68] + (u64 const   )x[4])));
#line 597
      h += t1___67;
#line 597
      d = t0___67 + t1___67;
#line 597
      break;
    }
#line 598
    while (1) {
#line 598
      t0___68 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
#line 598
      x[5] += (((x[3] << 45) | (x[3] >> 19)) ^ (((x[3] << 3) | (x[3] >> 61)) ^ (x[3] >> 6))) + (x[14] + (((x[6] << 63) | (x[6] >> 1)) ^ (((x[6] << 56) | (x[6] >> 8)) ^ (x[6] >> 7))));
#line 598
      t1___68 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long )(sha512_round_constants[69] + (u64 const   )x[5])));
#line 598
      g += t1___68;
#line 598
      c = t0___68 + t1___68;
#line 598
      break;
    }
#line 599
    while (1) {
#line 599
      t0___69 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
#line 599
      x[6] += (((x[4] << 45) | (x[4] >> 19)) ^ (((x[4] << 3) | (x[4] >> 61)) ^ (x[4] >> 6))) + (x[15] + (((x[7] << 63) | (x[7] >> 1)) ^ (((x[7] << 56) | (x[7] >> 8)) ^ (x[7] >> 7))));
#line 599
      t1___69 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long )(sha512_round_constants[70] + (u64 const   )x[6])));
#line 599
      f += t1___69;
#line 599
      b = t0___69 + t1___69;
#line 599
      break;
    }
#line 600
    while (1) {
#line 600
      t0___70 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
#line 600
      x[7] += (((x[5] << 45) | (x[5] >> 19)) ^ (((x[5] << 3) | (x[5] >> 61)) ^ (x[5] >> 6))) + (x[0] + (((x[8] << 63) | (x[8] >> 1)) ^ (((x[8] << 56) | (x[8] >> 8)) ^ (x[8] >> 7))));
#line 600
      t1___70 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long )(sha512_round_constants[71] + (u64 const   )x[7])));
#line 600
      e += t1___70;
#line 600
      a = t0___70 + t1___70;
#line 600
      break;
    }
#line 601
    while (1) {
#line 601
      t0___71 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
#line 601
      x[8] += (((x[6] << 45) | (x[6] >> 19)) ^ (((x[6] << 3) | (x[6] >> 61)) ^ (x[6] >> 6))) + (x[1] + (((x[9] << 63) | (x[9] >> 1)) ^ (((x[9] << 56) | (x[9] >> 8)) ^ (x[9] >> 7))));
#line 601
      t1___71 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long )(sha512_round_constants[72] + (u64 const   )x[8])));
#line 601
      d += t1___71;
#line 601
      h = t0___71 + t1___71;
#line 601
      break;
    }
#line 602
    while (1) {
#line 602
      t0___72 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
#line 602
      x[9] += (((x[7] << 45) | (x[7] >> 19)) ^ (((x[7] << 3) | (x[7] >> 61)) ^ (x[7] >> 6))) + (x[2] + (((x[10] << 63) | (x[10] >> 1)) ^ (((x[10] << 56) | (x[10] >> 8)) ^ (x[10] >> 7))));
#line 602
      t1___72 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long )(sha512_round_constants[73] + (u64 const   )x[9])));
#line 602
      c += t1___72;
#line 602
      g = t0___72 + t1___72;
#line 602
      break;
    }
#line 603
    while (1) {
#line 603
      t0___73 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
#line 603
      x[10] += (((x[8] << 45) | (x[8] >> 19)) ^ (((x[8] << 3) | (x[8] >> 61)) ^ (x[8] >> 6))) + (x[3] + (((x[11] << 63) | (x[11] >> 1)) ^ (((x[11] << 56) | (x[11] >> 8)) ^ (x[11] >> 7))));
#line 603
      t1___73 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long )(sha512_round_constants[74] + (u64 const   )x[10])));
#line 603
      b += t1___73;
#line 603
      f = t0___73 + t1___73;
#line 603
      break;
    }
#line 604
    while (1) {
#line 604
      t0___74 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
#line 604
      x[11] += (((x[9] << 45) | (x[9] >> 19)) ^ (((x[9] << 3) | (x[9] >> 61)) ^ (x[9] >> 6))) + (x[4] + (((x[12] << 63) | (x[12] >> 1)) ^ (((x[12] << 56) | (x[12] >> 8)) ^ (x[12] >> 7))));
#line 604
      t1___74 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long )(sha512_round_constants[75] + (u64 const   )x[11])));
#line 604
      a += t1___74;
#line 604
      e = t0___74 + t1___74;
#line 604
      break;
    }
#line 605
    while (1) {
#line 605
      t0___75 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
#line 605
      x[12] += (((x[10] << 45) | (x[10] >> 19)) ^ (((x[10] << 3) | (x[10] >> 61)) ^ (x[10] >> 6))) + (x[5] + (((x[13] << 63) | (x[13] >> 1)) ^ (((x[13] << 56) | (x[13] >> 8)) ^ (x[13] >> 7))));
#line 605
      t1___75 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long )(sha512_round_constants[76] + (u64 const   )x[12])));
#line 605
      h += t1___75;
#line 605
      d = t0___75 + t1___75;
#line 605
      break;
    }
#line 606
    while (1) {
#line 606
      t0___76 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
#line 606
      x[13] += (((x[11] << 45) | (x[11] >> 19)) ^ (((x[11] << 3) | (x[11] >> 61)) ^ (x[11] >> 6))) + (x[6] + (((x[14] << 63) | (x[14] >> 1)) ^ (((x[14] << 56) | (x[14] >> 8)) ^ (x[14] >> 7))));
#line 606
      t1___76 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long )(sha512_round_constants[77] + (u64 const   )x[13])));
#line 606
      g += t1___76;
#line 606
      c = t0___76 + t1___76;
#line 606
      break;
    }
#line 607
    while (1) {
#line 607
      t0___77 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
#line 607
      x[14] += (((x[12] << 45) | (x[12] >> 19)) ^ (((x[12] << 3) | (x[12] >> 61)) ^ (x[12] >> 6))) + (x[7] + (((x[15] << 63) | (x[15] >> 1)) ^ (((x[15] << 56) | (x[15] >> 8)) ^ (x[15] >> 7))));
#line 607
      t1___77 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long )(sha512_round_constants[78] + (u64 const   )x[14])));
#line 607
      f += t1___77;
#line 607
      b = t0___77 + t1___77;
#line 607
      break;
    }
#line 608
    while (1) {
#line 608
      t0___78 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
#line 608
      x[15] += (((x[13] << 45) | (x[13] >> 19)) ^ (((x[13] << 3) | (x[13] >> 61)) ^ (x[13] >> 6))) + (x[8] + (((x[0] << 63) | (x[0] >> 1)) ^ (((x[0] << 56) | (x[0] >> 8)) ^ (x[0] >> 7))));
#line 608
      t1___78 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long )(sha512_round_constants[79] + (u64 const   )x[15])));
#line 608
      e += t1___78;
#line 608
      a = t0___78 + t1___78;
#line 608
      break;
    }
#line 610
    tmp = ctx->state[0] + a;
#line 610
    ctx->state[0] = tmp;
#line 610
    a = tmp;
#line 611
    tmp___0 = ctx->state[1] + b;
#line 611
    ctx->state[1] = tmp___0;
#line 611
    b = tmp___0;
#line 612
    tmp___1 = ctx->state[2] + c;
#line 612
    ctx->state[2] = tmp___1;
#line 612
    c = tmp___1;
#line 613
    tmp___2 = ctx->state[3] + d;
#line 613
    ctx->state[3] = tmp___2;
#line 613
    d = tmp___2;
#line 614
    tmp___3 = ctx->state[4] + e;
#line 614
    ctx->state[4] = tmp___3;
#line 614
    e = tmp___3;
#line 615
    tmp___4 = ctx->state[5] + f;
#line 615
    ctx->state[5] = tmp___4;
#line 615
    f = tmp___4;
#line 616
    tmp___5 = ctx->state[6] + g;
#line 616
    ctx->state[6] = tmp___5;
#line 616
    g = tmp___5;
#line 617
    tmp___6 = ctx->state[7] + h;
#line 617
    ctx->state[7] = tmp___6;
#line 617
    h = tmp___6;
  }
#line 619
  return;
}
}
#line 1 "cycle-check.o"
#pragma merger(0,"/tmp/cil-6Ziuf9IL.i","-g,-O2")
#line 71 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_fail(char const   *__assertion ,
                                                                      char const   *__file ,
                                                                      unsigned int __line ,
                                                                      char const   *__function ) ;
#line 35 "cycle-check.h"
void cycle_check_init(struct cycle_check_state *state ) ;
#line 36
_Bool cycle_check(struct cycle_check_state *state , struct stat  const  *sb ) ;
#line 36 "cycle-check.c"
__inline static _Bool is_zero_or_power_of_two(uintmax_t i ) 
{ 

  {
#line 39
  return ((_Bool )((i & (i - 1UL)) == 0UL));
}
}
#line 42 "cycle-check.c"
void cycle_check_init(struct cycle_check_state *state ) 
{ 

  {
#line 45
  state->chdir_counter = (uintmax_t )0;
#line 46
  state->magic = 9827862;
#line 47
  return;
}
}
#line 57 "cycle-check.c"
_Bool cycle_check(struct cycle_check_state *state , struct stat  const  *sb ) 
{ _Bool tmp ;

  {
#line 60
  if (! (state->magic == 9827862)) {
#line 60
    __assert_fail("state->magic == 9827862", "cycle-check.c", 60U, "cycle_check");
  }
#line 65
  if (state->chdir_counter) {
#line 65
    if (sb->st_ino == (__ino_t const   )state->dev_ino.st_ino) {
#line 65
      if (sb->st_dev == (__dev_t const   )state->dev_ino.st_dev) {
#line 66
        return ((_Bool)1);
      }
    }
  }
#line 70
  (state->chdir_counter) ++;
#line 70
  tmp = is_zero_or_power_of_two(state->chdir_counter);
#line 70
  if (tmp) {
#line 77
    if (state->chdir_counter == 0UL) {
#line 78
      return ((_Bool)1);
    }
#line 80
    state->dev_ino.st_dev = (dev_t )sb->st_dev;
#line 81
    state->dev_ino.st_ino = (ino_t )sb->st_ino;
  }
#line 84
  return ((_Bool)0);
}
}
#line 1 "di-set.o"
#pragma merger(0,"/tmp/cil-lQKk38Pv.i","-g,-O2")
#line 13 "di-set.h"
struct di_set *di_set_alloc(void) ;
#line 14
int di_set_insert(struct di_set *dis , dev_t dev , ino_t ino )  __attribute__((__nonnull__(1))) ;
#line 15
void di_set_free(struct di_set *dis )  __attribute__((__nonnull__(1))) ;
#line 16
int di_set_lookup(struct di_set *dis , dev_t dev , ino_t ino )  __attribute__((__nonnull__(1))) ;
#line 68 "hash.h"
void *hash_lookup(Hash_table const   *table___0 , void const   *entry ) ;
#line 87
void *hash_insert(Hash_table *table___0 , void const   *entry )  __attribute__((__warn_unused_result__)) ;
#line 88
int hash_insert0(Hash_table *table___0 , void const   *entry , void const   **matched_ent ) ;
#line 15 "ino-map.h"
struct ino_map *ino_map_alloc(size_t next_mapped_ino ) ;
#line 17
size_t ino_map_insert(struct ino_map *im , ino_t ino )  __attribute__((__nonnull__(1))) ;
#line 75 "di-set.c"
static size_t di_ent_hash(void const   *x , size_t table_size ) 
{ struct di_ent  const  *p ;
  dev_t dev ;
  size_t h ;
  unsigned int i ;
  unsigned int n_words ;

  {
#line 78
  p = (struct di_ent  const  *)x;
#line 79
  dev = (dev_t )p->dev;
#line 84
  h = dev;
#line 86
  n_words = (unsigned int )(sizeof(dev) / sizeof(h) + (unsigned long )(sizeof(dev) % sizeof(h) != 0UL));
#line 87
  i = 1U;
#line 87
  while (i < n_words) {
#line 88
    h ^= dev >> (8UL * sizeof(h)) * (unsigned long )i;
#line 87
    i ++;
  }
#line 90
  return (h % table_size);
}
}
#line 94 "di-set.c"
static _Bool di_ent_compare(void const   *x , void const   *y ) 
{ struct di_ent  const  *a ;
  struct di_ent  const  *b ;

  {
#line 97
  a = (struct di_ent  const  *)x;
#line 98
  b = (struct di_ent  const  *)y;
#line 99
  return ((_Bool )(a->dev == b->dev));
}
}
#line 103 "di-set.c"
static void di_ent_free(void *v ) 
{ struct di_ent *a ;

  {
#line 106
  a = (struct di_ent *)v;
#line 107
  hash_free(a->ino_set);
#line 108
  free((void *)a);
#line 109
  return;
}
}
#line 112 "di-set.c"
struct di_set *di_set_alloc(void) 
{ struct di_set *dis ;
  void *tmp ;

  {
#line 115
  tmp = malloc(sizeof(*dis));
#line 115
  dis = (struct di_set *)tmp;
#line 116
  if (dis) {
#line 119
    dis->dev_map = hash_initialize((size_t )11, (Hash_tuning const   *)((void *)0),
                                   & di_ent_hash, & di_ent_compare, & di_ent_free);
#line 122
    if (! dis->dev_map) {
#line 124
      free((void *)dis);
#line 125
      return ((struct di_set *)((void *)0));
    }
#line 127
    dis->ino_map = (struct ino_map *)((void *)0);
#line 128
    dis->probe = (struct di_ent *)((void *)0);
  }
#line 131
  return (dis);
}
}
#line 135
void di_set_free(struct di_set *dis )  __attribute__((__nonnull__(1))) ;
#line 135 "di-set.c"
void di_set_free(struct di_set *dis ) 
{ 

  {
#line 138
  hash_free(dis->dev_map);
#line 139
  free((void *)dis->ino_map);
#line 140
  free((void *)dis->probe);
#line 141
  free((void *)dis);
#line 142
  return;
}
}
#line 145 "di-set.c"
static size_t di_ino_hash(void const   *i , size_t table_size ) 
{ 

  {
#line 148
  return ((hashint )i % table_size);
}
}
#line 153 "di-set.c"
static struct hash_table *map_device(struct di_set *dis , dev_t dev ) 
{ struct di_ent *ent ;
  struct di_ent *probe ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 158
  probe = dis->probe;
#line 159
  if (probe) {
#line 162
    if (probe->dev == dev) {
#line 163
      return (probe->ino_set);
    }
  } else {
#line 167
    tmp = malloc(sizeof(*probe));
#line 167
    probe = (struct di_ent *)tmp;
#line 167
    dis->probe = probe;
#line 168
    if (! probe) {
#line 169
      return ((struct hash_table *)((void *)0));
    }
  }
#line 173
  probe->dev = dev;
#line 174
  tmp___0 = hash_insert(dis->dev_map, (void const   *)probe);
#line 174
  ent = (struct di_ent *)tmp___0;
#line 175
  if (! ent) {
#line 176
    return ((struct hash_table *)((void *)0));
  }
#line 178
  if ((unsigned long )ent != (unsigned long )probe) {
#line 181
    probe->ino_set = ent->ino_set;
  } else {
#line 188
    dis->probe = (struct di_ent *)((void *)0);
#line 191
    probe->ino_set = hash_initialize((size_t )1021, (Hash_tuning const   *)((void *)0),
                                     & di_ino_hash, (_Bool (*)(void const   * , void const   * ))((void *)0),
                                     (void (*)(void * ))((void *)0));
  }
#line 195
  return (probe->ino_set);
}
}
#line 200 "di-set.c"
static hashint map_inode_number(struct di_set *dis , ino_t ino ) 
{ size_t tmp ;

  {
#line 203
  if (0UL < ino) {
#line 203
    if (ino < 9223372036854775807UL) {
#line 204
      return (ino);
    }
  }
#line 206
  if (! dis->ino_map) {
#line 208
    dis->ino_map = ino_map_alloc(9223372036854775807UL);
#line 209
    if (! dis->ino_map) {
#line 210
      return ((size_t )-1);
    }
  }
#line 213
  tmp = ino_map_insert(dis->ino_map, ino);
#line 213
  return (tmp);
}
}
#line 220
int di_set_insert(struct di_set *dis , dev_t dev , ino_t ino )  __attribute__((__nonnull__(1))) ;
#line 220 "di-set.c"
int di_set_insert(struct di_set *dis , dev_t dev , ino_t ino ) 
{ hashint i ;
  struct hash_table *ino_set ;
  struct hash_table *tmp ;
  int tmp___0 ;

  {
#line 226
  tmp = map_device(dis, dev);
#line 226
  ino_set = tmp;
#line 227
  if (! ino_set) {
#line 228
    return (-1);
  }
#line 231
  i = map_inode_number(dis, ino);
#line 232
  if (i == 0xffffffffffffffffUL) {
#line 233
    return (-1);
  }
#line 236
  tmp___0 = hash_insert0(ino_set, (void const   *)i, (void const   **)((void *)0));
#line 236
  return (tmp___0);
}
}
#line 242
int di_set_lookup(struct di_set *dis , dev_t dev , ino_t ino )  __attribute__((__nonnull__(1))) ;
#line 242 "di-set.c"
int di_set_lookup(struct di_set *dis , dev_t dev , ino_t ino ) 
{ hashint i ;
  struct hash_table *ino_set ;
  struct hash_table *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 248
  tmp = map_device(dis, dev);
#line 248
  ino_set = tmp;
#line 249
  if (! ino_set) {
#line 250
    return (-1);
  }
#line 253
  i = map_inode_number(dis, ino);
#line 254
  if (i == 0xffffffffffffffffUL) {
#line 255
    return (-1);
  }
#line 258
  tmp___0 = hash_lookup((Hash_table const   *)ino_set, (void const   *)i);
#line 258
  if (tmp___0) {
#line 258
    tmp___1 = 1;
  } else {
#line 258
    tmp___1 = 0;
  }
#line 258
  return (tmp___1);
}
}
#line 1 "diacrit.o"
#pragma merger(0,"/tmp/cil-nFOZk6Rv.i","-g,-O2")
#line 20 "diacrit.h"
char const   diacrit_base[256] ;
#line 21
char const   diacrit_diac[256] ;
#line 35 "diacrit.c"
char const   diacrit_base[256]  = 
#line 35 "diacrit.c"
  {      (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )'A',      (char const   )'B',      (char const   )'C', 
        (char const   )'D',      (char const   )'E',      (char const   )'F',      (char const   )'G', 
        (char const   )'H',      (char const   )'I',      (char const   )'J',      (char const   )'K', 
        (char const   )'L',      (char const   )'M',      (char const   )'N',      (char const   )'O', 
        (char const   )'P',      (char const   )'Q',      (char const   )'R',      (char const   )'S', 
        (char const   )'T',      (char const   )'U',      (char const   )'V',      (char const   )'W', 
        (char const   )'X',      (char const   )'Y',      (char const   )'Z',      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )'a',      (char const   )'b',      (char const   )'c', 
        (char const   )'d',      (char const   )'e',      (char const   )'f',      (char const   )'g', 
        (char const   )'h',      (char const   )'i',      (char const   )'j',      (char const   )'k', 
        (char const   )'l',      (char const   )'m',      (char const   )'n',      (char const   )'o', 
        (char const   )'p',      (char const   )'q',      (char const   )'r',      (char const   )'s', 
        (char const   )'t',      (char const   )'u',      (char const   )'v',      (char const   )'w', 
        (char const   )'x',      (char const   )'y',      (char const   )'z',      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )'A',      (char const   )'A',      (char const   )'A',      (char const   )'A', 
        (char const   )'A',      (char const   )'A',      (char const   )'A',      (char const   )'C', 
        (char const   )'E',      (char const   )'E',      (char const   )'E',      (char const   )'E', 
        (char const   )'I',      (char const   )'I',      (char const   )'I',      (char const   )'I', 
        (char const   )0,      (char const   )'N',      (char const   )'O',      (char const   )'O', 
        (char const   )'O',      (char const   )'O',      (char const   )'O',      (char const   )0, 
        (char const   )'O',      (char const   )'U',      (char const   )'U',      (char const   )'U', 
        (char const   )'U',      (char const   )'Y',      (char const   )0,      (char const   )0, 
        (char const   )'a',      (char const   )'a',      (char const   )'a',      (char const   )'a', 
        (char const   )'a',      (char const   )'a',      (char const   )'a',      (char const   )'c', 
        (char const   )'e',      (char const   )'e',      (char const   )'e',      (char const   )'e', 
        (char const   )'i',      (char const   )'i',      (char const   )'i',      (char const   )'i', 
        (char const   )0,      (char const   )'n',      (char const   )'o',      (char const   )'o', 
        (char const   )'o',      (char const   )'o',      (char const   )'o',      (char const   )0, 
        (char const   )'o',      (char const   )'u',      (char const   )'u',      (char const   )'u', 
        (char const   )'u',      (char const   )'y',      (char const   )0,      (char const   )'y'};
#line 103 "diacrit.c"
char const   diacrit_diac[256]  = 
#line 103
  {      (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )4,      (char const   )0, 
        (char const   )3,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )6,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )3,      (char const   )2,      (char const   )4,      (char const   )6, 
        (char const   )5,      (char const   )8,      (char const   )1,      (char const   )7, 
        (char const   )3,      (char const   )2,      (char const   )4,      (char const   )5, 
        (char const   )3,      (char const   )2,      (char const   )4,      (char const   )5, 
        (char const   )0,      (char const   )6,      (char const   )3,      (char const   )2, 
        (char const   )4,      (char const   )6,      (char const   )5,      (char const   )0, 
        (char const   )9,      (char const   )3,      (char const   )2,      (char const   )4, 
        (char const   )5,      (char const   )2,      (char const   )0,      (char const   )0, 
        (char const   )3,      (char const   )2,      (char const   )4,      (char const   )6, 
        (char const   )5,      (char const   )8,      (char const   )1,      (char const   )7, 
        (char const   )3,      (char const   )2,      (char const   )4,      (char const   )5, 
        (char const   )3,      (char const   )2,      (char const   )4,      (char const   )5, 
        (char const   )0,      (char const   )6,      (char const   )3,      (char const   )2, 
        (char const   )4,      (char const   )6,      (char const   )5,      (char const   )0, 
        (char const   )9,      (char const   )3,      (char const   )2,      (char const   )4, 
        (char const   )5,      (char const   )2,      (char const   )0,      (char const   )0};
#line 1 "opendir-safer.o"
#pragma merger(0,"/tmp/cil-LNTrpPJG.i","-g,-O2")
#line 135 "/usr/include/dirent.h"
extern DIR *opendir(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 142
extern DIR *fdopendir(int __fd ) ;
#line 224
extern  __attribute__((__nothrow__)) int dirfd(DIR *__dirp )  __attribute__((__nonnull__(1))) ;
#line 350 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 20 "unistd-safer.h"
int dup_safer(int fd ) ;
#line 30 "opendir-safer.c"
DIR *opendir_safer(char const   *name ) 
{ DIR *dp ;
  DIR *tmp ;
  int fd ;
  int tmp___0 ;
  DIR *newdp ;
  int e ;
  int f ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
#line 33
  tmp = opendir(name);
#line 33
  dp = tmp;
#line 35
  if (dp) {
#line 37
    tmp___0 = dirfd(dp);
#line 37
    fd = tmp___0;
#line 39
    if (0 <= fd) {
#line 39
      if (fd <= 2) {
#line 52
        tmp___1 = dup_safer(fd);
#line 52
        f = tmp___1;
#line 53
        if (f < 0) {
#line 55
          tmp___2 = __errno_location();
#line 55
          e = *tmp___2;
#line 56
          newdp = (DIR *)((void *)0);
        } else {
#line 60
          newdp = fdopendir(f);
#line 61
          tmp___3 = __errno_location();
#line 61
          e = *tmp___3;
#line 62
          if (! newdp) {
#line 63
            close(f);
          }
        }
#line 69
        closedir(dp);
#line 70
        tmp___4 = __errno_location();
#line 70
        *tmp___4 = e;
#line 71
        dp = newdp;
      }
    }
  }
#line 75
  return (dp);
}
}
#line 1 "dirname.o"
#pragma merger(0,"/tmp/cil-vzNqwqIX.i","-g,-O2")
#line 36 "dirname.h"
char *dir_name(char const   *file ) ;
#line 39
char *mdir_name(char const   *file ) ;
#line 31 "dirname.c"
char *dir_name(char const   *file ) 
{ char *result ;
  char *tmp ;

  {
#line 34
  tmp = mdir_name(file);
#line 34
  result = tmp;
#line 35
  if (! result) {
#line 36
    xalloc_die();
  }
#line 37
  return (result);
}
}
#line 1 "basename.o"
#pragma merger(0,"/tmp/cil-T1DO3Ht_.i","-g,-O2")
#line 35 "dirname.h"
char *base_name(char const   *name ) ;
#line 23 "xstrndup.h"
char *xstrndup(char const   *string , size_t n ) ;
#line 27 "basename.c"
char *base_name(char const   *name ) 
{ char const   *base ;
  char *tmp ;
  size_t length ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___3 ;

  {
#line 30
  tmp = last_component(name);
#line 30
  base = (char const   *)tmp;
#line 35
  if (! *base) {
#line 36
    tmp___0 = base_len(name);
#line 36
    tmp___1 = xstrndup(name, tmp___0);
#line 36
    return (tmp___1);
  }
#line 39
  length = base_len(base);
#line 40
  if ((int const   )*(base + length) == 47) {
#line 41
    length ++;
  }
#line 57
  tmp___3 = xstrndup(base, length);
#line 57
  return (tmp___3);
}
}
#line 1 "dirname-lgpl.o"
#pragma merger(0,"/tmp/cil-t9EJ0OFP.i","-g,-O2")
#line 41 "dirname.h"
size_t dir_len(char const   *file ) ;
#line 31 "dirname-lgpl.c"
size_t dir_len(char const   *file ) 
{ size_t prefix_length ;
  size_t length ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 34
  prefix_length = (size_t )0;
#line 38
  if (prefix_length != 0UL) {
#line 38
    tmp___0 = 0;
  } else {
#line 38
    if ((int const   )*(file + 0) == 47) {
#line 38
      tmp = 1;
    } else {
#line 38
      tmp = 0;
    }
#line 38
    tmp___0 = tmp;
  }
#line 38
  prefix_length += (size_t )tmp___0;
#line 48
  tmp___1 = last_component(file);
#line 48
  length = (size_t )(tmp___1 - (char *)file);
#line 48
  while (prefix_length < length) {
#line 50
    if (! ((int const   )*(file + (length - 1UL)) == 47)) {
#line 51
      break;
    }
#line 48
    length --;
  }
#line 52
  return (length);
}
}
#line 70 "dirname-lgpl.c"
char *mdir_name(char const   *file ) 
{ size_t length ;
  size_t tmp ;
  _Bool append_dot ;
  int tmp___0 ;
  char *dir ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
#line 73
  tmp = dir_len(file);
#line 73
  length = tmp;
#line 74
  if (length == 0UL) {
#line 74
    tmp___0 = 1;
  } else {
#line 74
    tmp___0 = 0;
  }
#line 74
  append_dot = (_Bool )tmp___0;
#line 78
  tmp___1 = malloc((length + (size_t )append_dot) + 1UL);
#line 78
  dir = (char *)tmp___1;
#line 79
  if (! dir) {
#line 80
    return ((char *)((void *)0));
  }
#line 81
  memcpy((void * __restrict  )dir, (void const   * __restrict  )file, length);
#line 82
  if (append_dot) {
#line 83
    tmp___2 = length;
#line 83
    length ++;
#line 83
    *(dir + tmp___2) = (char )'.';
  }
#line 84
  *(dir + length) = (char )'\000';
#line 85
  return (dir);
}
}
#line 1 "basename-lgpl.o"
#pragma merger(0,"/tmp/cil-BzAWVA58.i","-g,-O2")
#line 29 "basename-lgpl.c"
char *last_component(char const   *name ) 
{ char const   *base ;
  char const   *p ;
  _Bool saw_slash ;

  {
#line 32
  base = name + 0;
#line 34
  saw_slash = (_Bool)0;
#line 36
  while ((int const   )*base == 47) {
#line 37
    base ++;
  }
#line 39
  p = base;
#line 39
  while (*p) {
#line 41
    if ((int const   )*p == 47) {
#line 42
      saw_slash = (_Bool)1;
    } else
#line 43
    if (saw_slash) {
#line 45
      base = p;
#line 46
      saw_slash = (_Bool)0;
    }
#line 39
    p ++;
  }
#line 50
  return ((char *)base);
}
}
#line 57 "basename-lgpl.c"
size_t base_len(char const   *name ) 
{ size_t len ;
  size_t prefix_len ;

  {
#line 61
  prefix_len = (size_t )0;
#line 63
  len = strlen(name);
#line 63
  while (1) {
#line 63
    if (1UL < len) {
#line 63
      if (! ((int const   )*(name + (len - 1UL)) == 47)) {
#line 63
        break;
      }
    } else {
#line 63
      break;
    }
#line 64
    goto __Cont;
    __Cont: 
#line 63
    len --;
  }
#line 74
  return (len);
}
}
#line 1 "stripslash.o"
#pragma merger(0,"/tmp/cil-sB6jEMZ2.i","-g,-O2")
#line 44 "dirname.h"
_Bool strip_trailing_slashes(char *file ) ;
#line 30 "stripslash.c"
_Bool strip_trailing_slashes(char *file ) 
{ char *base ;
  char *tmp ;
  char *base_lim ;
  _Bool had_slash ;
  size_t tmp___0 ;

  {
#line 33
  tmp = last_component((char const   *)file);
#line 33
  base = tmp;
#line 39
  if (! *base) {
#line 40
    base = file;
  }
#line 41
  tmp___0 = base_len((char const   *)base);
#line 41
  base_lim = base + tmp___0;
#line 42
  had_slash = (_Bool )((int )*base_lim != 0);
#line 43
  *base_lim = (char )'\000';
#line 44
  return (had_slash);
}
}
#line 1 "dtoastr.o"
#pragma merger(0,"/tmp/cil-KIKnPJ4S.i","-g,-O2")
#line 48 "ftoastr.h"
int dtoastr(char *buf___1 , size_t bufsize___0 , int flags , int width , double x ) ;
#line 99 "ftoastr.c"
int dtoastr(char *buf___1 , size_t bufsize___0 , int flags , int width , double x ) 
{ char format[sizeof("%-+ 0*.*Lg")] ;
  double abs_x ;
  double tmp ;
  int prec ;
  char *p ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int n ;
  int __attribute__((__artificial__))  tmp___5 ;
  double tmp___6 ;

  {
#line 111
  if (x < (double )0) {
#line 111
    tmp = - x;
  } else {
#line 111
    tmp = x;
  }
#line 111
  abs_x = tmp;
#line 114
  p = format;
#line 115
  tmp___0 = p;
#line 115
  p ++;
#line 115
  *tmp___0 = (char )'%';
#line 118
  *p = (char )'-';
#line 118
  p += (flags & 1) != 0;
#line 119
  *p = (char )'+';
#line 119
  p += (flags & 2) != 0;
#line 120
  *p = (char )' ';
#line 120
  p += (flags & 4) != 0;
#line 121
  *p = (char )'0';
#line 121
  p += (flags & 8) != 0;
#line 123
  tmp___1 = p;
#line 123
  p ++;
#line 123
  *tmp___1 = (char )'*';
#line 124
  tmp___2 = p;
#line 124
  p ++;
#line 124
  *tmp___2 = (char )'.';
#line 125
  tmp___3 = p;
#line 125
  p ++;
#line 125
  *tmp___3 = (char )'*';
#line 126
  *p = (char )'L';
#line 126
  p += 0;
#line 127
  tmp___4 = p;
#line 127
  p ++;
#line 127
  if (flags & 16) {
#line 127
    *tmp___4 = (char )'G';
  } else {
#line 127
    *tmp___4 = (char )'g';
  }
#line 128
  *p = (char )'\000';
#line 130
  if (abs_x < (double )2.22507385850720138309e-308L) {
#line 130
    prec = 1;
  } else {
#line 130
    prec = 15;
  }
#line 130
  while (1) {
#line 132
    tmp___5 = snprintf((char * __restrict  )buf___1, bufsize___0, (char const   * __restrict  )(format),
                       width, prec, x);
#line 132
    n = (int )tmp___5;
#line 133
    if (n < 0) {
#line 136
      return (n);
    } else
#line 133
    if (17 <= prec) {
#line 136
      return (n);
    } else
#line 133
    if ((size_t )n < bufsize___0) {
#line 133
      tmp___6 = strtod((char const   * __restrict  )buf___1, (char ** __restrict  )((void *)0));
#line 133
      if (tmp___6 == x) {
#line 136
        return (n);
      }
    }
#line 130
    prec ++;
  }
}
}
#line 1 "dtotimespec.o"
#pragma merger(0,"/tmp/cil-Aur6k6LT.i","-g,-O2")
#line 70 "timespec.h"
struct timespec dtotimespec(double sec ) ;
#line 29 "dtotimespec.c"
struct timespec dtotimespec(double sec ) 
{ double min_representable ;
  double max_representable ;
  struct timespec r ;
  time_t s ;
  double frac ;
  long ns ;

  {
#line 33
  min_representable = (double )(~ (((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L));
#line 34
  max_representable = ((double )(((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L) * (double )1000000000 + (double )999999999) / (double )1000000000;
#line 39
  if (! (min_representable < sec)) {
#line 41
    r.tv_sec = ~ (((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L);
#line 42
    r.tv_nsec = 0L;
  } else
#line 44
  if (! (sec < max_representable)) {
#line 46
    r.tv_sec = ((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L;
#line 47
    r.tv_nsec = 999999999L;
  } else {
#line 51
    s = (time_t )sec;
#line 52
    frac = (double )1000000000 * (sec - (double )s);
#line 53
    ns = (long )frac;
#line 54
    ns += (long )((double )ns < frac);
#line 55
    s += ns / 1000000000L;
#line 56
    ns %= 1000000000L;
#line 58
    if (ns < 0L) {
#line 60
      s --;
#line 61
      ns += 1000000000L;
    }
#line 64
    r.tv_sec = s;
#line 65
    r.tv_nsec = ns;
  }
#line 68
  return (r);
}
}
#line 1 "exclude.o"
#pragma merger(0,"/tmp/cil-DrCo3LJV.i","-g,-O2")
#line 81 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 83
extern  __attribute__((__nothrow__)) __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
#line 85
extern  __attribute__((__nothrow__)) __int32_t const   **__ctype_toupper_loc(void)  __attribute__((__const__)) ;
#line 116
__inline extern  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 119
__inline extern  __attribute__((__nothrow__)) int toupper(int __c ) ;
#line 190
__inline extern  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 190 "/usr/include/ctype.h"
__inline extern int tolower(int __c ) 
{ __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
#line 193
  if (__c >= -128) {
#line 193
    if (__c < 256) {
#line 193
      tmp = __ctype_tolower_loc();
#line 193
      tmp___0 = (__int32_t )*(*tmp + __c);
    } else {
#line 193
      tmp___0 = (__int32_t )((__int32_t const   )__c);
    }
  } else {
#line 193
    tmp___0 = (__int32_t )((__int32_t const   )__c);
  }
#line 193
  return (tmp___0);
}
}
#line 196
__inline extern  __attribute__((__nothrow__)) int toupper(int __c ) ;
#line 196 "/usr/include/ctype.h"
__inline extern int toupper(int __c ) 
{ __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
#line 199
  if (__c >= -128) {
#line 199
    if (__c < 256) {
#line 199
      tmp = __ctype_toupper_loc();
#line 199
      tmp___0 = (__int32_t )*(*tmp + __c);
    } else {
#line 199
      tmp___0 = (__int32_t )((__int32_t const   )__c);
    }
  } else {
#line 199
    tmp___0 = (__int32_t )((__int32_t const   )__c);
  }
#line 199
  return (tmp___0);
}
}
#line 269 "/usr/include/stdio.h"
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __attribute__((__warn_unused_result__)) ;
#line 140 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t __ctype_get_mb_cur_max(void)  __attribute__((__warn_unused_result__)) ;
#line 262 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 1114 "./string.h"
int mbscasecmp(char const   *s1 , char const   *s2 )  __attribute__((__nonnull__(1,2))) ;
#line 144 "/usr/include/wchar.h"
__inline extern  __attribute__((__nothrow__)) wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wcscpy)(wchar_t * __restrict  __dest ,
                                                                                                                                     wchar_t const   * __restrict  __src ) ;
#line 147
__inline extern  __attribute__((__nothrow__)) wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wcsncpy)(wchar_t * __restrict  __dest ,
                                                                                                                                      wchar_t const   * __restrict  __src ,
                                                                                                                                      size_t __n ) ;
#line 152
__inline extern  __attribute__((__nothrow__)) wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wcscat)(wchar_t * __restrict  __dest ,
                                                                                                                                     wchar_t const   * __restrict  __src ) ;
#line 155
__inline extern  __attribute__((__nothrow__)) wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wcsncat)(wchar_t * __restrict  __dest ,
                                                                                                                                      wchar_t const   * __restrict  __src ,
                                                                                                                                      size_t __n ) ;
#line 327
__inline extern  __attribute__((__nothrow__)) wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wmemcpy)(wchar_t * __restrict  __s1 ,
                                                                                                                                      wchar_t const   * __restrict  __s2 ,
                                                                                                                                      size_t __n ) ;
#line 332
__inline extern  __attribute__((__nothrow__)) wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wmemmove)(wchar_t *__s1 ,
                                                                                                                                       wchar_t const   *__s2 ,
                                                                                                                                       size_t __n ) ;
#line 336
__inline extern  __attribute__((__nothrow__)) wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wmemset)(wchar_t *__s ,
                                                                                                                                      wchar_t __c ,
                                                                                                                                      size_t __n ) ;
#line 342
__inline extern  __attribute__((__nothrow__)) wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wmempcpy)(wchar_t * __restrict  __s1 ,
                                                                                                                                       wchar_t const   * __restrict  __s2 ,
                                                                                                                                       size_t __n ) ;
#line 351
__inline extern  __attribute__((__nothrow__)) wint_t btowc(int __c ) ;
#line 355
__inline extern  __attribute__((__nothrow__)) int wctob(wint_t __wc ) ;
#line 359
extern  __attribute__((__nothrow__)) int mbsinit(mbstate_t const   *__ps )  __attribute__((__pure__)) ;
#line 363
extern  __attribute__((__nothrow__)) size_t mbrtowc(wchar_t * __restrict  __pwc ,
                                                    char const   * __restrict  __s ,
                                                    size_t __n , mbstate_t *__p ) ;
#line 368
__inline extern  __attribute__((__nothrow__)) size_t __attribute__((__warn_unused_result__,
__artificial__))  ( __attribute__((__always_inline__)) wcrtomb)(char * __restrict  __s ,
                                                                wchar_t __wchar ,
                                                                mbstate_t * __restrict  __ps ) ;
#line 372
extern  __attribute__((__nothrow__)) size_t __mbrlen(char const   * __restrict  __s ,
                                                     size_t __n , mbstate_t * __restrict  __ps ) ;
#line 374
__inline extern  __attribute__((__nothrow__)) size_t mbrlen(char const   * __restrict  __s ,
                                                            size_t __n , mbstate_t * __restrict  __ps ) ;
#line 384
extern wint_t __btowc_alias(int __c )  __asm__("btowc")  ;
#line 385
__inline extern  __attribute__((__nothrow__)) wint_t btowc(int __c ) ;
#line 385 "/usr/include/wchar.h"
__inline extern wint_t btowc(int __c ) 
{ wint_t tmp ;

  {
#line 387
  tmp = __btowc_alias(__c);
#line 387
  return (tmp);
}
}
#line 390
extern int __wctob_alias(wint_t __c )  __asm__("wctob")  ;
#line 391
__inline extern  __attribute__((__nothrow__)) int wctob(wint_t __wc ) ;
#line 391 "/usr/include/wchar.h"
__inline extern int wctob(wint_t __wc ) 
{ int tmp ;

  {
#line 393
  tmp = __wctob_alias(__wc);
#line 393
  return (tmp);
}
}
#line 396
__inline extern  __attribute__((__nothrow__)) size_t mbrlen(char const   * __restrict  __s ,
                                                            size_t __n , mbstate_t * __restrict  __ps ) ;
#line 396 "/usr/include/wchar.h"
__inline extern size_t mbrlen(char const   * __restrict  __s , size_t __n , mbstate_t * __restrict  __ps ) 
{ size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 399
  if ((unsigned long )__ps != (unsigned long )((void *)0)) {
#line 399
    tmp = mbrtowc((wchar_t * __restrict  )((void *)0), __s, __n, (mbstate_t *)__ps);
#line 399
    tmp___1 = tmp;
  } else {
#line 399
    tmp___0 = __mbrlen(__s, __n, (mbstate_t * __restrict  )((void *)0));
#line 399
    tmp___1 = tmp___0;
  }
#line 399
  return (tmp___1);
}
}
#line 406
__inline extern  __attribute__((__nothrow__)) size_t __attribute__((__artificial__))  ( __attribute__((__always_inline__)) mbsrtowcs)(wchar_t * __restrict  __dst ,
                                                                                                                                      char const   ** __restrict  __src ,
                                                                                                                                      size_t __len ,
                                                                                                                                      mbstate_t * __restrict  __ps ) ;
#line 412
__inline extern  __attribute__((__nothrow__)) size_t __attribute__((__artificial__))  ( __attribute__((__always_inline__)) wcsrtombs)(char * __restrict  __dst ,
                                                                                                                                      wchar_t const   ** __restrict  __src ,
                                                                                                                                      size_t __len ,
                                                                                                                                      mbstate_t * __restrict  __ps ) ;
#line 421
__inline extern  __attribute__((__nothrow__)) size_t __attribute__((__artificial__))  ( __attribute__((__always_inline__)) mbsnrtowcs)(wchar_t * __restrict  __dst ,
                                                                                                                                       char const   ** __restrict  __src ,
                                                                                                                                       size_t __nmc ,
                                                                                                                                       size_t __len ,
                                                                                                                                       mbstate_t * __restrict  __ps ) ;
#line 427
__inline extern  __attribute__((__nothrow__)) size_t __attribute__((__artificial__))  ( __attribute__((__always_inline__)) wcsnrtombs)(char * __restrict  __dst ,
                                                                                                                                       wchar_t const   ** __restrict  __src ,
                                                                                                                                       size_t __nwc ,
                                                                                                                                       size_t __len ,
                                                                                                                                       mbstate_t * __restrict  __ps ) ;
#line 562
__inline extern  __attribute__((__nothrow__)) wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wcpcpy)(wchar_t * __restrict  __dest ,
                                                                                                                                     wchar_t const   * __restrict  __src ) ;
#line 567
__inline extern  __attribute__((__nothrow__)) wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wcpncpy)(wchar_t * __restrict  __dest ,
                                                                                                                                      wchar_t const   * __restrict  __src ,
                                                                                                                                      size_t __n ) ;
#line 592
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) fwprintf)(__FILE * __restrict  __stream ,
                                                                                                    wchar_t const   * __restrict  __fmt 
                                                                                                    , ...) ;
#line 599
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) wprintf)(wchar_t const   * __restrict  __fmt 
                                                                                                   , ...) ;
#line 602
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) swprintf)(wchar_t * __restrict  __s ,
                                                                                                                                  size_t __n ,
                                                                                                                                  wchar_t const   * __restrict  __fmt 
                                                                                                                                  , ...) ;
#line 610
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) vfwprintf)(__FILE * __restrict  __stream ,
                                                                                                     wchar_t const   * __restrict  __fmt ,
                                                                                                     __gnuc_va_list __ap ) ;
#line 618
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) vwprintf)(wchar_t const   * __restrict  __fmt ,
                                                                                                    __gnuc_va_list __ap ) ;
#line 623
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) vswprintf)(wchar_t * __restrict  __s ,
                                                                                                                                   size_t __n ,
                                                                                                                                   wchar_t const   * __restrict  __fmt ,
                                                                                                                                   __gnuc_va_list __ap ) ;
#line 772
__inline extern wchar_t __attribute__((__warn_unused_result__, __artificial__))  *( __attribute__((__always_inline__)) fgetws)(wchar_t * __restrict  __s ,
                                                                                                                               int __n ,
                                                                                                                               __FILE * __restrict  __stream ) ;
#line 835
__inline extern wchar_t __attribute__((__warn_unused_result__, __artificial__))  *( __attribute__((__always_inline__)) fgetws_unlocked)(wchar_t * __restrict  __s ,
                                                                                                                                        int __n ,
                                                                                                                                        __FILE * __restrict  __stream ) ;
#line 25 "/usr/include/bits/wchar2.h"
extern  __attribute__((__nothrow__)) wchar_t *__wmemcpy_chk(wchar_t * __restrict  __s1 ,
                                                            wchar_t const   * __restrict  __s2 ,
                                                            size_t __n , size_t __ns1 ) ;
#line 28
extern  __attribute__((__nothrow__)) wchar_t *__wmemcpy_alias(wchar_t * __restrict  __s1 ,
                                                              wchar_t const   * __restrict  __s2 ,
                                                              size_t __n )  __asm__("wmemcpy")  ;
#line 32
extern  __attribute__((__nothrow__)) wchar_t *__wmemcpy_chk_warn(wchar_t * __restrict  __s1 ,
                                                                 wchar_t const   * __restrict  __s2 ,
                                                                 size_t __n , size_t __ns1 )  __asm__("__wmemcpy_chk") __attribute__((__warning__("wmemcpy called with length bigger than size of destination buffer"))) ;
#line 39
__inline extern  __attribute__((__nothrow__)) wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wmemcpy)(wchar_t * __restrict  __s1 ,
                                                                                                                                      wchar_t const   * __restrict  __s2 ,
                                                                                                                                      size_t __n ) ;
#line 39 "/usr/include/bits/wchar2.h"
__inline extern wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wmemcpy)(wchar_t * __restrict  __s1 ,
                                                                                                        wchar_t const   * __restrict  __s2 ,
                                                                                                        size_t __n ) 
{ unsigned long tmp ;
  wchar_t *tmp___0 ;
  unsigned long tmp___1 ;
  wchar_t *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  wchar_t *tmp___5 ;

  {
#line 43
  tmp___4 = __builtin_object_size((void *)__s1, 0);
#line 43
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 46
    tmp = __builtin_object_size((void *)__s1, 0);
#line 46
    tmp___0 = __wmemcpy_chk(__s1, __s2, __n, tmp / sizeof(wchar_t ));
#line 46
    return ((wchar_t __attribute__((__artificial__))  *)tmp___0);
#line 49
    tmp___3 = __builtin_object_size((void *)__s1, 0);
#line 49
    if (__n > tmp___3 / sizeof(wchar_t )) {
#line 50
      tmp___1 = __builtin_object_size((void *)__s1, 0);
#line 50
      tmp___2 = __wmemcpy_chk_warn(__s1, __s2, __n, tmp___1 / sizeof(wchar_t ));
#line 50
      return ((wchar_t __attribute__((__artificial__))  *)tmp___2);
    }
  }
#line 53
  tmp___5 = __wmemcpy_alias(__s1, __s2, __n);
#line 53
  return ((wchar_t __attribute__((__artificial__))  *)tmp___5);
}
}
#line 57
extern  __attribute__((__nothrow__)) wchar_t *__wmemmove_chk(wchar_t *__s1 , wchar_t const   *__s2 ,
                                                             size_t __n , size_t __ns1 ) ;
#line 59
extern  __attribute__((__nothrow__)) wchar_t *__wmemmove_alias(wchar_t *__s1 , wchar_t const   *__s2 ,
                                                               size_t __n )  __asm__("wmemmove")  ;
#line 62
extern  __attribute__((__nothrow__)) wchar_t *__wmemmove_chk_warn(wchar_t *__s1 ,
                                                                  wchar_t const   *__s2 ,
                                                                  size_t __n , size_t __ns1 )  __asm__("__wmemmove_chk") __attribute__((__warning__("wmemmove called with length bigger than size of destination buffer"))) ;
#line 68
__inline extern  __attribute__((__nothrow__)) wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wmemmove)(wchar_t *__s1 ,
                                                                                                                                       wchar_t const   *__s2 ,
                                                                                                                                       size_t __n ) ;
#line 68 "/usr/include/bits/wchar2.h"
__inline extern wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wmemmove)(wchar_t *__s1 ,
                                                                                                         wchar_t const   *__s2 ,
                                                                                                         size_t __n ) 
{ unsigned long tmp ;
  wchar_t *tmp___0 ;
  unsigned long tmp___1 ;
  wchar_t *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  wchar_t *tmp___5 ;

  {
#line 71
  tmp___4 = __builtin_object_size((void *)__s1, 0);
#line 71
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 74
    tmp = __builtin_object_size((void *)__s1, 0);
#line 74
    tmp___0 = __wmemmove_chk(__s1, __s2, __n, tmp / sizeof(wchar_t ));
#line 74
    return ((wchar_t __attribute__((__artificial__))  *)tmp___0);
#line 77
    tmp___3 = __builtin_object_size((void *)__s1, 0);
#line 77
    if (__n > tmp___3 / sizeof(wchar_t )) {
#line 78
      tmp___1 = __builtin_object_size((void *)__s1, 0);
#line 78
      tmp___2 = __wmemmove_chk_warn(__s1, __s2, __n, tmp___1 / sizeof(wchar_t ));
#line 78
      return ((wchar_t __attribute__((__artificial__))  *)tmp___2);
    }
  }
#line 81
  tmp___5 = __wmemmove_alias(__s1, __s2, __n);
#line 81
  return ((wchar_t __attribute__((__artificial__))  *)tmp___5);
}
}
#line 86
extern  __attribute__((__nothrow__)) wchar_t *__wmempcpy_chk(wchar_t * __restrict  __s1 ,
                                                             wchar_t const   * __restrict  __s2 ,
                                                             size_t __n , size_t __ns1 ) ;
#line 89
extern  __attribute__((__nothrow__)) wchar_t *__wmempcpy_alias(wchar_t * __restrict  __s1 ,
                                                               wchar_t const   * __restrict  __s2 ,
                                                               size_t __n )  __asm__("wmempcpy")  ;
#line 93
extern  __attribute__((__nothrow__)) wchar_t *__wmempcpy_chk_warn(wchar_t * __restrict  __s1 ,
                                                                  wchar_t const   * __restrict  __s2 ,
                                                                  size_t __n , size_t __ns1 )  __asm__("__wmempcpy_chk") __attribute__((__warning__("wmempcpy called with length bigger than size of destination buffer"))) ;
#line 100
__inline extern  __attribute__((__nothrow__)) wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wmempcpy)(wchar_t * __restrict  __s1 ,
                                                                                                                                       wchar_t const   * __restrict  __s2 ,
                                                                                                                                       size_t __n ) ;
#line 100 "/usr/include/bits/wchar2.h"
__inline extern wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wmempcpy)(wchar_t * __restrict  __s1 ,
                                                                                                         wchar_t const   * __restrict  __s2 ,
                                                                                                         size_t __n ) 
{ unsigned long tmp ;
  wchar_t *tmp___0 ;
  unsigned long tmp___1 ;
  wchar_t *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  wchar_t *tmp___5 ;

  {
#line 104
  tmp___4 = __builtin_object_size((void *)__s1, 0);
#line 104
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 107
    tmp = __builtin_object_size((void *)__s1, 0);
#line 107
    tmp___0 = __wmempcpy_chk(__s1, __s2, __n, tmp / sizeof(wchar_t ));
#line 107
    return ((wchar_t __attribute__((__artificial__))  *)tmp___0);
#line 110
    tmp___3 = __builtin_object_size((void *)__s1, 0);
#line 110
    if (__n > tmp___3 / sizeof(wchar_t )) {
#line 111
      tmp___1 = __builtin_object_size((void *)__s1, 0);
#line 111
      tmp___2 = __wmempcpy_chk_warn(__s1, __s2, __n, tmp___1 / sizeof(wchar_t ));
#line 111
      return ((wchar_t __attribute__((__artificial__))  *)tmp___2);
    }
  }
#line 114
  tmp___5 = __wmempcpy_alias(__s1, __s2, __n);
#line 114
  return ((wchar_t __attribute__((__artificial__))  *)tmp___5);
}
}
#line 119
extern  __attribute__((__nothrow__)) wchar_t *__wmemset_chk(wchar_t *__s , wchar_t __c ,
                                                            size_t __n , size_t __ns ) ;
#line 121
extern  __attribute__((__nothrow__)) wchar_t *__wmemset_alias(wchar_t *__s , wchar_t __c ,
                                                              size_t __n )  __asm__("wmemset")  ;
#line 123
extern  __attribute__((__nothrow__)) wchar_t *__wmemset_chk_warn(wchar_t *__s , wchar_t __c ,
                                                                 size_t __n , size_t __ns )  __asm__("__wmemset_chk") __attribute__((__warning__("wmemset called with length bigger than size of destination buffer"))) ;
#line 129
__inline extern  __attribute__((__nothrow__)) wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wmemset)(wchar_t *__s ,
                                                                                                                                      wchar_t __c ,
                                                                                                                                      size_t __n ) ;
#line 129 "/usr/include/bits/wchar2.h"
__inline extern wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wmemset)(wchar_t *__s ,
                                                                                                        wchar_t __c ,
                                                                                                        size_t __n ) 
{ unsigned long tmp ;
  wchar_t *tmp___0 ;
  unsigned long tmp___1 ;
  wchar_t *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  wchar_t *tmp___5 ;

  {
#line 132
  tmp___4 = __builtin_object_size((void *)__s, 0);
#line 132
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 135
    tmp = __builtin_object_size((void *)__s, 0);
#line 135
    tmp___0 = __wmemset_chk(__s, __c, __n, tmp / sizeof(wchar_t ));
#line 135
    return ((wchar_t __attribute__((__artificial__))  *)tmp___0);
#line 137
    tmp___3 = __builtin_object_size((void *)__s, 0);
#line 137
    if (__n > tmp___3 / sizeof(wchar_t )) {
#line 138
      tmp___1 = __builtin_object_size((void *)__s, 0);
#line 138
      tmp___2 = __wmemset_chk_warn(__s, __c, __n, tmp___1 / sizeof(wchar_t ));
#line 138
      return ((wchar_t __attribute__((__artificial__))  *)tmp___2);
    }
  }
#line 141
  tmp___5 = __wmemset_alias(__s, __c, __n);
#line 141
  return ((wchar_t __attribute__((__artificial__))  *)tmp___5);
}
}
#line 145
extern  __attribute__((__nothrow__)) wchar_t *__wcscpy_chk(wchar_t * __restrict  __dest ,
                                                           wchar_t const   * __restrict  __src ,
                                                           size_t __n ) ;
#line 148
extern  __attribute__((__nothrow__)) wchar_t *__wcscpy_alias(wchar_t * __restrict  __dest ,
                                                             wchar_t const   * __restrict  __src )  __asm__("wcscpy")  ;
#line 152
__inline extern  __attribute__((__nothrow__)) wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wcscpy)(wchar_t * __restrict  __dest ,
                                                                                                                                     wchar_t const   * __restrict  __src ) ;
#line 152 "/usr/include/bits/wchar2.h"
__inline extern wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wcscpy)(wchar_t * __restrict  __dest ,
                                                                                                       wchar_t const   * __restrict  __src ) 
{ unsigned long tmp ;
  wchar_t *tmp___0 ;
  unsigned long tmp___1 ;
  wchar_t *tmp___2 ;

  {
#line 155
  tmp___1 = __builtin_object_size((void *)__dest, 1);
#line 155
  if (tmp___1 != 0xffffffffffffffffUL) {
#line 156
    tmp = __builtin_object_size((void *)__dest, 1);
#line 156
    tmp___0 = __wcscpy_chk(__dest, __src, tmp / sizeof(wchar_t ));
#line 156
    return ((wchar_t __attribute__((__artificial__))  *)tmp___0);
  }
#line 157
  tmp___2 = __wcscpy_alias(__dest, __src);
#line 157
  return ((wchar_t __attribute__((__artificial__))  *)tmp___2);
}
}
#line 161
extern  __attribute__((__nothrow__)) wchar_t *__wcpcpy_chk(wchar_t * __restrict  __dest ,
                                                           wchar_t const   * __restrict  __src ,
                                                           size_t __destlen ) ;
#line 164
extern  __attribute__((__nothrow__)) wchar_t *__wcpcpy_alias(wchar_t * __restrict  __dest ,
                                                             wchar_t const   * __restrict  __src )  __asm__("wcpcpy")  ;
#line 168
__inline extern  __attribute__((__nothrow__)) wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wcpcpy)(wchar_t * __restrict  __dest ,
                                                                                                                                     wchar_t const   * __restrict  __src ) ;
#line 168 "/usr/include/bits/wchar2.h"
__inline extern wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wcpcpy)(wchar_t * __restrict  __dest ,
                                                                                                       wchar_t const   * __restrict  __src ) 
{ unsigned long tmp ;
  wchar_t *tmp___0 ;
  unsigned long tmp___1 ;
  wchar_t *tmp___2 ;

  {
#line 171
  tmp___1 = __builtin_object_size((void *)__dest, 1);
#line 171
  if (tmp___1 != 0xffffffffffffffffUL) {
#line 172
    tmp = __builtin_object_size((void *)__dest, 1);
#line 172
    tmp___0 = __wcpcpy_chk(__dest, __src, tmp / sizeof(wchar_t ));
#line 172
    return ((wchar_t __attribute__((__artificial__))  *)tmp___0);
  }
#line 173
  tmp___2 = __wcpcpy_alias(__dest, __src);
#line 173
  return ((wchar_t __attribute__((__artificial__))  *)tmp___2);
}
}
#line 177
extern  __attribute__((__nothrow__)) wchar_t *__wcsncpy_chk(wchar_t * __restrict  __dest ,
                                                            wchar_t const   * __restrict  __src ,
                                                            size_t __n , size_t __destlen ) ;
#line 180
extern  __attribute__((__nothrow__)) wchar_t *__wcsncpy_alias(wchar_t * __restrict  __dest ,
                                                              wchar_t const   * __restrict  __src ,
                                                              size_t __n )  __asm__("wcsncpy")  ;
#line 184
extern  __attribute__((__nothrow__)) wchar_t *__wcsncpy_chk_warn(wchar_t * __restrict  __dest ,
                                                                 wchar_t const   * __restrict  __src ,
                                                                 size_t __n , size_t __destlen )  __asm__("__wcsncpy_chk") __attribute__((__warning__("wcsncpy called with length bigger than size of destination buffer"))) ;
#line 191
__inline extern  __attribute__((__nothrow__)) wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wcsncpy)(wchar_t * __restrict  __dest ,
                                                                                                                                      wchar_t const   * __restrict  __src ,
                                                                                                                                      size_t __n ) ;
#line 191 "/usr/include/bits/wchar2.h"
__inline extern wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wcsncpy)(wchar_t * __restrict  __dest ,
                                                                                                        wchar_t const   * __restrict  __src ,
                                                                                                        size_t __n ) 
{ unsigned long tmp ;
  wchar_t *tmp___0 ;
  unsigned long tmp___1 ;
  wchar_t *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  wchar_t *tmp___5 ;

  {
#line 195
  tmp___4 = __builtin_object_size((void *)__dest, 1);
#line 195
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 198
    tmp = __builtin_object_size((void *)__dest, 1);
#line 198
    tmp___0 = __wcsncpy_chk(__dest, __src, __n, tmp / sizeof(wchar_t ));
#line 198
    return ((wchar_t __attribute__((__artificial__))  *)tmp___0);
#line 200
    tmp___3 = __builtin_object_size((void *)__dest, 1);
#line 200
    if (__n > tmp___3 / sizeof(wchar_t )) {
#line 201
      tmp___1 = __builtin_object_size((void *)__dest, 1);
#line 201
      tmp___2 = __wcsncpy_chk_warn(__dest, __src, __n, tmp___1 / sizeof(wchar_t ));
#line 201
      return ((wchar_t __attribute__((__artificial__))  *)tmp___2);
    }
  }
#line 204
  tmp___5 = __wcsncpy_alias(__dest, __src, __n);
#line 204
  return ((wchar_t __attribute__((__artificial__))  *)tmp___5);
}
}
#line 208
extern  __attribute__((__nothrow__)) wchar_t *__wcpncpy_chk(wchar_t * __restrict  __dest ,
                                                            wchar_t const   * __restrict  __src ,
                                                            size_t __n , size_t __destlen ) ;
#line 211
extern  __attribute__((__nothrow__)) wchar_t *__wcpncpy_alias(wchar_t * __restrict  __dest ,
                                                              wchar_t const   * __restrict  __src ,
                                                              size_t __n )  __asm__("wcpncpy")  ;
#line 215
extern  __attribute__((__nothrow__)) wchar_t *__wcpncpy_chk_warn(wchar_t * __restrict  __dest ,
                                                                 wchar_t const   * __restrict  __src ,
                                                                 size_t __n , size_t __destlen )  __asm__("__wcpncpy_chk") __attribute__((__warning__("wcpncpy called with length bigger than size of destination buffer"))) ;
#line 222
__inline extern  __attribute__((__nothrow__)) wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wcpncpy)(wchar_t * __restrict  __dest ,
                                                                                                                                      wchar_t const   * __restrict  __src ,
                                                                                                                                      size_t __n ) ;
#line 222 "/usr/include/bits/wchar2.h"
__inline extern wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wcpncpy)(wchar_t * __restrict  __dest ,
                                                                                                        wchar_t const   * __restrict  __src ,
                                                                                                        size_t __n ) 
{ unsigned long tmp ;
  wchar_t *tmp___0 ;
  unsigned long tmp___1 ;
  wchar_t *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  wchar_t *tmp___5 ;

  {
#line 226
  tmp___4 = __builtin_object_size((void *)__dest, 1);
#line 226
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 229
    tmp = __builtin_object_size((void *)__dest, 1);
#line 229
    tmp___0 = __wcpncpy_chk(__dest, __src, __n, tmp / sizeof(wchar_t ));
#line 229
    return ((wchar_t __attribute__((__artificial__))  *)tmp___0);
#line 231
    tmp___3 = __builtin_object_size((void *)__dest, 1);
#line 231
    if (__n > tmp___3 / sizeof(wchar_t )) {
#line 232
      tmp___1 = __builtin_object_size((void *)__dest, 1);
#line 232
      tmp___2 = __wcpncpy_chk_warn(__dest, __src, __n, tmp___1 / sizeof(wchar_t ));
#line 232
      return ((wchar_t __attribute__((__artificial__))  *)tmp___2);
    }
  }
#line 235
  tmp___5 = __wcpncpy_alias(__dest, __src, __n);
#line 235
  return ((wchar_t __attribute__((__artificial__))  *)tmp___5);
}
}
#line 239
extern  __attribute__((__nothrow__)) wchar_t *__wcscat_chk(wchar_t * __restrict  __dest ,
                                                           wchar_t const   * __restrict  __src ,
                                                           size_t __destlen ) ;
#line 242
extern  __attribute__((__nothrow__)) wchar_t *__wcscat_alias(wchar_t * __restrict  __dest ,
                                                             wchar_t const   * __restrict  __src )  __asm__("wcscat")  ;
#line 246
__inline extern  __attribute__((__nothrow__)) wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wcscat)(wchar_t * __restrict  __dest ,
                                                                                                                                     wchar_t const   * __restrict  __src ) ;
#line 246 "/usr/include/bits/wchar2.h"
__inline extern wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wcscat)(wchar_t * __restrict  __dest ,
                                                                                                       wchar_t const   * __restrict  __src ) 
{ unsigned long tmp ;
  wchar_t *tmp___0 ;
  unsigned long tmp___1 ;
  wchar_t *tmp___2 ;

  {
#line 249
  tmp___1 = __builtin_object_size((void *)__dest, 1);
#line 249
  if (tmp___1 != 0xffffffffffffffffUL) {
#line 250
    tmp = __builtin_object_size((void *)__dest, 1);
#line 250
    tmp___0 = __wcscat_chk(__dest, __src, tmp / sizeof(wchar_t ));
#line 250
    return ((wchar_t __attribute__((__artificial__))  *)tmp___0);
  }
#line 251
  tmp___2 = __wcscat_alias(__dest, __src);
#line 251
  return ((wchar_t __attribute__((__artificial__))  *)tmp___2);
}
}
#line 255
extern  __attribute__((__nothrow__)) wchar_t *__wcsncat_chk(wchar_t * __restrict  __dest ,
                                                            wchar_t const   * __restrict  __src ,
                                                            size_t __n , size_t __destlen ) ;
#line 258
extern  __attribute__((__nothrow__)) wchar_t *__wcsncat_alias(wchar_t * __restrict  __dest ,
                                                              wchar_t const   * __restrict  __src ,
                                                              size_t __n )  __asm__("wcsncat")  ;
#line 263
__inline extern  __attribute__((__nothrow__)) wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wcsncat)(wchar_t * __restrict  __dest ,
                                                                                                                                      wchar_t const   * __restrict  __src ,
                                                                                                                                      size_t __n ) ;
#line 263 "/usr/include/bits/wchar2.h"
__inline extern wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wcsncat)(wchar_t * __restrict  __dest ,
                                                                                                        wchar_t const   * __restrict  __src ,
                                                                                                        size_t __n ) 
{ unsigned long tmp ;
  wchar_t *tmp___0 ;
  unsigned long tmp___1 ;
  wchar_t *tmp___2 ;

  {
#line 267
  tmp___1 = __builtin_object_size((void *)__dest, 1);
#line 267
  if (tmp___1 != 0xffffffffffffffffUL) {
#line 268
    tmp = __builtin_object_size((void *)__dest, 1);
#line 268
    tmp___0 = __wcsncat_chk(__dest, __src, __n, tmp / sizeof(wchar_t ));
#line 268
    return ((wchar_t __attribute__((__artificial__))  *)tmp___0);
  }
#line 270
  tmp___2 = __wcsncat_alias(__dest, __src, __n);
#line 270
  return ((wchar_t __attribute__((__artificial__))  *)tmp___2);
}
}
#line 274
extern  __attribute__((__nothrow__)) int __swprintf_chk(wchar_t * __restrict  __s ,
                                                        size_t __n , int __flag ,
                                                        size_t __s_len , wchar_t const   * __restrict  __format 
                                                        , ...) ;
#line 279
extern  __attribute__((__nothrow__)) int __swprintf_alias(wchar_t * __restrict  __s ,
                                                          size_t __n , wchar_t const   * __restrict  __fmt 
                                                          , ...)  __asm__("swprintf")  ;
#line 285
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) swprintf)(wchar_t * __restrict  __s ,
                                                                                                                                  size_t __n ,
                                                                                                                                  wchar_t const   * __restrict  __fmt 
                                                                                                                                  , ...) ;
#line 285 "/usr/include/bits/wchar2.h"
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) swprintf)(wchar_t * __restrict  __s ,
                                                                                                    size_t __n ,
                                                                                                    wchar_t const   * __restrict  __fmt 
                                                                                                    , ...) 
{ unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;

  {
#line 289
  tmp___1 = __builtin_object_size((void *)__s, 1);
#line 289
  if (tmp___1 != 0xffffffffffffffffUL) {
#line 290
    tmp = __builtin_object_size((void *)__s, 1);
#line 290
    tmp___0 = __swprintf_chk(__s, __n, 1, tmp / sizeof(wchar_t ), __fmt, __builtin_va_arg_pack());
#line 290
    return ((int __attribute__((__artificial__))  )tmp___0);
  } else {
#line 290
    tmp = __builtin_object_size((void *)__s, 1);
#line 290
    tmp___0 = __swprintf_chk(__s, __n, 1, tmp / sizeof(wchar_t ), __fmt, __builtin_va_arg_pack());
#line 290
    return ((int __attribute__((__artificial__))  )tmp___0);
  }
#line 293
  tmp___2 = __swprintf_alias(__s, __n, __fmt, __builtin_va_arg_pack());
#line 293
  return ((int __attribute__((__artificial__))  )tmp___2);
}
}
#line 304
extern  __attribute__((__nothrow__)) int __vswprintf_chk(wchar_t * __restrict  __s ,
                                                         size_t __n , int __flag ,
                                                         size_t __s_len , wchar_t const   * __restrict  __format ,
                                                         __gnuc_va_list __arg ) ;
#line 310
extern  __attribute__((__nothrow__)) int __vswprintf_alias(wchar_t * __restrict  __s ,
                                                           size_t __n , wchar_t const   * __restrict  __fmt ,
                                                           __gnuc_va_list __ap )  __asm__("vswprintf")  ;
#line 315
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) vswprintf)(wchar_t * __restrict  __s ,
                                                                                                                                   size_t __n ,
                                                                                                                                   wchar_t const   * __restrict  __fmt ,
                                                                                                                                   __gnuc_va_list __ap ) ;
#line 315 "/usr/include/bits/wchar2.h"
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) vswprintf)(wchar_t * __restrict  __s ,
                                                                                                     size_t __n ,
                                                                                                     wchar_t const   * __restrict  __fmt ,
                                                                                                     __gnuc_va_list __ap ) 
{ unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;

  {
#line 319
  tmp___1 = __builtin_object_size((void *)__s, 1);
#line 319
  if (tmp___1 != 0xffffffffffffffffUL) {
#line 320
    tmp = __builtin_object_size((void *)__s, 1);
#line 320
    tmp___0 = __vswprintf_chk(__s, __n, 1, tmp / sizeof(wchar_t ), __fmt, __ap);
#line 320
    return ((int __attribute__((__artificial__))  )tmp___0);
  } else {
#line 320
    tmp = __builtin_object_size((void *)__s, 1);
#line 320
    tmp___0 = __vswprintf_chk(__s, __n, 1, tmp / sizeof(wchar_t ), __fmt, __ap);
#line 320
    return ((int __attribute__((__artificial__))  )tmp___0);
  }
#line 322
  tmp___2 = __vswprintf_alias(__s, __n, __fmt, __ap);
#line 322
  return ((int __attribute__((__artificial__))  )tmp___2);
}
}
#line 328
extern int __fwprintf_chk(__FILE * __restrict  __stream , int __flag , wchar_t const   * __restrict  __format 
                          , ...) ;
#line 330
extern int __wprintf_chk(int __flag , wchar_t const   * __restrict  __format  , ...) ;
#line 332
extern int __vfwprintf_chk(__FILE * __restrict  __stream , int __flag , wchar_t const   * __restrict  __format ,
                           __gnuc_va_list __ap ) ;
#line 335
extern int __vwprintf_chk(int __flag , wchar_t const   * __restrict  __format , __gnuc_va_list __ap ) ;
#line 339 "/usr/include/bits/wchar2.h"
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) wprintf)(wchar_t const   * __restrict  __fmt 
                                                                                                   , ...) 
{ int tmp ;

  {
#line 342
  tmp = __wprintf_chk(1, __fmt, __builtin_va_arg_pack());
#line 342
  return ((int __attribute__((__artificial__))  )tmp);
}
}
#line 345 "/usr/include/bits/wchar2.h"
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) fwprintf)(__FILE * __restrict  __stream ,
                                                                                                    wchar_t const   * __restrict  __fmt 
                                                                                                    , ...) 
{ int tmp ;

  {
#line 348
  tmp = __fwprintf_chk(__stream, 1, __fmt, __builtin_va_arg_pack());
#line 348
  return ((int __attribute__((__artificial__))  )tmp);
}
}
#line 358 "/usr/include/bits/wchar2.h"
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) vwprintf)(wchar_t const   * __restrict  __fmt ,
                                                                                                    __gnuc_va_list __ap ) 
{ int tmp ;

  {
#line 361
  tmp = __vwprintf_chk(1, __fmt, __ap);
#line 361
  return ((int __attribute__((__artificial__))  )tmp);
}
}
#line 364 "/usr/include/bits/wchar2.h"
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) vfwprintf)(__FILE * __restrict  __stream ,
                                                                                                     wchar_t const   * __restrict  __fmt ,
                                                                                                     __gnuc_va_list __ap ) 
{ int tmp ;

  {
#line 368
  tmp = __vfwprintf_chk(__stream, 1, __fmt, __ap);
#line 368
  return ((int __attribute__((__artificial__))  )tmp);
}
}
#line 373
extern wchar_t *__fgetws_chk(wchar_t * __restrict  __s , size_t __size , int __n ,
                             __FILE * __restrict  __stream )  __attribute__((__warn_unused_result__)) ;
#line 375
extern wchar_t *__fgetws_alias(wchar_t * __restrict  __s , int __n , __FILE * __restrict  __stream )  __asm__("fgetws") __attribute__((__warn_unused_result__)) ;
#line 378
extern wchar_t *__fgetws_chk_warn(wchar_t * __restrict  __s , size_t __size , int __n ,
                                  __FILE * __restrict  __stream )  __asm__("__fgetws_chk") __attribute__((__warning__("fgetws called with bigger size than length of destination buffer"),
__warn_unused_result__)) ;
#line 384 "/usr/include/bits/wchar2.h"
__inline extern wchar_t __attribute__((__warn_unused_result__, __artificial__))  *( __attribute__((__always_inline__)) fgetws)(wchar_t * __restrict  __s ,
                                                                                                                               int __n ,
                                                                                                                               __FILE * __restrict  __stream ) 
{ unsigned long tmp ;
  wchar_t *tmp___0 ;
  unsigned long tmp___1 ;
  wchar_t *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  wchar_t *tmp___5 ;

  {
#line 387
  tmp___4 = __builtin_object_size((void *)__s, 1);
#line 387
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 390
    tmp = __builtin_object_size((void *)__s, 1);
#line 390
    tmp___0 = __fgetws_chk(__s, tmp / sizeof(wchar_t ), __n, __stream);
#line 390
    return ((wchar_t __attribute__((__warn_unused_result__, __artificial__))  *)tmp___0);
#line 393
    tmp___3 = __builtin_object_size((void *)__s, 1);
#line 393
    if ((size_t )__n > tmp___3 / sizeof(wchar_t )) {
#line 394
      tmp___1 = __builtin_object_size((void *)__s, 1);
#line 394
      tmp___2 = __fgetws_chk_warn(__s, tmp___1 / sizeof(wchar_t ), __n, __stream);
#line 394
      return ((wchar_t __attribute__((__warn_unused_result__, __artificial__))  *)tmp___2);
    }
  }
#line 397
  tmp___5 = __fgetws_alias(__s, __n, __stream);
#line 397
  return ((wchar_t __attribute__((__warn_unused_result__, __artificial__))  *)tmp___5);
}
}
#line 401
extern wchar_t *__fgetws_unlocked_chk(wchar_t * __restrict  __s , size_t __size ,
                                      int __n , __FILE * __restrict  __stream )  __attribute__((__warn_unused_result__)) ;
#line 404
extern wchar_t *__fgetws_unlocked_alias(wchar_t * __restrict  __s , int __n , __FILE * __restrict  __stream )  __asm__("fgetws_unlocked") __attribute__((__warn_unused_result__)) ;
#line 408
extern wchar_t *__fgetws_unlocked_chk_warn(wchar_t * __restrict  __s , size_t __size ,
                                           int __n , __FILE * __restrict  __stream )  __asm__("__fgetws_unlocked_chk") __attribute__((__warning__("fgetws_unlocked called with bigger size than length of destination buffer"),
__warn_unused_result__)) ;
#line 415 "/usr/include/bits/wchar2.h"
__inline extern wchar_t __attribute__((__warn_unused_result__, __artificial__))  *( __attribute__((__always_inline__)) fgetws_unlocked)(wchar_t * __restrict  __s ,
                                                                                                                                        int __n ,
                                                                                                                                        __FILE * __restrict  __stream ) 
{ unsigned long tmp ;
  wchar_t *tmp___0 ;
  unsigned long tmp___1 ;
  wchar_t *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  wchar_t *tmp___5 ;

  {
#line 418
  tmp___4 = __builtin_object_size((void *)__s, 1);
#line 418
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 421
    tmp = __builtin_object_size((void *)__s, 1);
#line 421
    tmp___0 = __fgetws_unlocked_chk(__s, tmp / sizeof(wchar_t ), __n, __stream);
#line 421
    return ((wchar_t __attribute__((__warn_unused_result__, __artificial__))  *)tmp___0);
#line 424
    tmp___3 = __builtin_object_size((void *)__s, 1);
#line 424
    if ((size_t )__n > tmp___3 / sizeof(wchar_t )) {
#line 425
      tmp___1 = __builtin_object_size((void *)__s, 1);
#line 425
      tmp___2 = __fgetws_unlocked_chk_warn(__s, tmp___1 / sizeof(wchar_t ), __n, __stream);
#line 425
      return ((wchar_t __attribute__((__warn_unused_result__, __artificial__))  *)tmp___2);
    }
  }
#line 428
  tmp___5 = __fgetws_unlocked_alias(__s, __n, __stream);
#line 428
  return ((wchar_t __attribute__((__warn_unused_result__, __artificial__))  *)tmp___5);
}
}
#line 433
extern  __attribute__((__nothrow__)) size_t __wcrtomb_chk(char * __restrict  __s ,
                                                          wchar_t __wchar , mbstate_t * __restrict  __p ,
                                                          size_t __buflen )  __attribute__((__warn_unused_result__)) ;
#line 436
extern  __attribute__((__nothrow__)) size_t __wcrtomb_alias(char * __restrict  __s ,
                                                            wchar_t __wchar , mbstate_t * __restrict  __ps )  __asm__("wcrtomb") __attribute__((__warn_unused_result__)) ;
#line 440
__inline extern  __attribute__((__nothrow__)) size_t __attribute__((__warn_unused_result__,
__artificial__))  ( __attribute__((__always_inline__)) wcrtomb)(char * __restrict  __s ,
                                                                wchar_t __wchar ,
                                                                mbstate_t * __restrict  __ps ) ;
#line 440 "/usr/include/bits/wchar2.h"
__inline extern size_t __attribute__((__warn_unused_result__, __artificial__))  ( __attribute__((__always_inline__)) wcrtomb)(char * __restrict  __s ,
                                                                                                                              wchar_t __wchar ,
                                                                                                                              mbstate_t * __restrict  __ps ) 
{ unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  size_t tmp___3 ;

  {
#line 451
  tmp___1 = __builtin_object_size((void *)__s, 1);
#line 451
  if (tmp___1 != 0xffffffffffffffffUL) {
#line 451
    tmp___2 = __builtin_object_size((void *)__s, 1);
#line 451
    if (16UL > tmp___2) {
#line 452
      tmp = __builtin_object_size((void *)__s, 1);
#line 452
      tmp___0 = __wcrtomb_chk(__s, __wchar, __ps, tmp);
#line 452
      return ((size_t __attribute__((__artificial__))  )tmp___0);
    }
  }
#line 453
  tmp___3 = __wcrtomb_alias(__s, __wchar, __ps);
#line 453
  return ((size_t __attribute__((__artificial__))  )tmp___3);
}
}
#line 457
extern  __attribute__((__nothrow__)) size_t __mbsrtowcs_chk(wchar_t * __restrict  __dst ,
                                                            char const   ** __restrict  __src ,
                                                            size_t __len , mbstate_t * __restrict  __ps ,
                                                            size_t __dstlen ) ;
#line 461
extern  __attribute__((__nothrow__)) size_t __mbsrtowcs_alias(wchar_t * __restrict  __dst ,
                                                              char const   ** __restrict  __src ,
                                                              size_t __len , mbstate_t * __restrict  __ps )  __asm__("mbsrtowcs")  ;
#line 466
extern  __attribute__((__nothrow__)) size_t __mbsrtowcs_chk_warn(wchar_t * __restrict  __dst ,
                                                                 char const   ** __restrict  __src ,
                                                                 size_t __len , mbstate_t * __restrict  __ps ,
                                                                 size_t __dstlen )  __asm__("__mbsrtowcs_chk") __attribute__((__warning__("mbsrtowcs called with dst buffer smaller than len * sizeof (wchar_t)"))) ;
#line 474
__inline extern  __attribute__((__nothrow__)) size_t __attribute__((__artificial__))  ( __attribute__((__always_inline__)) mbsrtowcs)(wchar_t * __restrict  __dst ,
                                                                                                                                      char const   ** __restrict  __src ,
                                                                                                                                      size_t __len ,
                                                                                                                                      mbstate_t * __restrict  __ps ) ;
#line 474 "/usr/include/bits/wchar2.h"
__inline extern size_t __attribute__((__artificial__))  ( __attribute__((__always_inline__)) mbsrtowcs)(wchar_t * __restrict  __dst ,
                                                                                                        char const   ** __restrict  __src ,
                                                                                                        size_t __len ,
                                                                                                        mbstate_t * __restrict  __ps ) 
{ unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
#line 478
  tmp___4 = __builtin_object_size((void *)__dst, 1);
#line 478
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 481
    tmp = __builtin_object_size((void *)__dst, 1);
#line 481
    tmp___0 = __mbsrtowcs_chk(__dst, __src, __len, __ps, tmp / sizeof(wchar_t ));
#line 481
    return ((size_t __attribute__((__artificial__))  )tmp___0);
#line 484
    tmp___3 = __builtin_object_size((void *)__dst, 1);
#line 484
    if (__len > tmp___3 / sizeof(wchar_t )) {
#line 485
      tmp___1 = __builtin_object_size((void *)__dst, 1);
#line 485
      tmp___2 = __mbsrtowcs_chk_warn(__dst, __src, __len, __ps, tmp___1 / sizeof(wchar_t ));
#line 485
      return ((size_t __attribute__((__artificial__))  )tmp___2);
    }
  }
#line 488
  tmp___5 = __mbsrtowcs_alias(__dst, __src, __len, __ps);
#line 488
  return ((size_t __attribute__((__artificial__))  )tmp___5);
}
}
#line 492
extern  __attribute__((__nothrow__)) size_t __wcsrtombs_chk(char * __restrict  __dst ,
                                                            wchar_t const   ** __restrict  __src ,
                                                            size_t __len , mbstate_t * __restrict  __ps ,
                                                            size_t __dstlen ) ;
#line 496
extern  __attribute__((__nothrow__)) size_t __wcsrtombs_alias(char * __restrict  __dst ,
                                                              wchar_t const   ** __restrict  __src ,
                                                              size_t __len , mbstate_t * __restrict  __ps )  __asm__("wcsrtombs")  ;
#line 501
extern  __attribute__((__nothrow__)) size_t __wcsrtombs_chk_warn(char * __restrict  __dst ,
                                                                 wchar_t const   ** __restrict  __src ,
                                                                 size_t __len , mbstate_t * __restrict  __ps ,
                                                                 size_t __dstlen )  __asm__("__wcsrtombs_chk") __attribute__((__warning__("wcsrtombs called with dst buffer smaller than len"))) ;
#line 508
__inline extern  __attribute__((__nothrow__)) size_t __attribute__((__artificial__))  ( __attribute__((__always_inline__)) wcsrtombs)(char * __restrict  __dst ,
                                                                                                                                      wchar_t const   ** __restrict  __src ,
                                                                                                                                      size_t __len ,
                                                                                                                                      mbstate_t * __restrict  __ps ) ;
#line 508 "/usr/include/bits/wchar2.h"
__inline extern size_t __attribute__((__artificial__))  ( __attribute__((__always_inline__)) wcsrtombs)(char * __restrict  __dst ,
                                                                                                        wchar_t const   ** __restrict  __src ,
                                                                                                        size_t __len ,
                                                                                                        mbstate_t * __restrict  __ps ) 
{ unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
#line 512
  tmp___4 = __builtin_object_size((void *)__dst, 1);
#line 512
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 515
    tmp = __builtin_object_size((void *)__dst, 1);
#line 515
    tmp___0 = __wcsrtombs_chk(__dst, __src, __len, __ps, tmp);
#line 515
    return ((size_t __attribute__((__artificial__))  )tmp___0);
#line 517
    tmp___3 = __builtin_object_size((void *)__dst, 1);
#line 517
    if (__len > tmp___3) {
#line 518
      tmp___1 = __builtin_object_size((void *)__dst, 1);
#line 518
      tmp___2 = __wcsrtombs_chk_warn(__dst, __src, __len, __ps, tmp___1);
#line 518
      return ((size_t __attribute__((__artificial__))  )tmp___2);
    }
  }
#line 520
  tmp___5 = __wcsrtombs_alias(__dst, __src, __len, __ps);
#line 520
  return ((size_t __attribute__((__artificial__))  )tmp___5);
}
}
#line 525
extern  __attribute__((__nothrow__)) size_t __mbsnrtowcs_chk(wchar_t * __restrict  __dst ,
                                                             char const   ** __restrict  __src ,
                                                             size_t __nmc , size_t __len ,
                                                             mbstate_t * __restrict  __ps ,
                                                             size_t __dstlen ) ;
#line 529
extern  __attribute__((__nothrow__)) size_t __mbsnrtowcs_alias(wchar_t * __restrict  __dst ,
                                                               char const   ** __restrict  __src ,
                                                               size_t __nmc , size_t __len ,
                                                               mbstate_t * __restrict  __ps )  __asm__("mbsnrtowcs")  ;
#line 534
extern  __attribute__((__nothrow__)) size_t __mbsnrtowcs_chk_warn(wchar_t * __restrict  __dst ,
                                                                  char const   ** __restrict  __src ,
                                                                  size_t __nmc , size_t __len ,
                                                                  mbstate_t * __restrict  __ps ,
                                                                  size_t __dstlen )  __asm__("__mbsnrtowcs_chk") __attribute__((__warning__("mbsnrtowcs called with dst buffer smaller than len * sizeof (wchar_t)"))) ;
#line 542
__inline extern  __attribute__((__nothrow__)) size_t __attribute__((__artificial__))  ( __attribute__((__always_inline__)) mbsnrtowcs)(wchar_t * __restrict  __dst ,
                                                                                                                                       char const   ** __restrict  __src ,
                                                                                                                                       size_t __nmc ,
                                                                                                                                       size_t __len ,
                                                                                                                                       mbstate_t * __restrict  __ps ) ;
#line 542 "/usr/include/bits/wchar2.h"
__inline extern size_t __attribute__((__artificial__))  ( __attribute__((__always_inline__)) mbsnrtowcs)(wchar_t * __restrict  __dst ,
                                                                                                         char const   ** __restrict  __src ,
                                                                                                         size_t __nmc ,
                                                                                                         size_t __len ,
                                                                                                         mbstate_t * __restrict  __ps ) 
{ unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
#line 546
  tmp___4 = __builtin_object_size((void *)__dst, 1);
#line 546
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 549
    tmp = __builtin_object_size((void *)__dst, 1);
#line 549
    tmp___0 = __mbsnrtowcs_chk(__dst, __src, __nmc, __len, __ps, tmp / sizeof(wchar_t ));
#line 549
    return ((size_t __attribute__((__artificial__))  )tmp___0);
#line 552
    tmp___3 = __builtin_object_size((void *)__dst, 1);
#line 552
    if (__len > tmp___3 / sizeof(wchar_t )) {
#line 553
      tmp___1 = __builtin_object_size((void *)__dst, 1);
#line 553
      tmp___2 = __mbsnrtowcs_chk_warn(__dst, __src, __nmc, __len, __ps, tmp___1 / sizeof(wchar_t ));
#line 553
      return ((size_t __attribute__((__artificial__))  )tmp___2);
    }
  }
#line 556
  tmp___5 = __mbsnrtowcs_alias(__dst, __src, __nmc, __len, __ps);
#line 556
  return ((size_t __attribute__((__artificial__))  )tmp___5);
}
}
#line 560
extern  __attribute__((__nothrow__)) size_t __wcsnrtombs_chk(char * __restrict  __dst ,
                                                             wchar_t const   ** __restrict  __src ,
                                                             size_t __nwc , size_t __len ,
                                                             mbstate_t * __restrict  __ps ,
                                                             size_t __dstlen ) ;
#line 565
extern  __attribute__((__nothrow__)) size_t __wcsnrtombs_alias(char * __restrict  __dst ,
                                                               wchar_t const   ** __restrict  __src ,
                                                               size_t __nwc , size_t __len ,
                                                               mbstate_t * __restrict  __ps )  __asm__("wcsnrtombs")  ;
#line 570
extern  __attribute__((__nothrow__)) size_t __wcsnrtombs_chk_warn(char * __restrict  __dst ,
                                                                  wchar_t const   ** __restrict  __src ,
                                                                  size_t __nwc , size_t __len ,
                                                                  mbstate_t * __restrict  __ps ,
                                                                  size_t __dstlen )  __asm__("__wcsnrtombs_chk") __attribute__((__warning__("wcsnrtombs called with dst buffer smaller than len"))) ;
#line 578
__inline extern  __attribute__((__nothrow__)) size_t __attribute__((__artificial__))  ( __attribute__((__always_inline__)) wcsnrtombs)(char * __restrict  __dst ,
                                                                                                                                       wchar_t const   ** __restrict  __src ,
                                                                                                                                       size_t __nwc ,
                                                                                                                                       size_t __len ,
                                                                                                                                       mbstate_t * __restrict  __ps ) ;
#line 578 "/usr/include/bits/wchar2.h"
__inline extern size_t __attribute__((__artificial__))  ( __attribute__((__always_inline__)) wcsnrtombs)(char * __restrict  __dst ,
                                                                                                         wchar_t const   ** __restrict  __src ,
                                                                                                         size_t __nwc ,
                                                                                                         size_t __len ,
                                                                                                         mbstate_t * __restrict  __ps ) 
{ unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
#line 582
  tmp___4 = __builtin_object_size((void *)__dst, 1);
#line 582
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 585
    tmp = __builtin_object_size((void *)__dst, 1);
#line 585
    tmp___0 = __wcsnrtombs_chk(__dst, __src, __nwc, __len, __ps, tmp);
#line 585
    return ((size_t __attribute__((__artificial__))  )tmp___0);
#line 588
    tmp___3 = __builtin_object_size((void *)__dst, 1);
#line 588
    if (__len > tmp___3) {
#line 589
      tmp___1 = __builtin_object_size((void *)__dst, 1);
#line 589
      tmp___2 = __wcsnrtombs_chk_warn(__dst, __src, __nwc, __len, __ps, tmp___1);
#line 589
      return ((size_t __attribute__((__artificial__))  )tmp___2);
    }
  }
#line 592
  tmp___5 = __wcsnrtombs_alias(__dst, __src, __nwc, __len, __ps);
#line 592
  return ((size_t __attribute__((__artificial__))  )tmp___5);
}
}
#line 195 "/usr/include/wctype.h"
extern  __attribute__((__nothrow__)) wint_t towlower(wint_t __wc ) ;
#line 42 "exclude.h"
_Bool fnmatch_pattern_has_wildcards(char const   *str , int options ) ;
#line 44
struct exclude *new_exclude(void) ;
#line 45
void free_exclude(struct exclude *ex ) ;
#line 46
void add_exclude(struct exclude *ex , char const   *pattern , int options ) ;
#line 47
int add_exclude_file(void (*add_func)(struct exclude * , char const   * , int  ) ,
                     struct exclude *ex , char const   *file_name___1 , int options ,
                     char line_end ) ;
#line 49
_Bool excluded_file_name(struct exclude  const  *ex , char const   *f ) ;
#line 50
_Bool exclude_fnmatch(char const   *pattern , char const   *f , int options ) ;
#line 77 "hash.h"
size_t hash_string(char const   *string , size_t n_buckets ) ;
#line 305 "mbchar.h"
unsigned int const   is_basic_table[8] ;
#line 307 "mbchar.h"
__inline static _Bool is_basic(char c ) 
{ 

  {
#line 310
  return ((_Bool )((is_basic_table[(int )((unsigned char )c) >> 5] >> ((int )((unsigned char )c) & 31)) & 1U));
}
}
#line 31 "strnlen1.h"
size_t strnlen1(char const   *string , size_t maxlen ) ;
#line 123 "mbuiter.h"
__inline static void mbuiter_multi_next(struct mbuiter_multi *iter ) 
{ int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  _Bool tmp___3 ;

  {
#line 126
  if (iter->next_done) {
#line 127
    return;
  }
#line 128
  if (iter->in_shift) {
#line 129
    goto with_shift;
  }
#line 131
  tmp___3 = is_basic((char )*(iter->cur.ptr));
#line 131
  if (tmp___3) {
#line 136
    iter->cur.bytes = (size_t )1;
#line 137
    iter->cur.wc = (wchar_t )*(iter->cur.ptr);
#line 138
    iter->cur.wc_valid = (_Bool)1;
  } else {
#line 142
    tmp = mbsinit((mbstate_t const   *)(& iter->state));
#line 142
    if (! tmp) {
#line 142
      __assert_fail("mbsinit (&iter->state)", "mbuiter.h", 142U, "mbuiter_multi_next");
    }
#line 143
    iter->in_shift = (_Bool)1;
    with_shift: 
#line 145
    tmp___0 = __ctype_get_mb_cur_max();
#line 145
    tmp___1 = strnlen1(iter->cur.ptr, tmp___0);
#line 145
    iter->cur.bytes = mbrtowc((wchar_t * __restrict  )(& iter->cur.wc), (char const   * __restrict  )iter->cur.ptr,
                              tmp___1, & iter->state);
#line 148
    if (iter->cur.bytes == 0xffffffffffffffffUL) {
#line 151
      iter->cur.bytes = (size_t )1;
#line 152
      iter->cur.wc_valid = (_Bool)0;
    } else
#line 156
    if (iter->cur.bytes == 0xfffffffffffffffeUL) {
#line 159
      iter->cur.bytes = strlen(iter->cur.ptr);
#line 160
      iter->cur.wc_valid = (_Bool)0;
    } else {
#line 166
      if (iter->cur.bytes == 0UL) {
#line 169
        iter->cur.bytes = (size_t )1;
#line 170
        if (! ((int const   )*(iter->cur.ptr) == 0)) {
#line 170
          __assert_fail("*iter->cur.ptr == \'\\0\'", "mbuiter.h", 170U, "mbuiter_multi_next");
        }
#line 171
        if (! (iter->cur.wc == 0)) {
#line 171
          __assert_fail("iter->cur.wc == 0", "mbuiter.h", 171U, "mbuiter_multi_next");
        }
      }
#line 173
      iter->cur.wc_valid = (_Bool)1;
#line 177
      tmp___2 = mbsinit((mbstate_t const   *)(& iter->state));
#line 177
      if (tmp___2) {
#line 178
        iter->in_shift = (_Bool)0;
      }
    }
  }
#line 181
  iter->next_done = (_Bool)1;
#line 182
  return;
}
}
#line 65 "/usr/include/fnmatch.h"
extern int fnmatch(char const   *__pattern , char const   *__name , int __flags ) ;
#line 51 "xalloc.h"
void *xzalloc(size_t s )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 57
void *x2realloc(void *p , size_t *pn ) ;
#line 60
char *xstrdup(char const   *string )  __attribute__((__malloc__)) ;
#line 184 "xalloc.h"
__inline static void *x2nrealloc(void *p , size_t *pn , size_t s ) 
{ size_t n ;
  void *tmp ;

  {
#line 187
  n = *pn;
#line 189
  if (! p) {
#line 191
    if (! n) {
#line 199
      n = 128UL / s;
#line 200
      n += (size_t )(! n);
    }
  } else {
#line 209
    if (0xaaaaaaaaaaaaaaaaUL / s <= n) {
#line 210
      xalloc_die();
    }
#line 211
    n += (n + 1UL) / 2UL;
  }
#line 214
  *pn = n;
#line 215
  tmp = xrealloc(p, n * s);
#line 215
  return (tmp);
}
}
#line 114 "exclude.c"
_Bool fnmatch_pattern_has_wildcards(char const   *str , int options ) 
{ char const   *cset ;
  size_t n ;
  unsigned long tmp___9 ;

  {
#line 117
  cset = "\\?*[]";
#line 118
  if (options & (1 << 1)) {
#line 119
    cset ++;
  }
#line 120
  while (*str) {
#line 122
    tmp___9 = __builtin_strcspn(str, cset);
#line 122
    n = tmp___9;
#line 123
    if ((int const   )*(str + n) == 0) {
#line 124
      break;
    } else
#line 125
    if ((int const   )*(str + n) == 92) {
#line 127
      str += n + 1UL;
#line 128
      if (*str) {
#line 129
        str ++;
      }
    } else {
#line 132
      return ((_Bool)1);
    }
  }
#line 134
  return ((_Bool)0);
}
}
#line 137 "exclude.c"
static void unescape_pattern(char *str ) 
{ int inset ;
  char *q ;
  char *tmp ;
  char tmp___0 ;
  char *tmp___1 ;

  {
#line 140
  inset = 0;
#line 141
  q = str;
#line 142
  while (1) {
#line 144
    if (inset) {
#line 146
      if ((int )*q == 93) {
#line 147
        inset = 0;
      }
    } else
#line 149
    if ((int )*q == 91) {
#line 150
      inset = 1;
    } else
#line 151
    if ((int )*q == 92) {
#line 152
      q ++;
    }
#line 142
    tmp = str;
#line 142
    str ++;
#line 142
    tmp___1 = q;
#line 142
    q ++;
#line 142
    tmp___0 = *tmp___1;
#line 142
    *tmp = tmp___0;
#line 142
    if (! tmp___0) {
#line 142
      break;
    }
  }
#line 155
  return;
}
}
#line 159 "exclude.c"
struct exclude *new_exclude(void) 
{ struct exclude *tmp ;
  void *tmp___0 ;

  {
#line 162
  tmp___0 = xzalloc(sizeof(*tmp));
#line 162
  return ((struct exclude *)tmp___0);
}
}
#line 166 "exclude.c"
static size_t string_hasher(void const   *data , size_t n_buckets ) 
{ char const   *p ;
  size_t tmp ;

  {
#line 169
  p = (char const   *)data;
#line 170
  tmp = hash_string(p, n_buckets);
#line 170
  return (tmp);
}
}
#line 174 "exclude.c"
static size_t string_hasher_ci(void const   *data , size_t n_buckets ) 
{ char const   *p ;
  mbui_iterator_t iter ;
  size_t value ;
  mbchar_t m ;
  wchar_t wc ;
  wint_t tmp ;
  int tmp___0 ;

  {
#line 177
  p = (char const   *)data;
#line 179
  value = (size_t )0;
#line 181
  iter.cur.ptr = p;
#line 181
  iter.in_shift = (_Bool)0;
#line 181
  memset((void *)(& iter.state), '\000', sizeof(mbstate_t ));
#line 181
  iter.next_done = (_Bool)0;
#line 181
  while (1) {
#line 181
    mbuiter_multi_next(& iter);
#line 181
    if (iter.cur.wc_valid) {
#line 181
      if (iter.cur.wc == 0) {
#line 181
        tmp___0 = 0;
      } else {
#line 181
        tmp___0 = 1;
      }
    } else {
#line 181
      tmp___0 = 1;
    }
#line 181
    if (! tmp___0) {
#line 181
      break;
    }
#line 183
    m = iter.cur;
#line 186
    if (m.wc_valid) {
#line 187
      tmp = towlower((wint_t )m.wc);
#line 187
      wc = (wchar_t )tmp;
    } else {
#line 189
      wc = (wchar_t )*(m.ptr);
    }
#line 191
    value = (value * 31UL + (size_t )wc) % n_buckets;
#line 181
    iter.cur.ptr += iter.cur.bytes;
#line 181
    iter.next_done = (_Bool)0;
  }
#line 194
  return (value);
}
}
#line 198 "exclude.c"
static _Bool string_compare(void const   *data1 , void const   *data2 ) 
{ char const   *p1 ;
  char const   *p2 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 201
  p1 = (char const   *)data1;
#line 202
  p2 = (char const   *)data2;
#line 203
  if (0) {
#line 203
    __s1_len = __builtin_strlen(p1);
#line 203
    __s2_len = __builtin_strlen(p2);
#line 203
    if (! ((size_t )((void const   *)(p1 + 1)) - (size_t )((void const   *)p1) == 1UL)) {
#line 203
      goto _L___0;
    } else
#line 203
    if (__s1_len >= 4UL) {
      _L___0: 
#line 203
      if (! ((size_t )((void const   *)(p2 + 1)) - (size_t )((void const   *)p2) == 1UL)) {
#line 203
        tmp___5 = 1;
      } else
#line 203
      if (__s2_len >= 4UL) {
#line 203
        tmp___5 = 1;
      } else {
#line 203
        tmp___5 = 0;
      }
    } else {
#line 203
      tmp___5 = 0;
    }
#line 203
    if (tmp___5) {
#line 203
      tmp___0 = __builtin_strcmp(p1, p2);
#line 203
      tmp___4 = tmp___0;
    } else {
#line 203
      tmp___3 = __builtin_strcmp(p1, p2);
#line 203
      tmp___4 = tmp___3;
    }
  } else {
#line 203
    tmp___3 = __builtin_strcmp(p1, p2);
#line 203
    tmp___4 = tmp___3;
  }
#line 203
  return ((_Bool )(tmp___4 == 0));
}
}
#line 207 "exclude.c"
static _Bool string_compare_ci(void const   *data1 , void const   *data2 ) 
{ char const   *p1 ;
  char const   *p2 ;
  int tmp ;

  {
#line 210
  p1 = (char const   *)data1;
#line 211
  p2 = (char const   *)data2;
#line 212
  tmp = mbscasecmp(p1, p2);
#line 212
  return ((_Bool )(tmp == 0));
}
}
#line 215 "exclude.c"
static void string_free(void *data ) 
{ 

  {
#line 218
  free(data);
#line 219
  return;
}
}
#line 223 "exclude.c"
static struct exclude_segment *new_exclude_segment(struct exclude *ex , enum exclude_type type ,
                                                   int options ) 
{ struct exclude_segment *sp ;
  void *tmp ;
  _Bool (*tmp___0)(void const   *data1 , void const   *data2 ) ;
  size_t (*tmp___1)(void const   *data , size_t n_buckets ) ;

  {
#line 226
  tmp = xzalloc(sizeof(struct exclude_segment ));
#line 226
  sp = (struct exclude_segment *)tmp;
#line 227
  sp->type = type;
#line 228
  sp->options = options;
#line 229
  switch ((int )type) {
  case 1: 
#line 232
  break;
  case 0: 
#line 235
  if (options & (1 << 4)) {
#line 235
    tmp___0 = & string_compare_ci;
  } else {
#line 235
    tmp___0 = & string_compare;
  }
#line 235
  if (options & (1 << 4)) {
#line 235
    tmp___1 = & string_hasher_ci;
  } else {
#line 235
    tmp___1 = & string_hasher;
  }
#line 235
  sp->v.table = hash_initialize((size_t )0, (Hash_tuning const   *)((void *)0), tmp___1,
                                tmp___0, & string_free);
#line 243
  break;
  }
#line 245
  if (ex->tail) {
#line 246
    (ex->tail)->next = sp;
  } else {
#line 248
    ex->head = sp;
  }
#line 249
  ex->tail = sp;
#line 250
  return (sp);
}
}
#line 254 "exclude.c"
static void free_exclude_segment(struct exclude_segment *seg ) 
{ 

  {
#line 257
  switch ((int )seg->type) {
  case 1: 
#line 260
  free((void *)seg->v.pat.exclude);
#line 261
  break;
  case 0: 
#line 264
  hash_free(seg->v.table);
#line 265
  break;
  }
#line 267
  free((void *)seg);
#line 268
  return;
}
}
#line 271 "exclude.c"
void free_exclude(struct exclude *ex ) 
{ struct exclude_segment *seg ;
  struct exclude_segment *next ;

  {
#line 275
  seg = ex->head;
#line 275
  while (seg) {
#line 277
    next = seg->next;
#line 278
    free_exclude_segment(seg);
#line 279
    seg = next;
  }
#line 281
  free((void *)ex);
#line 282
  return;
}
}
#line 287 "exclude.c"
static int fnmatch_no_wildcards(char const   *pattern , char const   *f , int options ) 
{ int tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___1 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t patlen ;
  size_t tmp___8 ;
  int r ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___12 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  char *fcopy ;
  char *tmp___22 ;
  char *p ;
  int r___0 ;
  char *tmp___23 ;
  char *tmp___25 ;

  {
#line 290
  if (! (options & (1 << 3))) {
#line 293
    if (options & (1 << 4)) {
#line 291
      tmp = mbscasecmp(pattern, f);
#line 293
      tmp___7 = tmp;
    } else {
#line 293
      if (0) {
#line 293
        __s1_len = __builtin_strlen(pattern);
#line 293
        __s2_len = __builtin_strlen(f);
#line 293
        if (! ((size_t )((void const   *)(pattern + 1)) - (size_t )((void const   *)pattern) == 1UL)) {
#line 293
          goto _L___0;
        } else
#line 293
        if (__s1_len >= 4UL) {
          _L___0: 
#line 293
          if (! ((size_t )((void const   *)(f + 1)) - (size_t )((void const   *)f) == 1UL)) {
#line 293
            tmp___6 = 1;
          } else
#line 293
          if (__s2_len >= 4UL) {
#line 293
            tmp___6 = 1;
          } else {
#line 293
            tmp___6 = 0;
          }
        } else {
#line 293
          tmp___6 = 0;
        }
#line 293
        if (tmp___6) {
#line 293
          tmp___1 = __builtin_strcmp(pattern, f);
#line 293
          tmp___5 = tmp___1;
        } else {
#line 293
          tmp___4 = __builtin_strcmp(pattern, f);
#line 293
          tmp___5 = tmp___4;
        }
      } else {
#line 293
        tmp___4 = __builtin_strcmp(pattern, f);
#line 293
        tmp___5 = tmp___4;
      }
#line 293
      tmp___7 = tmp___5;
    }
#line 291
    return (tmp___7);
  } else
#line 294
  if (! (options & (1 << 4))) {
#line 296
    tmp___8 = strlen(pattern);
#line 296
    patlen = tmp___8;
#line 297
    if (0) {
#line 297
      if (0) {
#line 297
        __s1_len___0 = __builtin_strlen(pattern);
#line 297
        __s2_len___0 = __builtin_strlen(f);
#line 297
        if (! ((size_t )((void const   *)(pattern + 1)) - (size_t )((void const   *)pattern) == 1UL)) {
#line 297
          goto _L___2;
        } else
#line 297
        if (__s1_len___0 >= 4UL) {
          _L___2: 
#line 297
          if (! ((size_t )((void const   *)(f + 1)) - (size_t )((void const   *)f) == 1UL)) {
#line 297
            tmp___17 = 1;
          } else
#line 297
          if (__s2_len___0 >= 4UL) {
#line 297
            tmp___17 = 1;
          } else {
#line 297
            tmp___17 = 0;
          }
        } else {
#line 297
          tmp___17 = 0;
        }
#line 297
        if (tmp___17) {
#line 297
          tmp___12 = __builtin_strcmp(pattern, f);
#line 297
          tmp___16 = tmp___12;
        } else {
#line 297
          tmp___15 = __builtin_strcmp(pattern, f);
#line 297
          tmp___16 = tmp___15;
        }
      } else {
#line 297
        tmp___15 = __builtin_strcmp(pattern, f);
#line 297
        tmp___16 = tmp___15;
      }
#line 297
      tmp___19 = tmp___16;
    } else {
#line 297
      tmp___18 = strncmp(pattern, f, patlen);
#line 297
      tmp___19 = tmp___18;
    }
#line 297
    r = tmp___19;
#line 298
    if (! r) {
#line 300
      r = (int )*(f + patlen);
#line 301
      if (r == 47) {
#line 302
        r = 0;
      }
    }
#line 304
    return (r);
  } else {
#line 315
    tmp___22 = xstrdup(f);
#line 315
    fcopy = tmp___22;
#line 318
    p = fcopy;
#line 318
    while (1) {
#line 320
      tmp___25 = __builtin_strchr(p, '/');
#line 320
      p = tmp___25;
#line 321
      if (p) {
#line 322
        *p = (char )'\000';
      }
#line 323
      r___0 = mbscasecmp(pattern, (char const   *)fcopy);
#line 324
      if (! p) {
#line 325
        break;
      } else
#line 324
      if (r___0 <= 0) {
#line 325
        break;
      }
#line 318
      tmp___23 = p;
#line 318
      p ++;
#line 318
      *tmp___23 = (char )'/';
    }
#line 327
    free((void *)fcopy);
#line 328
    return (r___0);
  }
}
}
#line 332 "exclude.c"
_Bool exclude_fnmatch(char const   *pattern , char const   *f , int options ) 
{ int (*matcher)(char const   * , char const   * , int  ) ;
  int (*tmp)(char const   *__pattern , char const   *__name , int __flags ) ;
  _Bool matched ;
  int tmp___0 ;
  char const   *p ;
  int tmp___1 ;

  {
#line 335
  if (options & (1 << 28)) {
#line 335
    tmp = & fnmatch;
  } else {
#line 335
    tmp = & fnmatch_no_wildcards;
  }
#line 335
  matcher = tmp;
#line 339
  tmp___0 = (*matcher)(pattern, f, options);
#line 339
  matched = (_Bool )(tmp___0 == 0);
#line 342
  if (! (options & (1 << 30))) {
#line 343
    p = f;
#line 343
    while (1) {
#line 343
      if (*p) {
#line 343
        if (! (! matched)) {
#line 343
          break;
        }
      } else {
#line 343
        break;
      }
#line 344
      if ((int const   )*p == 47) {
#line 344
        if ((int const   )*(p + 1) != 47) {
#line 345
          tmp___1 = (*matcher)(pattern, p + 1, options);
#line 345
          matched = (_Bool )(tmp___1 == 0);
        }
      }
#line 343
      p ++;
    }
  }
#line 347
  return (matched);
}
}
#line 352 "exclude.c"
static _Bool excluded_file_pattern_p(struct exclude_segment  const  *seg , char const   *f ) 
{ size_t exclude_count ;
  struct patopts  const  *exclude ;
  size_t i ;
  _Bool excluded ;
  char const   *pattern ;
  int options ;
  _Bool tmp ;

  {
#line 355
  exclude_count = (size_t )seg->v.pat.exclude_count;
#line 356
  exclude = (struct patopts  const  *)seg->v.pat.exclude;
#line 358
  excluded = (_Bool )(! (! ((exclude + 0)->options & (int const   )(1 << 29))));
#line 361
  i = (size_t )0;
#line 361
  while (i < exclude_count) {
#line 363
    pattern = (char const   *)(exclude + i)->pattern;
#line 364
    options = (int )(exclude + i)->options;
#line 365
    tmp = exclude_fnmatch(pattern, f, options);
#line 365
    if (tmp) {
#line 366
      return ((_Bool )(! excluded));
    }
#line 361
    i ++;
  }
#line 368
  return (excluded);
}
}
#line 374 "exclude.c"
static _Bool excluded_file_name_p(struct exclude_segment  const  *seg , char const   *f ,
                                  char *buffer ) 
{ int options ;
  _Bool excluded ;
  Hash_table *table___0 ;
  void *tmp ;
  char *p ;
  char *tmp___0 ;
  char *tmp___2 ;

  {
#line 378
  options = (int )seg->options;
#line 379
  excluded = (_Bool )(! (! (options & (1 << 29))));
#line 380
  table___0 = (Hash_table *)seg->v.table;
#line 382
  while (1) {
#line 385
    strcpy((char * __restrict  )buffer, (char const   * __restrict  )f);
#line 387
    while (1) {
#line 389
      tmp = hash_lookup((Hash_table const   *)table___0, (void const   *)buffer);
#line 389
      if (tmp) {
#line 390
        return ((_Bool )(! excluded));
      }
#line 391
      if (options & (1 << 3)) {
#line 393
        tmp___0 = strrchr((char const   *)buffer, '/');
#line 393
        p = tmp___0;
#line 394
        if (p) {
#line 396
          *p = (char)0;
#line 397
          continue;
        }
      }
#line 400
      break;
    }
#line 403
    if (! (options & (1 << 30))) {
#line 405
      tmp___2 = __builtin_strchr((char *)f, '/');
#line 405
      f = (char const   *)tmp___2;
#line 406
      if (f) {
#line 407
        f ++;
      }
    } else {
#line 410
      break;
    }
#line 382
    if (! f) {
#line 382
      break;
    }
  }
#line 413
  return (excluded);
}
}
#line 418 "exclude.c"
_Bool excluded_file_name(struct exclude  const  *ex , char const   *f ) 
{ struct exclude_segment *seg ;
  _Bool excluded ;
  char *filename ;
  _Bool rc ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 423
  filename = (char *)((void *)0);
#line 426
  if (! ex->head) {
#line 427
    return ((_Bool)0);
  }
#line 430
  excluded = (_Bool )(! (! ((ex->head)->options & (1 << 29))));
#line 433
  seg = (struct exclude_segment *)ex->head;
#line 433
  while (seg) {
#line 437
    switch ((int )seg->type) {
    case 1: 
#line 440
    rc = excluded_file_pattern_p((struct exclude_segment  const  *)seg, f);
#line 441
    break;
    case 0: 
#line 444
    if (! filename) {
#line 445
      tmp = strlen(f);
#line 445
      tmp___0 = xmalloc(tmp + 1UL);
#line 445
      filename = (char *)tmp___0;
    }
#line 446
    rc = excluded_file_name_p((struct exclude_segment  const  *)seg, f, filename);
#line 447
    break;
    default: 
#line 450
    abort();
    }
#line 452
    if ((int )rc != (int )excluded) {
#line 454
      excluded = rc;
#line 455
      break;
    }
#line 433
    seg = seg->next;
  }
#line 458
  free((void *)filename);
#line 459
  return (excluded);
}
}
#line 464 "exclude.c"
void add_exclude(struct exclude *ex , char const   *pattern , int options ) 
{ struct exclude_segment *seg ;
  struct exclude_pattern *pat ;
  struct patopts *patopts ;
  void *tmp ;
  size_t tmp___0 ;
  char *str ;
  char *p ;
  void *tmp___1 ;
  _Bool tmp___2 ;

  {
#line 469
  if (options & (1 << 28)) {
#line 469
    tmp___2 = fnmatch_pattern_has_wildcards(pattern, options);
#line 469
    if (tmp___2) {
#line 475
      if (ex->tail) {
#line 475
        if ((unsigned int )(ex->tail)->type == 1U) {
#line 475
          if (((ex->tail)->options & (1 << 29)) == (options & (1 << 29))) {
#line 478
            seg = ex->tail;
          } else {
#line 480
            seg = new_exclude_segment(ex, (enum exclude_type )1, options);
          }
        } else {
#line 480
          seg = new_exclude_segment(ex, (enum exclude_type )1, options);
        }
      } else {
#line 480
        seg = new_exclude_segment(ex, (enum exclude_type )1, options);
      }
#line 482
      pat = & seg->v.pat;
#line 483
      if (pat->exclude_count == pat->exclude_alloc) {
#line 484
        tmp = x2nrealloc((void *)pat->exclude, & pat->exclude_alloc, sizeof(*(pat->exclude)));
#line 484
        pat->exclude = (struct patopts *)tmp;
      }
#line 486
      tmp___0 = pat->exclude_count;
#line 486
      (pat->exclude_count) ++;
#line 486
      patopts = pat->exclude + tmp___0;
#line 487
      patopts->pattern = pattern;
#line 488
      patopts->options = options;
    } else {
#line 469
      goto _L;
    }
  } else {
    _L: 
#line 495
    if (ex->tail) {
#line 495
      if ((unsigned int )(ex->tail)->type == 0U) {
#line 495
        if (((ex->tail)->options & ((((1 << 29) | (1 << 30)) | (1 << 3)) | (1 << 4))) == (options & ((((1 << 29) | (1 << 30)) | (1 << 3)) | (1 << 4)))) {
#line 498
          seg = ex->tail;
        } else {
#line 500
          seg = new_exclude_segment(ex, (enum exclude_type )0, options);
        }
      } else {
#line 500
        seg = new_exclude_segment(ex, (enum exclude_type )0, options);
      }
    } else {
#line 500
      seg = new_exclude_segment(ex, (enum exclude_type )0, options);
    }
#line 502
    str = xstrdup(pattern);
#line 503
    if (options & (1 << 28)) {
#line 504
      unescape_pattern(str);
    }
#line 505
    tmp___1 = hash_insert(seg->v.table, (void const   *)str);
#line 505
    p = (char *)tmp___1;
#line 506
    if ((unsigned long )p != (unsigned long )str) {
#line 507
      free((void *)str);
    }
  }
#line 509
  return;
}
}
#line 516 "exclude.c"
int add_exclude_file(void (*add_func)(struct exclude * , char const   * , int  ) ,
                     struct exclude *ex , char const   *file_name___1 , int options ,
                     char line_end ) 
{ _Bool use_stdin ;
  int tmp ;
  FILE *in ;
  char *buf___1 ;
  char *p ;
  char const   *pattern ;
  char const   *lim ;
  size_t buf_alloc ;
  size_t buf_count ;
  int c ;
  int e ;
  void *tmp___0 ;
  size_t tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  char *pattern_end ;
  unsigned short const   **tmp___8 ;
  unsigned short const   **tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;

  {
#line 521
  if ((int const   )*(file_name___1 + 0) == 45) {
#line 521
    if (! *(file_name___1 + 1)) {
#line 521
      tmp = 1;
    } else {
#line 521
      tmp = 0;
    }
  } else {
#line 521
    tmp = 0;
  }
#line 521
  use_stdin = (_Bool )tmp;
#line 523
  buf___1 = (char *)((void *)0);
#line 527
  buf_alloc = (size_t )0;
#line 528
  buf_count = (size_t )0;
#line 530
  e = 0;
#line 532
  if (use_stdin) {
#line 533
    in = stdin;
  } else {
#line 534
    in = fopen((char const   * __restrict  )file_name___1, (char const   * __restrict  )"r");
#line 534
    if (! in) {
#line 535
      return (-1);
    }
  }
#line 537
  while (1) {
#line 537
    c = getc_unlocked(in);
#line 537
    if (! (c != -1)) {
#line 537
      break;
    }
#line 539
    if (buf_count == buf_alloc) {
#line 540
      tmp___0 = x2realloc((void *)buf___1, & buf_alloc);
#line 540
      buf___1 = (char *)tmp___0;
    }
#line 541
    tmp___1 = buf_count;
#line 541
    buf_count ++;
#line 541
    *(buf___1 + tmp___1) = (char )c;
  }
#line 544
  tmp___3 = ferror_unlocked(in);
#line 544
  if (tmp___3) {
#line 545
    tmp___2 = __errno_location();
#line 545
    e = *tmp___2;
  }
#line 547
  if (! use_stdin) {
#line 547
    tmp___5 = rpl_fclose(in);
#line 547
    if (tmp___5 != 0) {
#line 548
      tmp___4 = __errno_location();
#line 548
      e = *tmp___4;
    }
  }
#line 550
  tmp___6 = xrealloc((void *)buf___1, buf_count + 1UL);
#line 550
  buf___1 = (char *)tmp___6;
#line 551
  *(buf___1 + buf_count) = line_end;
#line 552
  if (buf_count == 0UL) {
#line 552
    tmp___7 = 0;
  } else
#line 552
  if ((int )*(buf___1 + (buf_count - 1UL)) == (int )line_end) {
#line 552
    tmp___7 = 0;
  } else {
#line 552
    tmp___7 = 1;
  }
#line 552
  lim = (char const   *)((buf___1 + buf_count) + tmp___7);
#line 553
  pattern = (char const   *)buf___1;
#line 555
  p = buf___1;
#line 555
  while ((unsigned long )p < (unsigned long )lim) {
#line 556
    if ((int )*p == (int )line_end) {
#line 558
      pattern_end = p;
#line 560
      tmp___9 = __ctype_b_loc();
#line 560
      if ((int const   )*(*tmp___9 + (int )((unsigned char )line_end)) & 8192) {
#line 562
        while (1) {
#line 563
          if ((unsigned long )pattern_end == (unsigned long )pattern) {
#line 564
            goto next_pattern;
          } else {
#line 565
            tmp___8 = __ctype_b_loc();
#line 565
            if (! ((int const   )*(*tmp___8 + (int )((unsigned char )*(pattern_end + -1))) & 8192)) {
#line 566
              break;
            }
          }
#line 562
          pattern_end --;
        }
      }
#line 569
      *pattern_end = (char )'\000';
#line 570
      (*add_func)(ex, pattern, options);
      next_pattern: 
#line 573
      pattern = (char const   *)(p + 1);
    }
#line 555
    p ++;
  }
#line 576
  tmp___10 = __errno_location();
#line 576
  *tmp___10 = e;
#line 577
  if (e) {
#line 577
    tmp___11 = -1;
  } else {
#line 577
    tmp___11 = 0;
  }
#line 577
  return (tmp___11);
}
}
#line 1 "exitfail.o"
#pragma merger(0,"/tmp/cil-ATKXZMYu.i","-g,-O2")
#line 24 "exitfail.c"
int volatile   exit_failure  =    (int volatile   )1;
#line 1 "fadvise.o"
#pragma merger(0,"/tmp/cil-BuwfHWUM.i","-g,-O2")
#line 851 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream )  __attribute__((__warn_unused_result__)) ;
#line 211 "/usr/include/fcntl.h"
extern  __attribute__((__nothrow__)) int posix_fadvise(int __fd , __off_t __offset ,
                                                       __off_t __len , int __advise ) ;
#line 71 "fadvise.h"
void fdadvise(int fd , off_t offset , off_t len , fadvice_t advice ) ;
#line 72
void fadvise(FILE *fp , fadvice_t advice ) ;
#line 24 "fadvise.c"
void fdadvise(int fd , off_t offset , off_t len , fadvice_t advice ) 
{ int __x ;
  int tmp ;

  {
#line 28
  tmp = posix_fadvise(fd, offset, len, (int )advice);
#line 28
  __x = tmp;
#line 30
  return;
}
}
#line 32 "fadvise.c"
void fadvise(FILE *fp , fadvice_t advice ) 
{ int tmp ;

  {
#line 35
  if (fp) {
#line 36
    tmp = fileno(fp);
#line 36
    fdadvise(tmp, (off_t )0, (off_t )0, advice);
  }
#line 37
  return;
}
}
#line 1 "creat-safer.o"
#pragma merger(0,"/tmp/cil-kVI1qgVW.i","-g,-O2")
#line 23 "fcntl-safer.h"
int creat_safer(char const   *file , mode_t mode ) ;
#line 165 "/usr/include/fcntl.h"
extern int creat(char const   *__file , __mode_t __mode )  __attribute__((__nonnull__(1))) ;
#line 21 "unistd-safer.h"
int fd_safer(int fd ) ;
#line 27 "creat-safer.c"
int creat_safer(char const   *file , mode_t mode ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 30
  tmp = creat(file, mode);
#line 30
  tmp___0 = fd_safer(tmp);
#line 30
  return (tmp___0);
}
}
#line 1 "open-safer.o"
#pragma merger(0,"/tmp/cil-AFAt3US3.i","-g,-O2")
#line 22 "fcntl-safer.h"
int open_safer(char const   *file , int flags  , ...) ;
#line 28 "open-safer.c"
int open_safer(char const   *file , int flags  , ...) 
{ mode_t mode ;
  va_list ap ;
  int __attribute__((__artificial__))  tmp ;
  int tmp___0 ;

  {
#line 31
  mode = (mode_t )0;
#line 33
  if (flags & 64) {
#line 36
    __builtin_va_start(ap, flags);
#line 40
    mode = __builtin_va_arg(ap, mode_t );
#line 42
    __builtin_va_end(ap);
  }
#line 45
  tmp = open(file, flags, mode);
#line 45
  tmp___0 = fd_safer((int )tmp);
#line 45
  return (tmp___0);
}
}
#line 1 "fd-hook.o"
#pragma merger(0,"/tmp/cil-rO9SayKB.i","-g,-O2")
#line 1 "fd-safer-flag.o"
#pragma merger(0,"/tmp/cil-Y0y6ZDam.i","-g,-O2")
#line 25 "unistd-safer.h"
int dup_safer_flag(int fd , int flag ) ;
#line 26
int fd_safer_flag(int fd , int flag ) ;
#line 39 "fd-safer-flag.c"
int fd_safer_flag(int fd , int flag ) 
{ int f ;
  int tmp ;
  int e ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 42
  if (0 <= fd) {
#line 42
    if (fd <= 2) {
#line 44
      tmp = dup_safer_flag(fd, flag);
#line 44
      f = tmp;
#line 45
      tmp___0 = __errno_location();
#line 45
      e = *tmp___0;
#line 46
      close(fd);
#line 47
      tmp___1 = __errno_location();
#line 47
      *tmp___1 = e;
#line 48
      fd = f;
    }
  }
#line 51
  return (fd);
}
}
#line 1 "dup-safer-flag.o"
#pragma merger(0,"/tmp/cil-2iGt_FNZ.i","-g,-O2")
#line 35 "dup-safer-flag.c"
int dup_safer_flag(int fd , int flag ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 38
  if (flag & 524288) {
#line 38
    tmp = 1030;
  } else {
#line 38
    tmp = 0;
  }
#line 38
  tmp___0 = rpl_fcntl(fd, tmp, 3);
#line 38
  return (tmp___0);
}
}
#line 1 "fdutimensat.o"
#pragma merger(0,"/tmp/cil-zY7AvlEo.i","-g,-O2")
#line 687 "./sys/stat.h"
int rpl_futimens(int fd , struct timespec  const  *times ) ;
#line 950
int rpl_utimensat(int fd , char const   *file , struct timespec  const  *times , int flag )  __attribute__((__nonnull__(2))) ;
#line 10 "utimens.h"
int fdutimensat(int fd , int dir , char const   *file , struct timespec  const  *ts ,
                int atflag ) ;
#line 42 "fdutimensat.c"
int fdutimensat(int fd , int dir , char const   *file , struct timespec  const  *ts ,
                int atflag ) 
{ int result ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 46
  result = 1;
#line 47
  if (0 <= fd) {
#line 48
    result = rpl_futimens(fd, ts);
  }
#line 49
  if (file) {
#line 49
    if (fd < 0) {
#line 50
      result = rpl_utimensat(dir, file, ts, atflag);
    } else
#line 49
    if (result == -1) {
#line 49
      tmp = __errno_location();
#line 49
      if (*tmp == 38) {
#line 50
        result = rpl_utimensat(dir, file, ts, atflag);
      }
    }
  }
#line 51
  if (result == 1) {
#line 53
    tmp___0 = __errno_location();
#line 53
    *tmp___0 = 9;
#line 54
    result = -1;
  }
#line 56
  return (result);
}
}
#line 1 "file-set.o"
#pragma merger(0,"/tmp/cil-upAmL0LZ.i","-g,-O2")
#line 28 "file-set.c"
void record_file(Hash_table *ht___0 , char const   *file , struct stat  const  *stats )  __attribute__((__nonnull__(2,3))) ;
#line 28 "file-set.c"
void record_file(Hash_table *ht___0 , char const   *file , struct stat  const  *stats ) 
{ struct F_triple *ent ;
  void *tmp ;
  struct F_triple *ent_from_table ;
  void *tmp___0 ;

  {
#line 33
  if ((unsigned long )ht___0 == (unsigned long )((void *)0)) {
#line 34
    return;
  }
#line 36
  tmp = xmalloc(sizeof(*ent));
#line 36
  ent = (struct F_triple *)tmp;
#line 37
  ent->name = xstrdup(file);
#line 38
  ent->st_ino = (ino_t )stats->st_ino;
#line 39
  ent->st_dev = (dev_t )stats->st_dev;
#line 42
  tmp___0 = hash_insert(ht___0, (void const   *)ent);
#line 42
  ent_from_table = (struct F_triple *)tmp___0;
#line 43
  if ((unsigned long )ent_from_table == (unsigned long )((void *)0)) {
#line 46
    xalloc_die();
  }
#line 49
  if ((unsigned long )ent_from_table != (unsigned long )ent) {
#line 53
    triple_free((void *)ent);
  }
#line 56
  return;
}
}
#line 60 "file-set.c"
_Bool seen_file(Hash_table const   *ht___0 , char const   *file , struct stat  const  *stats ) 
{ struct F_triple new_ent ;
  void *tmp ;
  int tmp___0 ;

  {
#line 66
  if ((unsigned long )ht___0 == (unsigned long )((void *)0)) {
#line 67
    return ((_Bool)0);
  }
#line 69
  new_ent.name = (char *)file;
#line 70
  new_ent.st_ino = (ino_t )stats->st_ino;
#line 71
  new_ent.st_dev = (dev_t )stats->st_dev;
#line 73
  tmp = hash_lookup(ht___0, (void const   *)(& new_ent));
#line 73
  if (tmp) {
#line 73
    tmp___0 = 1;
  } else {
#line 73
    tmp___0 = 0;
  }
#line 73
  return ((_Bool )tmp___0);
}
}
#line 1 "file-type.o"
#pragma merger(0,"/tmp/cil-zsnj7wcN.i","-g,-O2")
#line 27 "file-type.h"
char const   *file_type(struct stat  const  *st ) ;
#line 28 "file-type.c"
char const   *file_type(struct stat  const  *st ) 
{ char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___12 ;

  {
#line 37
  if ((st->st_mode & 61440U) == 32768U) {
#line 38
    if (st->st_size == 0L) {
#line 38
      tmp = dcgettext((char const   *)((void *)0), "regular empty file", 5);
#line 38
      tmp___1 = tmp;
    } else {
#line 38
      tmp___0 = dcgettext((char const   *)((void *)0), "regular file", 5);
#line 38
      tmp___1 = tmp___0;
    }
#line 38
    return ((char const   *)tmp___1);
  }
#line 40
  if ((st->st_mode & 61440U) == 16384U) {
#line 41
    tmp___2 = dcgettext((char const   *)((void *)0), "directory", 5);
#line 41
    return ((char const   *)tmp___2);
  }
#line 43
  if ((st->st_mode & 61440U) == 24576U) {
#line 44
    tmp___3 = dcgettext((char const   *)((void *)0), "block special file", 5);
#line 44
    return ((char const   *)tmp___3);
  }
#line 46
  if ((st->st_mode & 61440U) == 8192U) {
#line 47
    tmp___4 = dcgettext((char const   *)((void *)0), "character special file", 5);
#line 47
    return ((char const   *)tmp___4);
  }
#line 49
  if ((st->st_mode & 61440U) == 4096U) {
#line 50
    tmp___5 = dcgettext((char const   *)((void *)0), "fifo", 5);
#line 50
    return ((char const   *)tmp___5);
  }
#line 52
  if ((st->st_mode & 61440U) == 40960U) {
#line 53
    tmp___6 = dcgettext((char const   *)((void *)0), "symbolic link", 5);
#line 53
    return ((char const   *)tmp___6);
  }
#line 55
  if ((st->st_mode & 61440U) == 49152U) {
#line 56
    tmp___7 = dcgettext((char const   *)((void *)0), "socket", 5);
#line 56
    return ((char const   *)tmp___7);
  }
#line 58
  if (st->st_mode - st->st_mode) {
#line 59
    tmp___8 = dcgettext((char const   *)((void *)0), "message queue", 5);
#line 59
    return ((char const   *)tmp___8);
  }
#line 61
  if (st->st_mode - st->st_mode) {
#line 62
    tmp___9 = dcgettext((char const   *)((void *)0), "semaphore", 5);
#line 62
    return ((char const   *)tmp___9);
  }
#line 64
  if (st->st_mode - st->st_mode) {
#line 65
    tmp___10 = dcgettext((char const   *)((void *)0), "shared memory object", 5);
#line 65
    return ((char const   *)tmp___10);
  }
#line 70
  tmp___12 = dcgettext((char const   *)((void *)0), "weird file", 5);
#line 70
  return ((char const   *)tmp___12);
}
}
#line 1 "filemode.o"
#pragma merger(0,"/tmp/cil-YmxOGSWk.i","-g,-O2")
#line 35 "filemode.h"
void strmode(mode_t mode , char *str ) ;
#line 38
void filemodestring(struct stat  const  *statp , char *str ) ;
#line 53 "filemode.c"
static char ftypelet(mode_t bits ) 
{ 

  {
#line 57
  if ((bits & 61440U) == 32768U) {
#line 58
    return ((char )'-');
  }
#line 59
  if ((bits & 61440U) == 16384U) {
#line 60
    return ((char )'d');
  }
#line 63
  if ((bits & 61440U) == 24576U) {
#line 64
    return ((char )'b');
  }
#line 65
  if ((bits & 61440U) == 8192U) {
#line 66
    return ((char )'c');
  }
#line 67
  if ((bits & 61440U) == 40960U) {
#line 68
    return ((char )'l');
  }
#line 69
  if ((bits & 61440U) == 4096U) {
#line 70
    return ((char )'p');
  }
#line 73
  if ((bits & 61440U) == 49152U) {
#line 74
    return ((char )'s');
  }
#line 90
  return ((char )'?');
}
}
#line 95 "filemode.c"
void strmode(mode_t mode , char *str ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 98
  *(str + 0) = ftypelet(mode);
#line 99
  if (mode & 256U) {
#line 99
    *(str + 1) = (char )'r';
  } else {
#line 99
    *(str + 1) = (char )'-';
  }
#line 100
  if (mode & 128U) {
#line 100
    *(str + 2) = (char )'w';
  } else {
#line 100
    *(str + 2) = (char )'-';
  }
#line 101
  if (mode & 2048U) {
#line 101
    if (mode & 64U) {
#line 101
      tmp = 's';
    } else {
#line 101
      tmp = 'S';
    }
#line 101
    *(str + 3) = (char )tmp;
  } else {
#line 101
    if (mode & 64U) {
#line 101
      tmp___0 = 'x';
    } else {
#line 101
      tmp___0 = '-';
    }
#line 101
    *(str + 3) = (char )tmp___0;
  }
#line 104
  if (mode & (unsigned int )(256 >> 3)) {
#line 104
    *(str + 4) = (char )'r';
  } else {
#line 104
    *(str + 4) = (char )'-';
  }
#line 105
  if (mode & (unsigned int )(128 >> 3)) {
#line 105
    *(str + 5) = (char )'w';
  } else {
#line 105
    *(str + 5) = (char )'-';
  }
#line 106
  if (mode & 1024U) {
#line 106
    if (mode & (unsigned int )(64 >> 3)) {
#line 106
      tmp___1 = 's';
    } else {
#line 106
      tmp___1 = 'S';
    }
#line 106
    *(str + 6) = (char )tmp___1;
  } else {
#line 106
    if (mode & (unsigned int )(64 >> 3)) {
#line 106
      tmp___2 = 'x';
    } else {
#line 106
      tmp___2 = '-';
    }
#line 106
    *(str + 6) = (char )tmp___2;
  }
#line 109
  if (mode & (unsigned int )((256 >> 3) >> 3)) {
#line 109
    *(str + 7) = (char )'r';
  } else {
#line 109
    *(str + 7) = (char )'-';
  }
#line 110
  if (mode & (unsigned int )((128 >> 3) >> 3)) {
#line 110
    *(str + 8) = (char )'w';
  } else {
#line 110
    *(str + 8) = (char )'-';
  }
#line 111
  if (mode & 512U) {
#line 111
    if (mode & (unsigned int )((64 >> 3) >> 3)) {
#line 111
      tmp___3 = 't';
    } else {
#line 111
      tmp___3 = 'T';
    }
#line 111
    *(str + 9) = (char )tmp___3;
  } else {
#line 111
    if (mode & (unsigned int )((64 >> 3) >> 3)) {
#line 111
      tmp___4 = 'x';
    } else {
#line 111
      tmp___4 = '-';
    }
#line 111
    *(str + 9) = (char )tmp___4;
  }
#line 114
  *(str + 10) = (char )' ';
#line 115
  *(str + 11) = (char )'\000';
#line 116
  return;
}
}
#line 165 "filemode.c"
void filemodestring(struct stat  const  *statp , char *str ) 
{ 

  {
#line 168
  strmode((mode_t )statp->st_mode, str);
#line 170
  if (statp->st_mode - statp->st_mode) {
#line 171
    *(str + 0) = (char )'F';
  } else
#line 174
  if (statp->st_mode - statp->st_mode) {
#line 175
    *(str + 0) = (char )'Q';
  } else
#line 176
  if (statp->st_mode - statp->st_mode) {
#line 177
    *(str + 0) = (char )'S';
  }
#line 180
  return;
}
}
#line 1 "filenamecat.o"
#pragma merger(0,"/tmp/cil-ajYKLC_9.i","-g,-O2")
#line 22 "filenamecat.h"
char *file_name_concat(char const   *dir , char const   *abase , char **base_in_result ) ;
#line 26
char *mfile_name_concat(char const   *dir , char const   *abase , char **base_in_result ) ;
#line 34 "filenamecat.c"
char *file_name_concat(char const   *dir , char const   *abase , char **base_in_result ) 
{ char *p ;
  char *tmp ;

  {
#line 37
  tmp = mfile_name_concat(dir, abase, base_in_result);
#line 37
  p = tmp;
#line 38
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 39
    xalloc_die();
  }
#line 40
  return (p);
}
}
#line 1 "filenamecat-lgpl.o"
#pragma merger(0,"/tmp/cil-CsxNKZLJ.i","-g,-O2")
#line 37 "filenamecat-lgpl.c"
static char const   *longest_relative_suffix(char const   *f ) 
{ 

  {
#line 40
  f += 0;
#line 40
  while ((int const   )*f == 47) {
#line 41
    goto __Cont;
    __Cont: 
#line 40
    f ++;
  }
#line 42
  return (f);
}
}
#line 60 "filenamecat-lgpl.c"
char *mfile_name_concat(char const   *dir , char const   *abase , char **base_in_result ) 
{ char const   *dirbase ;
  char *tmp ;
  size_t dirbaselen ;
  size_t tmp___0 ;
  size_t dirlen ;
  size_t needs_separator ;
  int tmp___1 ;
  char const   *base ;
  char const   *tmp___2 ;
  size_t baselen ;
  size_t tmp___3 ;
  char *p_concat ;
  void *tmp___4 ;
  char *p ;
  void __attribute__((__artificial__))  *tmp___5 ;
  int tmp___6 ;
  void __attribute__((__artificial__))  *tmp___7 ;

  {
#line 63
  tmp = last_component(dir);
#line 63
  dirbase = (char const   *)tmp;
#line 64
  tmp___0 = base_len(dirbase);
#line 64
  dirbaselen = tmp___0;
#line 65
  dirlen = (size_t )(dirbase - dir) + dirbaselen;
#line 66
  if (dirbaselen) {
#line 66
    if (! ((int const   )*(dirbase + (dirbaselen - 1UL)) == 47)) {
#line 66
      tmp___1 = 1;
    } else {
#line 66
      tmp___1 = 0;
    }
  } else {
#line 66
    tmp___1 = 0;
  }
#line 66
  needs_separator = (size_t )tmp___1;
#line 68
  tmp___2 = longest_relative_suffix(abase);
#line 68
  base = tmp___2;
#line 69
  tmp___3 = strlen(base);
#line 69
  baselen = tmp___3;
#line 71
  tmp___4 = malloc(((dirlen + needs_separator) + baselen) + 1UL);
#line 71
  p_concat = (char *)tmp___4;
#line 74
  if ((unsigned long )p_concat == (unsigned long )((void *)0)) {
#line 75
    return ((char *)((void *)0));
  }
#line 77
  tmp___5 = mempcpy((void * __restrict  )p_concat, (void const   * __restrict  )dir,
                    dirlen);
#line 77
  p = (char *)tmp___5;
#line 78
  *p = (char )'/';
#line 79
  p += needs_separator;
#line 81
  if (base_in_result) {
#line 82
    if ((int const   )*(abase + 0) == 47) {
#line 82
      tmp___6 = 1;
    } else {
#line 82
      tmp___6 = 0;
    }
#line 82
    *base_in_result = p - tmp___6;
  }
#line 84
  tmp___7 = mempcpy((void * __restrict  )p, (void const   * __restrict  )base, baselen);
#line 84
  p = (char *)tmp___7;
#line 85
  *p = (char )'\000';
#line 87
  return (p_concat);
}
}
#line 1 "filevercmp.o"
#pragma merger(0,"/tmp/cil-LWCXPaKo.i","-g,-O2")
#line 40 "filevercmp.h"
int filevercmp(char const   *s1 , char const   *s2 ) ;
#line 33 "filevercmp.c"
static char const   *match_suffix(char const   **str ) 
{ char const   *match ;
  _Bool read_alpha ;
  int __c ;
  int tmp ;
  int __c___0 ;
  int tmp___0 ;

  {
#line 36
  match = (char const   *)((void *)0);
#line 37
  read_alpha = (_Bool)0;
#line 38
  while (*(*str)) {
#line 40
    if (read_alpha) {
#line 42
      read_alpha = (_Bool)0;
#line 43
      __c = (int )*(*str);
#line 43
      if ((__c & -33) >= 65) {
#line 43
        if ((__c & -33) <= 90) {
#line 43
          tmp = 1;
        } else {
#line 43
          tmp = 0;
        }
      } else {
#line 43
        tmp = 0;
      }
#line 43
      if (! tmp) {
#line 43
        if (126 != (int )*(*str)) {
#line 44
          match = (char const   *)((void *)0);
        }
      }
    } else
#line 46
    if (46 == (int )*(*str)) {
#line 48
      read_alpha = (_Bool)1;
#line 49
      if (! match) {
#line 50
        match = *str;
      }
    } else {
#line 52
      __c___0 = (int )*(*str);
#line 52
      if (__c___0 >= 48) {
#line 52
        if (__c___0 <= 57) {
#line 52
          tmp___0 = 1;
        } else {
#line 52
          goto _L;
        }
      } else
      _L: 
#line 52
      if ((__c___0 & -33) >= 65) {
#line 52
        if ((__c___0 & -33) <= 90) {
#line 52
          tmp___0 = 1;
        } else {
#line 52
          tmp___0 = 0;
        }
      } else {
#line 52
        tmp___0 = 0;
      }
#line 52
      if (! tmp___0) {
#line 52
        if (126 != (int )*(*str)) {
#line 53
          match = (char const   *)((void *)0);
        }
      }
    }
#line 54
    (*str) ++;
  }
#line 56
  return (match);
}
}
#line 60 "filevercmp.c"
__inline static int order(unsigned char c ) 
{ int __c ;
  int tmp ;
  int __c___0 ;
  int tmp___0 ;

  {
#line 63
  __c___0 = (int )c;
#line 63
  if (__c___0 >= 48) {
#line 63
    if (__c___0 <= 57) {
#line 63
      tmp___0 = 1;
    } else {
#line 63
      tmp___0 = 0;
    }
  } else {
#line 63
    tmp___0 = 0;
  }
#line 63
  if (tmp___0) {
#line 64
    return (0);
  } else {
#line 65
    __c = (int )c;
#line 65
    if ((__c & -33) >= 65) {
#line 65
      if ((__c & -33) <= 90) {
#line 65
        tmp = 1;
      } else {
#line 65
        tmp = 0;
      }
    } else {
#line 65
      tmp = 0;
    }
#line 65
    if (tmp) {
#line 66
      return ((int )c);
    } else
#line 67
    if ((int )c == 126) {
#line 68
      return (-1);
    } else {
#line 70
      return (((int )c + 255) + 1);
    }
  }
}
}
#line 83 "filevercmp.c"
static int verrevcmp(char const   *s1 , size_t s1_len , char const   *s2 , size_t s2_len ) 
{ size_t s1_pos ;
  size_t s2_pos ;
  int first_diff ;
  int s1_c ;
  int tmp ;
  int tmp___0 ;
  int s2_c ;
  int tmp___1 ;
  int tmp___2 ;
  int __c ;
  int tmp___3 ;
  int __c___0 ;
  int tmp___4 ;
  int __c___1 ;
  int tmp___5 ;
  int __c___2 ;
  int tmp___6 ;
  int __c___3 ;
  int tmp___7 ;
  int __c___4 ;
  int tmp___8 ;

  {
#line 86
  s1_pos = (size_t )0;
#line 87
  s2_pos = (size_t )0;
#line 88
  while (1) {
#line 88
    if (! (s1_pos < s1_len)) {
#line 88
      if (! (s2_pos < s2_len)) {
#line 88
        break;
      }
    }
#line 90
    first_diff = 0;
#line 92
    while (1) {
#line 92
      if (s1_pos < s1_len) {
#line 91
        __c = (int )*(s1 + s1_pos);
#line 91
        if (__c >= 48) {
#line 91
          if (__c <= 57) {
#line 91
            tmp___3 = 1;
          } else {
#line 91
            tmp___3 = 0;
          }
        } else {
#line 91
          tmp___3 = 0;
        }
#line 92
        if (tmp___3) {
#line 92
          goto _L;
        }
      } else
      _L: 
#line 92
      if (s2_pos < s2_len) {
#line 92
        __c___0 = (int )*(s2 + s2_pos);
#line 92
        if (__c___0 >= 48) {
#line 92
          if (__c___0 <= 57) {
#line 92
            tmp___4 = 1;
          } else {
#line 92
            tmp___4 = 0;
          }
        } else {
#line 92
          tmp___4 = 0;
        }
#line 92
        if (tmp___4) {
#line 91
          break;
        }
      } else {
#line 91
        break;
      }
#line 94
      if (s1_pos == s1_len) {
#line 94
        tmp___0 = 0;
      } else {
#line 94
        tmp = order((unsigned char )*(s1 + s1_pos));
#line 94
        tmp___0 = tmp;
      }
#line 94
      s1_c = tmp___0;
#line 95
      if (s2_pos == s2_len) {
#line 95
        tmp___2 = 0;
      } else {
#line 95
        tmp___1 = order((unsigned char )*(s2 + s2_pos));
#line 95
        tmp___2 = tmp___1;
      }
#line 95
      s2_c = tmp___2;
#line 96
      if (s1_c != s2_c) {
#line 97
        return (s1_c - s2_c);
      }
#line 98
      s1_pos ++;
#line 99
      s2_pos ++;
    }
#line 101
    while ((int const   )*(s1 + s1_pos) == 48) {
#line 102
      s1_pos ++;
    }
#line 103
    while ((int const   )*(s2 + s2_pos) == 48) {
#line 104
      s2_pos ++;
    }
#line 105
    while (1) {
#line 105
      __c___1 = (int )*(s1 + s1_pos);
#line 105
      if (__c___1 >= 48) {
#line 105
        if (__c___1 <= 57) {
#line 105
          tmp___5 = 1;
        } else {
#line 105
          tmp___5 = 0;
        }
      } else {
#line 105
        tmp___5 = 0;
      }
#line 105
      if (tmp___5) {
#line 105
        __c___2 = (int )*(s2 + s2_pos);
#line 105
        if (__c___2 >= 48) {
#line 105
          if (__c___2 <= 57) {
#line 105
            tmp___6 = 1;
          } else {
#line 105
            tmp___6 = 0;
          }
        } else {
#line 105
          tmp___6 = 0;
        }
#line 105
        if (! tmp___6) {
#line 105
          break;
        }
      } else {
#line 105
        break;
      }
#line 107
      if (! first_diff) {
#line 108
        first_diff = (int )((int const   )*(s1 + s1_pos) - (int const   )*(s2 + s2_pos));
      }
#line 109
      s1_pos ++;
#line 110
      s2_pos ++;
    }
#line 112
    __c___3 = (int )*(s1 + s1_pos);
#line 112
    if (__c___3 >= 48) {
#line 112
      if (__c___3 <= 57) {
#line 112
        tmp___7 = 1;
      } else {
#line 112
        tmp___7 = 0;
      }
    } else {
#line 112
      tmp___7 = 0;
    }
#line 112
    if (tmp___7) {
#line 113
      return (1);
    }
#line 114
    __c___4 = (int )*(s2 + s2_pos);
#line 114
    if (__c___4 >= 48) {
#line 114
      if (__c___4 <= 57) {
#line 114
        tmp___8 = 1;
      } else {
#line 114
        tmp___8 = 0;
      }
    } else {
#line 114
      tmp___8 = 0;
    }
#line 114
    if (tmp___8) {
#line 115
      return (-1);
    }
#line 116
    if (first_diff) {
#line 117
      return (first_diff);
    }
  }
#line 119
  return (0);
}
}
#line 124 "filevercmp.c"
int filevercmp(char const   *s1 , char const   *s2 ) 
{ char const   *s1_pos ;
  char const   *s2_pos ;
  char const   *s1_suffix ;
  char const   *s2_suffix ;
  size_t s1_len ;
  size_t s2_len ;
  int result ;
  int simple_cmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___21 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___28 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  char const   *tmp___34 ;
  char const   *tmp___35 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___39 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___49 ;

  {
#line 134
  if (0) {
#line 134
    __s1_len = __builtin_strlen(s1);
#line 134
    __s2_len = __builtin_strlen(s2);
#line 134
    if (! ((size_t )((void const   *)(s1 + 1)) - (size_t )((void const   *)s1) == 1UL)) {
#line 134
      goto _L___0;
    } else
#line 134
    if (__s1_len >= 4UL) {
      _L___0: 
#line 134
      if (! ((size_t )((void const   *)(s2 + 1)) - (size_t )((void const   *)s2) == 1UL)) {
#line 134
        tmp___5 = 1;
      } else
#line 134
      if (__s2_len >= 4UL) {
#line 134
        tmp___5 = 1;
      } else {
#line 134
        tmp___5 = 0;
      }
    } else {
#line 134
      tmp___5 = 0;
    }
#line 134
    if (tmp___5) {
#line 134
      tmp___0 = __builtin_strcmp(s1, s2);
#line 134
      tmp___4 = tmp___0;
    } else {
#line 134
      tmp___3 = __builtin_strcmp(s1, s2);
#line 134
      tmp___4 = tmp___3;
    }
  } else {
#line 134
    tmp___3 = __builtin_strcmp(s1, s2);
#line 134
    tmp___4 = tmp___3;
  }
#line 134
  simple_cmp = tmp___4;
#line 135
  if (simple_cmp == 0) {
#line 136
    return (0);
  }
#line 139
  if (! *s1) {
#line 140
    return (-1);
  }
#line 141
  if (! *s2) {
#line 142
    return (1);
  }
#line 143
  if (0) {
#line 143
    __s1_len___0 = __builtin_strlen(".");
#line 143
    __s2_len___0 = __builtin_strlen(s1);
#line 143
    if (! ((size_t )((void const   *)("." + 1)) - (size_t )((void const   *)".") == 1UL)) {
#line 143
      goto _L___2;
    } else
#line 143
    if (__s1_len___0 >= 4UL) {
      _L___2: 
#line 143
      if (! ((size_t )((void const   *)(s1 + 1)) - (size_t )((void const   *)s1) == 1UL)) {
#line 143
        tmp___12 = 1;
      } else
#line 143
      if (__s2_len___0 >= 4UL) {
#line 143
        tmp___12 = 1;
      } else {
#line 143
        tmp___12 = 0;
      }
    } else {
#line 143
      tmp___12 = 0;
    }
#line 143
    if (tmp___12) {
#line 143
      tmp___7 = __builtin_strcmp(".", s1);
#line 143
      tmp___11 = tmp___7;
    } else {
#line 143
      tmp___10 = __builtin_strcmp(".", s1);
#line 143
      tmp___11 = tmp___10;
    }
  } else {
#line 143
    tmp___10 = __builtin_strcmp(".", s1);
#line 143
    tmp___11 = tmp___10;
  }
#line 143
  if (0 == tmp___11) {
#line 144
    return (-1);
  }
#line 145
  if (0) {
#line 145
    __s1_len___1 = __builtin_strlen(".");
#line 145
    __s2_len___1 = __builtin_strlen(s2);
#line 145
    if (! ((size_t )((void const   *)("." + 1)) - (size_t )((void const   *)".") == 1UL)) {
#line 145
      goto _L___4;
    } else
#line 145
    if (__s1_len___1 >= 4UL) {
      _L___4: 
#line 145
      if (! ((size_t )((void const   *)(s2 + 1)) - (size_t )((void const   *)s2) == 1UL)) {
#line 145
        tmp___19 = 1;
      } else
#line 145
      if (__s2_len___1 >= 4UL) {
#line 145
        tmp___19 = 1;
      } else {
#line 145
        tmp___19 = 0;
      }
    } else {
#line 145
      tmp___19 = 0;
    }
#line 145
    if (tmp___19) {
#line 145
      tmp___14 = __builtin_strcmp(".", s2);
#line 145
      tmp___18 = tmp___14;
    } else {
#line 145
      tmp___17 = __builtin_strcmp(".", s2);
#line 145
      tmp___18 = tmp___17;
    }
  } else {
#line 145
    tmp___17 = __builtin_strcmp(".", s2);
#line 145
    tmp___18 = tmp___17;
  }
#line 145
  if (0 == tmp___18) {
#line 146
    return (1);
  }
#line 147
  if (0) {
#line 147
    __s1_len___2 = __builtin_strlen("..");
#line 147
    __s2_len___2 = __builtin_strlen(s1);
#line 147
    if (! ((size_t )((void const   *)(".." + 1)) - (size_t )((void const   *)"..") == 1UL)) {
#line 147
      goto _L___6;
    } else
#line 147
    if (__s1_len___2 >= 4UL) {
      _L___6: 
#line 147
      if (! ((size_t )((void const   *)(s1 + 1)) - (size_t )((void const   *)s1) == 1UL)) {
#line 147
        tmp___26 = 1;
      } else
#line 147
      if (__s2_len___2 >= 4UL) {
#line 147
        tmp___26 = 1;
      } else {
#line 147
        tmp___26 = 0;
      }
    } else {
#line 147
      tmp___26 = 0;
    }
#line 147
    if (tmp___26) {
#line 147
      tmp___21 = __builtin_strcmp("..", s1);
#line 147
      tmp___25 = tmp___21;
    } else {
#line 147
      tmp___24 = __builtin_strcmp("..", s1);
#line 147
      tmp___25 = tmp___24;
    }
  } else {
#line 147
    tmp___24 = __builtin_strcmp("..", s1);
#line 147
    tmp___25 = tmp___24;
  }
#line 147
  if (0 == tmp___25) {
#line 148
    return (-1);
  }
#line 149
  if (0) {
#line 149
    __s1_len___3 = __builtin_strlen("..");
#line 149
    __s2_len___3 = __builtin_strlen(s2);
#line 149
    if (! ((size_t )((void const   *)(".." + 1)) - (size_t )((void const   *)"..") == 1UL)) {
#line 149
      goto _L___8;
    } else
#line 149
    if (__s1_len___3 >= 4UL) {
      _L___8: 
#line 149
      if (! ((size_t )((void const   *)(s2 + 1)) - (size_t )((void const   *)s2) == 1UL)) {
#line 149
        tmp___33 = 1;
      } else
#line 149
      if (__s2_len___3 >= 4UL) {
#line 149
        tmp___33 = 1;
      } else {
#line 149
        tmp___33 = 0;
      }
    } else {
#line 149
      tmp___33 = 0;
    }
#line 149
    if (tmp___33) {
#line 149
      tmp___28 = __builtin_strcmp("..", s2);
#line 149
      tmp___32 = tmp___28;
    } else {
#line 149
      tmp___31 = __builtin_strcmp("..", s2);
#line 149
      tmp___32 = tmp___31;
    }
  } else {
#line 149
    tmp___31 = __builtin_strcmp("..", s2);
#line 149
    tmp___32 = tmp___31;
  }
#line 149
  if (0 == tmp___32) {
#line 150
    return (1);
  }
#line 153
  if ((int const   )*s1 == 46) {
#line 153
    if ((int const   )*s2 != 46) {
#line 154
      return (-1);
    }
  }
#line 155
  if ((int const   )*s1 != 46) {
#line 155
    if ((int const   )*s2 == 46) {
#line 156
      return (1);
    }
  }
#line 157
  if ((int const   )*s1 == 46) {
#line 157
    if ((int const   )*s2 == 46) {
#line 159
      s1 ++;
#line 160
      s2 ++;
    }
  }
#line 164
  s1_pos = s1;
#line 165
  s2_pos = s2;
#line 166
  s1_suffix = match_suffix(& s1_pos);
#line 167
  s2_suffix = match_suffix(& s2_pos);
#line 168
  if (s1_suffix) {
#line 168
    tmp___34 = s1_suffix;
  } else {
#line 168
    tmp___34 = s1_pos;
  }
#line 168
  s1_len = (size_t )(tmp___34 - s1);
#line 169
  if (s2_suffix) {
#line 169
    tmp___35 = s2_suffix;
  } else {
#line 169
    tmp___35 = s2_pos;
  }
#line 169
  s2_len = (size_t )(tmp___35 - s2);
#line 173
  if (s1_suffix) {
#line 173
    goto _L___11;
  } else
#line 173
  if (s2_suffix) {
    _L___11: 
#line 173
    if (s1_len == s2_len) {
#line 173
      if (0) {
#line 173
        if (0) {
#line 173
          __s1_len___4 = __builtin_strlen(s1);
#line 173
          __s2_len___4 = __builtin_strlen(s2);
#line 173
          if (! ((size_t )((void const   *)(s1 + 1)) - (size_t )((void const   *)s1) == 1UL)) {
#line 173
            goto _L___10;
          } else
#line 173
          if (__s1_len___4 >= 4UL) {
            _L___10: 
#line 173
            if (! ((size_t )((void const   *)(s2 + 1)) - (size_t )((void const   *)s2) == 1UL)) {
#line 173
              tmp___44 = 1;
            } else
#line 173
            if (__s2_len___4 >= 4UL) {
#line 173
              tmp___44 = 1;
            } else {
#line 173
              tmp___44 = 0;
            }
          } else {
#line 173
            tmp___44 = 0;
          }
#line 173
          if (tmp___44) {
#line 173
            tmp___39 = __builtin_strcmp(s1, s2);
#line 173
            tmp___43 = tmp___39;
          } else {
#line 173
            tmp___42 = __builtin_strcmp(s1, s2);
#line 173
            tmp___43 = tmp___42;
          }
        } else {
#line 173
          tmp___42 = __builtin_strcmp(s1, s2);
#line 173
          tmp___43 = tmp___42;
        }
#line 173
        tmp___46 = tmp___43;
      } else {
#line 173
        tmp___45 = strncmp(s1, s2, s1_len);
#line 173
        tmp___46 = tmp___45;
      }
#line 173
      if (0 == tmp___46) {
#line 175
        s1_len = (size_t )(s1_pos - s1);
#line 176
        s2_len = (size_t )(s2_pos - s2);
      }
    }
  }
#line 179
  result = verrevcmp(s1, s1_len, s2, s2_len);
#line 180
  if (result == 0) {
#line 180
    tmp___49 = simple_cmp;
  } else {
#line 180
    tmp___49 = result;
  }
#line 180
  return (tmp___49);
}
}
#line 1 "fopen-safer.o"
#pragma merger(0,"/tmp/cil-_sI2s1x_.i","-g,-O2")
#line 303 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes )  __attribute__((__warn_unused_result__)) ;
#line 23 "stdio-safer.h"
FILE *fopen_safer(char const   *file , char const   *mode ) ;
#line 30 "fopen-safer.c"
FILE *fopen_safer(char const   *file , char const   *mode ) 
{ FILE *fp ;
  FILE *tmp ;
  int fd ;
  int tmp___0 ;
  int f ;
  int tmp___1 ;
  int e ;
  int *tmp___2 ;
  int *tmp___3 ;
  int e___0 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;

  {
#line 33
  tmp = fopen((char const   * __restrict  )file, (char const   * __restrict  )mode);
#line 33
  fp = tmp;
#line 35
  if (fp) {
#line 37
    tmp___0 = fileno(fp);
#line 37
    fd = tmp___0;
#line 39
    if (0 <= fd) {
#line 39
      if (fd <= 2) {
#line 41
        tmp___1 = dup_safer(fd);
#line 41
        f = tmp___1;
#line 43
        if (f < 0) {
#line 45
          tmp___2 = __errno_location();
#line 45
          e = *tmp___2;
#line 46
          rpl_fclose(fp);
#line 47
          tmp___3 = __errno_location();
#line 47
          *tmp___3 = e;
#line 48
          return ((FILE *)((void *)0));
        }
#line 51
        tmp___6 = rpl_fclose(fp);
#line 51
        if (tmp___6 != 0) {
#line 51
          goto _L;
        } else {
#line 51
          fp = fdopen(f, mode);
#line 51
          if (! fp) {
            _L: 
#line 54
            tmp___4 = __errno_location();
#line 54
            e___0 = *tmp___4;
#line 55
            close(f);
#line 56
            tmp___5 = __errno_location();
#line 56
            *tmp___5 = e___0;
#line 57
            return ((FILE *)((void *)0));
          }
        }
      }
    }
  }
#line 62
  return (fp);
}
}
#line 1 "fprintftime.o"
#pragma merger(0,"/tmp/cil-saVQXsxK.i","-g,-O2")
#line 575 "/usr/include/stdio.h"
extern int fputc(int __c , FILE *__stream ) ;
#line 708
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 878 "./stdio.h"
__inline static size_t __attribute__((__nonnull__(1,4)))  rpl_fwrite(void const   *ptr ,
                                                                     size_t s , size_t n ,
                                                                     FILE *stream ) 
{ size_t r ;
  size_t tmp ;

  {
#line 881
  tmp = fwrite((void const   * __restrict  )ptr, s, n, (FILE * __restrict  )stream);
#line 881
  r = tmp;
#line 883
  return ((size_t __attribute__((__nonnull__(1,4)))  )r);
}
}
#line 193 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t mktime(struct tm *__tp ) ;
#line 199
extern  __attribute__((__nothrow__)) size_t strftime(char * __restrict  __s , size_t __maxsize ,
                                                     char const   * __restrict  __format ,
                                                     struct tm  const  * __restrict  __tp ) ;
#line 28 "fprintftime.h"
size_t fprintftime(FILE *s , char const   *format , struct tm  const  *tp , int ut ,
                   int ns ) ;
#line 299 "strftime.c"
static void fwrite_lowcase(FILE *fp , char const   *src , size_t len ) 
{ int __res ;
  __int32_t const   **tmp___0 ;
  size_t tmp___1 ;

  {
#line 302
  while (1) {
#line 302
    tmp___1 = len;
#line 302
    len --;
#line 302
    if (! (tmp___1 > 0UL)) {
#line 302
      break;
    }
#line 304
    if (sizeof((unsigned char )*src) > 1UL) {
#line 304
      __res = tolower((int )((unsigned char )*src));
    } else {
#line 304
      tmp___0 = __ctype_tolower_loc();
#line 304
      __res = (int )*(*tmp___0 + (int )((unsigned char )*src));
    }
#line 304
    fputc(__res, fp);
#line 305
    src ++;
  }
#line 307
  return;
}
}
#line 309 "strftime.c"
static void fwrite_uppcase(FILE *fp , char const   *src , size_t len ) 
{ int __res ;
  __int32_t const   **tmp___0 ;
  size_t tmp___1 ;

  {
#line 312
  while (1) {
#line 312
    tmp___1 = len;
#line 312
    len --;
#line 312
    if (! (tmp___1 > 0UL)) {
#line 312
      break;
    }
#line 314
    if (sizeof((unsigned char )*src) > 1UL) {
#line 314
      __res = toupper((int )((unsigned char )*src));
    } else {
#line 314
      tmp___0 = __ctype_toupper_loc();
#line 314
      __res = (int )*(*tmp___0 + (int )((unsigned char )*src));
    }
#line 314
    fputc(__res, fp);
#line 315
    src ++;
  }
#line 317
  return;
}
}
#line 375 "strftime.c"
__inline static int iso_week_days(int yday , int wday ) 
{ int big_enough_multiple_of_7 ;

  {
#line 381
  big_enough_multiple_of_7 = 378;
#line 382
  return (((yday - (((yday - wday) + 4) + big_enough_multiple_of_7) % 7) + 4) - 1);
}
}
#line 423 "strftime.c"
static size_t strftime_case_(_Bool upcase , FILE *s , char const   *format , struct tm  const  *tp ,
                             int ut , int ns ) 
{ size_t maxsize ;
  int hour12 ;
  char const   *zone ;
  size_t i ;
  FILE *p ;
  char const   *f ;
  int pad ;
  int modifier ;
  int digits ;
  int number_value ;
  unsigned int u_number_value ;
  _Bool negative_number ;
  _Bool always_output_a_sign ;
  int tz_colon_mask ;
  char const   *subfmt ;
  char sign_char ;
  char *bufp ;
  char buf___1[3UL + (((sizeof(time_t ) * 8UL - 1UL) * 146UL) / 485UL + 2UL)] ;
  int width ;
  _Bool to_lowcase ;
  _Bool to_uppcase ;
  size_t colons ;
  _Bool change_case ;
  int format_char ;
  size_t _n ;
  size_t _w ;
  int tmp ;
  size_t _incr ;
  size_t tmp___0 ;
  size_t _delta ;
  size_t _i ;
  size_t _i___0 ;
  char const   *tmp___1 ;
  size_t _n___0 ;
  size_t _w___0 ;
  int tmp___2 ;
  size_t _incr___0 ;
  size_t tmp___3 ;
  size_t _delta___0 ;
  size_t _i___1 ;
  size_t _i___2 ;
  size_t len ;
  size_t tmp___4 ;
  size_t _n___1 ;
  size_t _w___1 ;
  int tmp___5 ;
  size_t _incr___1 ;
  size_t tmp___6 ;
  size_t _delta___1 ;
  size_t _i___3 ;
  size_t _i___4 ;
  char ufmt[5] ;
  char *u ;
  char ubuf[1024] ;
  size_t len___0 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  size_t _n___2 ;
  size_t _w___2 ;
  int tmp___11 ;
  size_t _incr___2 ;
  size_t tmp___12 ;
  size_t _delta___2 ;
  size_t _i___5 ;
  size_t _i___6 ;
  size_t __attribute__((__nonnull__(1,4)))  __x ;
  size_t __attribute__((__nonnull__(1,4)))  tmp___13 ;
  int century ;
  int tmp___14 ;
  int tmp___15 ;
  size_t _n___3 ;
  size_t _w___3 ;
  int tmp___16 ;
  size_t _incr___3 ;
  size_t tmp___17 ;
  size_t _delta___3 ;
  size_t _i___7 ;
  size_t _i___8 ;
  int padding ;
  size_t _i___9 ;
  size_t _n___4 ;
  size_t _w___4 ;
  int tmp___18 ;
  size_t _incr___4 ;
  size_t tmp___19 ;
  size_t _delta___4 ;
  size_t _i___10 ;
  size_t _i___11 ;
  size_t _n___5 ;
  size_t _w___5 ;
  int tmp___20 ;
  size_t _incr___5 ;
  size_t tmp___21 ;
  size_t _delta___5 ;
  size_t _i___12 ;
  size_t _i___13 ;
  size_t _i___14 ;
  size_t _n___6 ;
  size_t _w___6 ;
  int tmp___22 ;
  size_t _incr___6 ;
  size_t tmp___23 ;
  size_t _delta___6 ;
  size_t _i___15 ;
  size_t _i___16 ;
  size_t _n___7 ;
  size_t _w___7 ;
  int tmp___24 ;
  size_t _incr___7 ;
  size_t tmp___25 ;
  size_t _delta___7 ;
  size_t _i___17 ;
  size_t _i___18 ;
  size_t __attribute__((__nonnull__(1,4)))  __x___0 ;
  size_t __attribute__((__nonnull__(1,4)))  tmp___26 ;
  int j ;
  size_t _n___8 ;
  size_t _w___8 ;
  int tmp___27 ;
  size_t _incr___8 ;
  size_t tmp___28 ;
  size_t _delta___8 ;
  size_t _i___19 ;
  size_t _i___20 ;
  struct tm ltm ;
  time_t t ;
  int d ;
  int tmp___29 ;
  size_t _n___9 ;
  size_t _w___9 ;
  int tmp___30 ;
  size_t _incr___9 ;
  size_t tmp___31 ;
  size_t _delta___9 ;
  size_t _i___21 ;
  size_t _i___22 ;
  int year___0 ;
  int tmp___32 ;
  int year_adjust ;
  int days ;
  int tmp___33 ;
  int tmp___34 ;
  int d___0 ;
  int tmp___35 ;
  int tmp___36 ;
  int yy ;
  int tmp___37 ;
  int yy___0 ;
  size_t _n___10 ;
  size_t tmp___38 ;
  size_t _w___10 ;
  int tmp___39 ;
  size_t _incr___10 ;
  size_t tmp___40 ;
  size_t _delta___10 ;
  size_t _i___23 ;
  size_t _i___24 ;
  size_t __attribute__((__nonnull__(1,4)))  __x___1 ;
  size_t __attribute__((__nonnull__(1,4)))  tmp___41 ;
  int diff ;
  int hour_diff ;
  int min_diff ;
  int sec_diff ;
  int flen ;
  size_t _n___11 ;
  size_t _w___11 ;
  int tmp___42 ;
  size_t _incr___11 ;
  size_t tmp___43 ;
  size_t _delta___11 ;
  size_t _i___25 ;
  size_t _i___26 ;
  size_t __attribute__((__nonnull__(1,4)))  __x___2 ;
  size_t __attribute__((__nonnull__(1,4)))  tmp___44 ;

  {
#line 433
  maxsize = (size_t )-1;
#line 436
  hour12 = (int )tp->tm_hour;
#line 461
  i = (size_t )0;
#line 462
  p = s;
#line 477
  zone = (char const   *)((void *)0);
#line 485
  zone = (char const   *)tp->tm_zone;
#line 503
  if (hour12 > 12) {
#line 504
    hour12 -= 12;
  } else
#line 506
  if (hour12 == 0) {
#line 507
    hour12 = 12;
  }
#line 509
  f = format;
#line 509
  while ((int const   )*f != 0) {
#line 511
    pad = 0;
#line 513
    digits = 0;
#line 527
    width = -1;
#line 528
    to_lowcase = (_Bool)0;
#line 529
    to_uppcase = upcase;
#line 531
    change_case = (_Bool)0;
#line 614
    if ((int const   )*f != 37) {
#line 616
      while (1) {
#line 616
        _n = (size_t )1;
#line 616
        if (width < 0) {
#line 616
          tmp = 0;
        } else {
#line 616
          tmp = width;
        }
#line 616
        _w = (size_t )tmp;
#line 616
        if (_n < _w) {
#line 616
          tmp___0 = _w;
        } else {
#line 616
          tmp___0 = _n;
        }
#line 616
        _incr = tmp___0;
#line 616
        if (_incr >= maxsize - i) {
#line 616
          return ((size_t )0);
        }
#line 616
        if (p) {
#line 616
          if (digits == 0) {
#line 616
            if (_n < _w) {
#line 616
              _delta = (size_t )width - _n;
#line 616
              if (pad == 48) {
#line 616
                while (1) {
#line 616
                  _i = (size_t )0;
#line 616
                  while (_i < _delta) {
#line 616
                    fputc('0', p);
#line 616
                    _i ++;
                  }
#line 616
                  break;
                }
              } else {
#line 616
                while (1) {
#line 616
                  _i___0 = (size_t )0;
#line 616
                  while (_i___0 < _delta) {
#line 616
                    fputc(' ', p);
#line 616
                    _i___0 ++;
                  }
#line 616
                  break;
                }
              }
            }
          }
#line 616
          fputc((int )*f, p);
        }
#line 616
        i += _incr;
#line 616
        break;
      }
#line 617
      goto __Cont;
    }
#line 623
    while (1) {
#line 625
      f ++;
#line 625
      switch ((int )*f) {
      case 95: 
      case 45: 
      case 48: 
#line 631
      pad = (int )*f;
#line 632
      continue;
      case 94: 
#line 636
      to_uppcase = (_Bool)1;
#line 637
      continue;
      case 35: 
#line 639
      change_case = (_Bool)1;
#line 640
      continue;
      default: 
#line 643
      break;
      }
#line 645
      break;
    }
#line 649
    if ((unsigned int )*f - 48U <= 9U) {
#line 651
      width = 0;
#line 652
      while (1) {
#line 654
        if (width > 214748364) {
#line 657
          width = 2147483647;
        } else
#line 654
        if (width == 214748364) {
#line 654
          if ((int const   )*f - 48 > 7) {
#line 657
            width = 2147483647;
          } else {
#line 660
            width *= 10;
#line 661
            width += (int )((int const   )*f - 48);
          }
        } else {
#line 660
          width *= 10;
#line 661
          width += (int )((int const   )*f - 48);
        }
#line 663
        f ++;
#line 652
        if (! ((unsigned int )*f - 48U <= 9U)) {
#line 652
          break;
        }
      }
    }
#line 669
    switch ((int )*f) {
    case 69: 
    case 79: 
#line 673
    tmp___1 = f;
#line 673
    f ++;
#line 673
    modifier = (int )*tmp___1;
#line 674
    break;
    default: 
#line 677
    modifier = 0;
#line 678
    break;
    }
#line 682
    format_char = (int )*f;
#line 683
    switch (format_char) {
    case 37: 
#line 706
    if (modifier != 0) {
#line 707
      goto bad_format;
    }
#line 708
    while (1) {
#line 708
      _n___0 = (size_t )1;
#line 708
      if (width < 0) {
#line 708
        tmp___2 = 0;
      } else {
#line 708
        tmp___2 = width;
      }
#line 708
      _w___0 = (size_t )tmp___2;
#line 708
      if (_n___0 < _w___0) {
#line 708
        tmp___3 = _w___0;
      } else {
#line 708
        tmp___3 = _n___0;
      }
#line 708
      _incr___0 = tmp___3;
#line 708
      if (_incr___0 >= maxsize - i) {
#line 708
        return ((size_t )0);
      }
#line 708
      if (p) {
#line 708
        if (digits == 0) {
#line 708
          if (_n___0 < _w___0) {
#line 708
            _delta___0 = (size_t )width - _n___0;
#line 708
            if (pad == 48) {
#line 708
              while (1) {
#line 708
                _i___1 = (size_t )0;
#line 708
                while (_i___1 < _delta___0) {
#line 708
                  fputc('0', p);
#line 708
                  _i___1 ++;
                }
#line 708
                break;
              }
            } else {
#line 708
              while (1) {
#line 708
                _i___2 = (size_t )0;
#line 708
                while (_i___2 < _delta___0) {
#line 708
                  fputc(' ', p);
#line 708
                  _i___2 ++;
                }
#line 708
                break;
              }
            }
          }
        }
#line 708
        fputc((int )*f, p);
      }
#line 708
      i += _incr___0;
#line 708
      break;
    }
#line 709
    break;
    case 97: 
#line 712
    if (modifier != 0) {
#line 713
      goto bad_format;
    }
#line 714
    if (change_case) {
#line 716
      to_uppcase = (_Bool)1;
#line 717
      to_lowcase = (_Bool)0;
    }
#line 723
    goto underlying_strftime;
    case 65: 
#line 727
    if (modifier != 0) {
#line 728
      goto bad_format;
    }
#line 729
    if (change_case) {
#line 731
      to_uppcase = (_Bool)1;
#line 732
      to_lowcase = (_Bool)0;
    }
#line 738
    goto underlying_strftime;
    case 98: 
    case 104: 
#line 743
    if (change_case) {
#line 745
      to_uppcase = (_Bool)1;
#line 746
      to_lowcase = (_Bool)0;
    }
#line 748
    if (modifier != 0) {
#line 749
      goto bad_format;
    }
#line 754
    goto underlying_strftime;
    case 66: 
#line 758
    if (modifier != 0) {
#line 759
      goto bad_format;
    }
#line 760
    if (change_case) {
#line 762
      to_uppcase = (_Bool)1;
#line 763
      to_lowcase = (_Bool)0;
    }
#line 769
    goto underlying_strftime;
    case 99: 
#line 773
    if (modifier == 79) {
#line 774
      goto bad_format;
    }
#line 783
    goto underlying_strftime;
    subformat: 
#line 788
    tmp___4 = strftime_case_(to_uppcase, (FILE *)((void *)0), subfmt, tp, ut, ns);
#line 788
    len = tmp___4;
#line 792
    while (1) {
#line 792
      _n___1 = len;
#line 792
      if (width < 0) {
#line 792
        tmp___5 = 0;
      } else {
#line 792
        tmp___5 = width;
      }
#line 792
      _w___1 = (size_t )tmp___5;
#line 792
      if (_n___1 < _w___1) {
#line 792
        tmp___6 = _w___1;
      } else {
#line 792
        tmp___6 = _n___1;
      }
#line 792
      _incr___1 = tmp___6;
#line 792
      if (_incr___1 >= maxsize - i) {
#line 792
        return ((size_t )0);
      }
#line 792
      if (p) {
#line 792
        if (digits == 0) {
#line 792
          if (_n___1 < _w___1) {
#line 792
            _delta___1 = (size_t )width - _n___1;
#line 792
            if (pad == 48) {
#line 792
              while (1) {
#line 792
                _i___3 = (size_t )0;
#line 792
                while (_i___3 < _delta___1) {
#line 792
                  fputc('0', p);
#line 792
                  _i___3 ++;
                }
#line 792
                break;
              }
            } else {
#line 792
              while (1) {
#line 792
                _i___4 = (size_t )0;
#line 792
                while (_i___4 < _delta___1) {
#line 792
                  fputc(' ', p);
#line 792
                  _i___4 ++;
                }
#line 792
                break;
              }
            }
          }
        }
#line 792
        strftime_case_(to_uppcase, p, subfmt, tp, ut, ns);
      }
#line 792
      i += _incr___1;
#line 792
      break;
    }
#line 797
    break;
    underlying_strftime: 
#line 805
    u = ufmt;
#line 818
    tmp___7 = u;
#line 818
    u ++;
#line 818
    *tmp___7 = (char )' ';
#line 819
    tmp___8 = u;
#line 819
    u ++;
#line 819
    *tmp___8 = (char )'%';
#line 820
    if (modifier != 0) {
#line 821
      tmp___9 = u;
#line 821
      u ++;
#line 821
      *tmp___9 = (char )modifier;
    }
#line 822
    tmp___10 = u;
#line 822
    u ++;
#line 822
    *tmp___10 = (char )format_char;
#line 823
    *u = (char )'\000';
#line 824
    len___0 = strftime((char * __restrict  )(ubuf), sizeof(ubuf), (char const   * __restrict  )(ufmt),
                       (struct tm  const  * __restrict  )tp);
#line 825
    if (len___0 != 0UL) {
#line 826
      while (1) {
#line 826
        _n___2 = len___0 - 1UL;
#line 826
        if (width < 0) {
#line 826
          tmp___11 = 0;
        } else {
#line 826
          tmp___11 = width;
        }
#line 826
        _w___2 = (size_t )tmp___11;
#line 826
        if (_n___2 < _w___2) {
#line 826
          tmp___12 = _w___2;
        } else {
#line 826
          tmp___12 = _n___2;
        }
#line 826
        _incr___2 = tmp___12;
#line 826
        if (_incr___2 >= maxsize - i) {
#line 826
          return ((size_t )0);
        }
#line 826
        if (p) {
#line 826
          if (digits == 0) {
#line 826
            if (_n___2 < _w___2) {
#line 826
              _delta___2 = (size_t )width - _n___2;
#line 826
              if (pad == 48) {
#line 826
                while (1) {
#line 826
                  _i___5 = (size_t )0;
#line 826
                  while (_i___5 < _delta___2) {
#line 826
                    fputc('0', p);
#line 826
                    _i___5 ++;
                  }
#line 826
                  break;
                }
              } else {
#line 826
                while (1) {
#line 826
                  _i___6 = (size_t )0;
#line 826
                  while (_i___6 < _delta___2) {
#line 826
                    fputc(' ', p);
#line 826
                    _i___6 ++;
                  }
#line 826
                  break;
                }
              }
            }
          }
#line 826
          while (1) {
#line 826
            if (to_lowcase) {
#line 826
              fwrite_lowcase(p, (char const   *)(ubuf + 1), _n___2);
            } else
#line 826
            if (to_uppcase) {
#line 826
              fwrite_uppcase(p, (char const   *)(ubuf + 1), _n___2);
            } else {
#line 826
              tmp___13 = rpl_fwrite((void const   *)(ubuf + 1), _n___2, (size_t )1,
                                    p);
#line 826
              __x = tmp___13;
            }
#line 826
            break;
          }
        }
#line 826
        i += _incr___2;
#line 826
        break;
      }
    }
#line 828
    break;
    case 67: 
#line 832
    if (modifier == 79) {
#line 833
      goto bad_format;
    }
#line 834
    if (modifier == 69) {
#line 850
      goto underlying_strftime;
    }
#line 855
    century = (int )(tp->tm_year / 100 + 19);
#line 856
    if (tp->tm_year % 100 < 0) {
#line 856
      if (0 < century) {
#line 856
        tmp___14 = 1;
      } else {
#line 856
        tmp___14 = 0;
      }
    } else {
#line 856
      tmp___14 = 0;
    }
#line 856
    century -= tmp___14;
#line 857
    digits = 2;
#line 857
    negative_number = (_Bool )(tp->tm_year < -1900);
#line 857
    u_number_value = (unsigned int )century;
#line 857
    goto do_signed_number;
    case 120: 
#line 861
    if (modifier == 79) {
#line 862
      goto bad_format;
    }
#line 871
    goto underlying_strftime;
    case 68: 
#line 874
    if (modifier != 0) {
#line 875
      goto bad_format;
    }
#line 876
    subfmt = "%m/%d/%y";
#line 877
    goto subformat;
    case 100: 
#line 880
    if (modifier == 69) {
#line 881
      goto bad_format;
    }
#line 883
    digits = 2;
#line 883
    number_value = (int )tp->tm_mday;
#line 883
    goto do_number;
    case 101: 
#line 886
    if (modifier == 69) {
#line 887
      goto bad_format;
    }
#line 889
    digits = 2;
#line 889
    number_value = (int )tp->tm_mday;
#line 889
    goto do_number_spacepad;
    do_tz_offset: 
#line 895
    always_output_a_sign = (_Bool)1;
#line 896
    goto do_number_body;
    do_number_spacepad: 
#line 900
    if (pad != 48) {
#line 900
      if (pad != 45) {
#line 901
        pad = '_';
      }
    }
    do_number: 
#line 905
    negative_number = (_Bool )(number_value < 0);
#line 906
    u_number_value = (unsigned int )number_value;
    do_signed_number: 
#line 909
    always_output_a_sign = (_Bool)0;
#line 910
    tz_colon_mask = 0;
    do_number_body: 
#line 918
    if (modifier == 79) {
#line 918
      if (! negative_number) {
#line 936
        goto underlying_strftime;
      }
    }
#line 940
    bufp = buf___1 + sizeof(buf___1) / sizeof(buf___1[0]);
#line 942
    if (negative_number) {
#line 943
      u_number_value = - u_number_value;
    }
#line 945
    while (1) {
#line 947
      if (tz_colon_mask & 1) {
#line 948
        bufp --;
#line 948
        *bufp = (char )':';
      }
#line 949
      tz_colon_mask >>= 1;
#line 950
      bufp --;
#line 950
      *bufp = (char )(u_number_value % 10U + 48U);
#line 951
      u_number_value /= 10U;
#line 945
      if (! (u_number_value != 0U)) {
#line 945
        if (! (tz_colon_mask != 0)) {
#line 945
          break;
        }
      }
    }
    do_number_sign_and_padding: 
#line 956
    if (digits < width) {
#line 957
      digits = width;
    }
#line 959
    if (negative_number) {
#line 959
      sign_char = (char )'-';
    } else {
#line 959
      if (always_output_a_sign) {
#line 959
        tmp___15 = '+';
      } else {
#line 959
        tmp___15 = 0;
      }
#line 959
      sign_char = (char )tmp___15;
    }
#line 963
    if (pad == 45) {
#line 965
      if (sign_char) {
#line 966
        while (1) {
#line 966
          _n___3 = (size_t )1;
#line 966
          if (width < 0) {
#line 966
            tmp___16 = 0;
          } else {
#line 966
            tmp___16 = width;
          }
#line 966
          _w___3 = (size_t )tmp___16;
#line 966
          if (_n___3 < _w___3) {
#line 966
            tmp___17 = _w___3;
          } else {
#line 966
            tmp___17 = _n___3;
          }
#line 966
          _incr___3 = tmp___17;
#line 966
          if (_incr___3 >= maxsize - i) {
#line 966
            return ((size_t )0);
          }
#line 966
          if (p) {
#line 966
            if (digits == 0) {
#line 966
              if (_n___3 < _w___3) {
#line 966
                _delta___3 = (size_t )width - _n___3;
#line 966
                if (pad == 48) {
#line 966
                  while (1) {
#line 966
                    _i___7 = (size_t )0;
#line 966
                    while (_i___7 < _delta___3) {
#line 966
                      fputc('0', p);
#line 966
                      _i___7 ++;
                    }
#line 966
                    break;
                  }
                } else {
#line 966
                  while (1) {
#line 966
                    _i___8 = (size_t )0;
#line 966
                    while (_i___8 < _delta___3) {
#line 966
                      fputc(' ', p);
#line 966
                      _i___8 ++;
                    }
#line 966
                    break;
                  }
                }
              }
            }
#line 966
            fputc((int )sign_char, p);
          }
#line 966
          i += _incr___3;
#line 966
          break;
        }
      }
    } else {
#line 970
      padding = (digits - ((buf___1 + sizeof(buf___1) / sizeof(buf___1[0])) - bufp)) - ! (! sign_char);
#line 973
      if (padding > 0) {
#line 975
        if (pad == 95) {
#line 977
          if ((size_t )padding >= maxsize - i) {
#line 978
            return ((size_t )0);
          }
#line 980
          if (p) {
#line 981
            while (1) {
#line 981
              _i___9 = (size_t )0;
#line 981
              while (_i___9 < (size_t )padding) {
#line 981
                fputc(' ', p);
#line 981
                _i___9 ++;
              }
#line 981
              break;
            }
          }
#line 982
          i += (size_t )padding;
#line 983
          if (width > padding) {
#line 983
            width -= padding;
          } else {
#line 983
            width = 0;
          }
#line 984
          if (sign_char) {
#line 985
            while (1) {
#line 985
              _n___4 = (size_t )1;
#line 985
              if (width < 0) {
#line 985
                tmp___18 = 0;
              } else {
#line 985
                tmp___18 = width;
              }
#line 985
              _w___4 = (size_t )tmp___18;
#line 985
              if (_n___4 < _w___4) {
#line 985
                tmp___19 = _w___4;
              } else {
#line 985
                tmp___19 = _n___4;
              }
#line 985
              _incr___4 = tmp___19;
#line 985
              if (_incr___4 >= maxsize - i) {
#line 985
                return ((size_t )0);
              }
#line 985
              if (p) {
#line 985
                if (digits == 0) {
#line 985
                  if (_n___4 < _w___4) {
#line 985
                    _delta___4 = (size_t )width - _n___4;
#line 985
                    if (pad == 48) {
#line 985
                      while (1) {
#line 985
                        _i___10 = (size_t )0;
#line 985
                        while (_i___10 < _delta___4) {
#line 985
                          fputc('0', p);
#line 985
                          _i___10 ++;
                        }
#line 985
                        break;
                      }
                    } else {
#line 985
                      while (1) {
#line 985
                        _i___11 = (size_t )0;
#line 985
                        while (_i___11 < _delta___4) {
#line 985
                          fputc(' ', p);
#line 985
                          _i___11 ++;
                        }
#line 985
                        break;
                      }
                    }
                  }
                }
#line 985
                fputc((int )sign_char, p);
              }
#line 985
              i += _incr___4;
#line 985
              break;
            }
          }
        } else {
#line 989
          if ((size_t )digits >= maxsize - i) {
#line 990
            return ((size_t )0);
          }
#line 992
          if (sign_char) {
#line 993
            while (1) {
#line 993
              _n___5 = (size_t )1;
#line 993
              if (width < 0) {
#line 993
                tmp___20 = 0;
              } else {
#line 993
                tmp___20 = width;
              }
#line 993
              _w___5 = (size_t )tmp___20;
#line 993
              if (_n___5 < _w___5) {
#line 993
                tmp___21 = _w___5;
              } else {
#line 993
                tmp___21 = _n___5;
              }
#line 993
              _incr___5 = tmp___21;
#line 993
              if (_incr___5 >= maxsize - i) {
#line 993
                return ((size_t )0);
              }
#line 993
              if (p) {
#line 993
                if (digits == 0) {
#line 993
                  if (_n___5 < _w___5) {
#line 993
                    _delta___5 = (size_t )width - _n___5;
#line 993
                    if (pad == 48) {
#line 993
                      while (1) {
#line 993
                        _i___12 = (size_t )0;
#line 993
                        while (_i___12 < _delta___5) {
#line 993
                          fputc('0', p);
#line 993
                          _i___12 ++;
                        }
#line 993
                        break;
                      }
                    } else {
#line 993
                      while (1) {
#line 993
                        _i___13 = (size_t )0;
#line 993
                        while (_i___13 < _delta___5) {
#line 993
                          fputc(' ', p);
#line 993
                          _i___13 ++;
                        }
#line 993
                        break;
                      }
                    }
                  }
                }
#line 993
                fputc((int )sign_char, p);
              }
#line 993
              i += _incr___5;
#line 993
              break;
            }
          }
#line 995
          if (p) {
#line 996
            while (1) {
#line 996
              _i___14 = (size_t )0;
#line 996
              while (_i___14 < (size_t )padding) {
#line 996
                fputc('0', p);
#line 996
                _i___14 ++;
              }
#line 996
              break;
            }
          }
#line 997
          i += (size_t )padding;
#line 998
          width = 0;
        }
      } else
#line 1003
      if (sign_char) {
#line 1004
        while (1) {
#line 1004
          _n___6 = (size_t )1;
#line 1004
          if (width < 0) {
#line 1004
            tmp___22 = 0;
          } else {
#line 1004
            tmp___22 = width;
          }
#line 1004
          _w___6 = (size_t )tmp___22;
#line 1004
          if (_n___6 < _w___6) {
#line 1004
            tmp___23 = _w___6;
          } else {
#line 1004
            tmp___23 = _n___6;
          }
#line 1004
          _incr___6 = tmp___23;
#line 1004
          if (_incr___6 >= maxsize - i) {
#line 1004
            return ((size_t )0);
          }
#line 1004
          if (p) {
#line 1004
            if (digits == 0) {
#line 1004
              if (_n___6 < _w___6) {
#line 1004
                _delta___6 = (size_t )width - _n___6;
#line 1004
                if (pad == 48) {
#line 1004
                  while (1) {
#line 1004
                    _i___15 = (size_t )0;
#line 1004
                    while (_i___15 < _delta___6) {
#line 1004
                      fputc('0', p);
#line 1004
                      _i___15 ++;
                    }
#line 1004
                    break;
                  }
                } else {
#line 1004
                  while (1) {
#line 1004
                    _i___16 = (size_t )0;
#line 1004
                    while (_i___16 < _delta___6) {
#line 1004
                      fputc(' ', p);
#line 1004
                      _i___16 ++;
                    }
#line 1004
                    break;
                  }
                }
              }
            }
#line 1004
            fputc((int )sign_char, p);
          }
#line 1004
          i += _incr___6;
#line 1004
          break;
        }
      }
    }
#line 1008
    while (1) {
#line 1008
      _n___7 = (size_t )((buf___1 + sizeof(buf___1) / sizeof(buf___1[0])) - bufp);
#line 1008
      if (width < 0) {
#line 1008
        tmp___24 = 0;
      } else {
#line 1008
        tmp___24 = width;
      }
#line 1008
      _w___7 = (size_t )tmp___24;
#line 1008
      if (_n___7 < _w___7) {
#line 1008
        tmp___25 = _w___7;
      } else {
#line 1008
        tmp___25 = _n___7;
      }
#line 1008
      _incr___7 = tmp___25;
#line 1008
      if (_incr___7 >= maxsize - i) {
#line 1008
        return ((size_t )0);
      }
#line 1008
      if (p) {
#line 1008
        if (digits == 0) {
#line 1008
          if (_n___7 < _w___7) {
#line 1008
            _delta___7 = (size_t )width - _n___7;
#line 1008
            if (pad == 48) {
#line 1008
              while (1) {
#line 1008
                _i___17 = (size_t )0;
#line 1008
                while (_i___17 < _delta___7) {
#line 1008
                  fputc('0', p);
#line 1008
                  _i___17 ++;
                }
#line 1008
                break;
              }
            } else {
#line 1008
              while (1) {
#line 1008
                _i___18 = (size_t )0;
#line 1008
                while (_i___18 < _delta___7) {
#line 1008
                  fputc(' ', p);
#line 1008
                  _i___18 ++;
                }
#line 1008
                break;
              }
            }
          }
        }
#line 1008
        while (1) {
#line 1008
          if (to_lowcase) {
#line 1008
            fwrite_lowcase(p, (char const   *)bufp, _n___7);
          } else
#line 1008
          if (to_uppcase) {
#line 1008
            fwrite_uppcase(p, (char const   *)bufp, _n___7);
          } else {
#line 1008
            tmp___26 = rpl_fwrite((void const   *)bufp, _n___7, (size_t )1, p);
#line 1008
            __x___0 = tmp___26;
          }
#line 1008
          break;
        }
      }
#line 1008
      i += _incr___7;
#line 1008
      break;
    }
#line 1009
    break;
    case 70: 
#line 1012
    if (modifier != 0) {
#line 1013
      goto bad_format;
    }
#line 1014
    subfmt = "%Y-%m-%d";
#line 1015
    goto subformat;
    case 72: 
#line 1018
    if (modifier == 69) {
#line 1019
      goto bad_format;
    }
#line 1021
    digits = 2;
#line 1021
    number_value = (int )tp->tm_hour;
#line 1021
    goto do_number;
    case 73: 
#line 1024
    if (modifier == 69) {
#line 1025
      goto bad_format;
    }
#line 1027
    digits = 2;
#line 1027
    number_value = hour12;
#line 1027
    goto do_number;
    case 107: 
#line 1030
    if (modifier == 69) {
#line 1031
      goto bad_format;
    }
#line 1033
    digits = 2;
#line 1033
    number_value = (int )tp->tm_hour;
#line 1033
    goto do_number_spacepad;
    case 108: 
#line 1036
    if (modifier == 69) {
#line 1037
      goto bad_format;
    }
#line 1039
    digits = 2;
#line 1039
    number_value = hour12;
#line 1039
    goto do_number_spacepad;
    case 106: 
#line 1042
    if (modifier == 69) {
#line 1043
      goto bad_format;
    }
#line 1045
    digits = 3;
#line 1045
    negative_number = (_Bool )(tp->tm_yday < -1);
#line 1045
    u_number_value = (unsigned int )tp->tm_yday + 1U;
#line 1045
    goto do_signed_number;
    case 77: 
#line 1048
    if (modifier == 69) {
#line 1049
      goto bad_format;
    }
#line 1051
    digits = 2;
#line 1051
    number_value = (int )tp->tm_min;
#line 1051
    goto do_number;
    case 109: 
#line 1054
    if (modifier == 69) {
#line 1055
      goto bad_format;
    }
#line 1057
    digits = 2;
#line 1057
    negative_number = (_Bool )(tp->tm_mon < -1);
#line 1057
    u_number_value = (unsigned int )tp->tm_mon + 1U;
#line 1057
    goto do_signed_number;
    case 78: 
#line 1061
    if (modifier == 69) {
#line 1062
      goto bad_format;
    }
#line 1064
    number_value = ns;
#line 1065
    if (width == -1) {
#line 1066
      width = 9;
    } else {
#line 1071
      j = width;
#line 1071
      while (j < 9) {
#line 1072
        number_value /= 10;
#line 1071
        j ++;
      }
    }
#line 1075
    digits = width;
#line 1075
    number_value = number_value;
#line 1075
    goto do_number;
    case 110: 
#line 1079
    while (1) {
#line 1079
      _n___8 = (size_t )1;
#line 1079
      if (width < 0) {
#line 1079
        tmp___27 = 0;
      } else {
#line 1079
        tmp___27 = width;
      }
#line 1079
      _w___8 = (size_t )tmp___27;
#line 1079
      if (_n___8 < _w___8) {
#line 1079
        tmp___28 = _w___8;
      } else {
#line 1079
        tmp___28 = _n___8;
      }
#line 1079
      _incr___8 = tmp___28;
#line 1079
      if (_incr___8 >= maxsize - i) {
#line 1079
        return ((size_t )0);
      }
#line 1079
      if (p) {
#line 1079
        if (digits == 0) {
#line 1079
          if (_n___8 < _w___8) {
#line 1079
            _delta___8 = (size_t )width - _n___8;
#line 1079
            if (pad == 48) {
#line 1079
              while (1) {
#line 1079
                _i___19 = (size_t )0;
#line 1079
                while (_i___19 < _delta___8) {
#line 1079
                  fputc('0', p);
#line 1079
                  _i___19 ++;
                }
#line 1079
                break;
              }
            } else {
#line 1079
              while (1) {
#line 1079
                _i___20 = (size_t )0;
#line 1079
                while (_i___20 < _delta___8) {
#line 1079
                  fputc(' ', p);
#line 1079
                  _i___20 ++;
                }
#line 1079
                break;
              }
            }
          }
        }
#line 1079
        fputc('\n', p);
      }
#line 1079
      i += _incr___8;
#line 1079
      break;
    }
#line 1080
    break;
    case 80: 
#line 1083
    to_lowcase = (_Bool)1;
#line 1085
    format_char = 'p';
    case 112: 
#line 1090
    if (change_case) {
#line 1092
      to_uppcase = (_Bool)0;
#line 1093
      to_lowcase = (_Bool)1;
    }
#line 1099
    goto underlying_strftime;
    case 82: 
#line 1103
    subfmt = "%H:%M";
#line 1104
    goto subformat;
    case 114: 
#line 1114
    goto underlying_strftime;
    case 83: 
#line 1118
    if (modifier == 69) {
#line 1119
      goto bad_format;
    }
#line 1121
    digits = 2;
#line 1121
    number_value = (int )tp->tm_sec;
#line 1121
    goto do_number;
    case 115: 
#line 1128
    ltm = (struct tm )*tp;
#line 1129
    t = mktime(& ltm);
#line 1134
    bufp = buf___1 + sizeof(buf___1) / sizeof(buf___1[0]);
#line 1135
    negative_number = (_Bool )(t < 0L);
#line 1137
    while (1) {
#line 1139
      d = (int )(t % 10L);
#line 1140
      t /= 10L;
#line 1141
      bufp --;
#line 1141
      if (negative_number) {
#line 1141
        tmp___29 = - d;
      } else {
#line 1141
        tmp___29 = d;
      }
#line 1141
      *bufp = (char )(tmp___29 + 48);
#line 1137
      if (! (t != 0L)) {
#line 1137
        break;
      }
    }
#line 1145
    digits = 1;
#line 1146
    always_output_a_sign = (_Bool)0;
#line 1147
    goto do_number_sign_and_padding;
    case 88: 
#line 1151
    if (modifier == 79) {
#line 1152
      goto bad_format;
    }
#line 1161
    goto underlying_strftime;
    case 84: 
#line 1164
    subfmt = "%H:%M:%S";
#line 1165
    goto subformat;
    case 116: 
#line 1168
    while (1) {
#line 1168
      _n___9 = (size_t )1;
#line 1168
      if (width < 0) {
#line 1168
        tmp___30 = 0;
      } else {
#line 1168
        tmp___30 = width;
      }
#line 1168
      _w___9 = (size_t )tmp___30;
#line 1168
      if (_n___9 < _w___9) {
#line 1168
        tmp___31 = _w___9;
      } else {
#line 1168
        tmp___31 = _n___9;
      }
#line 1168
      _incr___9 = tmp___31;
#line 1168
      if (_incr___9 >= maxsize - i) {
#line 1168
        return ((size_t )0);
      }
#line 1168
      if (p) {
#line 1168
        if (digits == 0) {
#line 1168
          if (_n___9 < _w___9) {
#line 1168
            _delta___9 = (size_t )width - _n___9;
#line 1168
            if (pad == 48) {
#line 1168
              while (1) {
#line 1168
                _i___21 = (size_t )0;
#line 1168
                while (_i___21 < _delta___9) {
#line 1168
                  fputc('0', p);
#line 1168
                  _i___21 ++;
                }
#line 1168
                break;
              }
            } else {
#line 1168
              while (1) {
#line 1168
                _i___22 = (size_t )0;
#line 1168
                while (_i___22 < _delta___9) {
#line 1168
                  fputc(' ', p);
#line 1168
                  _i___22 ++;
                }
#line 1168
                break;
              }
            }
          }
        }
#line 1168
        fputc('\t', p);
      }
#line 1168
      i += _incr___9;
#line 1168
      break;
    }
#line 1169
    break;
    case 117: 
#line 1172
    digits = 1;
#line 1172
    number_value = (int )(((tp->tm_wday - 1) + 7) % 7 + 1);
#line 1172
    goto do_number;
    case 85: 
#line 1175
    if (modifier == 69) {
#line 1176
      goto bad_format;
    }
#line 1178
    digits = 2;
#line 1178
    number_value = (int )(((tp->tm_yday - tp->tm_wday) + 7) / 7);
#line 1178
    goto do_number;
    case 86: 
    case 103: 
    case 71: 
#line 1183
    if (modifier == 69) {
#line 1184
      goto bad_format;
    }
#line 1190
    if (tp->tm_year < 0) {
#line 1190
      tmp___32 = 300;
    } else {
#line 1190
      tmp___32 = -100;
    }
#line 1190
    year___0 = (int )(tp->tm_year + (int const   )tmp___32);
#line 1194
    year_adjust = 0;
#line 1195
    tmp___33 = iso_week_days((int )tp->tm_yday, (int )tp->tm_wday);
#line 1195
    days = tmp___33;
#line 1197
    if (days < 0) {
#line 1200
      year_adjust = -1;
#line 1201
      if ((year___0 - 1) % 4 == 0) {
#line 1201
        if ((year___0 - 1) % 100 != 0) {
#line 1201
          tmp___34 = 1;
        } else
#line 1201
        if ((year___0 - 1) % 400 == 0) {
#line 1201
          tmp___34 = 1;
        } else {
#line 1201
          tmp___34 = 0;
        }
      } else {
#line 1201
        tmp___34 = 0;
      }
#line 1201
      days = iso_week_days((int )(tp->tm_yday + (int const   )(365 + tmp___34)), (int )tp->tm_wday);
    } else {
#line 1206
      if (year___0 % 4 == 0) {
#line 1206
        if (year___0 % 100 != 0) {
#line 1206
          tmp___35 = 1;
        } else
#line 1206
        if (year___0 % 400 == 0) {
#line 1206
          tmp___35 = 1;
        } else {
#line 1206
          tmp___35 = 0;
        }
      } else {
#line 1206
        tmp___35 = 0;
      }
#line 1206
      tmp___36 = iso_week_days((int )(tp->tm_yday - (int const   )(365 + tmp___35)),
                               (int )tp->tm_wday);
#line 1206
      d___0 = tmp___36;
#line 1208
      if (0 <= d___0) {
#line 1211
        year_adjust = 1;
#line 1212
        days = d___0;
      }
    }
#line 1216
    switch ((int )*f) {
    case 103: 
#line 1220
    yy = (int )((tp->tm_year % 100 + (int const   )year_adjust) % 100);
#line 1221
    digits = 2;
#line 1221
    if (0 <= yy) {
#line 1221
      number_value = yy;
    } else {
#line 1221
      if (tp->tm_year < (int const   )(-1900 - year_adjust)) {
#line 1221
        tmp___37 = - yy;
      } else {
#line 1221
        tmp___37 = yy + 100;
      }
#line 1221
      number_value = tmp___37;
    }
#line 1221
    goto do_number;
    case 71: 
#line 1229
    digits = 4;
#line 1229
    negative_number = (_Bool )(tp->tm_year < (int const   )(-1900 - year_adjust));
#line 1229
    u_number_value = ((unsigned int )tp->tm_year + 1900U) + (unsigned int )year_adjust;
#line 1229
    goto do_signed_number;
    default: 
#line 1234
    digits = 2;
#line 1234
    number_value = days / 7 + 1;
#line 1234
    goto do_number;
    }
    case 87: 
#line 1239
    if (modifier == 69) {
#line 1240
      goto bad_format;
    }
#line 1242
    digits = 2;
#line 1242
    number_value = (int )(((tp->tm_yday - ((tp->tm_wday - 1) + 7) % 7) + 7) / 7);
#line 1242
    goto do_number;
    case 119: 
#line 1245
    if (modifier == 69) {
#line 1246
      goto bad_format;
    }
#line 1248
    digits = 1;
#line 1248
    number_value = (int )tp->tm_wday;
#line 1248
    goto do_number;
    case 89: 
#line 1251
    if (modifier == 69) {
#line 1265
      goto underlying_strftime;
    }
#line 1268
    if (modifier == 79) {
#line 1269
      goto bad_format;
    } else {
#line 1271
      digits = 4;
    }
#line 1271
    negative_number = (_Bool )(tp->tm_year < -1900);
#line 1271
    u_number_value = (unsigned int )tp->tm_year + 1900U;
#line 1271
    goto do_signed_number;
    case 121: 
#line 1275
    if (modifier == 69) {
#line 1286
      goto underlying_strftime;
    }
#line 1291
    yy___0 = (int )(tp->tm_year % 100);
#line 1292
    if (yy___0 < 0) {
#line 1293
      if (tp->tm_year < -1900) {
#line 1293
        yy___0 = - yy___0;
      } else {
#line 1293
        yy___0 += 100;
      }
    }
#line 1294
    digits = 2;
#line 1294
    number_value = yy___0;
#line 1294
    goto do_number;
    case 90: 
#line 1298
    if (change_case) {
#line 1300
      to_uppcase = (_Bool)0;
#line 1301
      to_lowcase = (_Bool)1;
    }
#line 1309
    if (! zone) {
#line 1310
      zone = "";
    }
#line 1322
    while (1) {
#line 1322
      tmp___38 = strlen(zone);
#line 1322
      _n___10 = tmp___38;
#line 1322
      if (width < 0) {
#line 1322
        tmp___39 = 0;
      } else {
#line 1322
        tmp___39 = width;
      }
#line 1322
      _w___10 = (size_t )tmp___39;
#line 1322
      if (_n___10 < _w___10) {
#line 1322
        tmp___40 = _w___10;
      } else {
#line 1322
        tmp___40 = _n___10;
      }
#line 1322
      _incr___10 = tmp___40;
#line 1322
      if (_incr___10 >= maxsize - i) {
#line 1322
        return ((size_t )0);
      }
#line 1322
      if (p) {
#line 1322
        if (digits == 0) {
#line 1322
          if (_n___10 < _w___10) {
#line 1322
            _delta___10 = (size_t )width - _n___10;
#line 1322
            if (pad == 48) {
#line 1322
              while (1) {
#line 1322
                _i___23 = (size_t )0;
#line 1322
                while (_i___23 < _delta___10) {
#line 1322
                  fputc('0', p);
#line 1322
                  _i___23 ++;
                }
#line 1322
                break;
              }
            } else {
#line 1322
              while (1) {
#line 1322
                _i___24 = (size_t )0;
#line 1322
                while (_i___24 < _delta___10) {
#line 1322
                  fputc(' ', p);
#line 1322
                  _i___24 ++;
                }
#line 1322
                break;
              }
            }
          }
        }
#line 1322
        while (1) {
#line 1322
          if (to_lowcase) {
#line 1322
            fwrite_lowcase(p, zone, _n___10);
          } else
#line 1322
          if (to_uppcase) {
#line 1322
            fwrite_uppcase(p, zone, _n___10);
          } else {
#line 1322
            tmp___41 = rpl_fwrite((void const   *)zone, _n___10, (size_t )1, p);
#line 1322
            __x___1 = tmp___41;
          }
#line 1322
          break;
        }
      }
#line 1322
      i += _incr___10;
#line 1322
      break;
    }
#line 1324
    break;
    case 58: 
#line 1329
    colons = (size_t )1;
#line 1329
    while ((int const   )*(f + colons) == 58) {
#line 1330
      goto __Cont___0;
      __Cont___0: 
#line 1329
      colons ++;
    }
#line 1331
    if ((int const   )*(f + colons) != 122) {
#line 1332
      goto bad_format;
    }
#line 1333
    f += colons;
#line 1334
    goto do_z_conversion;
    case 122: 
#line 1337
    colons = (size_t )0;
    do_z_conversion: 
#line 1340
    if (tp->tm_isdst < 0) {
#line 1341
      break;
    }
#line 1349
    diff = (int )tp->tm_gmtoff;
#line 1386
    hour_diff = (diff / 60) / 60;
#line 1387
    min_diff = (diff / 60) % 60;
#line 1388
    sec_diff = diff % 60;
#line 1390
    switch ((int )colons) {
    case 0: 
#line 1393
    digits = 5;
#line 1393
    negative_number = (_Bool )(diff < 0);
#line 1393
    tz_colon_mask = 0;
#line 1393
    u_number_value = (unsigned int )(hour_diff * 100 + min_diff);
#line 1393
    goto do_tz_offset;
    tz_hh_mm: 
    case 1: 
#line 1396
    digits = 6;
#line 1396
    negative_number = (_Bool )(diff < 0);
#line 1396
    tz_colon_mask = 4;
#line 1396
    u_number_value = (unsigned int )(hour_diff * 100 + min_diff);
#line 1396
    goto do_tz_offset;
    tz_hh_mm_ss: 
    case 2: 
#line 1399
    digits = 9;
#line 1399
    negative_number = (_Bool )(diff < 0);
#line 1399
    tz_colon_mask = 20;
#line 1399
    u_number_value = (unsigned int )((hour_diff * 10000 + min_diff * 100) + sec_diff);
#line 1399
    goto do_tz_offset;
    case 3: 
#line 1403
    if (sec_diff != 0) {
#line 1404
      goto tz_hh_mm_ss;
    }
#line 1405
    if (min_diff != 0) {
#line 1406
      goto tz_hh_mm;
    }
#line 1407
    digits = 3;
#line 1407
    negative_number = (_Bool )(diff < 0);
#line 1407
    tz_colon_mask = 0;
#line 1407
    u_number_value = (unsigned int )hour_diff;
#line 1407
    goto do_tz_offset;
    default: 
#line 1410
    goto bad_format;
    }
    case 0: 
#line 1415
    f --;
    bad_format: 
    default: 
#line 1424
    flen = 1;
#line 1424
    while ((int const   )*(f + (1 - flen)) != 37) {
#line 1425
      goto __Cont___1;
      __Cont___1: 
#line 1424
      flen ++;
    }
#line 1426
    while (1) {
#line 1426
      _n___11 = (size_t )flen;
#line 1426
      if (width < 0) {
#line 1426
        tmp___42 = 0;
      } else {
#line 1426
        tmp___42 = width;
      }
#line 1426
      _w___11 = (size_t )tmp___42;
#line 1426
      if (_n___11 < _w___11) {
#line 1426
        tmp___43 = _w___11;
      } else {
#line 1426
        tmp___43 = _n___11;
      }
#line 1426
      _incr___11 = tmp___43;
#line 1426
      if (_incr___11 >= maxsize - i) {
#line 1426
        return ((size_t )0);
      }
#line 1426
      if (p) {
#line 1426
        if (digits == 0) {
#line 1426
          if (_n___11 < _w___11) {
#line 1426
            _delta___11 = (size_t )width - _n___11;
#line 1426
            if (pad == 48) {
#line 1426
              while (1) {
#line 1426
                _i___25 = (size_t )0;
#line 1426
                while (_i___25 < _delta___11) {
#line 1426
                  fputc('0', p);
#line 1426
                  _i___25 ++;
                }
#line 1426
                break;
              }
            } else {
#line 1426
              while (1) {
#line 1426
                _i___26 = (size_t )0;
#line 1426
                while (_i___26 < _delta___11) {
#line 1426
                  fputc(' ', p);
#line 1426
                  _i___26 ++;
                }
#line 1426
                break;
              }
            }
          }
        }
#line 1426
        while (1) {
#line 1426
          if (to_lowcase) {
#line 1426
            fwrite_lowcase(p, f + (1 - flen), _n___11);
          } else
#line 1426
          if (to_uppcase) {
#line 1426
            fwrite_uppcase(p, f + (1 - flen), _n___11);
          } else {
#line 1426
            tmp___44 = rpl_fwrite((void const   *)(f + (1 - flen)), _n___11, (size_t )1,
                                  p);
#line 1426
            __x___2 = tmp___44;
          }
#line 1426
          break;
        }
      }
#line 1426
      i += _incr___11;
#line 1426
      break;
    }
#line 1428
    break;
    }
    __Cont: 
#line 509
    f ++;
  }
#line 1437
  return (i);
}
}
#line 1446 "strftime.c"
size_t fprintftime(FILE *s , char const   *format , struct tm  const  *tp , int ut ,
                   int ns ) 
{ size_t tmp ;

  {
#line 1451
  tmp = strftime_case_((_Bool)0, s, format, tp, ut, ns);
#line 1451
  return (tmp);
}
}
#line 1 "freadahead.o"
#pragma merger(0,"/tmp/cil-ztRb6z_d.i","-g,-O2")
#line 25 "freadahead.c"
size_t freadahead(FILE *fp ) 
{ int tmp ;

  {
#line 29
  if ((unsigned long )fp->_IO_write_ptr > (unsigned long )fp->_IO_write_base) {
#line 30
    return ((size_t )0);
  }
#line 31
  if (fp->_flags & 256) {
#line 31
    tmp = fp->_IO_save_end - fp->_IO_save_base;
  } else {
#line 31
    tmp = 0;
  }
#line 31
  return ((size_t )((fp->_IO_read_end - fp->_IO_read_ptr) + tmp));
}
}
#line 1 "freading.o"
#pragma merger(0,"/tmp/cil-zP5Aoosk.i","-g,-O2")
#line 1 "freadptr.o"
#pragma merger(0,"/tmp/cil-vDNMEXYj.i","-g,-O2")
#line 35 "freadptr.h"
char const   *freadptr(FILE *fp , size_t *sizep ) ;
#line 26 "freadptr.c"
char const   *freadptr(FILE *fp , size_t *sizep ) 
{ size_t size ;

  {
#line 33
  if ((unsigned long )fp->_IO_write_ptr > (unsigned long )fp->_IO_write_base) {
#line 34
    return ((char const   *)((void *)0));
  }
#line 35
  size = (size_t )(fp->_IO_read_end - fp->_IO_read_ptr);
#line 36
  if (size == 0UL) {
#line 37
    return ((char const   *)((void *)0));
  }
#line 38
  *sizep = size;
#line 39
  return ((char const   *)fp->_IO_read_ptr);
}
}
#line 1 "freadseek.o"
#pragma merger(0,"/tmp/cil-B5HvgpJq.i","-g,-O2")
#line 533 "/usr/include/stdio.h"
extern int fgetc(FILE *__stream ) ;
#line 823
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream )  __attribute__((__warn_unused_result__)) ;
#line 38 "freadseek.h"
int freadseek(FILE *fp , size_t offset ) ;
#line 331 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
#line 33 "freadseek.c"
__inline static void freadptrinc(FILE *fp , size_t increment ) 
{ 

  {
#line 38
  fp->_IO_read_ptr += increment;
#line 65
  return;
}
}
#line 67 "freadseek.c"
int freadseek(FILE *fp , size_t offset ) 
{ size_t total_buffered ;
  int fd ;
  size_t buffered ;
  size_t increment ;
  size_t tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char buf___1[4096] ;
  size_t count ;
  unsigned long tmp___3 ;
  size_t __attribute__((__artificial__))  tmp___4 ;
  __off_t tmp___5 ;
  int tmp___6 ;
  size_t __attribute__((__artificial__))  tmp___7 ;

  {
#line 73
  if (offset == 0UL) {
#line 74
    return (0);
  }
#line 78
  total_buffered = freadahead(fp);
#line 81
  while (total_buffered > 0UL) {
#line 85
    tmp___0 = freadptr(fp, & buffered);
#line 85
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 85
      if (buffered > 0UL) {
#line 87
        if (buffered < offset) {
#line 87
          tmp = buffered;
        } else {
#line 87
          tmp = offset;
        }
#line 87
        increment = tmp;
#line 89
        freadptrinc(fp, increment);
#line 90
        offset -= increment;
#line 91
        if (offset == 0UL) {
#line 92
          return (0);
        }
#line 93
        total_buffered -= increment;
#line 94
        if (total_buffered == 0UL) {
#line 95
          break;
        }
      }
    }
#line 99
    tmp___1 = fgetc(fp);
#line 99
    if (tmp___1 == -1) {
#line 100
      goto eof;
    }
#line 101
    offset --;
#line 102
    if (offset == 0UL) {
#line 103
      return (0);
    }
#line 104
    total_buffered --;
  }
#line 108
  fd = fileno(fp);
#line 109
  if (fd >= 0) {
#line 109
    tmp___5 = lseek(fd, (__off_t )0, 1);
#line 109
    if (tmp___5 >= 0L) {
#line 112
      tmp___2 = rpl_fseeko(fp, (off_t )offset, 1);
#line 112
      return (tmp___2);
    } else {
#line 109
      goto _L;
    }
  } else {
    _L: 
#line 120
    while (1) {
#line 122
      if (sizeof(buf___1) < offset) {
#line 122
        tmp___3 = sizeof(buf___1);
      } else {
#line 122
        tmp___3 = offset;
      }
#line 122
      count = tmp___3;
#line 123
      tmp___7 = (size_t __attribute__((__artificial__))  )fread((void * __restrict  )(buf___1),
                                                                (size_t )1, count,
                                                                (FILE * __restrict  )fp);
#line 123
      tmp___4 = tmp___7;
#line 123
      if (tmp___4 < (size_t __attribute__((__artificial__))  )count) {
#line 124
        goto eof;
      }
#line 125
      offset -= count;
#line 120
      if (! (offset > 0UL)) {
#line 120
        break;
      }
    }
#line 129
    return (0);
  }
  eof: 
#line 134
  tmp___6 = ferror(fp);
#line 134
  if (tmp___6) {
#line 135
    return (-1);
  } else {
#line 138
    return (0);
  }
}
}
#line 1 "freopen-safer.o"
#pragma merger(0,"/tmp/cil-lqbX4cDW.i","-g,-O2")
#line 275 "/usr/include/stdio.h"
extern FILE *freopen(char const   * __restrict  __filename , char const   * __restrict  __modes ,
                     FILE * __restrict  __stream )  __attribute__((__warn_unused_result__)) ;
#line 27 "stdio-safer.h"
FILE *freopen_safer(char const   *name , char const   *mode , FILE *f ) ;
#line 531 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 31 "freopen-safer.c"
static _Bool protect_fd(int fd ) 
{ int value ;
  int __attribute__((__artificial__))  tmp ;
  int *tmp___0 ;

  {
#line 34
  tmp = open("/dev/null", 0);
#line 34
  value = (int )tmp;
#line 35
  if (value != fd) {
#line 37
    if (0 <= value) {
#line 39
      close(value);
#line 40
      tmp___0 = __errno_location();
#line 40
      *tmp___0 = 9;
    }
#line 42
    return ((_Bool)0);
  }
#line 44
  return ((_Bool)1);
}
}
#line 53 "freopen-safer.c"
FILE *freopen_safer(char const   *name , char const   *mode , FILE *f ) 
{ _Bool protect_in ;
  _Bool protect_out ;
  _Bool protect_err ;
  int saved_errno ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;

  {
#line 62
  protect_in = (_Bool)0;
#line 63
  protect_out = (_Bool)0;
#line 64
  protect_err = (_Bool)0;
#line 67
  tmp = fileno(f);
#line 67
  switch (tmp) {
  default: 
#line 70
  tmp___0 = dup2(2, 2);
#line 70
  if (tmp___0 != 2) {
#line 71
    protect_err = (_Bool)1;
  }
  case 2: 
#line 74
  tmp___1 = dup2(1, 1);
#line 74
  if (tmp___1 != 1) {
#line 75
    protect_out = (_Bool)1;
  }
  case 1: 
#line 78
  tmp___2 = dup2(0, 0);
#line 78
  if (tmp___2 != 0) {
#line 79
    protect_in = (_Bool)1;
  }
  case 0: 
#line 83
  break;
  }
#line 85
  if (protect_in) {
#line 85
    tmp___5 = protect_fd(0);
#line 85
    if (tmp___5) {
#line 85
      goto _L___0;
    } else {
#line 86
      f = (FILE *)((void *)0);
    }
  } else
  _L___0: 
#line 87
  if (protect_out) {
#line 87
    tmp___4 = protect_fd(1);
#line 87
    if (tmp___4) {
#line 87
      goto _L;
    } else {
#line 88
      f = (FILE *)((void *)0);
    }
  } else
  _L: 
#line 89
  if (protect_err) {
#line 89
    tmp___3 = protect_fd(2);
#line 89
    if (tmp___3) {
#line 92
      f = freopen((char const   * __restrict  )name, (char const   * __restrict  )mode,
                  (FILE * __restrict  )f);
    } else {
#line 90
      f = (FILE *)((void *)0);
    }
  } else {
#line 92
    f = freopen((char const   * __restrict  )name, (char const   * __restrict  )mode,
                (FILE * __restrict  )f);
  }
#line 93
  tmp___6 = __errno_location();
#line 93
  saved_errno = *tmp___6;
#line 94
  if (protect_err) {
#line 95
    close(2);
  }
#line 96
  if (protect_out) {
#line 97
    close(1);
  }
#line 98
  if (protect_in) {
#line 99
    close(0);
  }
#line 100
  if (! f) {
#line 101
    tmp___7 = __errno_location();
#line 101
    *tmp___7 = saved_errno;
  }
#line 102
  return (f);
}
}
#line 1 "fseterr.o"
#pragma merger(0,"/tmp/cil-JDOXkos9.i","-g,-O2")
#line 30 "fseterr.h"
void fseterr(FILE *fp ) ;
#line 26 "fseterr.c"
void fseterr(FILE *fp ) 
{ 

  {
#line 33
  fp->_flags |= 32;
#line 76
  return;
}
}
#line 1 "ftoastr.o"
#pragma merger(0,"/tmp/cil-T_QGVLoq.i","-g,-O2")
#line 47 "ftoastr.h"
int ftoastr(char *buf___1 , size_t bufsize___0 , int flags , int width , float x ) ;
#line 173 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) float strtof(char const   * __restrict  __nptr ,
                                                  char ** __restrict  __endptr )  __attribute__((__warn_unused_result__,
__nonnull__(1))) ;
#line 99 "ftoastr.c"
int ftoastr(char *buf___1 , size_t bufsize___0 , int flags , int width , float x ) 
{ char format[sizeof("%-+ 0*.*Lg")] ;
  float abs_x ;
  float tmp ;
  int prec ;
  char *p ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int n ;
  int __attribute__((__artificial__))  tmp___5 ;
  float tmp___6 ;

  {
#line 111
  if (x < (float )0) {
#line 111
    tmp = - x;
  } else {
#line 111
    tmp = x;
  }
#line 111
  abs_x = tmp;
#line 114
  p = format;
#line 115
  tmp___0 = p;
#line 115
  p ++;
#line 115
  *tmp___0 = (char )'%';
#line 118
  *p = (char )'-';
#line 118
  p += (flags & 1) != 0;
#line 119
  *p = (char )'+';
#line 119
  p += (flags & 2) != 0;
#line 120
  *p = (char )' ';
#line 120
  p += (flags & 4) != 0;
#line 121
  *p = (char )'0';
#line 121
  p += (flags & 8) != 0;
#line 123
  tmp___1 = p;
#line 123
  p ++;
#line 123
  *tmp___1 = (char )'*';
#line 124
  tmp___2 = p;
#line 124
  p ++;
#line 124
  *tmp___2 = (char )'.';
#line 125
  tmp___3 = p;
#line 125
  p ++;
#line 125
  *tmp___3 = (char )'*';
#line 126
  *p = (char )'L';
#line 126
  p += 0;
#line 127
  tmp___4 = p;
#line 127
  p ++;
#line 127
  if (flags & 16) {
#line 127
    *tmp___4 = (char )'G';
  } else {
#line 127
    *tmp___4 = (char )'g';
  }
#line 128
  *p = (char )'\000';
#line 130
  if (abs_x < 1.17549435082228750797e-38F) {
#line 130
    prec = 1;
  } else {
#line 130
    prec = 6;
  }
#line 130
  while (1) {
#line 132
    tmp___5 = snprintf((char * __restrict  )buf___1, bufsize___0, (char const   * __restrict  )(format),
                       width, prec, (double )x);
#line 132
    n = (int )tmp___5;
#line 133
    if (n < 0) {
#line 136
      return (n);
    } else
#line 133
    if (9 <= prec) {
#line 136
      return (n);
    } else
#line 133
    if ((size_t )n < bufsize___0) {
#line 133
      tmp___6 = strtof((char const   * __restrict  )buf___1, (char ** __restrict  )((void *)0));
#line 133
      if (tmp___6 == x) {
#line 136
        return (n);
      }
    }
#line 130
    prec ++;
  }
}
}
#line 1 "full-read.o"
#pragma merger(0,"/tmp/cil-FIppj7wc.i","-g,-O2")
#line 24 "full-read.h"
size_t full_read(int fd , void *buf___1 , size_t count ) ;
#line 42 "safe-read.h"
size_t safe_read(int fd , void *buf___1 , size_t count ) ;
#line 57 "full-write.c"
size_t full_read(int fd , void *buf___1 , size_t count ) 
{ size_t total ;
  char *ptr ;
  size_t n_rw ;
  size_t tmp ;
  int *tmp___0 ;

  {
#line 60
  total = (size_t )0;
#line 61
  ptr = (char *)buf___1;
#line 63
  while (count > 0UL) {
#line 65
    tmp = safe_read(fd, (void *)ptr, count);
#line 65
    n_rw = tmp;
#line 66
    if (n_rw == 0xffffffffffffffffUL) {
#line 67
      break;
    }
#line 68
    if (n_rw == 0UL) {
#line 70
      tmp___0 = __errno_location();
#line 70
      *tmp___0 = 0;
#line 71
      break;
    }
#line 73
    total += n_rw;
#line 74
    ptr += n_rw;
#line 75
    count -= n_rw;
  }
#line 78
  return (total);
}
}
#line 1 "full-write.o"
#pragma merger(0,"/tmp/cil-G9SfYcZz.i","-g,-O2")
#line 29 "full-write.h"
size_t full_write(int fd , void const   *buf___1 , size_t count ) ;
#line 37 "safe-write.h"
size_t safe_write(int fd , void const   *buf___1 , size_t count ) ;
#line 57 "full-write.c"
size_t full_write(int fd , void const   *buf___1 , size_t count ) 
{ size_t total ;
  char const   *ptr ;
  size_t n_rw ;
  size_t tmp ;
  int *tmp___0 ;

  {
#line 60
  total = (size_t )0;
#line 61
  ptr = (char const   *)buf___1;
#line 63
  while (count > 0UL) {
#line 65
    tmp = safe_write(fd, (void const   *)ptr, count);
#line 65
    n_rw = tmp;
#line 66
    if (n_rw == 0xffffffffffffffffUL) {
#line 67
      break;
    }
#line 68
    if (n_rw == 0UL) {
#line 70
      tmp___0 = __errno_location();
#line 70
      *tmp___0 = 28;
#line 71
      break;
    }
#line 73
    total += n_rw;
#line 74
    ptr += n_rw;
#line 75
    count -= n_rw;
  }
#line 78
  return (total);
}
}
#line 1 "getndelim2.o"
#pragma merger(0,"/tmp/cil-J1SYbdhw.i","-g,-O2")
#line 38 "getndelim2.h"
ssize_t getndelim2(char **lineptr , size_t *linesize , size_t offset , size_t nmax ,
                   int delim1 , int delim2 , FILE *stream ) ;
#line 27 "memchr2.h"
void *memchr2(void const   *s , int c1_in , int c2_in , size_t n ) ;
#line 70 "getndelim2.c"
ssize_t getndelim2(char **lineptr , size_t *linesize , size_t offset , size_t nmax ,
                   int delim1 , int delim2 , FILE *stream ) 
{ size_t nbytes_avail ;
  char *read_pos ;
  ssize_t bytes_stored ;
  char *ptr ;
  size_t size ;
  _Bool found_delimiter ;
  void *tmp ;
  int c ;
  char const   *buffer ;
  size_t buffer_len ;
  char const   *end ;
  void *tmp___0 ;
  size_t newsize ;
  size_t tmp___1 ;
  char *newptr ;
  size_t newsizemax ;
  void *tmp___2 ;
  size_t copy_len ;
  int tmp___3 ;
  ssize_t tmp___4 ;

  {
#line 76
  bytes_stored = (ssize_t )-1;
#line 77
  ptr = *lineptr;
#line 78
  size = *linesize;
#line 81
  if (! ptr) {
#line 83
    if (nmax < 64UL) {
#line 83
      size = nmax;
    } else {
#line 83
      size = (size_t )64;
    }
#line 84
    tmp = malloc(size);
#line 84
    ptr = (char *)tmp;
#line 85
    if (! ptr) {
#line 86
      return ((ssize_t )-1);
    }
  }
#line 89
  if (size < offset) {
#line 90
    goto done;
  }
#line 92
  nbytes_avail = size - offset;
#line 93
  read_pos = ptr + offset;
#line 95
  if (nbytes_avail == 0UL) {
#line 95
    if (nmax <= size) {
#line 96
      goto done;
    }
  }
#line 99
  if (delim1 == -1) {
#line 100
    delim1 = delim2;
  } else
#line 101
  if (delim2 == -1) {
#line 102
    delim2 = delim1;
  }
#line 106
  found_delimiter = (_Bool)0;
#line 107
  while (1) {
#line 116
    buffer = freadptr(stream, & buffer_len);
#line 117
    if (buffer) {
#line 119
      if (delim1 != -1) {
#line 121
        tmp___0 = memchr2((void const   *)buffer, delim1, delim2, buffer_len);
#line 121
        end = (char const   *)tmp___0;
#line 122
        if (end) {
#line 124
          buffer_len = (size_t )((end - buffer) + 1);
#line 125
          found_delimiter = (_Bool)1;
        }
      }
    } else {
#line 131
      c = getc_unlocked(stream);
#line 132
      if (c == -1) {
#line 135
        if ((unsigned long )read_pos == (unsigned long )ptr) {
#line 136
          goto unlock_done;
        } else {
#line 138
          break;
        }
      }
#line 140
      if (c == delim1) {
#line 141
        found_delimiter = (_Bool)1;
      } else
#line 140
      if (c == delim2) {
#line 141
        found_delimiter = (_Bool)1;
      }
#line 142
      buffer_len = (size_t )1;
    }
#line 149
    if (nbytes_avail < buffer_len + 1UL) {
#line 149
      if (size < nmax) {
#line 153
        if (size < 64UL) {
#line 153
          tmp___1 = size + 64UL;
        } else {
#line 153
          tmp___1 = 2UL * size;
        }
#line 153
        newsize = tmp___1;
#line 158
        if (newsize - (size_t )(read_pos - ptr) < buffer_len + 1UL) {
#line 159
          newsize = ((size_t )(read_pos - ptr) + buffer_len) + 1UL;
        }
#line 161
        if (size < newsize) {
#line 161
          if (! (newsize <= nmax)) {
#line 162
            newsize = nmax;
          }
        } else {
#line 162
          newsize = nmax;
        }
#line 164
        if (9223372036854775807UL < newsize - offset) {
#line 166
          newsizemax = (offset + 9223372036854775807UL) + 1UL;
#line 167
          if (size == newsizemax) {
#line 168
            goto unlock_done;
          }
#line 169
          newsize = newsizemax;
        }
#line 172
        nbytes_avail = newsize - (size_t )(read_pos - ptr);
#line 173
        tmp___2 = realloc((void *)ptr, newsize);
#line 173
        newptr = (char *)tmp___2;
#line 174
        if (! newptr) {
#line 175
          goto unlock_done;
        }
#line 176
        ptr = newptr;
#line 177
        size = newsize;
#line 178
        read_pos = ptr + (size - nbytes_avail);
      }
    }
#line 184
    if (1UL < nbytes_avail) {
#line 186
      copy_len = nbytes_avail - 1UL;
#line 187
      if (buffer_len < copy_len) {
#line 188
        copy_len = buffer_len;
      }
#line 189
      if (buffer) {
#line 190
        memcpy((void * __restrict  )read_pos, (void const   * __restrict  )buffer,
               copy_len);
      } else {
#line 192
        *read_pos = (char )c;
      }
#line 193
      read_pos += copy_len;
#line 194
      nbytes_avail -= copy_len;
    }
#line 199
    if (buffer) {
#line 199
      tmp___3 = freadseek(stream, buffer_len);
#line 199
      if (tmp___3) {
#line 200
        goto unlock_done;
      }
    }
#line 107
    if (! (! found_delimiter)) {
#line 107
      break;
    }
  }
#line 206
  *read_pos = (char )'\000';
#line 208
  bytes_stored = (ssize_t )(read_pos - (ptr + offset));
  unlock_done: ;
  done: 
#line 214
  *lineptr = ptr;
#line 215
  *linesize = size;
#line 216
  if (bytes_stored) {
#line 216
    tmp___4 = bytes_stored;
  } else {
#line 216
    tmp___4 = (ssize_t )-1;
  }
#line 216
  return (tmp___4);
}
}
#line 1 "gettime.o"
#pragma merger(0,"/tmp/cil-ZqsGmBkR.i","-g,-O2")
#line 336 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) int clock_gettime(clockid_t __clock_id , struct timespec *__tp ) ;
#line 79 "timespec.h"
void gettime(struct timespec *ts ) ;
#line 73 "/usr/include/sys/time.h"
extern  __attribute__((__nothrow__)) int gettimeofday(struct timeval * __restrict  __tv ,
                                                      __timezone_ptr_t __tz )  __attribute__((__nonnull__(1))) ;
#line 28 "gettime.c"
void gettime(struct timespec *ts ) 
{ int tmp ;
  struct timeval tv ;

  {
#line 36
  tmp = clock_gettime(0, ts);
#line 36
  if (tmp == 0) {
#line 37
    return;
  }
#line 42
  gettimeofday((struct timeval * __restrict  )(& tv), (__timezone_ptr_t )((void *)0));
#line 43
  ts->tv_sec = tv.tv_sec;
#line 44
  ts->tv_nsec = tv.tv_usec * 1000L;
#line 48
  return;
}
}
#line 1 "getugroups.o"
#pragma merger(0,"/tmp/cil-WU8bhowZ.i","-g,-O2")
#line 18 "getugroups.h"
int getugroups(int maxcount , gid_t *grouplist , char const   *username , gid_t gid ) ;
#line 64 "/usr/include/grp.h"
extern void setgrent(void) ;
#line 73
extern void endgrent(void) ;
#line 79
extern struct group *getgrent(void) ;
#line 57 "getugroups.c"
int getugroups(int maxcount , gid_t *grouplist , char const   *username , gid_t gid ) 
{ int count ;
  char **cp ;
  struct group *grp ;
  int *tmp ;
  int n ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___1 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int saved_errno ;
  int *tmp___9 ;
  int *tmp___10 ;

  {
#line 61
  count = 0;
#line 63
  if (gid != 4294967295U) {
#line 65
    if (maxcount != 0) {
#line 66
      *(grouplist + count) = gid;
    }
#line 67
    count ++;
  }
#line 70
  setgrent();
#line 71
  while (1) {
#line 76
    tmp = __errno_location();
#line 76
    *tmp = 0;
#line 77
    grp = getgrent();
#line 78
    if ((unsigned long )grp == (unsigned long )((void *)0)) {
#line 79
      break;
    }
#line 81
    cp = grp->gr_mem;
#line 81
    while (*cp) {
#line 85
      if (0) {
#line 85
        __s1_len = __builtin_strlen(username);
#line 85
        __s2_len = __builtin_strlen((char const   *)*cp);
#line 85
        if (! ((size_t )((void const   *)(username + 1)) - (size_t )((void const   *)username) == 1UL)) {
#line 85
          goto _L___0;
        } else
#line 85
        if (__s1_len >= 4UL) {
          _L___0: 
#line 85
          if (! ((size_t )((void const   *)(*cp + 1)) - (size_t )((void const   *)*cp) == 1UL)) {
#line 85
            tmp___6 = 1;
          } else
#line 85
          if (__s2_len >= 4UL) {
#line 85
            tmp___6 = 1;
          } else {
#line 85
            tmp___6 = 0;
          }
        } else {
#line 85
          tmp___6 = 0;
        }
#line 85
        if (tmp___6) {
#line 85
          tmp___1 = __builtin_strcmp(username, (char const   *)*cp);
#line 85
          tmp___5 = tmp___1;
        } else {
#line 85
          tmp___4 = __builtin_strcmp(username, (char const   *)*cp);
#line 85
          tmp___5 = tmp___4;
        }
      } else {
#line 85
        tmp___4 = __builtin_strcmp(username, (char const   *)*cp);
#line 85
        tmp___5 = tmp___4;
      }
#line 85
      if (! (tmp___5 == 0)) {
#line 86
        goto __Cont;
      }
#line 89
      n = 0;
#line 89
      while (n < count) {
#line 90
        if (grouplist) {
#line 90
          if (*(grouplist + n) == grp->gr_gid) {
#line 91
            break;
          }
        }
#line 89
        n ++;
      }
#line 94
      if (n == count) {
#line 96
        if (maxcount != 0) {
#line 98
          if (count >= maxcount) {
#line 99
            goto done;
          }
#line 100
          *(grouplist + count) = grp->gr_gid;
        }
#line 102
        if (count == 2147483647) {
#line 104
          tmp___7 = __errno_location();
#line 104
          *tmp___7 = 75;
#line 105
          goto done;
        }
#line 107
        count ++;
      }
      __Cont: 
#line 81
      cp ++;
    }
  }
#line 112
  tmp___8 = __errno_location();
#line 112
  if (*tmp___8 != 0) {
#line 113
    count = -1;
  }
  done: 
#line 117
  tmp___9 = __errno_location();
#line 117
  saved_errno = *tmp___9;
#line 118
  endgrent();
#line 119
  tmp___10 = __errno_location();
#line 119
  *tmp___10 = saved_errno;
#line 122
  return (count);
}
}
#line 1 "hard-locale.o"
#pragma merger(0,"/tmp/cil-2AJ0O4fs.i","-g,-O2")
#line 23 "hard-locale.h"
_Bool hard_locale(int category ) ;
#line 125 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *setlocale(int __category , char const   *__locale ) ;
#line 37 "hard-locale.c"
_Bool hard_locale(int category ) 
{ _Bool hard ;
  char const   *p ;
  char *tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___1 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char *locale ;
  char *tmp___19 ;
  char *tmp___20 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___22 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  char *tmp___28 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___30 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;

  {
#line 40
  hard = (_Bool)1;
#line 41
  tmp = setlocale(category, (char const   *)((void *)0));
#line 41
  p = (char const   *)tmp;
#line 43
  if (p) {
#line 45
    if (1) {
#line 47
      if (0) {
#line 47
        __s1_len = __builtin_strlen(p);
#line 47
        __s2_len = __builtin_strlen("C");
#line 47
        if (! ((size_t )((void const   *)(p + 1)) - (size_t )((void const   *)p) == 1UL)) {
#line 47
          goto _L___0;
        } else
#line 47
        if (__s1_len >= 4UL) {
          _L___0: 
#line 47
          if (! ((size_t )((void const   *)("C" + 1)) - (size_t )((void const   *)"C") == 1UL)) {
#line 47
            tmp___6 = 1;
          } else
#line 47
          if (__s2_len >= 4UL) {
#line 47
            tmp___6 = 1;
          } else {
#line 47
            tmp___6 = 0;
          }
        } else {
#line 47
          tmp___6 = 0;
        }
#line 47
        if (tmp___6) {
#line 47
          tmp___1 = __builtin_strcmp(p, "C");
#line 47
          tmp___5 = tmp___1;
        } else {
#line 47
          tmp___4 = __builtin_strcmp(p, "C");
#line 47
          tmp___5 = tmp___4;
        }
      } else {
#line 47
        tmp___4 = __builtin_strcmp(p, "C");
#line 47
        tmp___5 = tmp___4;
      }
#line 47
      if (tmp___5 == 0) {
#line 48
        hard = (_Bool)0;
      } else {
#line 47
        if (0) {
#line 47
          __s1_len___0 = __builtin_strlen(p);
#line 47
          __s2_len___0 = __builtin_strlen("POSIX");
#line 47
          if (! ((size_t )((void const   *)(p + 1)) - (size_t )((void const   *)p) == 1UL)) {
#line 47
            goto _L___2;
          } else
#line 47
          if (__s1_len___0 >= 4UL) {
            _L___2: 
#line 47
            if (! ((size_t )((void const   *)("POSIX" + 1)) - (size_t )((void const   *)"POSIX") == 1UL)) {
#line 47
              tmp___13 = 1;
            } else
#line 47
            if (__s2_len___0 >= 4UL) {
#line 47
              tmp___13 = 1;
            } else {
#line 47
              tmp___13 = 0;
            }
          } else {
#line 47
            tmp___13 = 0;
          }
#line 47
          if (tmp___13) {
#line 47
            tmp___8 = __builtin_strcmp(p, "POSIX");
#line 47
            tmp___12 = tmp___8;
          } else {
#line 47
            tmp___11 = __builtin_strcmp(p, "POSIX");
#line 47
            tmp___12 = tmp___11;
          }
        } else {
#line 47
          tmp___11 = __builtin_strcmp(p, "POSIX");
#line 47
          tmp___12 = tmp___11;
        }
#line 47
        if (tmp___12 == 0) {
#line 48
          hard = (_Bool)0;
        }
      }
    } else {
#line 52
      tmp___19 = __strdup(p);
#line 52
      locale = tmp___19;
#line 53
      if (locale) {
#line 58
        tmp___20 = setlocale(category, "C");
#line 58
        p = (char const   *)tmp___20;
#line 61
        if (p) {
#line 59
          if (0) {
#line 59
            __s1_len___1 = __builtin_strlen(p);
#line 59
            __s2_len___1 = __builtin_strlen((char const   *)locale);
#line 59
            if (! ((size_t )((void const   *)(p + 1)) - (size_t )((void const   *)p) == 1UL)) {
#line 59
              goto _L___4;
            } else
#line 59
            if (__s1_len___1 >= 4UL) {
              _L___4: 
#line 59
              if (! ((size_t )((void const   *)(locale + 1)) - (size_t )((void const   *)locale) == 1UL)) {
#line 59
                tmp___27 = 1;
              } else
#line 59
              if (__s2_len___1 >= 4UL) {
#line 59
                tmp___27 = 1;
              } else {
#line 59
                tmp___27 = 0;
              }
            } else {
#line 59
              tmp___27 = 0;
            }
#line 59
            if (tmp___27) {
#line 59
              tmp___22 = __builtin_strcmp(p, (char const   *)locale);
#line 59
              tmp___26 = tmp___22;
            } else {
#line 59
              tmp___25 = __builtin_strcmp(p, (char const   *)locale);
#line 59
              tmp___26 = tmp___25;
            }
          } else {
#line 59
            tmp___25 = __builtin_strcmp(p, (char const   *)locale);
#line 59
            tmp___26 = tmp___25;
          }
#line 61
          if (tmp___26 == 0) {
#line 62
            hard = (_Bool)0;
          } else {
#line 61
            goto _L___7;
          }
        } else {
          _L___7: 
#line 59
          tmp___28 = setlocale(category, "POSIX");
#line 59
          p = (char const   *)tmp___28;
#line 61
          if (p) {
#line 61
            if (0) {
#line 61
              __s1_len___2 = __builtin_strlen(p);
#line 61
              __s2_len___2 = __builtin_strlen((char const   *)locale);
#line 61
              if (! ((size_t )((void const   *)(p + 1)) - (size_t )((void const   *)p) == 1UL)) {
#line 61
                goto _L___6;
              } else
#line 61
              if (__s1_len___2 >= 4UL) {
                _L___6: 
#line 61
                if (! ((size_t )((void const   *)(locale + 1)) - (size_t )((void const   *)locale) == 1UL)) {
#line 61
                  tmp___35 = 1;
                } else
#line 61
                if (__s2_len___2 >= 4UL) {
#line 61
                  tmp___35 = 1;
                } else {
#line 61
                  tmp___35 = 0;
                }
              } else {
#line 61
                tmp___35 = 0;
              }
#line 61
              if (tmp___35) {
#line 61
                tmp___30 = __builtin_strcmp(p, (char const   *)locale);
#line 61
                tmp___34 = tmp___30;
              } else {
#line 61
                tmp___33 = __builtin_strcmp(p, (char const   *)locale);
#line 61
                tmp___34 = tmp___33;
              }
            } else {
#line 61
              tmp___33 = __builtin_strcmp(p, (char const   *)locale);
#line 61
              tmp___34 = tmp___33;
            }
#line 61
            if (tmp___34 == 0) {
#line 62
              hard = (_Bool)0;
            }
          }
        }
#line 65
        setlocale(category, (char const   *)locale);
#line 66
        free((void *)locale);
      }
    }
  }
#line 71
  return (hard);
}
}
#line 1 "hash.o"
#pragma merger(0,"/tmp/cil-0YyoiNqN.i","-g,-O2")
#line 62 "hash.h"
size_t hash_get_n_buckets(Hash_table const   *table___0 ) ;
#line 63
size_t hash_get_n_buckets_used(Hash_table const   *table___0 ) ;
#line 64
size_t hash_get_n_entries(Hash_table const   *table___0 ) ;
#line 65
size_t hash_get_max_bucket_length(Hash_table const   *table___0 ) ;
#line 66
_Bool hash_table_ok(Hash_table const   *table___0 ) ;
#line 67
void hash_print_statistics(Hash_table const   *table___0 , FILE *stream ) ;
#line 71
void *hash_get_first(Hash_table const   *table___0 ) ;
#line 72
void *hash_get_next(Hash_table const   *table___0 , void const   *entry ) ;
#line 73
size_t hash_get_entries(Hash_table const   *table___0 , void **buffer , size_t buffer_size ) ;
#line 74
size_t hash_do_for_each(Hash_table const   *table___0 , _Bool (*processor)(void * ,
                                                                           void * ) ,
                        void *processor_data ) ;
#line 78
void hash_reset_tuning(Hash_tuning *tuning ) ;
#line 82
void hash_clear(Hash_table *table___0 ) ;
#line 86
_Bool hash_rehash(Hash_table *table___0 , size_t candidate )  __attribute__((__warn_unused_result__)) ;
#line 90
void *hash_delete(Hash_table *table___0 , void const   *entry ) ;
#line 76 "bitrotate.h"
__inline static size_t rotr_sz(size_t x , int n ) 
{ 

  {
#line 79
  return (((x >> n) | (x << (8UL * sizeof(x) - (unsigned long )n))) & 0xffffffffffffffffUL);
}
}
#line 473 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__warn_unused_result__,
__malloc__)) ;
#line 130 "hash.c"
static struct hash_tuning  const  default_tuning  =    {(float )0.0, (float )1.0, (float )0.8, (float )1.414, (_Bool)0};
#line 149 "hash.c"
size_t hash_get_n_buckets(Hash_table const   *table___0 ) 
{ 

  {
#line 152
  return ((size_t )table___0->n_buckets);
}
}
#line 157 "hash.c"
size_t hash_get_n_buckets_used(Hash_table const   *table___0 ) 
{ 

  {
#line 160
  return ((size_t )table___0->n_buckets_used);
}
}
#line 165 "hash.c"
size_t hash_get_n_entries(Hash_table const   *table___0 ) 
{ 

  {
#line 168
  return ((size_t )table___0->n_entries);
}
}
#line 173 "hash.c"
size_t hash_get_max_bucket_length(Hash_table const   *table___0 ) 
{ struct hash_entry  const  *bucket ;
  size_t max_bucket_length ;
  struct hash_entry  const  *cursor ;
  size_t bucket_length ;

  {
#line 177
  max_bucket_length = (size_t )0;
#line 179
  bucket = (struct hash_entry  const  *)table___0->bucket;
#line 179
  while ((unsigned long )bucket < (unsigned long )table___0->bucket_limit) {
#line 181
    if (bucket->data) {
#line 183
      cursor = bucket;
#line 184
      bucket_length = (size_t )1;
#line 186
      while (1) {
#line 186
        cursor = (struct hash_entry  const  *)cursor->next;
#line 186
        if (! cursor) {
#line 186
          break;
        }
#line 187
        bucket_length ++;
      }
#line 189
      if (bucket_length > max_bucket_length) {
#line 190
        max_bucket_length = bucket_length;
      }
    }
#line 179
    bucket ++;
  }
#line 194
  return (max_bucket_length);
}
}
#line 200 "hash.c"
_Bool hash_table_ok(Hash_table const   *table___0 ) 
{ struct hash_entry  const  *bucket ;
  size_t n_buckets_used ;
  size_t n_entries ;
  struct hash_entry  const  *cursor ;

  {
#line 204
  n_buckets_used = (size_t )0;
#line 205
  n_entries = (size_t )0;
#line 207
  bucket = (struct hash_entry  const  *)table___0->bucket;
#line 207
  while ((unsigned long )bucket < (unsigned long )table___0->bucket_limit) {
#line 209
    if (bucket->data) {
#line 211
      cursor = bucket;
#line 214
      n_buckets_used ++;
#line 215
      n_entries ++;
#line 218
      while (1) {
#line 218
        cursor = (struct hash_entry  const  *)cursor->next;
#line 218
        if (! cursor) {
#line 218
          break;
        }
#line 219
        n_entries ++;
      }
    }
#line 207
    bucket ++;
  }
#line 223
  if (n_buckets_used == (size_t )table___0->n_buckets_used) {
#line 223
    if (n_entries == (size_t )table___0->n_entries) {
#line 224
      return ((_Bool)1);
    }
  }
#line 226
  return ((_Bool)0);
}
}
#line 229 "hash.c"
void hash_print_statistics(Hash_table const   *table___0 , FILE *stream ) 
{ size_t n_entries ;
  size_t tmp ;
  size_t n_buckets ;
  size_t tmp___0 ;
  size_t n_buckets_used ;
  size_t tmp___1 ;
  size_t max_bucket_length ;
  size_t tmp___2 ;

  {
#line 232
  tmp = hash_get_n_entries(table___0);
#line 232
  n_entries = tmp;
#line 233
  tmp___0 = hash_get_n_buckets(table___0);
#line 233
  n_buckets = tmp___0;
#line 234
  tmp___1 = hash_get_n_buckets_used(table___0);
#line 234
  n_buckets_used = tmp___1;
#line 235
  tmp___2 = hash_get_max_bucket_length(table___0);
#line 235
  max_bucket_length = tmp___2;
#line 237
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )"# entries:         %lu\n",
          n_entries);
#line 238
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )"# buckets:         %lu\n",
          n_buckets);
#line 239
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )"# buckets used:    %lu (%.2f%%)\n",
          n_buckets_used, (100.0 * (double )n_buckets_used) / (double )n_buckets);
#line 242
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )"max bucket length: %lu\n",
          max_bucket_length);
#line 244
  return;
}
}
#line 248 "hash.c"
static struct hash_entry *safe_hasher(Hash_table const   *table___0 , void const   *key ) 
{ size_t n ;
  size_t tmp ;

  {
#line 251
  tmp = (*(table___0->hasher))(key, (size_t )table___0->n_buckets);
#line 251
  n = tmp;
#line 252
  if (! (n < (size_t )table___0->n_buckets)) {
#line 253
    abort();
  }
#line 254
  return ((struct hash_entry *)(table___0->bucket + n));
}
}
#line 260 "hash.c"
void *hash_lookup(Hash_table const   *table___0 , void const   *entry ) 
{ struct hash_entry  const  *bucket ;
  struct hash_entry *tmp ;
  struct hash_entry  const  *cursor ;
  _Bool tmp___0 ;

  {
#line 263
  tmp = safe_hasher(table___0, entry);
#line 263
  bucket = (struct hash_entry  const  *)tmp;
#line 266
  if ((unsigned long )bucket->data == (unsigned long )((void *)0)) {
#line 267
    return ((void *)0);
  }
#line 269
  cursor = bucket;
#line 269
  while (cursor) {
#line 270
    if ((unsigned long )entry == (unsigned long )cursor->data) {
#line 271
      return ((void *)cursor->data);
    } else {
#line 270
      tmp___0 = (*(table___0->comparator))(entry, (void const   *)cursor->data);
#line 270
      if (tmp___0) {
#line 271
        return ((void *)cursor->data);
      }
    }
#line 269
    cursor = (struct hash_entry  const  *)cursor->next;
  }
#line 273
  return ((void *)0);
}
}
#line 287 "hash.c"
void *hash_get_first(Hash_table const   *table___0 ) 
{ struct hash_entry  const  *bucket ;

  {
#line 292
  if (table___0->n_entries == 0UL) {
#line 293
    return ((void *)0);
  }
#line 295
  bucket = (struct hash_entry  const  *)table___0->bucket;
#line 295
  while (1) {
#line 296
    if (! ((unsigned long )bucket < (unsigned long )table___0->bucket_limit)) {
#line 297
      abort();
    } else
#line 298
    if (bucket->data) {
#line 299
      return ((void *)bucket->data);
    }
#line 295
    bucket ++;
  }
}
}
#line 306 "hash.c"
void *hash_get_next(Hash_table const   *table___0 , void const   *entry ) 
{ struct hash_entry  const  *bucket ;
  struct hash_entry *tmp ;
  struct hash_entry  const  *cursor ;

  {
#line 309
  tmp = safe_hasher(table___0, entry);
#line 309
  bucket = (struct hash_entry  const  *)tmp;
#line 313
  cursor = bucket;
#line 314
  while (1) {
#line 316
    if ((unsigned long )cursor->data == (unsigned long )entry) {
#line 316
      if (cursor->next) {
#line 317
        return ((cursor->next)->data);
      }
    }
#line 318
    cursor = (struct hash_entry  const  *)cursor->next;
#line 314
    if (! ((unsigned long )cursor != (unsigned long )((void *)0))) {
#line 314
      break;
    }
  }
#line 323
  while (1) {
#line 323
    bucket ++;
#line 323
    if (! ((unsigned long )bucket < (unsigned long )table___0->bucket_limit)) {
#line 323
      break;
    }
#line 324
    if (bucket->data) {
#line 325
      return ((void *)bucket->data);
    }
  }
#line 328
  return ((void *)0);
}
}
#line 335 "hash.c"
size_t hash_get_entries(Hash_table const   *table___0 , void **buffer , size_t buffer_size ) 
{ size_t counter ;
  struct hash_entry  const  *bucket ;
  struct hash_entry  const  *cursor ;
  size_t tmp ;

  {
#line 339
  counter = (size_t )0;
#line 343
  bucket = (struct hash_entry  const  *)table___0->bucket;
#line 343
  while ((unsigned long )bucket < (unsigned long )table___0->bucket_limit) {
#line 345
    if (bucket->data) {
#line 347
      cursor = bucket;
#line 347
      while (cursor) {
#line 349
        if (counter >= buffer_size) {
#line 350
          return (counter);
        }
#line 351
        tmp = counter;
#line 351
        counter ++;
#line 351
        *(buffer + tmp) = (void *)cursor->data;
#line 347
        cursor = (struct hash_entry  const  *)cursor->next;
      }
    }
#line 343
    bucket ++;
  }
#line 356
  return (counter);
}
}
#line 367 "hash.c"
size_t hash_do_for_each(Hash_table const   *table___0 , _Bool (*processor)(void * ,
                                                                           void * ) ,
                        void *processor_data ) 
{ size_t counter ;
  struct hash_entry  const  *bucket ;
  struct hash_entry  const  *cursor ;
  _Bool tmp ;

  {
#line 371
  counter = (size_t )0;
#line 375
  bucket = (struct hash_entry  const  *)table___0->bucket;
#line 375
  while ((unsigned long )bucket < (unsigned long )table___0->bucket_limit) {
#line 377
    if (bucket->data) {
#line 379
      cursor = bucket;
#line 379
      while (cursor) {
#line 381
        tmp = (*processor)((void *)cursor->data, processor_data);
#line 381
        if (! tmp) {
#line 382
          return (counter);
        }
#line 383
        counter ++;
#line 379
        cursor = (struct hash_entry  const  *)cursor->next;
      }
    }
#line 375
    bucket ++;
  }
#line 388
  return (counter);
}
}
#line 427 "hash.c"
size_t hash_string(char const   *string , size_t n_buckets ) 
{ size_t value ;
  unsigned char ch ;

  {
#line 430
  value = (size_t )0;
#line 433
  while (1) {
#line 433
    ch = (unsigned char )*string;
#line 433
    if (! ch) {
#line 433
      break;
    }
#line 434
    value = (value * 31UL + (size_t )ch) % n_buckets;
#line 433
    string ++;
  }
#line 435
  return (value);
}
}
#line 443 "hash.c"
static _Bool is_prime(size_t candidate ) 
{ size_t divisor ;
  size_t square ;
  int tmp ;

  {
#line 446
  divisor = (size_t )3;
#line 447
  square = divisor * divisor;
#line 449
  while (1) {
#line 449
    if (square < candidate) {
#line 449
      if (! (candidate % divisor)) {
#line 449
        break;
      }
    } else {
#line 449
      break;
    }
#line 451
    divisor ++;
#line 452
    square += 4UL * divisor;
#line 453
    divisor ++;
  }
#line 456
  if (candidate % divisor) {
#line 456
    tmp = 1;
  } else {
#line 456
    tmp = 0;
  }
#line 456
  return ((_Bool )tmp);
}
}
#line 462 "hash.c"
static size_t next_prime(size_t candidate ) 
{ _Bool tmp ;

  {
#line 466
  if (candidate < 10UL) {
#line 467
    candidate = (size_t )10;
  }
#line 470
  candidate |= 1UL;
#line 472
  while (1) {
#line 472
    if (0xffffffffffffffffUL != candidate) {
#line 472
      tmp = is_prime(candidate);
#line 472
      if (tmp) {
#line 472
        break;
      }
    } else {
#line 472
      break;
    }
#line 473
    candidate += 2UL;
  }
#line 475
  return (candidate);
}
}
#line 478 "hash.c"
void hash_reset_tuning(Hash_tuning *tuning ) 
{ 

  {
#line 481
  *tuning = (Hash_tuning )default_tuning;
#line 482
  return;
}
}
#line 485 "hash.c"
static size_t raw_hasher(void const   *data , size_t n ) 
{ size_t val ;
  size_t tmp ;

  {
#line 493
  tmp = rotr_sz((size_t )data, 3);
#line 493
  val = tmp;
#line 494
  return (val % n);
}
}
#line 498 "hash.c"
static _Bool raw_comparator(void const   *a , void const   *b ) 
{ 

  {
#line 501
  return ((_Bool )((unsigned long )a == (unsigned long )b));
}
}
#line 511 "hash.c"
static _Bool check_tuning(Hash_table *table___0 ) 
{ Hash_tuning const   *tuning ;
  float epsilon ;

  {
#line 514
  tuning = table___0->tuning;
#line 516
  if ((unsigned long )tuning == (unsigned long )(& default_tuning)) {
#line 517
    return ((_Bool)1);
  }
#line 524
  epsilon = 0.1f;
#line 526
  if (epsilon < (float )tuning->growth_threshold) {
#line 526
    if (tuning->growth_threshold < (float const   )((float )1 - epsilon)) {
#line 526
      if ((float )1 + epsilon < (float )tuning->growth_factor) {
#line 526
        if ((float const   )0 <= tuning->shrink_threshold) {
#line 526
          if (tuning->shrink_threshold + (float const   )epsilon < tuning->shrink_factor) {
#line 526
            if (tuning->shrink_factor <= (float const   )1) {
#line 526
              if (tuning->shrink_threshold + (float const   )epsilon < tuning->growth_threshold) {
#line 533
                return ((_Bool)1);
              }
            }
          }
        }
      }
    }
  }
#line 535
  table___0->tuning = & default_tuning;
#line 536
  return ((_Bool)0);
}
}
#line 543 "hash.c"
static size_t compute_bucket_size(size_t candidate , Hash_tuning const   *tuning ) 
{ float new_candidate ;
  int tmp ;

  {
#line 546
  if (! tuning->is_n_buckets) {
#line 548
    new_candidate = (float )((float const   )candidate / tuning->growth_threshold);
#line 549
    if ((float )0xffffffffffffffffUL <= new_candidate) {
#line 550
      return ((size_t )0);
    }
#line 551
    candidate = (size_t )new_candidate;
  }
#line 553
  candidate = next_prime(candidate);
#line 554
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 554
    tmp = -1;
  } else {
#line 554
    tmp = -2;
  }
#line 554
  if ((size_t )tmp / sizeof(struct hash_entry *) < candidate) {
#line 555
    return ((size_t )0);
  }
#line 556
  return (candidate);
}
}
#line 593
Hash_table *hash_initialize(size_t candidate , Hash_tuning const   *tuning , size_t (*hasher)(void const   * ,
                                                                                              size_t  ) ,
                            _Bool (*comparator)(void const   * , void const   * ) ,
                            void (*data_freer)(void * ) )  __attribute__((__warn_unused_result__)) ;
#line 593 "hash.c"
Hash_table *hash_initialize(size_t candidate , Hash_tuning const   *tuning , size_t (*hasher)(void const   * ,
                                                                                              size_t  ) ,
                            _Bool (*comparator)(void const   * , void const   * ) ,
                            void (*data_freer)(void * ) ) 
{ Hash_table *table___0 ;
  void *tmp ;
  _Bool tmp___0 ;
  void *tmp___1 ;

  {
#line 600
  if ((unsigned long )hasher == (unsigned long )((void *)0)) {
#line 601
    hasher = & raw_hasher;
  }
#line 602
  if ((unsigned long )comparator == (unsigned long )((void *)0)) {
#line 603
    comparator = & raw_comparator;
  }
#line 605
  tmp = malloc(sizeof(*table___0));
#line 605
  table___0 = (Hash_table *)tmp;
#line 606
  if ((unsigned long )table___0 == (unsigned long )((void *)0)) {
#line 607
    return ((Hash_table *)((void *)0));
  }
#line 609
  if (! tuning) {
#line 610
    tuning = & default_tuning;
  }
#line 611
  table___0->tuning = tuning;
#line 612
  tmp___0 = check_tuning(table___0);
#line 612
  if (! tmp___0) {
#line 619
    goto fail;
  }
#line 622
  table___0->n_buckets = compute_bucket_size(candidate, tuning);
#line 623
  if (! table___0->n_buckets) {
#line 624
    goto fail;
  }
#line 626
  tmp___1 = calloc(table___0->n_buckets, sizeof(*(table___0->bucket)));
#line 626
  table___0->bucket = (struct hash_entry *)tmp___1;
#line 627
  if ((unsigned long )table___0->bucket == (unsigned long )((void *)0)) {
#line 628
    goto fail;
  }
#line 629
  table___0->bucket_limit = (struct hash_entry  const  *)(table___0->bucket + table___0->n_buckets);
#line 630
  table___0->n_buckets_used = (size_t )0;
#line 631
  table___0->n_entries = (size_t )0;
#line 633
  table___0->hasher = hasher;
#line 634
  table___0->comparator = comparator;
#line 635
  table___0->data_freer = data_freer;
#line 637
  table___0->free_entry_list = (struct hash_entry *)((void *)0);
#line 641
  return (table___0);
  fail: 
#line 644
  free((void *)table___0);
#line 645
  return ((Hash_table *)((void *)0));
}
}
#line 652 "hash.c"
void hash_clear(Hash_table *table___0 ) 
{ struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;

  {
#line 657
  bucket = table___0->bucket;
#line 657
  while ((unsigned long )bucket < (unsigned long )table___0->bucket_limit) {
#line 659
    if (bucket->data) {
#line 665
      cursor = bucket->next;
#line 665
      while (cursor) {
#line 667
        if (table___0->data_freer) {
#line 668
          (*(table___0->data_freer))(cursor->data);
        }
#line 669
        cursor->data = (void *)0;
#line 671
        next = cursor->next;
#line 674
        cursor->next = table___0->free_entry_list;
#line 675
        table___0->free_entry_list = cursor;
#line 665
        cursor = next;
      }
#line 679
      if (table___0->data_freer) {
#line 680
        (*(table___0->data_freer))(bucket->data);
      }
#line 681
      bucket->data = (void *)0;
#line 682
      bucket->next = (struct hash_entry *)((void *)0);
    }
#line 657
    bucket ++;
  }
#line 686
  table___0->n_buckets_used = (size_t )0;
#line 687
  table___0->n_entries = (size_t )0;
#line 688
  return;
}
}
#line 695 "hash.c"
void hash_free(Hash_table *table___0 ) 
{ struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;

  {
#line 703
  if (table___0->data_freer) {
#line 703
    if (table___0->n_entries) {
#line 705
      bucket = table___0->bucket;
#line 705
      while ((unsigned long )bucket < (unsigned long )table___0->bucket_limit) {
#line 707
        if (bucket->data) {
#line 709
          cursor = bucket;
#line 709
          while (cursor) {
#line 710
            (*(table___0->data_freer))(cursor->data);
#line 709
            cursor = cursor->next;
          }
        }
#line 705
        bucket ++;
      }
    }
  }
#line 722
  bucket = table___0->bucket;
#line 722
  while ((unsigned long )bucket < (unsigned long )table___0->bucket_limit) {
#line 724
    cursor = bucket->next;
#line 724
    while (cursor) {
#line 726
      next = cursor->next;
#line 727
      free((void *)cursor);
#line 724
      cursor = next;
    }
#line 722
    bucket ++;
  }
#line 732
  cursor = table___0->free_entry_list;
#line 732
  while (cursor) {
#line 734
    next = cursor->next;
#line 735
    free((void *)cursor);
#line 732
    cursor = next;
  }
#line 741
  free((void *)table___0->bucket);
#line 742
  free((void *)table___0);
#line 743
  return;
}
}
#line 750 "hash.c"
static struct hash_entry *allocate_entry(Hash_table *table___0 ) 
{ struct hash_entry *new ;
  void *tmp ;

  {
#line 755
  if (table___0->free_entry_list) {
#line 757
    new = table___0->free_entry_list;
#line 758
    table___0->free_entry_list = new->next;
  } else {
#line 765
    tmp = malloc(sizeof(*new));
#line 765
    new = (struct hash_entry *)tmp;
  }
#line 769
  return (new);
}
}
#line 775 "hash.c"
static void free_entry(Hash_table *table___0 , struct hash_entry *entry ) 
{ 

  {
#line 778
  entry->data = (void *)0;
#line 779
  entry->next = table___0->free_entry_list;
#line 780
  table___0->free_entry_list = entry;
#line 781
  return;
}
}
#line 789 "hash.c"
static void *hash_find_entry(Hash_table *table___0 , void const   *entry , struct hash_entry **bucket_head ,
                             _Bool delete ) 
{ struct hash_entry *bucket ;
  struct hash_entry *tmp ;
  struct hash_entry *cursor ;
  void *data ;
  struct hash_entry *next ;
  _Bool tmp___0 ;
  void *data___0 ;
  struct hash_entry *next___0 ;
  _Bool tmp___1 ;

  {
#line 793
  tmp = safe_hasher((Hash_table const   *)table___0, entry);
#line 793
  bucket = tmp;
#line 796
  *bucket_head = bucket;
#line 799
  if ((unsigned long )bucket->data == (unsigned long )((void *)0)) {
#line 800
    return ((void *)0);
  }
#line 803
  if ((unsigned long )entry == (unsigned long )bucket->data) {
#line 803
    goto _L;
  } else {
#line 803
    tmp___0 = (*(table___0->comparator))(entry, (void const   *)bucket->data);
#line 803
    if (tmp___0) {
      _L: 
#line 805
      data = bucket->data;
#line 807
      if (delete) {
#line 809
        if (bucket->next) {
#line 811
          next = bucket->next;
#line 815
          *bucket = *next;
#line 816
          free_entry(table___0, next);
        } else {
#line 820
          bucket->data = (void *)0;
        }
      }
#line 824
      return (data);
    }
  }
#line 828
  cursor = bucket;
#line 828
  while (cursor->next) {
#line 830
    if ((unsigned long )entry == (unsigned long )(cursor->next)->data) {
#line 830
      goto _L___0;
    } else {
#line 830
      tmp___1 = (*(table___0->comparator))(entry, (void const   *)(cursor->next)->data);
#line 830
      if (tmp___1) {
        _L___0: 
#line 833
        data___0 = (cursor->next)->data;
#line 835
        if (delete) {
#line 837
          next___0 = cursor->next;
#line 841
          cursor->next = next___0->next;
#line 842
          free_entry(table___0, next___0);
        }
#line 845
        return (data___0);
      }
    }
#line 828
    cursor = cursor->next;
  }
#line 850
  return ((void *)0);
}
}
#line 859 "hash.c"
static _Bool transfer_entries(Hash_table *dst , Hash_table *src , _Bool safe ) 
{ struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;
  void *data ;
  struct hash_entry *new_bucket ;
  struct hash_entry *new_entry ;
  struct hash_entry *tmp ;

  {
#line 865
  bucket = src->bucket;
#line 865
  while ((unsigned long )bucket < (unsigned long )src->bucket_limit) {
#line 866
    if (bucket->data) {
#line 877
      cursor = bucket->next;
#line 877
      while (cursor) {
#line 879
        data = cursor->data;
#line 880
        new_bucket = safe_hasher((Hash_table const   *)dst, (void const   *)data);
#line 882
        next = cursor->next;
#line 884
        if (new_bucket->data) {
#line 888
          cursor->next = new_bucket->next;
#line 889
          new_bucket->next = cursor;
        } else {
#line 895
          new_bucket->data = data;
#line 896
          (dst->n_buckets_used) ++;
#line 897
          free_entry(dst, cursor);
        }
#line 877
        cursor = next;
      }
#line 903
      data = bucket->data;
#line 904
      bucket->next = (struct hash_entry *)((void *)0);
#line 905
      if (safe) {
#line 906
        goto __Cont;
      }
#line 907
      new_bucket = safe_hasher((Hash_table const   *)dst, (void const   *)data);
#line 909
      if (new_bucket->data) {
#line 913
        tmp = allocate_entry(dst);
#line 913
        new_entry = tmp;
#line 915
        if ((unsigned long )new_entry == (unsigned long )((void *)0)) {
#line 916
          return ((_Bool)0);
        }
#line 918
        new_entry->data = data;
#line 919
        new_entry->next = new_bucket->next;
#line 920
        new_bucket->next = new_entry;
      } else {
#line 925
        new_bucket->data = data;
#line 926
        (dst->n_buckets_used) ++;
      }
#line 928
      bucket->data = (void *)0;
#line 929
      (src->n_buckets_used) --;
    }
    __Cont: 
#line 865
    bucket ++;
  }
#line 931
  return ((_Bool)1);
}
}
#line 942
_Bool hash_rehash(Hash_table *table___0 , size_t candidate )  __attribute__((__warn_unused_result__)) ;
#line 942 "hash.c"
_Bool hash_rehash(Hash_table *table___0 , size_t candidate ) 
{ Hash_table storage ;
  Hash_table *new_table ;
  size_t new_size ;
  size_t tmp ;
  void *tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;

  {
#line 947
  tmp = compute_bucket_size(candidate, table___0->tuning);
#line 947
  new_size = tmp;
#line 949
  if (! new_size) {
#line 950
    return ((_Bool)0);
  }
#line 951
  if (new_size == table___0->n_buckets) {
#line 952
    return ((_Bool)1);
  }
#line 953
  new_table = & storage;
#line 954
  tmp___0 = calloc(new_size, sizeof(*(new_table->bucket)));
#line 954
  new_table->bucket = (struct hash_entry *)tmp___0;
#line 955
  if ((unsigned long )new_table->bucket == (unsigned long )((void *)0)) {
#line 956
    return ((_Bool)0);
  }
#line 957
  new_table->n_buckets = new_size;
#line 958
  new_table->bucket_limit = (struct hash_entry  const  *)(new_table->bucket + new_size);
#line 959
  new_table->n_buckets_used = (size_t )0;
#line 960
  new_table->n_entries = (size_t )0;
#line 961
  new_table->tuning = table___0->tuning;
#line 962
  new_table->hasher = table___0->hasher;
#line 963
  new_table->comparator = table___0->comparator;
#line 964
  new_table->data_freer = table___0->data_freer;
#line 984
  new_table->free_entry_list = table___0->free_entry_list;
#line 986
  tmp___1 = transfer_entries(new_table, table___0, (_Bool)0);
#line 986
  if (tmp___1) {
#line 989
    free((void *)table___0->bucket);
#line 990
    table___0->bucket = new_table->bucket;
#line 991
    table___0->bucket_limit = new_table->bucket_limit;
#line 992
    table___0->n_buckets = new_table->n_buckets;
#line 993
    table___0->n_buckets_used = new_table->n_buckets_used;
#line 994
    table___0->free_entry_list = new_table->free_entry_list;
#line 996
    return ((_Bool)1);
  }
#line 1012
  table___0->free_entry_list = new_table->free_entry_list;
#line 1013
  tmp___2 = transfer_entries(table___0, new_table, (_Bool)1);
#line 1013
  if (tmp___2) {
#line 1013
    tmp___3 = transfer_entries(table___0, new_table, (_Bool)0);
#line 1013
    if (! tmp___3) {
#line 1015
      abort();
    }
  } else {
#line 1015
    abort();
  }
#line 1017
  free((void *)new_table->bucket);
#line 1018
  return ((_Bool)0);
}
}
#line 1035 "hash.c"
int hash_insert0(Hash_table *table___0 , void const   *entry , void const   **matched_ent ) 
{ void *data ;
  struct hash_entry *bucket ;
  Hash_tuning const   *tuning ;
  float candidate ;
  float tmp ;
  _Bool tmp___0 ;
  void *tmp___1 ;
  struct hash_entry *new_entry ;
  struct hash_entry *tmp___2 ;

  {
#line 1044
  if (! entry) {
#line 1045
    abort();
  }
#line 1048
  data = hash_find_entry(table___0, entry, & bucket, (_Bool)0);
#line 1048
  if ((unsigned long )data != (unsigned long )((void *)0)) {
#line 1050
    if (matched_ent) {
#line 1051
      *matched_ent = (void const   *)data;
    }
#line 1052
    return (0);
  }
#line 1060
  if ((float const   )table___0->n_buckets_used > (table___0->tuning)->growth_threshold * (float const   )table___0->n_buckets) {
#line 1065
    check_tuning(table___0);
#line 1066
    if ((float const   )table___0->n_buckets_used > (table___0->tuning)->growth_threshold * (float const   )table___0->n_buckets) {
#line 1069
      tuning = table___0->tuning;
#line 1070
      if (tuning->is_n_buckets) {
#line 1070
        tmp = (float )((float const   )table___0->n_buckets * tuning->growth_factor);
      } else {
#line 1070
        tmp = (float )(((float const   )table___0->n_buckets * tuning->growth_factor) * tuning->growth_threshold);
      }
#line 1070
      candidate = tmp;
#line 1076
      if ((float )0xffffffffffffffffUL <= candidate) {
#line 1077
        return (-1);
      }
#line 1080
      tmp___0 = hash_rehash(table___0, (size_t )candidate);
#line 1080
      if (! tmp___0) {
#line 1081
        return (-1);
      }
#line 1084
      tmp___1 = hash_find_entry(table___0, entry, & bucket, (_Bool)0);
#line 1084
      if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 1085
        abort();
      }
    }
  }
#line 1091
  if (bucket->data) {
#line 1093
    tmp___2 = allocate_entry(table___0);
#line 1093
    new_entry = tmp___2;
#line 1095
    if ((unsigned long )new_entry == (unsigned long )((void *)0)) {
#line 1096
      return (-1);
    }
#line 1100
    new_entry->data = (void *)entry;
#line 1101
    new_entry->next = bucket->next;
#line 1102
    bucket->next = new_entry;
#line 1103
    (table___0->n_entries) ++;
#line 1104
    return (1);
  }
#line 1109
  bucket->data = (void *)entry;
#line 1110
  (table___0->n_entries) ++;
#line 1111
  (table___0->n_buckets_used) ++;
#line 1113
  return (1);
}
}
#line 1122
void *hash_insert(Hash_table *table___0 , void const   *entry )  __attribute__((__warn_unused_result__)) ;
#line 1122 "hash.c"
void *hash_insert(Hash_table *table___0 , void const   *entry ) 
{ void const   *matched_ent ;
  int err ;
  int tmp ;
  void const   *tmp___0 ;
  void *tmp___1 ;

  {
#line 1126
  tmp = hash_insert0(table___0, entry, & matched_ent);
#line 1126
  err = tmp;
#line 1127
  if (err == -1) {
#line 1127
    tmp___1 = (void *)0;
  } else {
#line 1127
    if (err == 0) {
#line 1127
      tmp___0 = matched_ent;
    } else {
#line 1127
      tmp___0 = entry;
    }
#line 1127
    tmp___1 = (void *)tmp___0;
  }
#line 1127
  return (tmp___1);
}
}
#line 1136 "hash.c"
void *hash_delete(Hash_table *table___0 , void const   *entry ) 
{ void *data ;
  struct hash_entry *bucket ;
  Hash_tuning const   *tuning ;
  size_t candidate ;
  float tmp ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;
  _Bool tmp___0 ;

  {
#line 1142
  data = hash_find_entry(table___0, entry, & bucket, (_Bool)1);
#line 1143
  if (! data) {
#line 1144
    return ((void *)0);
  }
#line 1146
  (table___0->n_entries) --;
#line 1147
  if (! bucket->data) {
#line 1149
    (table___0->n_buckets_used) --;
#line 1154
    if ((float const   )table___0->n_buckets_used < (table___0->tuning)->shrink_threshold * (float const   )table___0->n_buckets) {
#line 1159
      check_tuning(table___0);
#line 1160
      if ((float const   )table___0->n_buckets_used < (table___0->tuning)->shrink_threshold * (float const   )table___0->n_buckets) {
#line 1163
        tuning = table___0->tuning;
#line 1164
        if (tuning->is_n_buckets) {
#line 1164
          tmp = (float )((float const   )table___0->n_buckets * tuning->shrink_factor);
        } else {
#line 1164
          tmp = (float )(((float const   )table___0->n_buckets * tuning->shrink_factor) * tuning->growth_threshold);
        }
#line 1164
        candidate = (size_t )tmp;
#line 1170
        tmp___0 = hash_rehash(table___0, candidate);
#line 1170
        if (! tmp___0) {
#line 1178
          cursor = table___0->free_entry_list;
#line 1180
          while (cursor) {
#line 1182
            next = cursor->next;
#line 1183
            free((void *)cursor);
#line 1184
            cursor = next;
          }
#line 1186
          table___0->free_entry_list = (struct hash_entry *)((void *)0);
        }
      }
    }
  }
#line 1193
  return (data);
}
}
#line 1 "hash-pjw.o"
#pragma merger(0,"/tmp/cil-zaoCfeDr.i","-g,-O2")
#line 23 "hash-pjw.h"
size_t hash_pjw(void const   *x , size_t tablesize ) ;
#line 30 "hash-pjw.c"
size_t hash_pjw(void const   *x , size_t tablesize ) 
{ char const   *s ;
  size_t h ;

  {
#line 34
  h = (size_t )0;
#line 36
  s = (char const   *)x;
#line 36
  while (*s) {
#line 37
    h = (unsigned long )*s + ((h << 9) | (h >> (sizeof(size_t ) * 8UL - 9UL)));
#line 36
    s ++;
  }
#line 39
  return (h % tablesize);
}
}
#line 1 "hash-triple.o"
#pragma merger(0,"/tmp/cil-cXtd8kxk.i","-g,-O2")
#line 17 "hash-triple.h"
size_t triple_hash_no_name(void const   *x , size_t table_size ) ;
#line 18
_Bool triple_compare(void const   *x , void const   *y ) ;
#line 23 "same.h"
_Bool same_name(char const   *source , char const   *dest ) ;
#line 33 "hash-triple.c"
size_t triple_hash(void const   *x , size_t table_size ) 
{ struct F_triple  const  *p ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 36
  p = (struct F_triple  const  *)x;
#line 37
  tmp___0 = hash_pjw((void const   *)p->name, table_size);
#line 37
  tmp = tmp___0;
#line 40
  return ((tmp ^ (unsigned long )p->st_ino) % table_size);
}
}
#line 44 "hash-triple.c"
size_t triple_hash_no_name(void const   *x , size_t table_size ) 
{ struct F_triple  const  *p ;

  {
#line 47
  p = (struct F_triple  const  *)x;
#line 50
  return ((size_t )(p->st_ino % (unsigned long const   )table_size));
}
}
#line 54 "hash-triple.c"
_Bool triple_compare(void const   *x , void const   *y ) 
{ struct F_triple  const  *a ;
  struct F_triple  const  *b ;
  int tmp___0 ;
  _Bool tmp___1 ;

  {
#line 57
  a = (struct F_triple  const  *)x;
#line 58
  b = (struct F_triple  const  *)y;
#line 59
  if (a->st_ino == b->st_ino) {
#line 59
    if (a->st_dev == b->st_dev) {
#line 59
      tmp___1 = same_name((char const   *)a->name, (char const   *)b->name);
#line 59
      if (tmp___1) {
#line 59
        tmp___0 = 1;
      } else {
#line 59
        tmp___0 = 0;
      }
    } else {
#line 59
      tmp___0 = 0;
    }
  } else {
#line 59
    tmp___0 = 0;
  }
#line 59
  return ((_Bool )tmp___0);
}
}
#line 62 "hash-triple.c"
_Bool triple_compare_ino_str(void const   *x , void const   *y ) 
{ struct F_triple  const  *a ;
  struct F_triple  const  *b ;
  int tmp___6 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 65
  a = (struct F_triple  const  *)x;
#line 66
  b = (struct F_triple  const  *)y;
#line 67
  if (a->st_ino == b->st_ino) {
#line 67
    if (a->st_dev == b->st_dev) {
#line 67
      if (0) {
#line 67
        __s1_len___0 = __builtin_strlen((char const   *)a->name);
#line 67
        __s2_len___0 = __builtin_strlen((char const   *)b->name);
#line 67
        if (! ((size_t )((void const   *)(a->name + 1)) - (size_t )((void const   *)a->name) == 1UL)) {
#line 67
          goto _L___2;
        } else
#line 67
        if (__s1_len___0 >= 4UL) {
          _L___2: 
#line 67
          if (! ((size_t )((void const   *)(b->name + 1)) - (size_t )((void const   *)b->name) == 1UL)) {
#line 67
            tmp___13 = 1;
          } else
#line 67
          if (__s2_len___0 >= 4UL) {
#line 67
            tmp___13 = 1;
          } else {
#line 67
            tmp___13 = 0;
          }
        } else {
#line 67
          tmp___13 = 0;
        }
#line 67
        if (tmp___13) {
#line 67
          tmp___8 = __builtin_strcmp((char const   *)a->name, (char const   *)b->name);
#line 67
          tmp___12 = tmp___8;
        } else {
#line 67
          tmp___11 = __builtin_strcmp((char const   *)a->name, (char const   *)b->name);
#line 67
          tmp___12 = tmp___11;
        }
      } else {
#line 67
        tmp___11 = __builtin_strcmp((char const   *)a->name, (char const   *)b->name);
#line 67
        tmp___12 = tmp___11;
      }
#line 67
      if (tmp___12 == 0) {
#line 67
        tmp___6 = 1;
      } else {
#line 67
        tmp___6 = 0;
      }
    } else {
#line 67
      tmp___6 = 0;
    }
  } else {
#line 67
    tmp___6 = 0;
  }
#line 67
  return ((_Bool )tmp___6);
}
}
#line 71 "hash-triple.c"
void triple_free(void *x ) 
{ struct F_triple *a ;

  {
#line 74
  a = (struct F_triple *)x;
#line 75
  free((void *)a->name);
#line 76
  free((void *)a);
#line 77
  return;
}
}
#line 1 "heap.o"
#pragma merger(0,"/tmp/cil-fPrWATfZ.i","-g,-O2")
#line 23 "heap.h"
struct heap *heap_alloc(int (*compare)(void const   * , void const   * ) , size_t n_reserve ) ;
#line 24
void heap_free(struct heap *heap ) ;
#line 25
int heap_insert(struct heap *heap , void *item ) ;
#line 26
void *heap_remove_top(struct heap *heap ) ;
#line 106 "xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 108
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 108 "xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s ) 
{ int tmp ;
  void *tmp___0 ;

  {
#line 111
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 111
    tmp = -1;
  } else {
#line 111
    tmp = -2;
  }
#line 111
  if ((size_t )tmp / s < n) {
#line 112
    xalloc_die();
  }
#line 113
  tmp___0 = xmalloc(n * s);
#line 113
  return (tmp___0);
}
}
#line 27 "heap.c"
static int heap_default_compare(void const   *a , void const   *b ) ;
#line 28
static size_t heapify_down(void **array , size_t count , size_t initial , int (*compare)(void const   * ,
                                                                                         void const   * ) ) ;
#line 30
static void heapify_up(void **array , size_t count , int (*compare)(void const   * ,
                                                                    void const   * ) ) ;
#line 43 "heap.c"
struct heap *heap_alloc(int (*compare)(void const   * , void const   * ) , size_t n_reserve ) 
{ struct heap *heap ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 46
  tmp = xmalloc(sizeof(*heap));
#line 46
  heap = (struct heap *)tmp;
#line 48
  if (n_reserve == 0UL) {
#line 49
    n_reserve = (size_t )1;
  }
#line 51
  tmp___0 = xnmalloc(n_reserve, sizeof(*(heap->array)));
#line 51
  heap->array = (void **)tmp___0;
#line 53
  *(heap->array + 0) = (void *)0;
#line 54
  heap->capacity = n_reserve;
#line 55
  heap->count = (size_t )0;
#line 56
  if (compare) {
#line 56
    heap->compare = compare;
  } else {
#line 56
    heap->compare = & heap_default_compare;
  }
#line 58
  return (heap);
}
}
#line 62 "heap.c"
static int heap_default_compare(void const   *a , void const   *b ) 
{ 

  {
#line 65
  return (0);
}
}
#line 69 "heap.c"
void heap_free(struct heap *heap ) 
{ 

  {
#line 72
  free((void *)heap->array);
#line 73
  free((void *)heap);
#line 74
  return;
}
}
#line 78 "heap.c"
int heap_insert(struct heap *heap , void *item ) 
{ void *tmp ;

  {
#line 81
  if (heap->capacity - 1UL <= heap->count) {
#line 82
    tmp = x2nrealloc((void *)heap->array, & heap->capacity, sizeof(*(heap->array)));
#line 82
    heap->array = (void **)tmp;
  }
#line 85
  (heap->count) ++;
#line 85
  *(heap->array + heap->count) = item;
#line 86
  heapify_up(heap->array, heap->count, heap->compare);
#line 88
  return (0);
}
}
#line 93 "heap.c"
void *heap_remove_top(struct heap *heap ) 
{ void *top ;
  size_t tmp ;

  {
#line 98
  if (heap->count == 0UL) {
#line 99
    return ((void *)0);
  }
#line 101
  top = *(heap->array + 1);
#line 102
  tmp = heap->count;
#line 102
  (heap->count) --;
#line 102
  *(heap->array + 1) = *(heap->array + tmp);
#line 103
  heapify_down(heap->array, heap->count, (size_t )1, heap->compare);
#line 105
  return (top);
}
}
#line 110 "heap.c"
static size_t heapify_down(void **array , size_t count , size_t initial , int (*compare)(void const   * ,
                                                                                         void const   * ) ) 
{ void *element ;
  size_t parent ;
  size_t child ;
  int tmp ;
  int tmp___0 ;

  {
#line 114
  element = *(array + initial);
#line 116
  parent = initial;
#line 117
  while (parent <= count / 2UL) {
#line 119
    child = 2UL * parent;
#line 121
    if (child < count) {
#line 121
      tmp = (*compare)((void const   *)*(array + child), (void const   *)*(array + (child + 1UL)));
#line 121
      if (tmp < 0) {
#line 122
        child ++;
      }
    }
#line 124
    tmp___0 = (*compare)((void const   *)*(array + child), (void const   *)element);
#line 124
    if (tmp___0 <= 0) {
#line 125
      break;
    }
#line 127
    *(array + parent) = *(array + child);
#line 128
    parent = child;
  }
#line 131
  *(array + parent) = element;
#line 132
  return (parent);
}
}
#line 137 "heap.c"
static void heapify_up(void **array , size_t count , int (*compare)(void const   * ,
                                                                    void const   * ) ) 
{ size_t k ;
  void *new_element ;
  int tmp ;

  {
#line 141
  k = count;
#line 142
  new_element = *(array + k);
#line 144
  while (1) {
#line 144
    if (k != 1UL) {
#line 144
      tmp = (*compare)((void const   *)*(array + k / 2UL), (void const   *)new_element);
#line 144
      if (! (tmp <= 0)) {
#line 144
        break;
      }
    } else {
#line 144
      break;
    }
#line 146
    *(array + k) = *(array + k / 2UL);
#line 147
    k /= 2UL;
  }
#line 150
  *(array + k) = new_element;
#line 151
  return;
}
}
#line 1 "human.o"
#pragma merger(0,"/tmp/cil-Ngtg3QH2.i","-g,-O2")
#line 305 "/usr/include/inttypes.h"
__inline extern  __attribute__((__nothrow__)) intmax_t strtoimax(char const   * __restrict  nptr ,
                                                                 char ** __restrict  endptr ,
                                                                 int base ) ;
#line 309
__inline extern  __attribute__((__nothrow__)) uintmax_t strtoumax(char const   * __restrict  nptr ,
                                                                  char ** __restrict  endptr ,
                                                                  int base ) ;
#line 313
__inline extern  __attribute__((__nothrow__)) intmax_t wcstoimax(__gwchar_t const   * __restrict  nptr ,
                                                                 __gwchar_t ** __restrict  endptr ,
                                                                 int base ) ;
#line 318
__inline extern  __attribute__((__nothrow__)) uintmax_t wcstoumax(__gwchar_t const   * __restrict  nptr ,
                                                                  __gwchar_t ** __restrict  endptr ,
                                                                  int base ) ;
#line 326
extern  __attribute__((__nothrow__)) long __strtol_internal(char const   * __restrict  __nptr ,
                                                            char ** __restrict  __endptr ,
                                                            int __base , int __group )  __attribute__((__warn_unused_result__,
__nonnull__(1))) ;
#line 331
__inline extern  __attribute__((__nothrow__)) intmax_t strtoimax(char const   * __restrict  nptr ,
                                                                 char ** __restrict  endptr ,
                                                                 int base ) ;
#line 331 "/usr/include/inttypes.h"
__inline extern intmax_t strtoimax(char const   * __restrict  nptr , char ** __restrict  endptr ,
                                   int base ) 
{ long tmp ;

  {
#line 335
  tmp = __strtol_internal(nptr, endptr, base, 0);
#line 335
  return (tmp);
}
}
#line 338
extern  __attribute__((__nothrow__)) unsigned long __strtoul_internal(char const   * __restrict  __nptr ,
                                                                      char ** __restrict  __endptr ,
                                                                      int __base ,
                                                                      int __group )  __attribute__((__warn_unused_result__,
__nonnull__(1))) ;
#line 344
__inline extern  __attribute__((__nothrow__)) uintmax_t strtoumax(char const   * __restrict  nptr ,
                                                                  char ** __restrict  endptr ,
                                                                  int base ) ;
#line 344 "/usr/include/inttypes.h"
__inline extern uintmax_t strtoumax(char const   * __restrict  nptr , char ** __restrict  endptr ,
                                    int base ) 
{ unsigned long tmp ;

  {
#line 348
  tmp = __strtoul_internal(nptr, endptr, base, 0);
#line 348
  return (tmp);
}
}
#line 351
extern  __attribute__((__nothrow__)) long __wcstol_internal(__gwchar_t const   * __restrict  __nptr ,
                                                            __gwchar_t ** __restrict  __endptr ,
                                                            int __base , int __group )  __attribute__((__warn_unused_result__,
__nonnull__(1))) ;
#line 356
__inline extern  __attribute__((__nothrow__)) intmax_t wcstoimax(__gwchar_t const   * __restrict  nptr ,
                                                                 __gwchar_t ** __restrict  endptr ,
                                                                 int base ) ;
#line 356 "/usr/include/inttypes.h"
__inline extern intmax_t wcstoimax(__gwchar_t const   * __restrict  nptr , __gwchar_t ** __restrict  endptr ,
                                   int base ) 
{ long tmp ;

  {
#line 360
  tmp = __wcstol_internal(nptr, endptr, base, 0);
#line 360
  return (tmp);
}
}
#line 363
extern  __attribute__((__nothrow__)) unsigned long __wcstoul_internal(__gwchar_t const   * __restrict  __nptr ,
                                                                      __gwchar_t ** __restrict  __endptr ,
                                                                      int __base ,
                                                                      int __group )  __attribute__((__warn_unused_result__,
__nonnull__(1))) ;
#line 370
__inline extern  __attribute__((__nothrow__)) uintmax_t wcstoumax(__gwchar_t const   * __restrict  nptr ,
                                                                  __gwchar_t ** __restrict  endptr ,
                                                                  int base ) ;
#line 370 "/usr/include/inttypes.h"
__inline extern uintmax_t wcstoumax(__gwchar_t const   * __restrict  nptr , __gwchar_t ** __restrict  endptr ,
                                    int base ) 
{ unsigned long tmp ;

  {
#line 374
  tmp = __wcstoul_internal(nptr, endptr, base, 0);
#line 374
  return (tmp);
}
}
#line 47 "./xstrtol.h"
strtol_error xstrtoumax(char const   *s , char **ptr , int strtol_base , uintmax_t *val ,
                        char const   *valid_suffixes ) ;
#line 79 "human.h"
char *human_readable(uintmax_t n , char *buf___1 , int opts , uintmax_t from_block_size ,
                     uintmax_t to_block_size ) ;
#line 81
enum strtol_error human_options(char const   *spec , int *opts , uintmax_t *block_size ) ;
#line 128 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) struct lconv *localeconv(void) ;
#line 36 "human.c"
static char const   power_letter[9]  = 
#line 36 "human.c"
  {      (char const   )0,      (char const   )'K',      (char const   )'M',      (char const   )'G', 
        (char const   )'T',      (char const   )'P',      (char const   )'E',      (char const   )'Z', 
        (char const   )'Y'};
#line 53 "human.c"
static long double adjust_value(int inexact_style , long double value ) 
{ uintmax_t u ;
  int tmp ;

  {
#line 60
  if (inexact_style != 1) {
#line 60
    if (value < (long double )0xffffffffffffffffUL) {
#line 62
      u = (uintmax_t )value;
#line 63
      if (inexact_style == 0) {
#line 63
        if ((long double )u != value) {
#line 63
          tmp = 1;
        } else {
#line 63
          tmp = 0;
        }
      } else {
#line 63
        tmp = 0;
      }
#line 63
      value = (long double )(u + (uintmax_t )tmp);
    }
  }
#line 66
  return (value);
}
}
#line 78 "human.c"
static char *group_number(char *number , size_t numberlen , char const   *grouping ,
                          char const   *thousands_sep ) 
{ register char *d ;
  size_t grouplen ;
  size_t thousands_seplen ;
  size_t tmp ;
  size_t i ;
  char buf___1[2UL * (((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL) + 1UL] ;
  unsigned char g ;

  {
#line 83
  grouplen = 0xffffffffffffffffUL;
#line 84
  tmp = strlen(thousands_sep);
#line 84
  thousands_seplen = tmp;
#line 85
  i = numberlen;
#line 91
  memcpy((void * __restrict  )(buf___1), (void const   * __restrict  )number, numberlen);
#line 92
  d = number + numberlen;
#line 94
  while (1) {
#line 96
    g = (unsigned char )*grouping;
#line 98
    if (g) {
#line 100
      if ((int )g < 127) {
#line 100
        grouplen = (size_t )g;
      } else {
#line 100
        grouplen = i;
      }
#line 101
      grouping ++;
    }
#line 104
    if (i < grouplen) {
#line 105
      grouplen = i;
    }
#line 107
    d -= grouplen;
#line 108
    i -= grouplen;
#line 109
    memcpy((void * __restrict  )d, (void const   * __restrict  )(buf___1 + i), grouplen);
#line 110
    if (i == 0UL) {
#line 111
      return (d);
    }
#line 113
    d -= thousands_seplen;
#line 114
    memcpy((void * __restrict  )d, (void const   * __restrict  )thousands_sep, thousands_seplen);
  }
}
}
#line 152 "human.c"
char *human_readable(uintmax_t n , char *buf___1 , int opts , uintmax_t from_block_size ,
                     uintmax_t to_block_size ) 
{ int inexact_style ;
  unsigned int base ;
  int tmp ;
  uintmax_t amt ;
  int tenths ;
  int exponent ;
  int exponent_max ;
  char *p ;
  char *psuffix ;
  char const   *integerlim ;
  int rounding ;
  char const   *decimal_point ;
  size_t decimal_pointlen ;
  char const   *grouping ;
  char const   *thousands_sep ;
  struct lconv  const  *l ;
  struct lconv *tmp___0 ;
  size_t pointlen ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  uintmax_t multiplier ;
  uintmax_t divisor ;
  uintmax_t r10 ;
  uintmax_t r2 ;
  long double dto_block_size ;
  long double damt ;
  size_t buflen ;
  size_t nonintegerlen ;
  long double tmp___3 ;
  long double e ;
  long double tmp___4 ;
  long double tmp___5 ;
  unsigned int r10___0 ;
  unsigned int r2___0 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int digit ;
  uintmax_t power ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;

  {
#line 156
  inexact_style = opts & 3;
#line 158
  if (opts & 32) {
#line 158
    tmp = 1024;
  } else {
#line 158
    tmp = 1000;
  }
#line 158
  base = (unsigned int )tmp;
#line 161
  exponent = -1;
#line 162
  exponent_max = (int )(sizeof(power_letter) - 1UL);
#line 173
  decimal_point = ".";
#line 174
  decimal_pointlen = (size_t )1;
#line 175
  grouping = "";
#line 176
  thousands_sep = "";
#line 177
  tmp___0 = localeconv();
#line 177
  l = (struct lconv  const  *)tmp___0;
#line 178
  tmp___1 = strlen((char const   *)l->decimal_point);
#line 178
  pointlen = tmp___1;
#line 179
  if (0UL < pointlen) {
#line 179
    if (pointlen <= 16UL) {
#line 181
      decimal_point = (char const   *)l->decimal_point;
#line 182
      decimal_pointlen = pointlen;
    }
  }
#line 184
  grouping = (char const   *)l->grouping;
#line 185
  tmp___2 = strlen((char const   *)l->thousands_sep);
#line 185
  if (tmp___2 <= 16UL) {
#line 186
    thousands_sep = (char const   *)l->thousands_sep;
  }
#line 188
  psuffix = (buf___1 + (((((((2UL * sizeof(uintmax_t )) * 8UL) * 146UL) / 485UL + 1UL) * 17UL - 16UL) + 1UL) + 3UL)) - 3;
#line 189
  p = psuffix;
#line 194
  if (to_block_size <= from_block_size) {
#line 196
    if (from_block_size % to_block_size == 0UL) {
#line 198
      multiplier = from_block_size / to_block_size;
#line 199
      amt = n * multiplier;
#line 200
      if (amt / multiplier == n) {
#line 202
        tenths = 0;
#line 203
        rounding = 0;
#line 204
        goto use_integer_arithmetic;
      }
    }
  } else
#line 208
  if (from_block_size != 0UL) {
#line 208
    if (to_block_size % from_block_size == 0UL) {
#line 210
      divisor = to_block_size / from_block_size;
#line 211
      r10 = (n % divisor) * 10UL;
#line 212
      r2 = (r10 % divisor) * 2UL;
#line 213
      amt = n / divisor;
#line 214
      tenths = (int )(r10 / divisor);
#line 215
      if (r2 < divisor) {
#line 215
        rounding = 0UL < r2;
      } else {
#line 215
        rounding = 2 + (divisor < r2);
      }
#line 216
      goto use_integer_arithmetic;
    }
  }
#line 224
  dto_block_size = (long double )to_block_size;
#line 225
  damt = (long double )n * ((long double )from_block_size / dto_block_size);
#line 229
  if (! (opts & 16)) {
#line 231
    tmp___3 = adjust_value(inexact_style, damt);
#line 231
    sprintf((char * __restrict  )buf___1, (char const   * __restrict  )"%.0Lf", tmp___3);
#line 232
    buflen = strlen((char const   *)buf___1);
#line 233
    nonintegerlen = (size_t )0;
  } else {
#line 237
    e = (long double )1;
#line 238
    exponent = 0;
#line 240
    while (1) {
#line 242
      e *= (long double )base;
#line 243
      exponent ++;
#line 240
      if (e * (long double )base <= damt) {
#line 240
        if (! (exponent < exponent_max)) {
#line 240
          break;
        }
      } else {
#line 240
        break;
      }
    }
#line 247
    damt /= e;
#line 249
    tmp___4 = adjust_value(inexact_style, damt);
#line 249
    sprintf((char * __restrict  )buf___1, (char const   * __restrict  )"%.1Lf", tmp___4);
#line 250
    buflen = strlen((char const   *)buf___1);
#line 251
    nonintegerlen = decimal_pointlen + 1UL;
#line 253
    if ((1UL + nonintegerlen) + (size_t )(! (opts & 32)) < buflen) {
#line 257
      tmp___5 = adjust_value(inexact_style, damt * (long double )10);
#line 257
      sprintf((char * __restrict  )buf___1, (char const   * __restrict  )"%.0Lf",
              tmp___5 / (long double )10);
#line 259
      buflen = strlen((char const   *)buf___1);
#line 260
      nonintegerlen = (size_t )0;
    } else
#line 253
    if (opts & 8) {
#line 253
      if ((int )*(buf___1 + (buflen - 1UL)) == 48) {
#line 257
        tmp___5 = adjust_value(inexact_style, damt * (long double )10);
#line 257
        sprintf((char * __restrict  )buf___1, (char const   * __restrict  )"%.0Lf",
                tmp___5 / (long double )10);
#line 259
        buflen = strlen((char const   *)buf___1);
#line 260
        nonintegerlen = (size_t )0;
      }
    }
  }
#line 264
  p = psuffix - buflen;
#line 265
  memmove((void *)p, (void const   *)buf___1, buflen);
#line 266
  integerlim = (char const   *)((p + buflen) - nonintegerlen);
#line 268
  goto do_grouping;
  use_integer_arithmetic: 
#line 277
  if (opts & 16) {
#line 279
    exponent = 0;
#line 281
    if ((uintmax_t )base <= amt) {
#line 283
      while (1) {
#line 285
        r10___0 = (unsigned int )((amt % (unsigned long )base) * 10UL + (unsigned long )tenths);
#line 286
        r2___0 = (r10___0 % base) * 2U + (unsigned int )(rounding >> 1);
#line 287
        amt /= (uintmax_t )base;
#line 288
        tenths = (int )(r10___0 / base);
#line 289
        if (r2___0 < base) {
#line 289
          rounding = r2___0 + (unsigned int )rounding != 0U;
        } else {
#line 289
          rounding = 2 + (base < r2___0 + (unsigned int )rounding);
        }
#line 292
        exponent ++;
#line 283
        if ((uintmax_t )base <= amt) {
#line 283
          if (! (exponent < exponent_max)) {
#line 283
            break;
          }
        } else {
#line 283
          break;
        }
      }
#line 296
      if (amt < 10UL) {
#line 298
        if (inexact_style == 1) {
#line 298
          tmp___7 = 2 < rounding + (tenths & 1);
        } else {
#line 298
          if (inexact_style == 0) {
#line 298
            if (0 < rounding) {
#line 298
              tmp___6 = 1;
            } else {
#line 298
              tmp___6 = 0;
            }
          } else {
#line 298
            tmp___6 = 0;
          }
#line 298
          tmp___7 = tmp___6;
        }
#line 298
        if (tmp___7) {
#line 302
          tenths ++;
#line 303
          rounding = 0;
#line 305
          if (tenths == 10) {
#line 307
            amt ++;
#line 308
            tenths = 0;
          }
        }
#line 312
        if (amt < 10UL) {
#line 312
          if (tenths) {
#line 312
            goto _L;
          } else
#line 312
          if (! (opts & 8)) {
            _L: 
#line 315
            p --;
#line 315
            *p = (char )(48 + tenths);
#line 316
            p -= decimal_pointlen;
#line 317
            memcpy((void * __restrict  )p, (void const   * __restrict  )decimal_point,
                   decimal_pointlen);
#line 318
            rounding = 0;
#line 318
            tenths = rounding;
          }
        }
      }
    }
  }
#line 324
  if (inexact_style == 1) {
#line 324
    tmp___9 = 5 < tenths + (0UL < (unsigned long )rounding + (amt & 1UL));
  } else {
#line 324
    if (inexact_style == 0) {
#line 324
      if (0 < tenths + rounding) {
#line 324
        tmp___8 = 1;
      } else {
#line 324
        tmp___8 = 0;
      }
    } else {
#line 324
      tmp___8 = 0;
    }
#line 324
    tmp___9 = tmp___8;
  }
#line 324
  if (tmp___9) {
#line 328
    amt ++;
#line 330
    if (opts & 16) {
#line 330
      if (amt == (uintmax_t )base) {
#line 330
        if (exponent < exponent_max) {
#line 333
          exponent ++;
#line 334
          if (! (opts & 8)) {
#line 336
            p --;
#line 336
            *p = (char )'0';
#line 337
            p -= decimal_pointlen;
#line 338
            memcpy((void * __restrict  )p, (void const   * __restrict  )decimal_point,
                   decimal_pointlen);
          }
#line 340
          amt = (uintmax_t )1;
        }
      }
    }
  }
#line 344
  integerlim = (char const   *)p;
#line 346
  while (1) {
#line 348
    digit = (int )(amt % 10UL);
#line 349
    p --;
#line 349
    *p = (char )(digit + 48);
#line 346
    amt /= 10UL;
#line 346
    if (! (amt != 0UL)) {
#line 346
      break;
    }
  }
  do_grouping: 
#line 355
  if (opts & 4) {
#line 356
    p = group_number(p, (size_t )(integerlim - (char const   *)p), grouping, thousands_sep);
  }
#line 358
  if (opts & 128) {
#line 360
    if (exponent < 0) {
#line 363
      exponent = 0;
#line 364
      power = (uintmax_t )1;
#line 364
      while (power < to_block_size) {
#line 365
        exponent ++;
#line 365
        if (exponent == exponent_max) {
#line 366
          break;
        }
#line 364
        power *= (uintmax_t )base;
      }
    }
#line 369
    if (exponent | (opts & 256)) {
#line 369
      if (opts & 64) {
#line 370
        tmp___10 = psuffix;
#line 370
        psuffix ++;
#line 370
        *tmp___10 = (char )' ';
      }
    }
#line 372
    if (exponent) {
#line 373
      tmp___11 = psuffix;
#line 373
      psuffix ++;
#line 373
      if (! (opts & 32)) {
#line 373
        if (exponent == 1) {
#line 373
          *tmp___11 = (char )'k';
        } else {
#line 373
          *tmp___11 = (char )power_letter[exponent];
        }
      } else {
#line 373
        *tmp___11 = (char )power_letter[exponent];
      }
    }
#line 377
    if (opts & 256) {
#line 379
      if (opts & 32) {
#line 379
        if (exponent) {
#line 380
          tmp___12 = psuffix;
#line 380
          psuffix ++;
#line 380
          *tmp___12 = (char )'i';
        }
      }
#line 381
      tmp___13 = psuffix;
#line 381
      psuffix ++;
#line 381
      *tmp___13 = (char )'B';
    }
  }
#line 385
  *psuffix = (char )'\000';
#line 387
  return (p);
}
}
#line 397 "human.c"
static char const   * const  block_size_args[3]  = {      (char const   * const  )"human-readable",      (char const   * const  )"si",      (char const   * const  )0};
#line 398 "human.c"
static int const   block_size_opts[2]  = {      (int const   )176,      (int const   )144};
#line 404 "human.c"
static uintmax_t default_block_size(void) 
{ int tmp___0 ;
  char *tmp___1 ;

  {
#line 407
  tmp___1 = getenv("POSIXLY_CORRECT");
#line 407
  if (tmp___1) {
#line 407
    tmp___0 = 512;
  } else {
#line 407
    tmp___0 = 1024;
  }
#line 407
  return ((uintmax_t )tmp___0);
}
}
#line 410 "human.c"
static strtol_error humblock(char const   *spec , uintmax_t *block_size , int *options ) 
{ int i ;
  int opts ;
  char *ptr ;
  strtol_error e ;
  strtol_error tmp ;
  ptrdiff_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 414
  opts = 0;
#line 416
  if (! spec) {
#line 416
    tmp___1 = getenv("BLOCK_SIZE");
#line 416
    spec = (char const   *)tmp___1;
#line 416
    if (spec) {
#line 416
      goto _L___0;
    } else {
#line 416
      tmp___2 = getenv("BLOCKSIZE");
#line 416
      spec = (char const   *)tmp___2;
#line 416
      if (spec) {
#line 416
        goto _L___0;
      } else {
#line 419
        *block_size = default_block_size();
      }
    }
  } else {
    _L___0: 
#line 422
    if ((int const   )*spec == 39) {
#line 424
      opts |= 4;
#line 425
      spec ++;
    }
#line 428
    tmp___0 = argmatch(spec, block_size_args, (char const   *)(block_size_opts), sizeof(block_size_opts[0]));
#line 428
    i = (int )tmp___0;
#line 428
    if (0 <= i) {
#line 430
      opts |= (int )block_size_opts[i];
#line 431
      *block_size = (uintmax_t )1;
    } else {
#line 436
      tmp = xstrtoumax(spec, & ptr, 0, block_size, "eEgGkKmMpPtTyYzZ0");
#line 436
      e = tmp;
#line 438
      if ((unsigned int )e != 0U) {
#line 440
        *options = 0;
#line 441
        return (e);
      }
#line 443
      while (1) {
#line 443
        if (48 <= (int )*spec) {
#line 443
          if ((int const   )*spec <= 57) {
#line 443
            break;
          }
        }
#line 444
        if ((unsigned long )spec == (unsigned long )ptr) {
#line 446
          opts |= 128;
#line 447
          if ((int )*(ptr + -1) == 66) {
#line 448
            opts |= 256;
          }
#line 449
          if ((int )*(ptr + -1) != 66) {
#line 450
            opts |= 32;
          } else
#line 449
          if ((int )*(ptr + -2) == 105) {
#line 450
            opts |= 32;
          }
#line 451
          break;
        }
#line 443
        spec ++;
      }
    }
  }
#line 456
  *options = opts;
#line 457
  return ((strtol_error )0);
}
}
#line 460 "human.c"
enum strtol_error human_options(char const   *spec , int *opts , uintmax_t *block_size ) 
{ strtol_error e ;
  strtol_error tmp ;

  {
#line 463
  tmp = humblock(spec, block_size, opts);
#line 463
  e = tmp;
#line 464
  if (*block_size == 0UL) {
#line 466
    *block_size = default_block_size();
#line 467
    e = (strtol_error )4;
  }
#line 469
  return (e);
}
}
#line 1 "i-ring.o"
#pragma merger(0,"/tmp/cil-7E9QST21.i","-g,-O2")
#line 41 "i-ring.h"
void i_ring_init(I_ring *ir , int default_val ) ;
#line 42
int i_ring_push(I_ring *ir , int val ) ;
#line 43
int i_ring_pop(I_ring *ir ) ;
#line 44
_Bool i_ring_empty(I_ring const   *ir ) ;
#line 24 "i-ring.c"
void i_ring_init(I_ring *ir , int default_val ) 
{ int i ;

  {
#line 28
  ir->ir_empty = (_Bool)1;
#line 29
  ir->ir_front = 0U;
#line 30
  ir->ir_back = 0U;
#line 31
  i = 0;
#line 31
  while (i < 4) {
#line 32
    ir->ir_data[i] = default_val;
#line 31
    i ++;
  }
#line 33
  ir->ir_default_val = default_val;
#line 34
  return;
}
}
#line 36 "i-ring.c"
_Bool i_ring_empty(I_ring const   *ir ) 
{ 

  {
#line 39
  return ((_Bool )ir->ir_empty);
}
}
#line 42 "i-ring.c"
int i_ring_push(I_ring *ir , int val ) 
{ unsigned int dest_idx ;
  int old_val ;

  {
#line 45
  dest_idx = (ir->ir_front + (unsigned int )(! ir->ir_empty)) % 4U;
#line 46
  old_val = ir->ir_data[dest_idx];
#line 47
  ir->ir_data[dest_idx] = val;
#line 48
  ir->ir_front = dest_idx;
#line 49
  if (dest_idx == ir->ir_back) {
#line 50
    ir->ir_back = (ir->ir_back + (unsigned int )(! ir->ir_empty)) % 4U;
  }
#line 51
  ir->ir_empty = (_Bool)0;
#line 52
  return (old_val);
}
}
#line 55 "i-ring.c"
int i_ring_pop(I_ring *ir ) 
{ int top_val ;
  _Bool tmp ;

  {
#line 59
  tmp = i_ring_empty((I_ring const   *)ir);
#line 59
  if (tmp) {
#line 60
    abort();
  }
#line 61
  top_val = ir->ir_data[ir->ir_front];
#line 62
  ir->ir_data[ir->ir_front] = ir->ir_default_val;
#line 63
  if (ir->ir_front == ir->ir_back) {
#line 64
    ir->ir_empty = (_Bool)1;
  } else {
#line 66
    ir->ir_front = ((ir->ir_front + 4U) - 1U) % 4U;
  }
#line 67
  return (top_val);
}
}
#line 1 "idcache.o"
#pragma merger(0,"/tmp/cil-UXRXXj5q.i","-g,-O2")
#line 6 "idcache.h"
char *getuser(uid_t uid ) ;
#line 7
char *getgroup(gid_t gid ) ;
#line 8
uid_t *getuidbyname(char const   *user ) ;
#line 9
gid_t *getgidbyname(char const   *group ) ;
#line 111 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 117
extern struct passwd *getpwnam(char const   *__name ) ;
#line 107 "/usr/include/grp.h"
extern struct group *getgrgid(__gid_t __gid ) ;
#line 113
extern struct group *getgrnam(char const   *__name ) ;
#line 54 "idcache.c"
static struct userid *user_alist  ;
#line 57 "idcache.c"
static struct userid *nouser_alist  ;
#line 60 "idcache.c"
static struct userid *group_alist  ;
#line 63 "idcache.c"
static struct userid *nogroup_alist  ;
#line 67 "idcache.c"
char *getuser(uid_t uid ) 
{ struct userid *tail ;
  struct userid *match ;
  struct passwd *pwent ;
  struct passwd *tmp ;
  char const   *name ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;

  {
#line 71
  match = (struct userid *)((void *)0);
#line 73
  tail = user_alist;
#line 73
  while (tail) {
#line 75
    if (tail->id.u == uid) {
#line 77
      match = tail;
#line 78
      break;
    }
#line 73
    tail = tail->next;
  }
#line 82
  if ((unsigned long )match == (unsigned long )((void *)0)) {
#line 84
    tmp = getpwuid(uid);
#line 84
    pwent = tmp;
#line 85
    if (pwent) {
#line 85
      tmp___0 = (char const   *)pwent->pw_name;
    } else {
#line 85
      tmp___0 = "";
    }
#line 85
    name = tmp___0;
#line 86
    tmp___1 = strlen(name);
#line 86
    tmp___2 = xmalloc(((size_t )((unsigned int )(& ((struct userid *)0)->name)) + tmp___1) + 1UL);
#line 86
    match = (struct userid *)tmp___2;
#line 87
    match->id.u = uid;
#line 88
    strcpy((char * __restrict  )(match->name), (char const   * __restrict  )name);
#line 91
    match->next = user_alist;
#line 92
    user_alist = match;
  }
#line 95
  if (match->name[0]) {
#line 95
    tmp___3 = match->name;
  } else {
#line 95
    tmp___3 = (char *)((void *)0);
  }
#line 95
  return (tmp___3);
}
}
#line 103 "idcache.c"
uid_t *getuidbyname(char const   *user ) 
{ struct userid *tail ;
  struct passwd *pwent ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  void *tmp___14 ;

  {
#line 109
  tail = user_alist;
#line 109
  while (tail) {
#line 111
    if ((int )tail->name[0] == (int )*user) {
#line 111
      if (0) {
#line 111
        __s1_len = __builtin_strlen((char const   *)(tail->name));
#line 111
        __s2_len = __builtin_strlen(user);
#line 111
        if (! ((size_t )((void const   *)(tail->name + 1)) - (size_t )((void const   *)(tail->name)) == 1UL)) {
#line 111
          goto _L___0;
        } else
#line 111
        if (__s1_len >= 4UL) {
          _L___0: 
#line 111
          if (! ((size_t )((void const   *)(user + 1)) - (size_t )((void const   *)user) == 1UL)) {
#line 111
            tmp___5 = 1;
          } else
#line 111
          if (__s2_len >= 4UL) {
#line 111
            tmp___5 = 1;
          } else {
#line 111
            tmp___5 = 0;
          }
        } else {
#line 111
          tmp___5 = 0;
        }
#line 111
        if (tmp___5) {
#line 111
          tmp___0 = __builtin_strcmp((char const   *)(tail->name), user);
#line 111
          tmp___4 = tmp___0;
        } else {
#line 111
          tmp___3 = __builtin_strcmp((char const   *)(tail->name), user);
#line 111
          tmp___4 = tmp___3;
        }
      } else {
#line 111
        tmp___3 = __builtin_strcmp((char const   *)(tail->name), user);
#line 111
        tmp___4 = tmp___3;
      }
#line 111
      if (! tmp___4) {
#line 112
        return (& tail->id.u);
      }
    }
#line 109
    tail = tail->next;
  }
#line 114
  tail = nouser_alist;
#line 114
  while (tail) {
#line 116
    if ((int )tail->name[0] == (int )*user) {
#line 116
      if (0) {
#line 116
        __s1_len___0 = __builtin_strlen((char const   *)(tail->name));
#line 116
        __s2_len___0 = __builtin_strlen(user);
#line 116
        if (! ((size_t )((void const   *)(tail->name + 1)) - (size_t )((void const   *)(tail->name)) == 1UL)) {
#line 116
          goto _L___2;
        } else
#line 116
        if (__s1_len___0 >= 4UL) {
          _L___2: 
#line 116
          if (! ((size_t )((void const   *)(user + 1)) - (size_t )((void const   *)user) == 1UL)) {
#line 116
            tmp___12 = 1;
          } else
#line 116
          if (__s2_len___0 >= 4UL) {
#line 116
            tmp___12 = 1;
          } else {
#line 116
            tmp___12 = 0;
          }
        } else {
#line 116
          tmp___12 = 0;
        }
#line 116
        if (tmp___12) {
#line 116
          tmp___7 = __builtin_strcmp((char const   *)(tail->name), user);
#line 116
          tmp___11 = tmp___7;
        } else {
#line 116
          tmp___10 = __builtin_strcmp((char const   *)(tail->name), user);
#line 116
          tmp___11 = tmp___10;
        }
      } else {
#line 116
        tmp___10 = __builtin_strcmp((char const   *)(tail->name), user);
#line 116
        tmp___11 = tmp___10;
      }
#line 116
      if (! tmp___11) {
#line 117
        return ((uid_t *)((void *)0));
      }
    }
#line 114
    tail = tail->next;
  }
#line 119
  pwent = getpwnam(user);
#line 130
  tmp___13 = strlen(user);
#line 130
  tmp___14 = xmalloc(((size_t )((unsigned int )(& ((struct userid *)0)->name)) + tmp___13) + 1UL);
#line 130
  tail = (struct userid *)tmp___14;
#line 131
  strcpy((char * __restrict  )(tail->name), (char const   * __restrict  )user);
#line 134
  if (pwent) {
#line 136
    tail->id.u = pwent->pw_uid;
#line 137
    tail->next = user_alist;
#line 138
    user_alist = tail;
#line 139
    return (& tail->id.u);
  }
#line 142
  tail->next = nouser_alist;
#line 143
  nouser_alist = tail;
#line 144
  return ((uid_t *)((void *)0));
}
}
#line 149 "idcache.c"
char *getgroup(gid_t gid ) 
{ struct userid *tail ;
  struct userid *match ;
  struct group *grent ;
  struct group *tmp ;
  char const   *name ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;

  {
#line 153
  match = (struct userid *)((void *)0);
#line 155
  tail = group_alist;
#line 155
  while (tail) {
#line 157
    if (tail->id.g == gid) {
#line 159
      match = tail;
#line 160
      break;
    }
#line 155
    tail = tail->next;
  }
#line 164
  if ((unsigned long )match == (unsigned long )((void *)0)) {
#line 166
    tmp = getgrgid(gid);
#line 166
    grent = tmp;
#line 167
    if (grent) {
#line 167
      tmp___0 = (char const   *)grent->gr_name;
    } else {
#line 167
      tmp___0 = "";
    }
#line 167
    name = tmp___0;
#line 168
    tmp___1 = strlen(name);
#line 168
    tmp___2 = xmalloc(((size_t )((unsigned int )(& ((struct userid *)0)->name)) + tmp___1) + 1UL);
#line 168
    match = (struct userid *)tmp___2;
#line 169
    match->id.g = gid;
#line 170
    strcpy((char * __restrict  )(match->name), (char const   * __restrict  )name);
#line 173
    match->next = group_alist;
#line 174
    group_alist = match;
  }
#line 177
  if (match->name[0]) {
#line 177
    tmp___3 = match->name;
  } else {
#line 177
    tmp___3 = (char *)((void *)0);
  }
#line 177
  return (tmp___3);
}
}
#line 185 "idcache.c"
gid_t *getgidbyname(char const   *group ) 
{ struct userid *tail ;
  struct group *grent ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  void *tmp___14 ;

  {
#line 191
  tail = group_alist;
#line 191
  while (tail) {
#line 193
    if ((int )tail->name[0] == (int )*group) {
#line 193
      if (0) {
#line 193
        __s1_len = __builtin_strlen((char const   *)(tail->name));
#line 193
        __s2_len = __builtin_strlen(group);
#line 193
        if (! ((size_t )((void const   *)(tail->name + 1)) - (size_t )((void const   *)(tail->name)) == 1UL)) {
#line 193
          goto _L___0;
        } else
#line 193
        if (__s1_len >= 4UL) {
          _L___0: 
#line 193
          if (! ((size_t )((void const   *)(group + 1)) - (size_t )((void const   *)group) == 1UL)) {
#line 193
            tmp___5 = 1;
          } else
#line 193
          if (__s2_len >= 4UL) {
#line 193
            tmp___5 = 1;
          } else {
#line 193
            tmp___5 = 0;
          }
        } else {
#line 193
          tmp___5 = 0;
        }
#line 193
        if (tmp___5) {
#line 193
          tmp___0 = __builtin_strcmp((char const   *)(tail->name), group);
#line 193
          tmp___4 = tmp___0;
        } else {
#line 193
          tmp___3 = __builtin_strcmp((char const   *)(tail->name), group);
#line 193
          tmp___4 = tmp___3;
        }
      } else {
#line 193
        tmp___3 = __builtin_strcmp((char const   *)(tail->name), group);
#line 193
        tmp___4 = tmp___3;
      }
#line 193
      if (! tmp___4) {
#line 194
        return (& tail->id.g);
      }
    }
#line 191
    tail = tail->next;
  }
#line 196
  tail = nogroup_alist;
#line 196
  while (tail) {
#line 198
    if ((int )tail->name[0] == (int )*group) {
#line 198
      if (0) {
#line 198
        __s1_len___0 = __builtin_strlen((char const   *)(tail->name));
#line 198
        __s2_len___0 = __builtin_strlen(group);
#line 198
        if (! ((size_t )((void const   *)(tail->name + 1)) - (size_t )((void const   *)(tail->name)) == 1UL)) {
#line 198
          goto _L___2;
        } else
#line 198
        if (__s1_len___0 >= 4UL) {
          _L___2: 
#line 198
          if (! ((size_t )((void const   *)(group + 1)) - (size_t )((void const   *)group) == 1UL)) {
#line 198
            tmp___12 = 1;
          } else
#line 198
          if (__s2_len___0 >= 4UL) {
#line 198
            tmp___12 = 1;
          } else {
#line 198
            tmp___12 = 0;
          }
        } else {
#line 198
          tmp___12 = 0;
        }
#line 198
        if (tmp___12) {
#line 198
          tmp___7 = __builtin_strcmp((char const   *)(tail->name), group);
#line 198
          tmp___11 = tmp___7;
        } else {
#line 198
          tmp___10 = __builtin_strcmp((char const   *)(tail->name), group);
#line 198
          tmp___11 = tmp___10;
        }
      } else {
#line 198
        tmp___10 = __builtin_strcmp((char const   *)(tail->name), group);
#line 198
        tmp___11 = tmp___10;
      }
#line 198
      if (! tmp___11) {
#line 199
        return ((gid_t *)((void *)0));
      }
    }
#line 196
    tail = tail->next;
  }
#line 201
  grent = getgrnam(group);
#line 212
  tmp___13 = strlen(group);
#line 212
  tmp___14 = xmalloc(((size_t )((unsigned int )(& ((struct userid *)0)->name)) + tmp___13) + 1UL);
#line 212
  tail = (struct userid *)tmp___14;
#line 213
  strcpy((char * __restrict  )(tail->name), (char const   * __restrict  )group);
#line 216
  if (grent) {
#line 218
    tail->id.g = grent->gr_gid;
#line 219
    tail->next = group_alist;
#line 220
    group_alist = tail;
#line 221
    return (& tail->id.g);
  }
#line 224
  tail->next = nogroup_alist;
#line 225
  nogroup_alist = tail;
#line 226
  return ((gid_t *)((void *)0));
}
}
#line 1 "ino-map.o"
#pragma merger(0,"/tmp/cil-STWqJWJl.i","-g,-O2")
#line 16 "ino-map.h"
void ino_map_free(struct ino_map *map )  __attribute__((__nonnull__(1))) ;
#line 53 "ino-map.c"
static size_t ino_hash(void const   *x , size_t table_size ) 
{ struct ino_map_ent  const  *p ;
  ino_t ino ;
  size_t h ;
  unsigned int i ;
  unsigned int n_words ;

  {
#line 56
  p = (struct ino_map_ent  const  *)x;
#line 57
  ino = (ino_t )p->ino;
#line 62
  h = ino;
#line 64
  n_words = (unsigned int )(sizeof(ino) / sizeof(h) + (unsigned long )(sizeof(ino) % sizeof(h) != 0UL));
#line 65
  i = 1U;
#line 65
  while (i < n_words) {
#line 66
    h ^= ino >> (8UL * sizeof(h)) * (unsigned long )i;
#line 65
    i ++;
  }
#line 68
  return (h % table_size);
}
}
#line 72 "ino-map.c"
static _Bool ino_compare(void const   *x , void const   *y ) 
{ struct ino_map_ent  const  *a ;
  struct ino_map_ent  const  *b ;

  {
#line 75
  a = (struct ino_map_ent  const  *)x;
#line 76
  b = (struct ino_map_ent  const  *)y;
#line 77
  return ((_Bool )(a->ino == b->ino));
}
}
#line 82 "ino-map.c"
struct ino_map *ino_map_alloc(size_t next_mapped_ino ) 
{ struct ino_map *im ;
  void *tmp ;

  {
#line 85
  tmp = malloc(sizeof(*im));
#line 85
  im = (struct ino_map *)tmp;
#line 87
  if (im) {
#line 90
    im->map = hash_initialize((size_t )1021, (Hash_tuning const   *)((void *)0), & ino_hash,
                              & ino_compare, & free);
#line 92
    if (! im->map) {
#line 94
      free((void *)im);
#line 95
      return ((struct ino_map *)((void *)0));
    }
#line 97
    im->next_mapped_ino = next_mapped_ino;
#line 98
    im->probe = (struct ino_map_ent *)((void *)0);
  }
#line 101
  return (im);
}
}
#line 105
void ino_map_free(struct ino_map *map )  __attribute__((__nonnull__(1))) ;
#line 105 "ino-map.c"
void ino_map_free(struct ino_map *map ) 
{ 

  {
#line 108
  hash_free(map->map);
#line 109
  free((void *)map->probe);
#line 110
  free((void *)map);
#line 111
  return;
}
}
#line 118
size_t ino_map_insert(struct ino_map *im , ino_t ino )  __attribute__((__nonnull__(1))) ;
#line 118 "ino-map.c"
size_t ino_map_insert(struct ino_map *im , ino_t ino ) 
{ struct ino_map_ent *ent ;
  struct ino_map_ent *probe ;
  void *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;

  {
#line 124
  probe = im->probe;
#line 125
  if (probe) {
#line 128
    if (probe->ino == ino) {
#line 129
      return (probe->mapped_ino);
    }
  } else {
#line 133
    tmp = malloc(sizeof(*probe));
#line 133
    probe = (struct ino_map_ent *)tmp;
#line 133
    im->probe = probe;
#line 134
    if (! probe) {
#line 135
      return ((size_t )-1);
    }
  }
#line 138
  probe->ino = ino;
#line 139
  tmp___0 = hash_insert(im->map, (void const   *)probe);
#line 139
  ent = (struct ino_map_ent *)tmp___0;
#line 140
  if (! ent) {
#line 141
    return ((size_t )-1);
  }
#line 143
  if ((unsigned long )ent != (unsigned long )probe) {
#line 146
    probe->mapped_ino = ent->mapped_ino;
  } else {
#line 157
    im->probe = (struct ino_map_ent *)((void *)0);
#line 160
    tmp___1 = im->next_mapped_ino;
#line 160
    (im->next_mapped_ino) ++;
#line 160
    probe->mapped_ino = tmp___1;
  }
#line 163
  return (probe->mapped_ino);
}
}
#line 1 "imaxtostr.o"
#pragma merger(0,"/tmp/cil-M2o9sadc.i","-g,-O2")
#line 22 "anytostr.c"
#pragma GCC diagnostic ignored "-Wtype-limits"
#line 42 "inttostr.h"
char * __attribute__((__warn_unused_result__)) imaxtostr(intmax_t i , char *buf___1 )  __attribute__((__warn_unused_result__)) ;
#line 33 "anytostr.c"
char * __attribute__((__warn_unused_result__)) imaxtostr(intmax_t i , char *buf___1 )  __attribute__((__warn_unused_result__)) ;
#line 33 "anytostr.c"
char * __attribute__((__warn_unused_result__)) imaxtostr(intmax_t i , char *buf___1 ) 
{ char *p ;

  {
#line 36
  p = buf___1 + (((sizeof(intmax_t ) * 8UL - 1UL) * 146UL + 484UL) / 485UL + 1UL);
#line 37
  *p = (char)0;
#line 39
  if (i < 0L) {
#line 41
    while (1) {
#line 42
      p --;
#line 42
      *p = (char )(48L - i % 10L);
#line 41
      i /= 10L;
#line 41
      if (! (i != 0L)) {
#line 41
        break;
      }
    }
#line 45
    p --;
#line 45
    *p = (char )'-';
  } else {
#line 49
    while (1) {
#line 50
      p --;
#line 50
      *p = (char )(48L + i % 10L);
#line 49
      i /= 10L;
#line 49
      if (! (i != 0L)) {
#line 49
        break;
      }
    }
  }
#line 54
  return (p);
}
}
#line 1 "inttostr.o"
#pragma merger(0,"/tmp/cil-yJAvgcLC.i","-g,-O2")
#line 22 "anytostr.c"
#pragma GCC diagnostic ignored "-Wtype-limits"
#line 43 "inttostr.h"
char * __attribute__((__warn_unused_result__)) inttostr(int i , char *buf___1 )  __attribute__((__warn_unused_result__)) ;
#line 33 "anytostr.c"
char * __attribute__((__warn_unused_result__)) inttostr(int i , char *buf___1 )  __attribute__((__warn_unused_result__)) ;
#line 33 "anytostr.c"
char * __attribute__((__warn_unused_result__)) inttostr(int i , char *buf___1 ) 
{ char *p ;

  {
#line 36
  p = buf___1 + (((sizeof(int ) * 8UL - 1UL) * 146UL + 484UL) / 485UL + 1UL);
#line 37
  *p = (char)0;
#line 39
  if (i < 0) {
#line 41
    while (1) {
#line 42
      p --;
#line 42
      *p = (char )(48 - i % 10);
#line 41
      i /= 10;
#line 41
      if (! (i != 0)) {
#line 41
        break;
      }
    }
#line 45
    p --;
#line 45
    *p = (char )'-';
  } else {
#line 49
    while (1) {
#line 50
      p --;
#line 50
      *p = (char )(48 + i % 10);
#line 49
      i /= 10;
#line 49
      if (! (i != 0)) {
#line 49
        break;
      }
    }
  }
#line 54
  return (p);
}
}
#line 1 "offtostr.o"
#pragma merger(0,"/tmp/cil-RowT0Odn.i","-g,-O2")
#line 22 "anytostr.c"
#pragma GCC diagnostic ignored "-Wtype-limits"
#line 44 "inttostr.h"
char * __attribute__((__warn_unused_result__)) offtostr(off_t i , char *buf___1 )  __attribute__((__warn_unused_result__)) ;
#line 33 "anytostr.c"
char * __attribute__((__warn_unused_result__)) offtostr(off_t i , char *buf___1 )  __attribute__((__warn_unused_result__)) ;
#line 33 "anytostr.c"
char * __attribute__((__warn_unused_result__)) offtostr(off_t i , char *buf___1 ) 
{ char *p ;

  {
#line 36
  p = buf___1 + (((sizeof(off_t ) * 8UL - 1UL) * 146UL + 484UL) / 485UL + 1UL);
#line 37
  *p = (char)0;
#line 39
  if (i < 0L) {
#line 41
    while (1) {
#line 42
      p --;
#line 42
      *p = (char )(48L - i % 10L);
#line 41
      i /= 10L;
#line 41
      if (! (i != 0L)) {
#line 41
        break;
      }
    }
#line 45
    p --;
#line 45
    *p = (char )'-';
  } else {
#line 49
    while (1) {
#line 50
      p --;
#line 50
      *p = (char )(48L + i % 10L);
#line 49
      i /= 10L;
#line 49
      if (! (i != 0L)) {
#line 49
        break;
      }
    }
  }
#line 54
  return (p);
}
}
#line 1 "uinttostr.o"
#pragma merger(0,"/tmp/cil-mPLJU93n.i","-g,-O2")
#line 22 "anytostr.c"
#pragma GCC diagnostic ignored "-Wtype-limits"
#line 45 "inttostr.h"
char * __attribute__((__warn_unused_result__)) uinttostr(unsigned int i , char *buf___1 )  __attribute__((__warn_unused_result__)) ;
#line 33 "anytostr.c"
char * __attribute__((__warn_unused_result__)) uinttostr(unsigned int i , char *buf___1 )  __attribute__((__warn_unused_result__)) ;
#line 33 "anytostr.c"
char * __attribute__((__warn_unused_result__)) uinttostr(unsigned int i , char *buf___1 ) 
{ char *p ;

  {
#line 36
  p = buf___1 + ((sizeof(unsigned int ) * 8UL) * 146UL + 484UL) / 485UL;
#line 37
  *p = (char)0;
#line 39
  if (i < 0U) {
#line 41
    while (1) {
#line 42
      p --;
#line 42
      *p = (char )(48U - i % 10U);
#line 41
      i /= 10U;
#line 41
      if (! (i != 0U)) {
#line 41
        break;
      }
    }
#line 45
    p --;
#line 45
    *p = (char )'-';
  } else {
#line 49
    while (1) {
#line 50
      p --;
#line 50
      *p = (char )(48U + i % 10U);
#line 49
      i /= 10U;
#line 49
      if (! (i != 0U)) {
#line 49
        break;
      }
    }
  }
#line 54
  return (p);
}
}
#line 1 "umaxtostr.o"
#pragma merger(0,"/tmp/cil-5smMv8wp.i","-g,-O2")
#line 22 "anytostr.c"
#pragma GCC diagnostic ignored "-Wtype-limits"
#line 46 "inttostr.h"
char * __attribute__((__warn_unused_result__)) umaxtostr(uintmax_t i , char *buf___1 )  __attribute__((__warn_unused_result__)) ;
#line 33 "anytostr.c"
char * __attribute__((__warn_unused_result__)) umaxtostr(uintmax_t i , char *buf___1 )  __attribute__((__warn_unused_result__)) ;
#line 33 "anytostr.c"
char * __attribute__((__warn_unused_result__)) umaxtostr(uintmax_t i , char *buf___1 ) 
{ char *p ;

  {
#line 36
  p = buf___1 + ((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL;
#line 37
  *p = (char)0;
#line 39
  if (i < 0UL) {
#line 41
    while (1) {
#line 42
      p --;
#line 42
      *p = (char )(48UL - i % 10UL);
#line 41
      i /= 10UL;
#line 41
      if (! (i != 0UL)) {
#line 41
        break;
      }
    }
#line 45
    p --;
#line 45
    *p = (char )'-';
  } else {
#line 49
    while (1) {
#line 50
      p --;
#line 50
      *p = (char )(48UL + i % 10UL);
#line 49
      i /= 10UL;
#line 49
      if (! (i != 0UL)) {
#line 49
        break;
      }
    }
  }
#line 54
  return (p);
}
}
#line 1 "ldtoastr.o"
#pragma merger(0,"/tmp/cil-qGn38_1r.i","-g,-O2")
#line 49 "ftoastr.h"
int ldtoastr(char *buf___1 , size_t bufsize___0 , int flags , int width , long double x ) ;
#line 176 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long double strtold(char const   * __restrict  __nptr ,
                                                         char ** __restrict  __endptr )  __attribute__((__warn_unused_result__,
__nonnull__(1))) ;
#line 99 "ftoastr.c"
int ldtoastr(char *buf___1 , size_t bufsize___0 , int flags , int width , long double x ) 
{ char format[sizeof("%-+ 0*.*Lg")] ;
  long double abs_x ;
  long double tmp ;
  int prec ;
  char *p ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int n ;
  int __attribute__((__artificial__))  tmp___5 ;
  long double tmp___6 ;

  {
#line 111
  if (x < (long double )0) {
#line 111
    tmp = - x;
  } else {
#line 111
    tmp = x;
  }
#line 111
  abs_x = tmp;
#line 114
  p = format;
#line 115
  tmp___0 = p;
#line 115
  p ++;
#line 115
  *tmp___0 = (char )'%';
#line 118
  *p = (char )'-';
#line 118
  p += (flags & 1) != 0;
#line 119
  *p = (char )'+';
#line 119
  p += (flags & 2) != 0;
#line 120
  *p = (char )' ';
#line 120
  p += (flags & 4) != 0;
#line 121
  *p = (char )'0';
#line 121
  p += (flags & 8) != 0;
#line 123
  tmp___1 = p;
#line 123
  p ++;
#line 123
  *tmp___1 = (char )'*';
#line 124
  tmp___2 = p;
#line 124
  p ++;
#line 124
  *tmp___2 = (char )'.';
#line 125
  tmp___3 = p;
#line 125
  p ++;
#line 125
  *tmp___3 = (char )'*';
#line 126
  *p = (char )'L';
#line 126
  p ++;
#line 127
  tmp___4 = p;
#line 127
  p ++;
#line 127
  if (flags & 16) {
#line 127
    *tmp___4 = (char )'G';
  } else {
#line 127
    *tmp___4 = (char )'g';
  }
#line 128
  *p = (char )'\000';
#line 130
  if (abs_x < 3.36210314311209350626e-4932L) {
#line 130
    prec = 1;
  } else {
#line 130
    prec = 18;
  }
#line 130
  while (1) {
#line 132
    tmp___5 = snprintf((char * __restrict  )buf___1, bufsize___0, (char const   * __restrict  )(format),
                       width, prec, x);
#line 132
    n = (int )tmp___5;
#line 133
    if (n < 0) {
#line 136
      return (n);
    } else
#line 133
    if (21 <= prec) {
#line 136
      return (n);
    } else
#line 133
    if ((size_t )n < bufsize___0) {
#line 133
      tmp___6 = strtold((char const   * __restrict  )buf___1, (char ** __restrict  )((void *)0));
#line 133
      if (tmp___6 == x) {
#line 136
        return (n);
      }
    }
#line 130
    prec ++;
  }
}
}
#line 1 "linebuffer.o"
#pragma merger(0,"/tmp/cil-1GvUG_eX.i","-g,-O2")
#line 34 "linebuffer.h"
void initbuffer(struct linebuffer *linebuffer ) ;
#line 41
struct linebuffer *readlinebuffer_delim(struct linebuffer *linebuffer , FILE *stream ,
                                        char delimiter ) ;
#line 48
struct linebuffer *readlinebuffer(struct linebuffer *linebuffer , FILE *stream ) ;
#line 51
void freebuffer(struct linebuffer *linebuffer ) ;
#line 36 "linebuffer.c"
void initbuffer(struct linebuffer *linebuffer ) 
{ 

  {
#line 39
  memset((void *)linebuffer, 0, sizeof(*linebuffer));
#line 40
  return;
}
}
#line 42 "linebuffer.c"
struct linebuffer *readlinebuffer(struct linebuffer *linebuffer , FILE *stream ) 
{ struct linebuffer *tmp ;

  {
#line 45
  tmp = readlinebuffer_delim(linebuffer, stream, (char )'\n');
#line 45
  return (tmp);
}
}
#line 58 "linebuffer.c"
struct linebuffer *readlinebuffer_delim(struct linebuffer *linebuffer , FILE *stream ,
                                        char delimiter ) 
{ int c ;
  char *buffer ;
  char *p ;
  char *end ;
  int tmp ;
  int tmp___0 ;
  size_t oldsize ;
  void *tmp___1 ;
  char *tmp___2 ;

  {
#line 63
  buffer = linebuffer->buffer;
#line 64
  p = linebuffer->buffer;
#line 65
  end = buffer + linebuffer->size;
#line 67
  tmp = feof_unlocked(stream);
#line 67
  if (tmp) {
#line 68
    return ((struct linebuffer *)((void *)0));
  }
#line 70
  while (1) {
#line 72
    c = getc_unlocked(stream);
#line 73
    if (c == -1) {
#line 75
      if ((unsigned long )p == (unsigned long )buffer) {
#line 76
        return ((struct linebuffer *)((void *)0));
      } else {
#line 75
        tmp___0 = ferror_unlocked(stream);
#line 75
        if (tmp___0) {
#line 76
          return ((struct linebuffer *)((void *)0));
        }
      }
#line 77
      if ((int )*(p + -1) == (int )delimiter) {
#line 78
        break;
      }
#line 79
      c = (int )delimiter;
    }
#line 81
    if ((unsigned long )p == (unsigned long )end) {
#line 83
      oldsize = linebuffer->size;
#line 84
      tmp___1 = x2realloc((void *)buffer, & linebuffer->size);
#line 84
      buffer = (char *)tmp___1;
#line 85
      p = buffer + oldsize;
#line 86
      linebuffer->buffer = buffer;
#line 87
      end = buffer + linebuffer->size;
    }
#line 89
    tmp___2 = p;
#line 89
    p ++;
#line 89
    *tmp___2 = (char )c;
#line 70
    if (! (c != (int )delimiter)) {
#line 70
      break;
    }
  }
#line 93
  linebuffer->length = (size_t )(p - buffer);
#line 94
  return (linebuffer);
}
}
#line 99 "linebuffer.c"
void freebuffer(struct linebuffer *linebuffer ) 
{ 

  {
#line 102
  free((void *)linebuffer->buffer);
#line 103
  return;
}
}
#line 1 "localcharset.o"
#pragma merger(0,"/tmp/cil-utpmCqBC.i","-g,-O2")
#line 35 "localcharset.h"
char const   *locale_charset(void) ;
#line 427 "/usr/include/stdio.h"
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...)  __attribute__((__warn_unused_result__)) ;
#line 695
extern int ungetc(int __c , FILE *__stream ) ;
#line 584 "/usr/include/langinfo.h"
extern  __attribute__((__nothrow__)) char *nl_langinfo(nl_item __item ) ;
#line 117 "localcharset.c"
static char const   * volatile  charset_aliases  ;
#line 120 "localcharset.c"
static char const   *get_charset_aliases(void) 
{ char const   *cp ;
  char const   *dir ;
  char const   *base ;
  char *file_name___1 ;
  char *tmp ;
  size_t dir_len___0 ;
  size_t tmp___0 ;
  size_t base_len___0 ;
  size_t tmp___1 ;
  int add_slash ;
  int tmp___2 ;
  void *tmp___3 ;
  int fd ;
  int __attribute__((__artificial__))  tmp___4 ;
  FILE *fp ;
  char *res_ptr ;
  size_t res_size ;
  int c ;
  char buf1[51] ;
  char buf2[51] ;
  size_t l1 ;
  size_t l2 ;
  char *old_res_ptr ;
  int tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;

  {
#line 125
  cp = (char const   *)charset_aliases;
#line 126
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 130
    base = "charset.alias";
#line 135
    tmp = getenv("CHARSETALIASDIR");
#line 135
    dir = (char const   *)tmp;
#line 136
    if ((unsigned long )dir == (unsigned long )((void *)0)) {
#line 137
      dir = "/usr/local/lib";
    } else
#line 136
    if ((int const   )*(dir + 0) == 0) {
#line 137
      dir = "/usr/local/lib";
    }
#line 141
    tmp___0 = strlen(dir);
#line 141
    dir_len___0 = tmp___0;
#line 142
    tmp___1 = strlen(base);
#line 142
    base_len___0 = tmp___1;
#line 143
    if (dir_len___0 > 0UL) {
#line 143
      if (! ((int const   )*(dir + (dir_len___0 - 1UL)) == 47)) {
#line 143
        tmp___2 = 1;
      } else {
#line 143
        tmp___2 = 0;
      }
    } else {
#line 143
      tmp___2 = 0;
    }
#line 143
    add_slash = tmp___2;
#line 144
    tmp___3 = malloc(((dir_len___0 + (size_t )add_slash) + base_len___0) + 1UL);
#line 144
    file_name___1 = (char *)tmp___3;
#line 145
    if ((unsigned long )file_name___1 != (unsigned long )((void *)0)) {
#line 147
      memcpy((void * __restrict  )file_name___1, (void const   * __restrict  )dir,
             dir_len___0);
#line 148
      if (add_slash) {
#line 149
        *(file_name___1 + dir_len___0) = (char )'/';
      }
#line 150
      memcpy((void * __restrict  )((file_name___1 + dir_len___0) + add_slash), (void const   * __restrict  )base,
             base_len___0 + 1UL);
    }
#line 154
    if ((unsigned long )file_name___1 == (unsigned long )((void *)0)) {
#line 156
      cp = "";
    } else {
#line 168
      tmp___4 = open((char const   *)file_name___1, 131072);
#line 168
      fd = (int )tmp___4;
#line 170
      if (fd < 0) {
#line 172
        cp = "";
      } else {
#line 177
        fp = fdopen(fd, "r");
#line 178
        if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 181
          close(fd);
#line 182
          cp = "";
        } else {
#line 187
          res_ptr = (char *)((void *)0);
#line 188
          res_size = (size_t )0;
#line 190
          while (1) {
#line 198
            c = getc_unlocked(fp);
#line 199
            if (c == -1) {
#line 200
              break;
            }
#line 201
            if (c == 10) {
#line 202
              goto __Cont;
            } else
#line 201
            if (c == 32) {
#line 202
              goto __Cont;
            } else
#line 201
            if (c == 9) {
#line 202
              goto __Cont;
            }
#line 203
            if (c == 35) {
#line 206
              while (1) {
#line 207
                c = getc_unlocked(fp);
#line 206
                if (c == -1) {
#line 206
                  break;
                } else
#line 206
                if (c == 10) {
#line 206
                  break;
                }
              }
#line 209
              if (c == -1) {
#line 210
                break;
              }
#line 211
              goto __Cont;
            }
#line 213
            ungetc(c, fp);
#line 214
            tmp___5 = fscanf((FILE * __restrict  )fp, (char const   * __restrict  )"%50s %50s",
                             buf1, buf2);
#line 214
            if (tmp___5 < 2) {
#line 215
              break;
            }
#line 216
            l1 = strlen((char const   *)(buf1));
#line 217
            l2 = strlen((char const   *)(buf2));
#line 218
            old_res_ptr = res_ptr;
#line 219
            if (res_size == 0UL) {
#line 221
              res_size = ((l1 + 1UL) + l2) + 1UL;
#line 222
              tmp___6 = malloc(res_size + 1UL);
#line 222
              res_ptr = (char *)tmp___6;
            } else {
#line 226
              res_size += ((l1 + 1UL) + l2) + 1UL;
#line 227
              tmp___7 = realloc((void *)res_ptr, res_size + 1UL);
#line 227
              res_ptr = (char *)tmp___7;
            }
#line 229
            if ((unsigned long )res_ptr == (unsigned long )((void *)0)) {
#line 232
              res_size = (size_t )0;
#line 233
              free((void *)old_res_ptr);
#line 234
              break;
            }
#line 236
            strcpy((char * __restrict  )(((res_ptr + res_size) - (l2 + 1UL)) - (l1 + 1UL)),
                   (char const   * __restrict  )(buf1));
#line 237
            strcpy((char * __restrict  )((res_ptr + res_size) - (l2 + 1UL)), (char const   * __restrict  )(buf2));
            __Cont: ;
          }
#line 239
          rpl_fclose(fp);
#line 240
          if (res_size == 0UL) {
#line 241
            cp = "";
          } else {
#line 244
            *(res_ptr + res_size) = (char )'\000';
#line 245
            cp = (char const   *)res_ptr;
          }
        }
      }
#line 250
      free((void *)file_name___1);
    }
#line 344
    charset_aliases = (char const   * volatile  )cp;
  }
#line 347
  return (cp);
}
}
#line 359 "localcharset.c"
char const   *locale_charset(void) 
{ char const   *codeset ;
  char const   *aliases ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 370
  tmp = nl_langinfo(14);
#line 370
  codeset = (char const   *)tmp;
#line 527
  if ((unsigned long )codeset == (unsigned long )((void *)0)) {
#line 529
    codeset = "";
  }
#line 532
  aliases = get_charset_aliases();
#line 532
  while ((int const   )*aliases != 0) {
#line 535
    if (0) {
#line 535
      __s1_len = __builtin_strlen(codeset);
#line 535
      __s2_len = __builtin_strlen(aliases);
#line 535
      if (! ((size_t )((void const   *)(codeset + 1)) - (size_t )((void const   *)codeset) == 1UL)) {
#line 535
        goto _L___0;
      } else
#line 535
      if (__s1_len >= 4UL) {
        _L___0: 
#line 535
        if (! ((size_t )((void const   *)(aliases + 1)) - (size_t )((void const   *)aliases) == 1UL)) {
#line 535
          tmp___9 = 1;
        } else
#line 535
        if (__s2_len >= 4UL) {
#line 535
          tmp___9 = 1;
        } else {
#line 535
          tmp___9 = 0;
        }
      } else {
#line 535
        tmp___9 = 0;
      }
#line 535
      if (tmp___9) {
#line 535
        tmp___4 = __builtin_strcmp(codeset, aliases);
#line 535
        tmp___8 = tmp___4;
      } else {
#line 535
        tmp___7 = __builtin_strcmp(codeset, aliases);
#line 535
        tmp___8 = tmp___7;
      }
    } else {
#line 535
      tmp___7 = __builtin_strcmp(codeset, aliases);
#line 535
      tmp___8 = tmp___7;
    }
#line 535
    if (tmp___8 == 0) {
#line 538
      tmp___2 = strlen(aliases);
#line 538
      codeset = (aliases + tmp___2) + 1;
#line 539
      break;
    } else
#line 535
    if ((int const   )*(aliases + 0) == 42) {
#line 535
      if ((int const   )*(aliases + 1) == 0) {
#line 538
        tmp___2 = strlen(aliases);
#line 538
        codeset = (aliases + tmp___2) + 1;
#line 539
        break;
      }
    }
#line 532
    tmp___0 = strlen(aliases);
#line 532
    aliases += tmp___0 + 1UL;
#line 532
    tmp___1 = strlen(aliases);
#line 532
    aliases += tmp___1 + 1UL;
  }
#line 545
  if ((int const   )*(codeset + 0) == 0) {
#line 546
    codeset = "ASCII";
  }
#line 548
  return (codeset);
}
}
#line 1 "lock.o"
#pragma merger(0,"/tmp/cil-zFsvc8XO.i","-g,-O2")
#line 270 "/usr/include/pthread.h"
__inline extern  __attribute__((__nothrow__)) int pthread_equal(pthread_t __thread1 ,
                                                                pthread_t __thread2 ) ;
#line 733
extern  __attribute__((__nothrow__)) int pthread_mutex_init(pthread_mutex_t *__mutex ,
                                                            pthread_mutexattr_t const   *__mutexattr )  __attribute__((__nonnull__(1))) ;
#line 790
extern  __attribute__((__nothrow__)) int pthread_mutexattr_init(pthread_mutexattr_t *__attr )  __attribute__((__nonnull__(1))) ;
#line 794
extern  __attribute__((__nothrow__)) int pthread_mutexattr_destroy(pthread_mutexattr_t *__attr )  __attribute__((__nonnull__(1))) ;
#line 817
extern  __attribute__((__nothrow__)) int pthread_mutexattr_settype(pthread_mutexattr_t *__attr ,
                                                                   int __kind )  __attribute__((__nonnull__(1))) ;
#line 1136
__inline extern  __attribute__((__nothrow__)) int pthread_equal(pthread_t __thread1 ,
                                                                pthread_t __thread2 ) ;
#line 1136 "/usr/include/pthread.h"
__inline extern int pthread_equal(pthread_t __thread1 , pthread_t __thread2 ) 
{ 

  {
#line 1139
  return (__thread1 == __thread2);
}
}
#line 127 "./glthread/lock.h"
#pragma weak pthread_mutex_init
#line 128
#pragma weak pthread_mutex_lock
#line 129
#pragma weak pthread_mutex_unlock
#line 130
#pragma weak pthread_mutex_destroy
#line 131
#pragma weak pthread_rwlock_init
#line 132
#pragma weak pthread_rwlock_rdlock
#line 133
#pragma weak pthread_rwlock_wrlock
#line 134
#pragma weak pthread_rwlock_unlock
#line 135
#pragma weak pthread_rwlock_destroy
#line 136
#pragma weak pthread_once
#line 137
#pragma weak pthread_cond_init
#line 138
#pragma weak pthread_cond_wait
#line 139
#pragma weak pthread_cond_signal
#line 140
#pragma weak pthread_cond_broadcast
#line 141
#pragma weak pthread_cond_destroy
#line 142
#pragma weak pthread_mutexattr_init
#line 143
#pragma weak pthread_mutexattr_settype
#line 144
#pragma weak pthread_mutexattr_destroy
#line 146
#pragma weak pthread_self
#line 150
#pragma weak pthread_cancel
#line 298
int glthread_recursive_lock_init_multithreaded(gl_recursive_lock_t *lock ) ;
#line 372
int glthread_once_singlethreaded(pthread_once_t *once_control ) ;
#line 286 "glthread/lock.c"
int glthread_recursive_lock_init_multithreaded(gl_recursive_lock_t *lock ) 
{ pthread_mutexattr_t attributes ;
  int err ;

  {
#line 292
  err = pthread_mutexattr_init(& attributes);
#line 293
  if (err != 0) {
#line 294
    return (err);
  }
#line 295
  err = pthread_mutexattr_settype(& attributes, 1);
#line 296
  if (err != 0) {
#line 298
    pthread_mutexattr_destroy(& attributes);
#line 299
    return (err);
  }
#line 301
  err = pthread_mutex_init(lock, (pthread_mutexattr_t const   *)(& attributes));
#line 302
  if (err != 0) {
#line 304
    pthread_mutexattr_destroy(& attributes);
#line 305
    return (err);
  }
#line 307
  err = pthread_mutexattr_destroy(& attributes);
#line 308
  if (err != 0) {
#line 309
    return (err);
  }
#line 310
  return (0);
}
}
#line 457 "glthread/lock.c"
static int const   fresh_once  =    (pthread_once_t const   )0;
#line 459 "glthread/lock.c"
int glthread_once_singlethreaded(pthread_once_t *once_control ) 
{ char *firstbyte ;

  {
#line 464
  firstbyte = (char *)once_control;
#line 465
  if ((int )*firstbyte == (int )*((char const   *)(& fresh_once))) {
#line 468
    *firstbyte = (char )(~ ((int const   )*((char const   *)(& fresh_once))));
#line 469
    return (1);
  } else {
#line 472
    return (0);
  }
}
}
#line 1 "long-options.o"
#pragma merger(0,"/tmp/cil-5GSFnkkV.i","-g,-O2")
#line 20 "long-options.h"
void parse_long_options(int argc , char **argv , char const   *command_name , char const   *package ,
                        char const   *version , void (*usage_func)(int  )  , ...) ;
#line 544 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 162 "./getopt.h"
int rpl_optind ;
#line 167
int rpl_opterr ;
#line 245
 __attribute__((__nothrow__)) int rpl_getopt_long(int argc , char **argv , char const   *options ,
                                                  struct rpl_option  const  *long_options___1 ,
                                                  int *opt_index )  __attribute__((__nonnull__(2,3))) ;
#line 63 "version-etc.h"
void version_etc_va(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , va_list authors ) ;
#line 33 "long-options.c"
static struct rpl_option  const  long_options[3]  = {      {"help", 0, (int *)((void *)0), 'h'}, 
        {"version", 0, (int *)((void *)0), 'v'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
#line 43 "long-options.c"
void parse_long_options(int argc , char **argv , char const   *command_name , char const   *package ,
                        char const   *version , void (*usage_func)(int  )  , ...) 
{ int c ;
  int saved_opterr ;
  va_list authors ;

  {
#line 55
  saved_opterr = rpl_opterr;
#line 58
  rpl_opterr = 0;
#line 60
  if (argc == 2) {
#line 60
    c = rpl_getopt_long(argc, argv, "+", long_options, (int *)((void *)0));
#line 60
    if (c != -1) {
#line 63
      switch (c) {
      case 104: 
#line 66
      (*usage_func)(0);
      case 118: 
#line 71
      __builtin_va_start(authors, usage_func);
#line 72
      version_etc_va(stdout, command_name, package, version, authors);
#line 73
      exit(0);
      default: 
#line 78
      break;
      }
    }
  }
#line 83
  rpl_opterr = saved_opterr;
#line 87
  rpl_optind = 0;
#line 88
  return;
}
}
#line 1 "malloca.o"
#pragma merger(0,"/tmp/cil-qlCqfvCJ.i","-g,-O2")
#line 66 "malloca.h"
void *mmalloca(size_t n ) ;
#line 70
void freea(void *p ) ;
#line 64 "malloca.c"
static void *mmalloca_results[257]  ;
#line 68 "malloca.c"
void *mmalloca(size_t n ) 
{ size_t nplus ;
  char *p ;
  void *tmp ;
  size_t slot ;

  {
#line 74
  nplus = n + (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL;
#line 76
  if (nplus >= n) {
#line 78
    tmp = malloc(nplus);
#line 78
    p = (char *)tmp;
#line 80
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 84
      p += (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL;
#line 87
      *((int *)p + -1) = 336984906;
#line 90
      slot = (unsigned long )p % 257UL;
#line 91
      ((struct header *)(p - (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL))->next = mmalloca_results[slot];
#line 92
      mmalloca_results[slot] = (void *)p;
#line 94
      return ((void *)p);
    }
  }
#line 98
  return ((void *)0);
}
}
#line 109 "malloca.c"
void freea(void *p ) 
{ size_t slot ;
  void **chain ;
  char *p_begin ;

  {
#line 113
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 119
    if (*((int *)p + -1) == 336984906) {
#line 123
      slot = (unsigned long )p % 257UL;
#line 124
      chain = & mmalloca_results[slot];
#line 125
      while ((unsigned long )*chain != (unsigned long )((void *)0)) {
#line 127
        if ((unsigned long )*chain == (unsigned long )p) {
#line 130
          p_begin = (char *)p - (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL;
#line 131
          *chain = ((struct header *)p_begin)->next;
#line 132
          free((void *)p_begin);
#line 133
          return;
        }
#line 135
        chain = & ((struct header *)((char *)*chain - (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL))->next;
      }
    }
  }
#line 140
  return;
}
}
#line 1 "mbchar.o"
#pragma merger(0,"/tmp/cil-Wugf18wQ.i","-g,-O2")
#line 26 "mbchar.c"
unsigned int const   is_basic_table[8]  = 
#line 26 "mbchar.c"
  {      (unsigned int const   )6656,      (unsigned int const   )4294967279U,      (unsigned int const   )4294967294U,      (unsigned int const   )2147483646, 
        (unsigned int const   )0U,      (unsigned int const   )0U,      (unsigned int const   )0U,      (unsigned int const   )0U};
#line 1 "mbsalign.o"
#pragma merger(0,"/tmp/cil-Eh3hNPaq.i","-g,-O2")
#line 41 "mbsalign.h"
size_t mbsalign(char const   *src , char *dest , size_t dest_size , size_t *width ,
                mbs_align_t align , int flags ) ;
#line 45
char *ambsalign(char const   *src , size_t *width , mbs_align_t align , int flags ) ;
#line 437 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) int wcwidth(wchar_t __c ) ;
#line 441
extern  __attribute__((__nothrow__)) int wcswidth(wchar_t const   *__s , size_t __n ) ;
#line 137 "/usr/include/wctype.h"
extern  __attribute__((__nothrow__)) int iswprint(wint_t __wc ) ;
#line 39 "mbsalign.c"
static _Bool wc_ensure_printable(wchar_t *wchars ) 
{ _Bool replaced ;
  wchar_t *wc ;
  int tmp ;

  {
#line 42
  replaced = (_Bool)0;
#line 43
  wc = wchars;
#line 44
  while (*wc) {
#line 46
    tmp = iswprint((wint_t )*wc);
#line 46
    if (! tmp) {
#line 48
      *wc = 65533;
#line 49
      replaced = (_Bool)1;
    }
#line 51
    wc ++;
  }
#line 53
  return (replaced);
}
}
#line 59 "mbsalign.c"
static size_t wc_truncate(wchar_t *wc , size_t width ) 
{ size_t cells ;
  int next_cells ;

  {
#line 62
  cells = (size_t )0;
#line 63
  next_cells = 0;
#line 65
  while (*wc) {
#line 67
    next_cells = wcwidth(*wc);
#line 68
    if (next_cells == -1) {
#line 70
      *wc = 65533;
#line 71
      next_cells = 1;
    }
#line 73
    if (cells + (size_t )next_cells > width) {
#line 74
      break;
    }
#line 75
    cells += (size_t )next_cells;
#line 76
    wc ++;
  }
#line 78
  *wc = 0;
#line 79
  return (cells);
}
}
#line 87 "mbsalign.c"
static char *mbs_align_pad(char *dest , char const   *dest_end , size_t n_spaces ) 
{ char *tmp ;
  size_t tmp___0 ;

  {
#line 92
  while (1) {
#line 92
    tmp___0 = n_spaces;
#line 92
    n_spaces --;
#line 92
    if (tmp___0) {
#line 92
      if (! ((unsigned long )dest < (unsigned long )dest_end)) {
#line 92
        break;
      }
    } else {
#line 92
      break;
    }
#line 93
    tmp = dest;
#line 93
    dest ++;
#line 93
    *tmp = (char )' ';
  }
#line 94
  *dest = (char )'\000';
#line 95
  return (dest);
}
}
#line 111 "mbsalign.c"
size_t mbsalign(char const   *src , char *dest , size_t dest_size , size_t *width ,
                mbs_align_t align , int flags ) 
{ size_t ret ;
  size_t src_size ;
  size_t tmp ;
  char *newstr ;
  wchar_t *str_wc ;
  char const   *str_to_print ;
  size_t n_cols ;
  size_t n_used_bytes ;
  size_t n_spaces ;
  _Bool conversion ;
  _Bool wc_enabled ;
  size_t src_chars ;
  size_t __attribute__((__artificial__))  tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  size_t __attribute__((__artificial__))  tmp___3 ;
  size_t tmp___4 ;
  size_t __attribute__((__artificial__))  tmp___5 ;
  void *tmp___6 ;
  size_t __attribute__((__artificial__))  tmp___7 ;
  size_t start_spaces ;
  size_t end_spaces ;
  size_t space_left ;
  char *dest_end ;
  size_t tmp___8 ;
  void __attribute__((__artificial__))  *tmp___9 ;

  {
#line 115
  ret = 0xffffffffffffffffUL;
#line 116
  tmp = strlen(src);
#line 116
  src_size = tmp + 1UL;
#line 117
  newstr = (char *)((void *)0);
#line 118
  str_wc = (wchar_t *)((void *)0);
#line 119
  str_to_print = src;
#line 120
  n_cols = src_size - 1UL;
#line 121
  n_used_bytes = n_cols;
#line 122
  n_spaces = (size_t )0;
#line 123
  conversion = (_Bool)0;
#line 124
  wc_enabled = (_Bool)0;
#line 129
  tmp___4 = __ctype_get_mb_cur_max();
#line 129
  if (tmp___4 > 1UL) {
#line 131
    tmp___0 = mbstowcs((wchar_t * __restrict  )((void *)0), (char const   * __restrict  )src,
                       (size_t )0);
#line 131
    src_chars = (size_t )tmp___0;
#line 132
    if (src_chars == 0xffffffffffffffffUL) {
#line 134
      if (flags & 1) {
#line 135
        goto mbsalign_unibyte;
      } else {
#line 137
        goto mbsalign_cleanup;
      }
    }
#line 139
    src_chars ++;
#line 140
    tmp___1 = malloc(src_chars * sizeof(wchar_t ));
#line 140
    str_wc = (wchar_t *)tmp___1;
#line 141
    if ((unsigned long )str_wc == (unsigned long )((void *)0)) {
#line 143
      if (flags & 1) {
#line 144
        goto mbsalign_unibyte;
      } else {
#line 146
        goto mbsalign_cleanup;
      }
    }
#line 148
    tmp___3 = mbstowcs((wchar_t * __restrict  )str_wc, (char const   * __restrict  )src,
                       src_chars);
#line 148
    if (tmp___3 != (size_t __attribute__((__artificial__))  )0) {
#line 150
      *(str_wc + (src_chars - 1UL)) = 0;
#line 151
      wc_enabled = (_Bool)1;
#line 152
      conversion = wc_ensure_printable(str_wc);
#line 153
      tmp___2 = wcswidth((wchar_t const   *)str_wc, src_chars);
#line 153
      n_cols = (size_t )tmp___2;
    }
  }
#line 159
  if (wc_enabled) {
#line 159
    if (conversion) {
#line 159
      goto _L;
    } else
#line 159
    if (n_cols > *width) {
      _L: 
#line 161
      if (conversion) {
#line 165
        tmp___5 = wcstombs((char * __restrict  )((void *)0), (wchar_t const   * __restrict  )str_wc,
                           (size_t )0);
#line 165
        src_size = (size_t )(tmp___5 + (size_t __attribute__((__artificial__))  )1);
      }
#line 167
      tmp___6 = malloc(src_size);
#line 167
      newstr = (char *)tmp___6;
#line 168
      if ((unsigned long )newstr == (unsigned long )((void *)0)) {
#line 170
        if (flags & 1) {
#line 171
          goto mbsalign_unibyte;
        } else {
#line 173
          goto mbsalign_cleanup;
        }
      }
#line 175
      str_to_print = (char const   *)newstr;
#line 176
      n_cols = wc_truncate(str_wc, *width);
#line 177
      tmp___7 = wcstombs((char * __restrict  )newstr, (wchar_t const   * __restrict  )str_wc,
                         src_size);
#line 177
      n_used_bytes = (size_t )tmp___7;
    }
  }
  mbsalign_unibyte: 
#line 182
  if (n_cols > *width) {
#line 184
    n_cols = *width;
#line 185
    n_used_bytes = n_cols;
  }
#line 188
  if (*width > n_cols) {
#line 189
    n_spaces = *width - n_cols;
  }
#line 192
  *width = n_cols;
#line 195
  ret = n_used_bytes + n_spaces;
#line 198
  if (dest_size != 0UL) {
#line 201
    dest_end = (dest + dest_size) - 1;
#line 203
    switch ((int )align) {
    case 0: 
#line 206
    start_spaces = (size_t )0;
#line 207
    end_spaces = n_spaces;
#line 208
    break;
    case 1: 
#line 210
    start_spaces = n_spaces;
#line 211
    end_spaces = (size_t )0;
#line 212
    break;
    default: 
#line 215
    start_spaces = n_spaces / 2UL + n_spaces % 2UL;
#line 216
    end_spaces = n_spaces / 2UL;
#line 217
    break;
    }
#line 220
    dest = mbs_align_pad(dest, (char const   *)dest_end, start_spaces);
#line 221
    space_left = (size_t )(dest_end - dest);
#line 222
    if (n_used_bytes < space_left) {
#line 222
      tmp___8 = n_used_bytes;
    } else {
#line 222
      tmp___8 = space_left;
    }
#line 222
    tmp___9 = mempcpy((void * __restrict  )dest, (void const   * __restrict  )str_to_print,
                      tmp___8);
#line 222
    dest = (char *)tmp___9;
#line 223
    mbs_align_pad(dest, (char const   *)dest_end, end_spaces);
  }
  mbsalign_cleanup: 
#line 228
  free((void *)str_wc);
#line 229
  free((void *)newstr);
#line 231
  return (ret);
}
}
#line 238 "mbsalign.c"
char *ambsalign(char const   *src , size_t *width , mbs_align_t align , int flags ) 
{ size_t orig_width ;
  size_t size ;
  size_t req ;
  char *buf___1 ;
  char *nbuf ;
  void *tmp ;

  {
#line 241
  orig_width = *width;
#line 242
  size = *width;
#line 243
  req = size;
#line 244
  buf___1 = (char *)((void *)0);
#line 246
  while (req >= size) {
#line 249
    size = req + 1UL;
#line 250
    tmp = realloc((void *)buf___1, size);
#line 250
    nbuf = (char *)tmp;
#line 251
    if ((unsigned long )nbuf == (unsigned long )((void *)0)) {
#line 253
      free((void *)buf___1);
#line 254
      buf___1 = (char *)((void *)0);
#line 255
      break;
    }
#line 257
    buf___1 = nbuf;
#line 258
    *width = orig_width;
#line 259
    req = mbsalign(src, buf___1, size, width, align, flags);
#line 260
    if (req == 0xffffffffffffffffUL) {
#line 262
      free((void *)buf___1);
#line 263
      buf___1 = (char *)((void *)0);
#line 264
      break;
    }
  }
#line 268
  return (buf___1);
}
}
#line 1 "mbscasecmp.o"
#pragma merger(0,"/tmp/cil-In6du6JB.i","-g,-O2")
#line 36 "mbscasecmp.c"
int mbscasecmp(char const   *s1 , char const   *s2 )  __attribute__((__nonnull__(1,2))) ;
#line 36 "mbscasecmp.c"
int mbscasecmp(char const   *s1 , char const   *s2 ) 
{ mbui_iterator_t iter1 ;
  mbui_iterator_t iter2 ;
  int cmp ;
  wint_t tmp ;
  wint_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  unsigned char const   *p1 ;
  unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int __res ;
  __int32_t const   **tmp___19 ;
  unsigned short const   **tmp___20 ;
  int __res___0 ;
  __int32_t const   **tmp___23 ;
  unsigned short const   **tmp___24 ;
  size_t tmp___27 ;

  {
#line 39
  if ((unsigned long )s1 == (unsigned long )s2) {
#line 40
    return (0);
  }
#line 45
  tmp___27 = __ctype_get_mb_cur_max();
#line 45
  if (tmp___27 > 1UL) {
#line 50
    iter1.cur.ptr = s1;
#line 50
    iter1.in_shift = (_Bool)0;
#line 50
    memset((void *)(& iter1.state), '\000', sizeof(mbstate_t ));
#line 50
    iter1.next_done = (_Bool)0;
#line 51
    iter2.cur.ptr = s2;
#line 51
    iter2.in_shift = (_Bool)0;
#line 51
    memset((void *)(& iter2.state), '\000', sizeof(mbstate_t ));
#line 51
    iter2.next_done = (_Bool)0;
#line 53
    while (1) {
#line 53
      mbuiter_multi_next(& iter1);
#line 53
      if (iter1.cur.wc_valid) {
#line 53
        if (iter1.cur.wc == 0) {
#line 53
          tmp___13 = 0;
        } else {
#line 53
          tmp___13 = 1;
        }
      } else {
#line 53
        tmp___13 = 1;
      }
#line 53
      if (tmp___13) {
#line 53
        mbuiter_multi_next(& iter2);
#line 53
        if (iter2.cur.wc_valid) {
#line 53
          if (iter2.cur.wc == 0) {
#line 53
            tmp___14 = 0;
          } else {
#line 53
            tmp___14 = 1;
          }
        } else {
#line 53
          tmp___14 = 1;
        }
#line 53
        if (! tmp___14) {
#line 53
          break;
        }
      } else {
#line 53
        break;
      }
#line 55
      if (iter1.cur.wc_valid) {
#line 55
        if (iter2.cur.wc_valid) {
#line 55
          tmp = towlower((wint_t )iter1.cur.wc);
#line 55
          tmp___0 = towlower((wint_t )iter2.cur.wc);
#line 55
          tmp___1 = (int )tmp - (int )tmp___0;
        } else {
#line 55
          tmp___1 = -1;
        }
#line 55
        tmp___12 = tmp___1;
      } else {
#line 55
        if (iter2.cur.wc_valid) {
#line 55
          tmp___11 = 1;
        } else {
#line 55
          if (iter1.cur.bytes == iter2.cur.bytes) {
#line 55
            tmp___2 = memcmp((void const   *)iter1.cur.ptr, (void const   *)iter2.cur.ptr,
                             iter1.cur.bytes);
#line 55
            tmp___10 = tmp___2;
          } else {
#line 55
            if (iter1.cur.bytes < iter2.cur.bytes) {
#line 55
              tmp___5 = memcmp((void const   *)iter1.cur.ptr, (void const   *)iter2.cur.ptr,
                               iter1.cur.bytes);
#line 55
              if (tmp___5 > 0) {
#line 55
                tmp___4 = 1;
              } else {
#line 55
                tmp___4 = -1;
              }
#line 55
              tmp___9 = tmp___4;
            } else {
#line 55
              tmp___8 = memcmp((void const   *)iter1.cur.ptr, (void const   *)iter2.cur.ptr,
                               iter2.cur.bytes);
#line 55
              if (tmp___8 >= 0) {
#line 55
                tmp___7 = 1;
              } else {
#line 55
                tmp___7 = -1;
              }
#line 55
              tmp___9 = tmp___7;
            }
#line 55
            tmp___10 = tmp___9;
          }
#line 55
          tmp___11 = tmp___10;
        }
#line 55
        tmp___12 = tmp___11;
      }
#line 55
      cmp = tmp___12;
#line 57
      if (cmp != 0) {
#line 58
        return (cmp);
      }
#line 60
      iter1.cur.ptr += iter1.cur.bytes;
#line 60
      iter1.next_done = (_Bool)0;
#line 61
      iter2.cur.ptr += iter2.cur.bytes;
#line 61
      iter2.next_done = (_Bool)0;
    }
#line 63
    mbuiter_multi_next(& iter1);
#line 63
    if (iter1.cur.wc_valid) {
#line 63
      if (iter1.cur.wc == 0) {
#line 63
        tmp___15 = 0;
      } else {
#line 63
        tmp___15 = 1;
      }
    } else {
#line 63
      tmp___15 = 1;
    }
#line 63
    if (tmp___15) {
#line 65
      return (1);
    }
#line 66
    mbuiter_multi_next(& iter2);
#line 66
    if (iter2.cur.wc_valid) {
#line 66
      if (iter2.cur.wc == 0) {
#line 66
        tmp___16 = 0;
      } else {
#line 66
        tmp___16 = 1;
      }
    } else {
#line 66
      tmp___16 = 1;
    }
#line 66
    if (tmp___16) {
#line 68
      return (-1);
    }
#line 69
    return (0);
  } else {
#line 73
    p1 = (unsigned char const   *)s1;
#line 74
    p2 = (unsigned char const   *)s2;
#line 77
    while (1) {
#line 79
      tmp___20 = __ctype_b_loc();
#line 79
      if ((int const   )*(*tmp___20 + (int )*p1) & 256) {
#line 79
        if (sizeof(*p1) > 1UL) {
#line 79
          __res = tolower((int )*p1);
        } else {
#line 79
          tmp___19 = __ctype_tolower_loc();
#line 79
          __res = (int )*(*tmp___19 + (int )*p1);
        }
#line 79
        c1 = (unsigned char )__res;
      } else {
#line 79
        c1 = (unsigned char )*p1;
      }
#line 80
      tmp___24 = __ctype_b_loc();
#line 80
      if ((int const   )*(*tmp___24 + (int )*p2) & 256) {
#line 80
        if (sizeof(*p2) > 1UL) {
#line 80
          __res___0 = tolower((int )*p2);
        } else {
#line 80
          tmp___23 = __ctype_tolower_loc();
#line 80
          __res___0 = (int )*(*tmp___23 + (int )*p2);
        }
#line 80
        c2 = (unsigned char )__res___0;
      } else {
#line 80
        c2 = (unsigned char )*p2;
      }
#line 82
      if ((int )c1 == 0) {
#line 83
        break;
      }
#line 85
      p1 ++;
#line 86
      p2 ++;
#line 77
      if (! ((int )c1 == (int )c2)) {
#line 77
        break;
      }
    }
#line 91
    return ((int )c1 - (int )c2);
  }
}
}
#line 1 "mbslen.o"
#pragma merger(0,"/tmp/cil-JgdeT8e1.i","-g,-O2")
#line 1045 "./string.h"
size_t mbslen(char const   *string )  __attribute__((__nonnull__(1))) ;
#line 28 "mbslen.c"
size_t mbslen(char const   *string )  __attribute__((__nonnull__(1))) ;
#line 28 "mbslen.c"
size_t mbslen(char const   *string ) 
{ size_t count ;
  mbui_iterator_t iter ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 31
  tmp___1 = __ctype_get_mb_cur_max();
#line 31
  if (tmp___1 > 1UL) {
#line 36
    count = (size_t )0;
#line 37
    iter.cur.ptr = string;
#line 37
    iter.in_shift = (_Bool)0;
#line 37
    memset((void *)(& iter.state), '\000', sizeof(mbstate_t ));
#line 37
    iter.next_done = (_Bool)0;
#line 37
    while (1) {
#line 37
      mbuiter_multi_next(& iter);
#line 37
      if (iter.cur.wc_valid) {
#line 37
        if (iter.cur.wc == 0) {
#line 37
          tmp = 0;
        } else {
#line 37
          tmp = 1;
        }
      } else {
#line 37
        tmp = 1;
      }
#line 37
      if (! tmp) {
#line 37
        break;
      }
#line 38
      count ++;
#line 37
      iter.cur.ptr += iter.cur.bytes;
#line 37
      iter.next_done = (_Bool)0;
    }
#line 40
    return (count);
  } else {
#line 43
    tmp___0 = strlen(string);
#line 43
    return (tmp___0);
  }
}
}
#line 1 "mbsstr.o"
#pragma merger(0,"/tmp/cil-1Q3l_JeC.i","-g,-O2")
#line 406 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t strnlen(char const   *__string , size_t __maxlen )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 1103 "./string.h"
char *mbsstr(char const   *haystack , char const   *needle )  __attribute__((__nonnull__(1,2))) ;
#line 259 "mbchar.h"
__inline static void mb_copy(mbchar_t *new_mbc , mbchar_t const   *old_mbc ) 
{ _Bool tmp ;

  {
#line 262
  if ((unsigned long )old_mbc->ptr == (unsigned long )(& old_mbc->buf[0])) {
#line 264
    memcpy((void * __restrict  )(& new_mbc->buf[0]), (void const   * __restrict  )(& old_mbc->buf[0]),
           (size_t )old_mbc->bytes);
#line 265
    new_mbc->ptr = (char const   *)(& new_mbc->buf[0]);
  } else {
#line 268
    new_mbc->ptr = (char const   *)old_mbc->ptr;
  }
#line 269
  new_mbc->bytes = (size_t )old_mbc->bytes;
#line 270
  tmp = (_Bool )old_mbc->wc_valid;
#line 270
  new_mbc->wc_valid = tmp;
#line 270
  if (tmp) {
#line 271
    new_mbc->wc = (wchar_t )old_mbc->wc;
  }
#line 272
  return;
}
}
#line 37 "str-kmp.h"
static _Bool knuth_morris_pratt(unsigned char const   *haystack , unsigned char const   *needle ,
                                size_t needle_len , unsigned char const   **resultp ) 
{ size_t m ;
  size_t *table___0 ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  size_t i ;
  size_t j ;
  unsigned char b ;
  size_t j___0 ;
  unsigned char const   *rhaystack ;
  unsigned char const   *phaystack ;

  {
#line 42
  m = needle_len;
#line 45
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 45
    tmp___4 = -1;
  } else {
#line 45
    tmp___4 = -2;
  }
#line 45
  if (m > (size_t )tmp___4 / sizeof(size_t )) {
#line 45
    tmp___3 = (void *)0;
  } else {
#line 45
    if (m * sizeof(size_t ) < 4016UL) {
#line 45
      tmp___0 = __builtin_alloca(m * sizeof(size_t ) + 16UL);
#line 45
      tmp___2 = (void *)((char *)tmp___0 + 16);
    } else {
#line 45
      tmp___1 = mmalloca(m * sizeof(size_t ));
#line 45
      tmp___2 = tmp___1;
    }
#line 45
    tmp___3 = tmp___2;
  }
#line 45
  table___0 = (size_t *)tmp___3;
#line 46
  if ((unsigned long )table___0 == (unsigned long )((void *)0)) {
#line 47
    return ((_Bool)0);
  }
#line 67
  *(table___0 + 1) = (size_t )1;
#line 68
  j = (size_t )0;
#line 70
  i = (size_t )2;
#line 70
  while (i < m) {
#line 76
    b = (unsigned char )*(needle + (i - 1UL));
#line 78
    while (1) {
#line 83
      if ((int )b == (int )*(needle + j)) {
#line 86
        j ++;
#line 86
        *(table___0 + i) = i - j;
#line 87
        break;
      }
#line 92
      if (j == 0UL) {
#line 95
        *(table___0 + i) = i;
#line 96
        break;
      }
#line 109
      j -= *(table___0 + j);
    }
#line 70
    i ++;
  }
#line 121
  *resultp = (unsigned char const   *)((void *)0);
#line 122
  j___0 = (size_t )0;
#line 123
  rhaystack = haystack;
#line 124
  phaystack = haystack;
#line 126
  while ((int const   )*phaystack != 0) {
#line 127
    if ((int const   )*(needle + j___0) == (int const   )*phaystack) {
#line 129
      j___0 ++;
#line 130
      phaystack ++;
#line 131
      if (j___0 == m) {
#line 134
        *resultp = rhaystack;
#line 135
        break;
      }
    } else
#line 138
    if (j___0 > 0UL) {
#line 141
      rhaystack += *(table___0 + j___0);
#line 142
      j___0 -= *(table___0 + j___0);
    } else {
#line 147
      rhaystack ++;
#line 148
      phaystack ++;
    }
  }
#line 152
  freea((void *)table___0);
#line 153
  return ((_Bool)1);
}
}
#line 39 "mbsstr.c"
static _Bool knuth_morris_pratt_multibyte(char const   *haystack , char const   *needle ,
                                          char const   **resultp ) 
{ size_t m ;
  size_t tmp ;
  mbchar_t *needle_mbchars ;
  size_t *table___0 ;
  char *memory ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  mbui_iterator_t iter ;
  size_t j ;
  int tmp___6 ;
  size_t i ;
  size_t j___0 ;
  mbchar_t *b ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t j___1 ;
  mbui_iterator_t rhaystack ;
  mbui_iterator_t phaystack ;
  size_t count ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
#line 43
  tmp = mbslen(needle);
#line 43
  m = tmp;
#line 48
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 48
    tmp___5 = -1;
  } else {
#line 48
    tmp___5 = -2;
  }
#line 48
  if (m > (size_t )tmp___5 / (sizeof(mbchar_t ) + sizeof(size_t ))) {
#line 48
    tmp___4 = (void *)0;
  } else {
#line 48
    if (m * (sizeof(mbchar_t ) + sizeof(size_t )) < 4016UL) {
#line 48
      tmp___1 = __builtin_alloca(m * (sizeof(mbchar_t ) + sizeof(size_t )) + 16UL);
#line 48
      tmp___3 = (void *)((char *)tmp___1 + 16);
    } else {
#line 48
      tmp___2 = mmalloca(m * (sizeof(mbchar_t ) + sizeof(size_t )));
#line 48
      tmp___3 = tmp___2;
    }
#line 48
    tmp___4 = tmp___3;
  }
#line 48
  memory = (char *)tmp___4;
#line 49
  if ((unsigned long )memory == (unsigned long )((void *)0)) {
#line 50
    return ((_Bool)0);
  }
#line 51
  needle_mbchars = (mbchar_t *)memory;
#line 52
  table___0 = (size_t *)(memory + m * sizeof(mbchar_t ));
#line 59
  j = (size_t )0;
#line 60
  iter.cur.ptr = needle;
#line 60
  iter.in_shift = (_Bool)0;
#line 60
  memset((void *)(& iter.state), '\000', sizeof(mbstate_t ));
#line 60
  iter.next_done = (_Bool)0;
#line 60
  while (1) {
#line 60
    mbuiter_multi_next(& iter);
#line 60
    if (iter.cur.wc_valid) {
#line 60
      if (iter.cur.wc == 0) {
#line 60
        tmp___6 = 0;
      } else {
#line 60
        tmp___6 = 1;
      }
    } else {
#line 60
      tmp___6 = 1;
    }
#line 60
    if (! tmp___6) {
#line 60
      break;
    }
#line 61
    mb_copy(needle_mbchars + j, (mbchar_t const   *)(& iter.cur));
#line 60
    iter.cur.ptr += iter.cur.bytes;
#line 60
    iter.next_done = (_Bool)0;
#line 60
    j ++;
  }
#line 83
  *(table___0 + 1) = (size_t )1;
#line 84
  j___0 = (size_t )0;
#line 86
  i = (size_t )2;
#line 86
  while (i < m) {
#line 92
    b = needle_mbchars + (i - 1UL);
#line 94
    while (1) {
#line 99
      if (b->wc_valid) {
#line 99
        if ((needle_mbchars + j___0)->wc_valid) {
#line 99
          tmp___9 = b->wc == (needle_mbchars + j___0)->wc;
        } else {
#line 99
          goto _L;
        }
      } else {
        _L: 
#line 99
        if (b->bytes == (needle_mbchars + j___0)->bytes) {
#line 99
          tmp___7 = memcmp((void const   *)b->ptr, (void const   *)(needle_mbchars + j___0)->ptr,
                           b->bytes);
#line 99
          if (tmp___7 == 0) {
#line 99
            tmp___8 = 1;
          } else {
#line 99
            tmp___8 = 0;
          }
        } else {
#line 99
          tmp___8 = 0;
        }
#line 99
        tmp___9 = tmp___8;
      }
#line 99
      if (tmp___9) {
#line 102
        j___0 ++;
#line 102
        *(table___0 + i) = i - j___0;
#line 103
        break;
      }
#line 108
      if (j___0 == 0UL) {
#line 111
        *(table___0 + i) = i;
#line 112
        break;
      }
#line 125
      j___0 -= *(table___0 + j___0);
    }
#line 86
    i ++;
  }
#line 137
  *resultp = (char const   *)((void *)0);
#line 138
  j___1 = (size_t )0;
#line 139
  rhaystack.cur.ptr = haystack;
#line 139
  rhaystack.in_shift = (_Bool)0;
#line 139
  memset((void *)(& rhaystack.state), '\000', sizeof(mbstate_t ));
#line 139
  rhaystack.next_done = (_Bool)0;
#line 140
  phaystack.cur.ptr = haystack;
#line 140
  phaystack.in_shift = (_Bool)0;
#line 140
  memset((void *)(& phaystack.state), '\000', sizeof(mbstate_t ));
#line 140
  phaystack.next_done = (_Bool)0;
#line 142
  while (1) {
#line 142
    mbuiter_multi_next(& phaystack);
#line 142
    if (phaystack.cur.wc_valid) {
#line 142
      if (phaystack.cur.wc == 0) {
#line 142
        tmp___15 = 0;
      } else {
#line 142
        tmp___15 = 1;
      }
    } else {
#line 142
      tmp___15 = 1;
    }
#line 142
    if (! tmp___15) {
#line 142
      break;
    }
#line 143
    if ((needle_mbchars + j___1)->wc_valid) {
#line 143
      if (phaystack.cur.wc_valid) {
#line 143
        tmp___14 = (needle_mbchars + j___1)->wc == phaystack.cur.wc;
      } else {
#line 143
        goto _L___0;
      }
    } else {
      _L___0: 
#line 143
      if ((needle_mbchars + j___1)->bytes == phaystack.cur.bytes) {
#line 143
        tmp___12 = memcmp((void const   *)(needle_mbchars + j___1)->ptr, (void const   *)phaystack.cur.ptr,
                          (needle_mbchars + j___1)->bytes);
#line 143
        if (tmp___12 == 0) {
#line 143
          tmp___13 = 1;
        } else {
#line 143
          tmp___13 = 0;
        }
      } else {
#line 143
        tmp___13 = 0;
      }
#line 143
      tmp___14 = tmp___13;
    }
#line 143
    if (tmp___14) {
#line 145
      j___1 ++;
#line 146
      phaystack.cur.ptr += phaystack.cur.bytes;
#line 146
      phaystack.next_done = (_Bool)0;
#line 147
      if (j___1 == m) {
#line 150
        *resultp = rhaystack.cur.ptr;
#line 151
        break;
      }
    } else
#line 154
    if (j___1 > 0UL) {
#line 157
      count = *(table___0 + j___1);
#line 158
      j___1 -= count;
#line 159
      while (count > 0UL) {
#line 161
        mbuiter_multi_next(& rhaystack);
#line 161
        if (rhaystack.cur.wc_valid) {
#line 161
          if (rhaystack.cur.wc == 0) {
#line 161
            tmp___10 = 0;
          } else {
#line 161
            tmp___10 = 1;
          }
        } else {
#line 161
          tmp___10 = 1;
        }
#line 161
        if (! tmp___10) {
#line 162
          abort();
        }
#line 163
        rhaystack.cur.ptr += rhaystack.cur.bytes;
#line 163
        rhaystack.next_done = (_Bool)0;
#line 159
        count --;
      }
    } else {
#line 169
      mbuiter_multi_next(& rhaystack);
#line 169
      if (rhaystack.cur.wc_valid) {
#line 169
        if (rhaystack.cur.wc == 0) {
#line 169
          tmp___11 = 0;
        } else {
#line 169
          tmp___11 = 1;
        }
      } else {
#line 169
        tmp___11 = 1;
      }
#line 169
      if (! tmp___11) {
#line 170
        abort();
      }
#line 171
      rhaystack.cur.ptr += rhaystack.cur.bytes;
#line 171
      rhaystack.next_done = (_Bool)0;
#line 172
      phaystack.cur.ptr += phaystack.cur.bytes;
#line 172
      phaystack.next_done = (_Bool)0;
    }
  }
#line 176
  freea((void *)memory);
#line 177
  return ((_Bool)1);
}
}
#line 182
char *mbsstr(char const   *haystack , char const   *needle )  __attribute__((__nonnull__(1,2))) ;
#line 182 "mbsstr.c"
char *mbsstr(char const   *haystack , char const   *needle ) 
{ mbui_iterator_t iter_needle ;
  _Bool try_kmp ;
  size_t outer_loop_count ;
  size_t comparison_count ;
  size_t last_ccount ;
  mbui_iterator_t iter_needle_last_ccount ;
  mbui_iterator_t iter_haystack ;
  int tmp ;
  size_t count ;
  int tmp___0 ;
  char const   *result ;
  _Bool success ;
  _Bool tmp___1 ;
  int tmp___2 ;
  mbui_iterator_t rhaystack ;
  mbui_iterator_t rneedle ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  _Bool try_kmp___0 ;
  size_t outer_loop_count___0 ;
  size_t comparison_count___0 ;
  size_t last_ccount___0 ;
  char const   *needle_last_ccount ;
  char b ;
  char const   *tmp___13 ;
  size_t tmp___14 ;
  unsigned char const   *result___0 ;
  _Bool success___0 ;
  size_t tmp___15 ;
  _Bool tmp___16 ;
  char const   *rhaystack___0 ;
  char const   *rneedle___0 ;
  size_t tmp___17 ;

  {
#line 190
  tmp___17 = __ctype_get_mb_cur_max();
#line 190
  if (tmp___17 > 1UL) {
#line 194
    iter_needle.cur.ptr = needle;
#line 194
    iter_needle.in_shift = (_Bool)0;
#line 194
    memset((void *)(& iter_needle.state), '\000', sizeof(mbstate_t ));
#line 194
    iter_needle.next_done = (_Bool)0;
#line 195
    mbuiter_multi_next(& iter_needle);
#line 195
    if (iter_needle.cur.wc_valid) {
#line 195
      if (iter_needle.cur.wc == 0) {
#line 195
        tmp___12 = 0;
      } else {
#line 195
        tmp___12 = 1;
      }
    } else {
#line 195
      tmp___12 = 1;
    }
#line 195
    if (tmp___12) {
#line 211
      try_kmp = (_Bool)1;
#line 212
      outer_loop_count = (size_t )0;
#line 213
      comparison_count = (size_t )0;
#line 214
      last_ccount = (size_t )0;
#line 219
      iter_needle_last_ccount.cur.ptr = needle;
#line 219
      iter_needle_last_ccount.in_shift = (_Bool)0;
#line 219
      memset((void *)(& iter_needle_last_ccount.state), '\000', sizeof(mbstate_t ));
#line 219
      iter_needle_last_ccount.next_done = (_Bool)0;
#line 220
      iter_haystack.cur.ptr = haystack;
#line 220
      iter_haystack.in_shift = (_Bool)0;
#line 220
      memset((void *)(& iter_haystack.state), '\000', sizeof(mbstate_t ));
#line 220
      iter_haystack.next_done = (_Bool)0;
#line 221
      while (1) {
#line 223
        mbuiter_multi_next(& iter_haystack);
#line 223
        if (iter_haystack.cur.wc_valid) {
#line 223
          if (iter_haystack.cur.wc == 0) {
#line 223
            tmp = 0;
          } else {
#line 223
            tmp = 1;
          }
        } else {
#line 223
          tmp = 1;
        }
#line 223
        if (! tmp) {
#line 225
          return ((char *)((void *)0));
        }
#line 229
        if (try_kmp) {
#line 229
          if (outer_loop_count >= 10UL) {
#line 229
            if (comparison_count >= 5UL * outer_loop_count) {
#line 235
              count = comparison_count - last_ccount;
#line 236
              while (1) {
#line 236
                if (count > 0UL) {
#line 236
                  mbuiter_multi_next(& iter_needle_last_ccount);
#line 236
                  if (iter_needle_last_ccount.cur.wc_valid) {
#line 236
                    if (iter_needle_last_ccount.cur.wc == 0) {
#line 236
                      tmp___0 = 0;
                    } else {
#line 236
                      tmp___0 = 1;
                    }
                  } else {
#line 236
                    tmp___0 = 1;
                  }
#line 236
                  if (! tmp___0) {
#line 236
                    break;
                  }
                } else {
#line 236
                  break;
                }
#line 239
                iter_needle_last_ccount.cur.ptr += iter_needle_last_ccount.cur.bytes;
#line 239
                iter_needle_last_ccount.next_done = (_Bool)0;
#line 236
                count --;
              }
#line 240
              last_ccount = comparison_count;
#line 241
              mbuiter_multi_next(& iter_needle_last_ccount);
#line 241
              if (iter_needle_last_ccount.cur.wc_valid) {
#line 241
                if (iter_needle_last_ccount.cur.wc == 0) {
#line 241
                  tmp___2 = 0;
                } else {
#line 241
                  tmp___2 = 1;
                }
              } else {
#line 241
                tmp___2 = 1;
              }
#line 241
              if (! tmp___2) {
#line 245
                tmp___1 = knuth_morris_pratt_multibyte(haystack, needle, & result);
#line 245
                success = tmp___1;
#line 248
                if (success) {
#line 249
                  return ((char *)result);
                }
#line 250
                try_kmp = (_Bool)0;
              }
            }
          }
        }
#line 254
        outer_loop_count ++;
#line 255
        comparison_count ++;
#line 256
        if (iter_haystack.cur.wc_valid) {
#line 256
          if (iter_needle.cur.wc_valid) {
#line 256
            tmp___11 = iter_haystack.cur.wc == iter_needle.cur.wc;
          } else {
#line 256
            goto _L___0;
          }
        } else {
          _L___0: 
#line 256
          if (iter_haystack.cur.bytes == iter_needle.cur.bytes) {
#line 256
            tmp___9 = memcmp((void const   *)iter_haystack.cur.ptr, (void const   *)iter_needle.cur.ptr,
                             iter_haystack.cur.bytes);
#line 256
            if (tmp___9 == 0) {
#line 256
              tmp___10 = 1;
            } else {
#line 256
              tmp___10 = 0;
            }
          } else {
#line 256
            tmp___10 = 0;
          }
#line 256
          tmp___11 = tmp___10;
        }
#line 256
        if (tmp___11) {
#line 262
          memcpy((void * __restrict  )(& rhaystack), (void const   * __restrict  )(& iter_haystack),
                 sizeof(mbui_iterator_t ));
#line 263
          rhaystack.cur.ptr += rhaystack.cur.bytes;
#line 263
          rhaystack.next_done = (_Bool)0;
#line 265
          rneedle.cur.ptr = needle;
#line 265
          rneedle.in_shift = (_Bool)0;
#line 265
          memset((void *)(& rneedle.state), '\000', sizeof(mbstate_t ));
#line 265
          rneedle.next_done = (_Bool)0;
#line 266
          mbuiter_multi_next(& rneedle);
#line 266
          if (rneedle.cur.wc_valid) {
#line 266
            if (rneedle.cur.wc == 0) {
#line 266
              tmp___3 = 0;
            } else {
#line 266
              tmp___3 = 1;
            }
          } else {
#line 266
            tmp___3 = 1;
          }
#line 266
          if (! tmp___3) {
#line 267
            abort();
          }
#line 268
          rneedle.cur.ptr += rneedle.cur.bytes;
#line 268
          rneedle.next_done = (_Bool)0;
#line 270
          while (1) {
#line 272
            mbuiter_multi_next(& rneedle);
#line 272
            if (rneedle.cur.wc_valid) {
#line 272
              if (rneedle.cur.wc == 0) {
#line 272
                tmp___4 = 0;
              } else {
#line 272
                tmp___4 = 1;
              }
            } else {
#line 272
              tmp___4 = 1;
            }
#line 272
            if (! tmp___4) {
#line 274
              return ((char *)iter_haystack.cur.ptr);
            }
#line 275
            mbuiter_multi_next(& rhaystack);
#line 275
            if (rhaystack.cur.wc_valid) {
#line 275
              if (rhaystack.cur.wc == 0) {
#line 275
                tmp___5 = 0;
              } else {
#line 275
                tmp___5 = 1;
              }
            } else {
#line 275
              tmp___5 = 1;
            }
#line 275
            if (! tmp___5) {
#line 277
              return ((char *)((void *)0));
            }
#line 278
            comparison_count ++;
#line 279
            if (rhaystack.cur.wc_valid) {
#line 279
              if (rneedle.cur.wc_valid) {
#line 279
                tmp___8 = rhaystack.cur.wc == rneedle.cur.wc;
              } else {
#line 279
                goto _L;
              }
            } else {
              _L: 
#line 279
              if (rhaystack.cur.bytes == rneedle.cur.bytes) {
#line 279
                tmp___6 = memcmp((void const   *)rhaystack.cur.ptr, (void const   *)rneedle.cur.ptr,
                                 rhaystack.cur.bytes);
#line 279
                if (tmp___6 == 0) {
#line 279
                  tmp___7 = 1;
                } else {
#line 279
                  tmp___7 = 0;
                }
              } else {
#line 279
                tmp___7 = 0;
              }
#line 279
              tmp___8 = tmp___7;
            }
#line 279
            if (! tmp___8) {
#line 281
              break;
            }
#line 270
            rhaystack.cur.ptr += rhaystack.cur.bytes;
#line 270
            rhaystack.next_done = (_Bool)0;
#line 270
            rneedle.cur.ptr += rneedle.cur.bytes;
#line 270
            rneedle.next_done = (_Bool)0;
          }
        }
#line 221
        iter_haystack.cur.ptr += iter_haystack.cur.bytes;
#line 221
        iter_haystack.next_done = (_Bool)0;
      }
    } else {
#line 287
      return ((char *)haystack);
    }
  } else
#line 291
  if ((int const   )*needle != 0) {
#line 307
    try_kmp___0 = (_Bool)1;
#line 308
    outer_loop_count___0 = (size_t )0;
#line 309
    comparison_count___0 = (size_t )0;
#line 310
    last_ccount___0 = (size_t )0;
#line 311
    needle_last_ccount = needle;
#line 315
    tmp___13 = needle;
#line 315
    needle ++;
#line 315
    b = (char )*tmp___13;
#line 317
    while (1) {
#line 319
      if ((int const   )*haystack == 0) {
#line 321
        return ((char *)((void *)0));
      }
#line 325
      if (try_kmp___0) {
#line 325
        if (outer_loop_count___0 >= 10UL) {
#line 325
          if (comparison_count___0 >= 5UL * outer_loop_count___0) {
#line 331
            if ((unsigned long )needle_last_ccount != (unsigned long )((void *)0)) {
#line 333
              tmp___14 = strnlen(needle_last_ccount, comparison_count___0 - last_ccount___0);
#line 333
              needle_last_ccount += tmp___14;
#line 336
              if ((int const   )*needle_last_ccount == 0) {
#line 337
                needle_last_ccount = (char const   *)((void *)0);
              }
#line 338
              last_ccount___0 = comparison_count___0;
            }
#line 340
            if ((unsigned long )needle_last_ccount == (unsigned long )((void *)0)) {
#line 344
              tmp___15 = strlen(needle - 1);
#line 344
              tmp___16 = knuth_morris_pratt((unsigned char const   *)haystack, (unsigned char const   *)(needle - 1),
                                            tmp___15, & result___0);
#line 344
              success___0 = tmp___16;
#line 349
              if (success___0) {
#line 350
                return ((char *)result___0);
              }
#line 351
              try_kmp___0 = (_Bool)0;
            }
          }
        }
      }
#line 355
      outer_loop_count___0 ++;
#line 356
      comparison_count___0 ++;
#line 357
      if ((int const   )*haystack == (int const   )b) {
#line 360
        rhaystack___0 = haystack + 1;
#line 361
        rneedle___0 = needle;
#line 363
        while (1) {
#line 365
          if ((int const   )*rneedle___0 == 0) {
#line 367
            return ((char *)haystack);
          }
#line 368
          if ((int const   )*rhaystack___0 == 0) {
#line 370
            return ((char *)((void *)0));
          }
#line 371
          comparison_count___0 ++;
#line 372
          if ((int const   )*rhaystack___0 != (int const   )*rneedle___0) {
#line 374
            break;
          }
#line 363
          rhaystack___0 ++;
#line 363
          rneedle___0 ++;
        }
      }
#line 317
      haystack ++;
    }
  } else {
#line 380
    return ((char *)haystack);
  }
}
}
#line 1 "mbswidth.o"
#pragma merger(0,"/tmp/cil-ihymVvBv.i","-g,-O2")
#line 51 "mbswidth.h"
int gnu_mbswidth(char const   *string , int flags ) ;
#line 55
int mbsnwidth(char const   *string , size_t nbytes , int flags ) ;
#line 121 "/usr/include/wctype.h"
extern  __attribute__((__nothrow__)) int iswcntrl(wint_t __wc ) ;
#line 46 "mbswidth.c"
int gnu_mbswidth(char const   *string , int flags ) 
{ size_t tmp ;
  int tmp___0 ;

  {
#line 49
  tmp = strlen(string);
#line 49
  tmp___0 = mbsnwidth(string, tmp, flags);
#line 49
  return (tmp___0);
}
}
#line 56 "mbswidth.c"
int mbsnwidth(char const   *string , size_t nbytes , int flags ) 
{ char const   *p ;
  char const   *plimit ;
  int width ;
  mbstate_t mbstate ;
  wchar_t wc ;
  size_t bytes ;
  int w ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  unsigned char c ;
  char const   *tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
#line 59
  p = string;
#line 60
  plimit = p + nbytes;
#line 63
  width = 0;
#line 64
  tmp___1 = __ctype_get_mb_cur_max();
#line 64
  if (tmp___1 > 1UL) {
#line 66
    while ((unsigned long )p < (unsigned long )plimit) {
#line 67
      switch ((int )*p) {
      case 32: 
      case 33: 
      case 34: 
      case 35: 
      case 37: 
      case 38: 
      case 39: 
      case 40: 
      case 41: 
      case 42: 
      case 43: 
      case 44: 
      case 45: 
      case 46: 
      case 47: 
      case 48: 
      case 49: 
      case 50: 
      case 51: 
      case 52: 
      case 53: 
      case 54: 
      case 55: 
      case 56: 
      case 57: 
      case 58: 
      case 59: 
      case 60: 
      case 61: 
      case 62: 
      case 63: 
      case 65: 
      case 66: 
      case 67: 
      case 68: 
      case 69: 
      case 70: 
      case 71: 
      case 72: 
      case 73: 
      case 74: 
      case 75: 
      case 76: 
      case 77: 
      case 78: 
      case 79: 
      case 80: 
      case 81: 
      case 82: 
      case 83: 
      case 84: 
      case 85: 
      case 86: 
      case 87: 
      case 88: 
      case 89: 
      case 90: 
      case 91: 
      case 92: 
      case 93: 
      case 94: 
      case 95: 
      case 97: 
      case 98: 
      case 99: 
      case 100: 
      case 101: 
      case 102: 
      case 103: 
      case 104: 
      case 105: 
      case 106: 
      case 107: 
      case 108: 
      case 109: 
      case 110: 
      case 111: 
      case 112: 
      case 113: 
      case 114: 
      case 115: 
      case 116: 
      case 117: 
      case 118: 
      case 119: 
      case 120: 
      case 121: 
      case 122: 
      case 123: 
      case 124: 
      case 125: 
      case 126: 
#line 90
      p ++;
#line 91
      width ++;
#line 92
      break;
      default: 
#line 97
      memset((void *)(& mbstate), 0, sizeof(mbstate));
#line 98
      while (1) {
#line 104
        bytes = mbrtowc((wchar_t * __restrict  )(& wc), (char const   * __restrict  )p,
                        (size_t )(plimit - p), & mbstate);
#line 106
        if (bytes == 0xffffffffffffffffUL) {
#line 109
          if (! (flags & 1)) {
#line 111
            p ++;
#line 112
            width ++;
#line 113
            break;
          } else {
#line 116
            return (-1);
          }
        }
#line 119
        if (bytes == 0xfffffffffffffffeUL) {
#line 122
          if (! (flags & 1)) {
#line 124
            p = plimit;
#line 125
            width ++;
#line 126
            break;
          } else {
#line 129
            return (-1);
          }
        }
#line 132
        if (bytes == 0UL) {
#line 134
          bytes = (size_t )1;
        }
#line 136
        w = wcwidth(wc);
#line 137
        if (w >= 0) {
#line 140
          if (w > 2147483647 - width) {
#line 141
            goto overflow;
          }
#line 142
          width += w;
        } else
#line 146
        if (! (flags & 2)) {
#line 148
          tmp = iswcntrl((wint_t )wc);
#line 148
          if (! tmp) {
#line 150
            if (width == 2147483647) {
#line 151
              goto overflow;
            }
#line 152
            width ++;
          }
        } else {
#line 156
          return (-1);
        }
#line 158
        p += bytes;
#line 98
        tmp___0 = mbsinit((mbstate_t const   *)(& mbstate));
#line 98
        if (tmp___0) {
#line 98
          break;
        }
      }
#line 162
      break;
      }
    }
#line 164
    return (width);
  }
#line 167
  while ((unsigned long )p < (unsigned long )plimit) {
#line 169
    tmp___2 = p;
#line 169
    p ++;
#line 169
    c = (unsigned char )*tmp___2;
#line 171
    tmp___4 = __ctype_b_loc();
#line 171
    if ((int const   )*(*tmp___4 + (int )c) & 16384) {
#line 173
      if (width == 2147483647) {
#line 174
        goto overflow;
      }
#line 175
      width ++;
    } else
#line 177
    if (! (flags & 2)) {
#line 179
      tmp___3 = __ctype_b_loc();
#line 179
      if (! ((int const   )*(*tmp___3 + (int )c) & 2)) {
#line 181
        if (width == 2147483647) {
#line 182
          goto overflow;
        }
#line 183
        width ++;
      }
    } else {
#line 187
      return (-1);
    }
  }
#line 189
  return (width);
  overflow: 
#line 192
  return (2147483647);
}
}
#line 1 "memcasecmp.o"
#pragma merger(0,"/tmp/cil-bpVVowuL.i","-g,-O2")
#line 22 "memcasecmp.h"
int memcasecmp(void const   *vs1 , void const   *vs2 , size_t n ) ;
#line 31 "memcasecmp.c"
int memcasecmp(void const   *vs1 , void const   *vs2 , size_t n ) 
{ size_t i ;
  char const   *s1 ;
  char const   *s2 ;
  unsigned char u1 ;
  unsigned char u2 ;
  int U1 ;
  int __res ;
  __int32_t const   **tmp___0 ;
  int U2 ;
  int __res___0 ;
  __int32_t const   **tmp___2 ;
  int diff ;

  {
#line 35
  s1 = (char const   *)vs1;
#line 36
  s2 = (char const   *)vs2;
#line 37
  i = (size_t )0;
#line 37
  while (i < n) {
#line 39
    u1 = (unsigned char )*(s1 + i);
#line 40
    u2 = (unsigned char )*(s2 + i);
#line 41
    if (sizeof(u1) > 1UL) {
#line 41
      __res = toupper((int )u1);
    } else {
#line 41
      tmp___0 = __ctype_toupper_loc();
#line 41
      __res = (int )*(*tmp___0 + (int )u1);
    }
#line 41
    U1 = __res;
#line 42
    if (sizeof(u2) > 1UL) {
#line 42
      __res___0 = toupper((int )u2);
    } else {
#line 42
      tmp___2 = __ctype_toupper_loc();
#line 42
      __res___0 = (int )*(*tmp___2 + (int )u2);
    }
#line 42
    U2 = __res___0;
#line 43
    diff = U1 - U2;
#line 45
    if (diff) {
#line 46
      return (diff);
    }
#line 37
    i ++;
  }
#line 48
  return (0);
}
}
#line 1 "memchr2.o"
#pragma merger(0,"/tmp/cil-rXaqB71M.i","-g,-O2")
#line 35 "memchr2.c"
void *memchr2(void const   *s , int c1_in , int c2_in , size_t n ) 
{ unsigned char const   *char_ptr ;
  longword const   *longword_ptr ;
  longword repeated_one ;
  longword repeated_c1 ;
  longword repeated_c2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  void *tmp ;
  size_t i ;
  longword longword1 ;
  longword longword2 ;

  {
#line 53
  c1 = (unsigned char )c1_in;
#line 54
  c2 = (unsigned char )c2_in;
#line 56
  if ((int )c1 == (int )c2) {
#line 57
    tmp = memchr(s, (int )c1, n);
#line 57
    return (tmp);
  }
#line 61
  char_ptr = (unsigned char const   *)s;
#line 61
  while (1) {
#line 61
    if (n > 0UL) {
#line 61
      if (! ((size_t )char_ptr % sizeof(longword ) != 0UL)) {
#line 61
        break;
      }
    } else {
#line 61
      break;
    }
#line 64
    if ((int const   )*char_ptr == (int const   )c1) {
#line 65
      return ((void *)char_ptr);
    } else
#line 64
    if ((int const   )*char_ptr == (int const   )c2) {
#line 65
      return ((void *)char_ptr);
    }
#line 61
    n --;
#line 61
    char_ptr ++;
  }
#line 67
  longword_ptr = (longword const   *)char_ptr;
#line 76
  repeated_one = (longword )16843009;
#line 77
  repeated_c1 = (longword )((int )c1 | ((int )c1 << 8));
#line 78
  repeated_c2 = (longword )((int )c2 | ((int )c2 << 8));
#line 79
  repeated_c1 |= repeated_c1 << 16;
#line 80
  repeated_c2 |= repeated_c2 << 16;
#line 83
  repeated_one |= (repeated_one << 31) << 1;
#line 84
  repeated_c1 |= (repeated_c1 << 31) << 1;
#line 85
  repeated_c2 |= (repeated_c2 << 31) << 1;
#line 86
  if (8UL < sizeof(longword )) {
#line 90
    i = (size_t )64;
#line 90
    while (i < sizeof(longword ) * 8UL) {
#line 92
      repeated_one |= repeated_one << i;
#line 93
      repeated_c1 |= repeated_c1 << i;
#line 94
      repeated_c2 |= repeated_c2 << i;
#line 90
      i *= 2UL;
    }
  }
#line 135
  while (n >= sizeof(longword )) {
#line 137
    longword1 = (longword )(*longword_ptr ^ (unsigned long const   )repeated_c1);
#line 138
    longword2 = (longword )(*longword_ptr ^ (unsigned long const   )repeated_c2);
#line 140
    if (((((longword1 - repeated_one) & ~ longword1) | ((longword2 - repeated_one) & ~ longword2)) & (repeated_one << 7)) != 0UL) {
#line 143
      break;
    }
#line 144
    longword_ptr ++;
#line 145
    n -= sizeof(longword );
  }
#line 148
  char_ptr = (unsigned char const   *)longword_ptr;
#line 157
  while (n > 0UL) {
#line 159
    if ((int const   )*char_ptr == (int const   )c1) {
#line 160
      return ((void *)char_ptr);
    } else
#line 159
    if ((int const   )*char_ptr == (int const   )c2) {
#line 160
      return ((void *)char_ptr);
    }
#line 157
    n --;
#line 157
    char_ptr ++;
  }
#line 163
  return ((void *)0);
}
}
#line 1 "memcmp2.o"
#pragma merger(0,"/tmp/cil-clO2L3Yu.i","-g,-O2")
#line 34 "memcmp2.h"
int memcmp2(char const   *s1 , size_t n1 , char const   *s2 , size_t n2 ) ;
#line 26 "memcmp2.c"
int memcmp2(char const   *s1 , size_t n1 , char const   *s2 , size_t n2 ) 
{ int cmp ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 29
  if (n1 <= n2) {
#line 29
    tmp = n1;
  } else {
#line 29
    tmp = n2;
  }
#line 29
  tmp___0 = memcmp((void const   *)s1, (void const   *)s2, tmp);
#line 29
  cmp = tmp___0;
#line 30
  if (cmp == 0) {
#line 32
    if (n1 < n2) {
#line 33
      cmp = -1;
    } else
#line 34
    if (n1 > n2) {
#line 35
      cmp = 1;
    }
  }
#line 37
  return (cmp);
}
}
#line 1 "memcoll.o"
#pragma merger(0,"/tmp/cil-K4HxhccU.i","-g,-O2")
#line 25 "memcoll.h"
int memcoll(char *s1 , size_t s1len , char *s2 , size_t s2len ) ;
#line 26
int memcoll0(char const   *s1 , size_t s1size , char const   *s2 , size_t s2size ) ;
#line 150 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int strcoll(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 34 "memcoll.c"
__inline static int strcoll_loop(char const   *s1 , size_t s1size , char const   *s2 ,
                                 size_t s2size ) 
{ int diff ;
  size_t size1 ;
  size_t tmp ;
  size_t size2 ;
  size_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
#line 39
  while (1) {
#line 39
    tmp___1 = __errno_location();
#line 39
    *tmp___1 = 0;
#line 39
    diff = strcoll(s1, s2);
#line 39
    if (diff) {
#line 39
      tmp___3 = 1;
    } else {
#line 39
      tmp___2 = __errno_location();
#line 39
      if (*tmp___2) {
#line 39
        tmp___3 = 1;
      } else {
#line 39
        tmp___3 = 0;
      }
    }
#line 39
    if (tmp___3) {
#line 39
      break;
    }
#line 44
    tmp = strlen(s1);
#line 44
    size1 = tmp + 1UL;
#line 45
    tmp___0 = strlen(s2);
#line 45
    size2 = tmp___0 + 1UL;
#line 46
    s1 += size1;
#line 47
    s2 += size2;
#line 48
    s1size -= size1;
#line 49
    s2size -= size2;
#line 51
    if (s1size == 0UL) {
#line 52
      return (- (s2size != 0UL));
    }
#line 53
    if (s2size == 0UL) {
#line 54
      return (1);
    }
  }
#line 57
  return (diff);
}
}
#line 65 "memcoll.c"
int memcoll(char *s1 , size_t s1len , char *s2 , size_t s2len ) 
{ int diff ;
  int *tmp ;
  char n1 ;
  char n2 ;
  int tmp___0 ;

  {
#line 74
  if (s1len == s2len) {
#line 74
    tmp___0 = memcmp((void const   *)s1, (void const   *)s2, s1len);
#line 74
    if (tmp___0 == 0) {
#line 76
      tmp = __errno_location();
#line 76
      *tmp = 0;
#line 77
      diff = 0;
    } else {
#line 74
      goto _L;
    }
  } else {
    _L: 
#line 81
    n1 = *(s1 + s1len);
#line 82
    n2 = *(s2 + s2len);
#line 84
    *(s1 + s1len) = (char )'\000';
#line 85
    *(s2 + s2len) = (char )'\000';
#line 87
    diff = strcoll_loop((char const   *)s1, s1len + 1UL, (char const   *)s2, s2len + 1UL);
#line 89
    *(s1 + s1len) = n1;
#line 90
    *(s2 + s2len) = n2;
  }
#line 93
  return (diff);
}
}
#line 101 "memcoll.c"
int memcoll0(char const   *s1 , size_t s1size , char const   *s2 , size_t s2size ) 
{ int *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 104
  if (s1size == s2size) {
#line 104
    tmp___1 = memcmp((void const   *)s1, (void const   *)s2, s1size);
#line 104
    if (tmp___1 == 0) {
#line 106
      tmp = __errno_location();
#line 106
      *tmp = 0;
#line 107
      return (0);
    } else {
#line 110
      tmp___0 = strcoll_loop(s1, s1size, s2, s2size);
#line 110
      return (tmp___0);
    }
  } else {
#line 110
    tmp___0 = strcoll_loop(s1, s1size, s2, s2size);
#line 110
    return (tmp___0);
  }
}
}
#line 1 "mgetgroups.o"
#pragma merger(0,"/tmp/cil-vXmlNLFr.i","-g,-O2")
#line 19 "mgetgroups.h"
int mgetgroups(char const   *username , gid_t gid , gid_t **groups ) ;
#line 192 "/usr/include/grp.h"
extern int getgrouplist(char const   *__user , __gid_t __group , __gid_t *__groups ,
                        int *__ngroups ) ;
#line 36 "mgetgroups.c"
static gid_t *realloc_groupbuf(gid_t *g , size_t num ) 
{ int *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 39
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 39
    tmp___0 = -1;
  } else {
#line 39
    tmp___0 = -2;
  }
#line 39
  if ((size_t )tmp___0 / sizeof(*g) < num) {
#line 41
    tmp = __errno_location();
#line 41
    *tmp = 12;
#line 42
    return ((gid_t *)((void *)0));
  }
#line 45
  tmp___1 = realloc((void *)g, num * sizeof(*g));
#line 45
  return ((gid_t *)tmp___1);
}
}
#line 59 "mgetgroups.c"
int mgetgroups(char const   *username , gid_t gid , gid_t **groups ) 
{ int max_n_groups ;
  int ng ;
  gid_t *g ;
  gid_t *h ;
  int last_n_groups ;
  int saved_errno ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int __attribute__((__artificial__))  tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int __attribute__((__artificial__))  tmp___5 ;
  int saved_errno___0 ;
  int *tmp___6 ;
  int *tmp___7 ;
  gid_t first ;
  gid_t *next ;
  gid_t *groups_end ;

  {
#line 75
  if (username) {
#line 78
    max_n_groups = 10;
#line 80
    g = realloc_groupbuf((gid_t *)((void *)0), (size_t )max_n_groups);
#line 81
    if ((unsigned long )g == (unsigned long )((void *)0)) {
#line 82
      return (-1);
    }
#line 84
    while (1) {
#line 87
      last_n_groups = max_n_groups;
#line 90
      ng = getgrouplist(username, gid, g, & max_n_groups);
#line 94
      if (ng < 0) {
#line 94
        if (last_n_groups == max_n_groups) {
#line 95
          max_n_groups *= 2;
        }
      }
#line 97
      h = realloc_groupbuf(g, (size_t )max_n_groups);
#line 97
      if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 99
        tmp = __errno_location();
#line 99
        saved_errno = *tmp;
#line 100
        free((void *)g);
#line 101
        tmp___0 = __errno_location();
#line 101
        *tmp___0 = saved_errno;
#line 102
        return (-1);
      }
#line 104
      g = h;
#line 106
      if (0 <= ng) {
#line 108
        *groups = g;
#line 111
        return (max_n_groups);
      }
    }
  }
#line 118
  if (username) {
#line 118
    tmp___1 = getugroups(0, (gid_t *)((void *)0), username, gid);
#line 118
    max_n_groups = tmp___1;
  } else {
#line 118
    tmp___2 = getgroups(0, (__gid_t *)((void *)0));
#line 118
    max_n_groups = (int )tmp___2;
  }
#line 125
  if (max_n_groups < 0) {
#line 127
    tmp___3 = __errno_location();
#line 127
    if (*tmp___3 == 38) {
#line 127
      g = realloc_groupbuf((gid_t *)((void *)0), (size_t )1);
#line 127
      if (g) {
#line 129
        *groups = g;
#line 130
        *g = gid;
#line 131
        return (gid != 4294967295U);
      }
    }
#line 133
    return (-1);
  }
#line 136
  if (! username) {
#line 136
    if (gid != 4294967295U) {
#line 137
      max_n_groups ++;
    }
  }
#line 138
  g = realloc_groupbuf((gid_t *)((void *)0), (size_t )max_n_groups);
#line 139
  if ((unsigned long )g == (unsigned long )((void *)0)) {
#line 140
    return (-1);
  }
#line 142
  if (username) {
#line 142
    tmp___4 = getugroups(max_n_groups, g, username, gid);
#line 142
    ng = tmp___4;
  } else {
#line 142
    tmp___5 = getgroups(max_n_groups - (gid != 4294967295U), g + (gid != 4294967295U));
#line 142
    ng = (int )tmp___5;
  }
#line 147
  if (ng < 0) {
#line 150
    tmp___6 = __errno_location();
#line 150
    saved_errno___0 = *tmp___6;
#line 151
    free((void *)g);
#line 152
    tmp___7 = __errno_location();
#line 152
    *tmp___7 = saved_errno___0;
#line 153
    return (-1);
  }
#line 156
  if (! username) {
#line 156
    if (gid != 4294967295U) {
#line 158
      *g = gid;
#line 159
      ng ++;
    }
  }
#line 161
  *groups = g;
#line 179
  if (1 < ng) {
#line 181
    first = *g;
#line 183
    groups_end = g + ng;
#line 185
    next = g + 1;
#line 185
    while ((unsigned long )next < (unsigned long )groups_end) {
#line 187
      if (*next == first) {
#line 188
        ng --;
      } else
#line 187
      if (*next == *g) {
#line 188
        ng --;
      } else {
#line 190
        g ++;
#line 190
        *g = *next;
      }
#line 185
      next ++;
    }
  }
#line 194
  return (ng);
}
}
#line 1 "mkancesdirs.o"
#pragma merger(0,"/tmp/cil-hNaCZG4w.i","-g,-O2")
#line 3 "mkancesdirs.h"
ptrdiff_t mkancesdirs(char *file , struct savewd *wd , int (*make_dir)(char const   * ,
                                                                       char const   * ,
                                                                       void * ) ,
                      void *make_dir_arg ) ;
#line 108 "savewd.h"
int savewd_chdir(struct savewd *wd , char const   *dir , int options , int *open_result ) ;
#line 66 "mkancesdirs.c"
ptrdiff_t mkancesdirs(char *file , struct savewd *wd , int (*make_dir)(char const   * ,
                                                                       char const   * ,
                                                                       void * ) ,
                      void *make_dir_arg ) 
{ char *sep ;
  char *component ;
  char *p ;
  char c ;
  _Bool made_dir ;
  int make_dir_errno ;
  int savewd_chdir_options ;
  int chdir_result ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;

  {
#line 74
  sep = (char *)((void *)0);
#line 78
  component = file;
#line 80
  p = file + 0;
#line 82
  made_dir = (_Bool)0;
#line 90
  while (1) {
#line 90
    tmp___3 = p;
#line 90
    p ++;
#line 90
    c = *tmp___3;
#line 90
    if (! c) {
#line 90
      break;
    }
#line 91
    if ((int )*p == 47) {
#line 93
      if (! ((int )c == 47)) {
#line 94
        sep = p;
      }
    } else
#line 96
    if ((int )c == 47) {
#line 96
      if (*p) {
#line 96
        if (sep) {
#line 100
          if (sep - component == 1) {
#line 100
            if (! ((int )*(component + 0) == 46)) {
#line 100
              goto _L___1;
            }
          } else {
            _L___1: 
#line 102
            make_dir_errno = 0;
#line 103
            savewd_chdir_options = 0;
#line 108
            *sep = (char )'\000';
#line 112
            if (sep - component == 2) {
#line 112
              if ((int )*(component + 0) == 46) {
#line 112
                if ((int )*(component + 1) == 46) {
#line 114
                  made_dir = (_Bool)0;
                } else {
#line 112
                  goto _L___0;
                }
              } else {
#line 112
                goto _L___0;
              }
            } else {
              _L___0: 
#line 116
              tmp = (*make_dir)((char const   *)file, (char const   *)component, make_dir_arg);
#line 116
              switch (tmp) {
              case -1: 
#line 119
              tmp___0 = __errno_location();
#line 119
              make_dir_errno = *tmp___0;
#line 120
              break;
              case 0: 
#line 123
              savewd_chdir_options |= 2;
              case 1: 
#line 126
              made_dir = (_Bool)1;
#line 127
              break;
              }
            }
#line 130
            if (made_dir) {
#line 131
              savewd_chdir_options |= 1;
            }
#line 133
            chdir_result = savewd_chdir(wd, (char const   *)component, savewd_chdir_options,
                                        (int *)((void *)0));
#line 138
            if (chdir_result != -1) {
#line 139
              *sep = (char )'/';
            }
#line 141
            if (chdir_result != 0) {
#line 143
              if (make_dir_errno != 0) {
#line 143
                tmp___2 = __errno_location();
#line 143
                if (*tmp___2 == 2) {
#line 144
                  tmp___1 = __errno_location();
#line 144
                  *tmp___1 = make_dir_errno;
                }
              }
#line 145
              return ((ptrdiff_t )chdir_result);
            }
          }
#line 149
          component = p;
        }
      }
    }
  }
#line 152
  return ((ptrdiff_t )(component - file));
}
}
#line 1 "dirchownmod.o"
#pragma merger(0,"/tmp/cil-llxXEgwu.i","-g,-O2")
#line 2 "dirchownmod.h"
int dirchownmod(int fd , char const   *dir , mode_t mkdir_mode , uid_t owner , gid_t group ,
                mode_t mode , mode_t mode_bits ) ;
#line 470 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int chown(char const   *__file , __uid_t __owner ,
                                               __gid_t __group )  __attribute__((__warn_unused_result__,
__nonnull__(1))) ;
#line 475
extern  __attribute__((__nothrow__)) int fchown(int __fd , __uid_t __owner , __gid_t __group )  __attribute__((__warn_unused_result__)) ;
#line 480
extern  __attribute__((__nothrow__)) int lchown(char const   *__file , __uid_t __owner ,
                                                __gid_t __group )  __attribute__((__warn_unused_result__,
__nonnull__(1))) ;
#line 60 "dirchownmod.c"
int dirchownmod(int fd , char const   *dir , mode_t mkdir_mode , uid_t owner , gid_t group ,
                mode_t mode , mode_t mode_bits ) 
{ struct stat st ;
  int result ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  mode_t dir_mode ;
  int *tmp___2 ;
  mode_t indeterminate ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  mode_t chmod_mode ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int e ;
  int *tmp___11 ;
  int *tmp___12 ;

  {
#line 66
  if (fd < 0) {
#line 66
    tmp = stat((char const   * __restrict  )dir, (struct stat * __restrict  )(& st));
#line 66
    tmp___1 = tmp;
  } else {
#line 66
    tmp___0 = fstat(fd, & st);
#line 66
    tmp___1 = tmp___0;
  }
#line 66
  result = tmp___1;
#line 68
  if (result == 0) {
#line 70
    dir_mode = st.st_mode;
#line 76
    if (! ((dir_mode & 61440U) == 16384U)) {
#line 78
      tmp___2 = __errno_location();
#line 78
      *tmp___2 = 20;
#line 79
      result = -1;
    } else {
#line 87
      indeterminate = (mode_t )0;
#line 94
      if (owner != 4294967295U) {
#line 94
        if (owner != st.st_uid) {
#line 94
          goto _L;
        } else {
#line 94
          goto _L___0;
        }
      } else
      _L___0: 
#line 94
      if (group != 4294967295U) {
#line 94
        if (group != st.st_gid) {
          _L: 
#line 97
          if (0 <= fd) {
#line 97
            tmp___3 = fchown(fd, owner, group);
#line 97
            result = tmp___3;
          } else {
#line 97
            if (mkdir_mode != 4294967295U) {
#line 97
              tmp___4 = lchown(dir, owner, group);
#line 97
              tmp___6 = tmp___4;
            } else {
#line 97
              tmp___5 = chown(dir, owner, group);
#line 97
              tmp___6 = tmp___5;
            }
#line 97
            result = tmp___6;
          }
#line 108
          if (result == 0) {
#line 108
            if (dir_mode & (unsigned int )((64 | (64 >> 3)) | ((64 >> 3) >> 3))) {
#line 109
              indeterminate = dir_mode & 3072U;
            }
          }
        }
      }
#line 115
      if (result == 0) {
#line 115
        if (((dir_mode ^ mode) | indeterminate) & mode_bits) {
#line 117
          chmod_mode = mode | ((dir_mode & (unsigned int )((4032 | (448 >> 3)) | ((448 >> 3) >> 3))) & ~ mode_bits);
#line 119
          if (0 <= fd) {
#line 119
            tmp___7 = fchmod(fd, chmod_mode);
#line 119
            result = tmp___7;
          } else {
#line 119
            if (mkdir_mode != 4294967295U) {
#line 119
              tmp___8 = chmod(dir, chmod_mode);
#line 119
              tmp___10 = tmp___8;
            } else {
#line 119
              tmp___9 = chmod(dir, chmod_mode);
#line 119
              tmp___10 = tmp___9;
            }
#line 119
            result = tmp___10;
          }
        }
      }
    }
  }
#line 128
  if (0 <= fd) {
#line 130
    if (result == 0) {
#line 131
      result = close(fd);
    } else {
#line 134
      tmp___11 = __errno_location();
#line 134
      e = *tmp___11;
#line 135
      close(fd);
#line 136
      tmp___12 = __errno_location();
#line 136
      *tmp___12 = e;
    }
  }
#line 140
  return (result);
}
}
#line 1 "mkdir-p.o"
#pragma merger(0,"/tmp/cil-PhWbYBXg.i","-g,-O2")
#line 25 "mkdir-p.h"
_Bool make_dir_parents(char *dir , struct savewd *wd , int (*make_ancestor)(char const   * ,
                                                                            char const   * ,
                                                                            void * ) ,
                       void *options , mode_t mode , void (*announce)(char const   * ,
                                                                      void * ) , mode_t mode_bits ,
                       uid_t owner , gid_t group , _Bool preserve_existing ) ;
#line 323 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int mkdir(char const   *__path , __mode_t __mode )  __attribute__((__nonnull__(1))) ;
#line 120 "savewd.h"
__inline static int savewd_errno(struct savewd  const  *wd ) 
{ int tmp ;

  {
#line 123
  if ((unsigned int const   )wd->state == 4U) {
#line 123
    tmp = (int )wd->val.errnum;
  } else {
#line 123
    tmp = (int )((int const   )0);
  }
#line 123
  return (tmp);
}
}
#line 85 "mkdir-p.c"
_Bool make_dir_parents(char *dir , struct savewd *wd , int (*make_ancestor)(char const   * ,
                                                                            char const   * ,
                                                                            void * ) ,
                       void *options , mode_t mode , void (*announce)(char const   * ,
                                                                      void * ) , mode_t mode_bits ,
                       uid_t owner , gid_t group , _Bool preserve_existing ) 
{ int mkdir_errno ;
  int tmp ;
  int tmp___0 ;
  ptrdiff_t prefix_len ;
  int savewd_chdir_options ;
  int *tmp___1 ;
  _Bool keep_owner ;
  int tmp___2 ;
  _Bool keep_special_mode_bits ;
  mode_t mkdir_mode ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  struct stat st ;
  int tmp___6 ;
  int open_result[2] ;
  int chdir_result ;
  int tmp___7 ;
  _Bool chdir_ok ;
  int chdir_errno ;
  int *tmp___8 ;
  int fd ;
  _Bool chdir_failed_unexpectedly ;
  int tmp___9 ;
  char const   *subdir ;
  char const   *tmp___10 ;
  int tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char *tmp___14 ;
  int *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int *tmp___18 ;
  char const   *tmp___19 ;
  char *tmp___20 ;

  {
#line 97
  if ((int )*(dir + 0) == 47) {
#line 97
    tmp___0 = 0;
  } else {
#line 97
    tmp = savewd_errno((struct savewd  const  *)wd);
#line 97
    tmp___0 = tmp;
  }
#line 97
  mkdir_errno = tmp___0;
#line 99
  if (mkdir_errno == 0) {
#line 101
    prefix_len = (ptrdiff_t )0;
#line 102
    savewd_chdir_options = 4;
#line 104
    if (make_ancestor) {
#line 106
      prefix_len = mkancesdirs(dir, wd, make_ancestor, options);
#line 107
      if (prefix_len < 0L) {
#line 109
        if (prefix_len < -1L) {
#line 110
          return ((_Bool)1);
        }
#line 111
        tmp___1 = __errno_location();
#line 111
        mkdir_errno = *tmp___1;
      }
    }
#line 115
    if (0L <= prefix_len) {
#line 122
      if (owner == 4294967295U) {
#line 122
        if (group == 4294967295U) {
#line 122
          tmp___2 = 1;
        } else {
#line 122
          tmp___2 = 0;
        }
      } else {
#line 122
        tmp___2 = 0;
      }
#line 122
      keep_owner = (_Bool )tmp___2;
#line 123
      keep_special_mode_bits = (_Bool )(((mode_bits & 3072U) | (mode & 512U)) == 0U);
#line 125
      mkdir_mode = mode;
#line 126
      if (! keep_owner) {
#line 127
        mkdir_mode &= (unsigned int )(~ ((448 >> 3) | ((448 >> 3) >> 3)));
      } else
#line 128
      if (! keep_special_mode_bits) {
#line 129
        mkdir_mode &= (unsigned int )(~ ((128 >> 3) | ((128 >> 3) >> 3)));
      }
#line 131
      tmp___5 = mkdir((char const   *)(dir + prefix_len), mkdir_mode);
#line 131
      if (tmp___5 == 0) {
#line 133
        (*announce)((char const   *)dir, options);
#line 134
        preserve_existing = (_Bool )((int )keep_owner & (int )keep_special_mode_bits);
#line 135
        if (mode & 256U) {
#line 135
          tmp___3 = 2;
        } else {
#line 135
          tmp___3 = 0;
        }
#line 135
        savewd_chdir_options |= 1 | tmp___3;
      } else {
#line 141
        tmp___4 = __errno_location();
#line 141
        mkdir_errno = *tmp___4;
#line 142
        mkdir_mode = (mode_t )-1;
      }
#line 145
      if (preserve_existing) {
#line 148
        if (mkdir_errno == 0) {
#line 152
          return ((_Bool)1);
        } else
#line 148
        if (mkdir_errno != 2) {
#line 148
          if (make_ancestor) {
#line 148
            tmp___6 = stat((char const   * __restrict  )(dir + prefix_len), (struct stat * __restrict  )(& st));
#line 148
            if (tmp___6 == 0) {
#line 148
              if ((st.st_mode & 61440U) == 16384U) {
#line 152
                return ((_Bool)1);
              }
            }
          }
        }
      } else {
#line 157
        tmp___7 = savewd_chdir(wd, (char const   *)(dir + prefix_len), savewd_chdir_options,
                               open_result);
#line 157
        chdir_result = tmp___7;
#line 160
        if (chdir_result < -1) {
#line 161
          return ((_Bool)1);
        } else {
#line 164
          chdir_ok = (_Bool )(chdir_result == 0);
#line 165
          tmp___8 = __errno_location();
#line 165
          chdir_errno = *tmp___8;
#line 166
          fd = open_result[0];
#line 167
          if (mkdir_errno == 0) {
#line 167
            if (! chdir_ok) {
#line 167
              if (mode & 64U) {
#line 167
                tmp___9 = 1;
              } else {
#line 167
                goto _L;
              }
            } else
            _L: 
#line 167
            if (fd < 0) {
#line 167
              if (mode & 256U) {
#line 167
                tmp___9 = 1;
              } else {
#line 167
                tmp___9 = 0;
              }
            } else {
#line 167
              tmp___9 = 0;
            }
          } else {
#line 167
            tmp___9 = 0;
          }
#line 167
          chdir_failed_unexpectedly = (_Bool )tmp___9;
#line 172
          if (chdir_failed_unexpectedly) {
#line 175
            if (0 <= fd) {
#line 176
              close(fd);
            }
          } else {
#line 180
            if (chdir_ok) {
#line 180
              tmp___10 = ".";
            } else {
#line 180
              tmp___10 = (char const   *)(dir + prefix_len);
            }
#line 180
            subdir = tmp___10;
#line 181
            tmp___11 = dirchownmod(fd, subdir, mkdir_mode, owner, group, mode, mode_bits);
#line 181
            if (tmp___11 == 0) {
#line 184
              return ((_Bool)1);
            }
          }
#line 187
          if (mkdir_errno == 0) {
#line 187
            goto _L___0;
          } else
#line 187
          if (mkdir_errno != 2) {
#line 187
            if (make_ancestor) {
#line 187
              tmp___18 = __errno_location();
#line 187
              if (*tmp___18 != 20) {
                _L___0: 
#line 191
                tmp___12 = quote((char const   *)dir);
#line 191
                if (keep_owner) {
#line 191
                  tmp___13 = "cannot change permissions of %s";
                } else {
#line 191
                  tmp___13 = "cannot change owner and permissions of %s";
                }
#line 191
                tmp___14 = dcgettext((char const   *)((void *)0), tmp___13, 5);
#line 191
                if (! chdir_failed_unexpectedly) {
#line 191
                  tmp___15 = __errno_location();
#line 191
                  tmp___17 = *tmp___15;
                } else {
#line 191
                  if (! chdir_ok) {
#line 191
                    if (mode & 64U) {
#line 191
                      tmp___16 = chdir_errno;
                    } else {
#line 191
                      tmp___16 = open_result[1];
                    }
                  } else {
#line 191
                    tmp___16 = open_result[1];
                  }
#line 191
                  tmp___17 = tmp___16;
                }
#line 191
                error(0, tmp___17, (char const   *)tmp___14, tmp___12);
#line 199
                return ((_Bool)0);
              }
            }
          }
        }
      }
    }
  }
#line 206
  tmp___19 = quote((char const   *)dir);
#line 206
  tmp___20 = dcgettext((char const   *)((void *)0), "cannot create directory %s",
                       5);
#line 206
  error(0, mkdir_errno, (char const   *)tmp___20, tmp___19);
#line 207
  return ((_Bool)0);
}
}
#line 1 "modechange.o"
#pragma merger(0,"/tmp/cil-ZBbx3fwk.i","-g,-O2")
#line 25 "modechange.h"
struct mode_change *mode_compile(char const   *mode_string ) ;
#line 26
struct mode_change *mode_create_from_ref(char const   *ref_file ) ;
#line 27
mode_t mode_adjust(mode_t oldmode , _Bool dir , mode_t umask_value , struct mode_change  const  *changes ,
                   mode_t *pmode_bits ) ;
#line 53 "modechange.c"
static mode_t octal_to_mode(unsigned int octal ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  unsigned int tmp___11 ;

  {
#line 58
  if (256 >> 3 == 32) {
#line 58
    if (128 >> 3 == 16) {
#line 58
      if (64 >> 3 == 8) {
#line 58
        if ((256 >> 3) >> 3 == 4) {
#line 58
          if ((128 >> 3) >> 3 == 2) {
#line 58
            if ((64 >> 3) >> 3 == 1) {
#line 58
              tmp___11 = octal;
            } else {
#line 58
              goto _L___3;
            }
          } else {
#line 58
            goto _L___3;
          }
        } else {
#line 58
          goto _L___3;
        }
      } else {
#line 58
        goto _L___3;
      }
    } else {
#line 58
      goto _L___3;
    }
  } else {
    _L___3: 
#line 58
    if (octal & 2048U) {
#line 58
      tmp = 2048;
    } else {
#line 58
      tmp = 0;
    }
#line 58
    if (octal & 1024U) {
#line 58
      tmp___0 = 1024;
    } else {
#line 58
      tmp___0 = 0;
    }
#line 58
    if (octal & 512U) {
#line 58
      tmp___1 = 512;
    } else {
#line 58
      tmp___1 = 0;
    }
#line 58
    if (octal & 256U) {
#line 58
      tmp___2 = 256;
    } else {
#line 58
      tmp___2 = 0;
    }
#line 58
    if (octal & 128U) {
#line 58
      tmp___3 = 128;
    } else {
#line 58
      tmp___3 = 0;
    }
#line 58
    if (octal & 64U) {
#line 58
      tmp___4 = 64;
    } else {
#line 58
      tmp___4 = 0;
    }
#line 58
    if (octal & 32U) {
#line 58
      tmp___5 = 256 >> 3;
    } else {
#line 58
      tmp___5 = 0;
    }
#line 58
    if (octal & 16U) {
#line 58
      tmp___6 = 128 >> 3;
    } else {
#line 58
      tmp___6 = 0;
    }
#line 58
    if (octal & 8U) {
#line 58
      tmp___7 = 64 >> 3;
    } else {
#line 58
      tmp___7 = 0;
    }
#line 58
    if (octal & 4U) {
#line 58
      tmp___8 = (256 >> 3) >> 3;
    } else {
#line 58
      tmp___8 = 0;
    }
#line 58
    if (octal & 2U) {
#line 58
      tmp___9 = (128 >> 3) >> 3;
    } else {
#line 58
      tmp___9 = 0;
    }
#line 58
    if (octal & 1U) {
#line 58
      tmp___10 = (64 >> 3) >> 3;
    } else {
#line 58
      tmp___10 = 0;
    }
#line 58
    tmp___11 = (mode_t )(((((((((((tmp | tmp___0) | tmp___1) | tmp___2) | tmp___3) | tmp___4) | tmp___5) | tmp___6) | tmp___7) | tmp___8) | tmp___9) | tmp___10);
  }
#line 58
  return (tmp___11);
}
}
#line 111 "modechange.c"
static struct mode_change *make_node_op_equals(mode_t new_mode , mode_t mentioned ) 
{ struct mode_change *p ;
  void *tmp ;

  {
#line 114
  tmp = xmalloc(2UL * sizeof(*p));
#line 114
  p = (struct mode_change *)tmp;
#line 115
  p->op = (char )'=';
#line 116
  p->flag = (char)1;
#line 117
  p->affected = (mode_t )((4032 | (448 >> 3)) | ((448 >> 3) >> 3));
#line 118
  p->value = new_mode;
#line 119
  p->mentioned = mentioned;
#line 120
  (p + 1)->flag = (char)0;
#line 121
  return (p);
}
}
#line 133 "modechange.c"
struct mode_change *mode_compile(char const   *mode_string ) 
{ struct mode_change *mc ;
  size_t used ;
  unsigned int octal_mode ;
  mode_t mode ;
  mode_t mentioned ;
  char const   *tmp ;
  struct mode_change *tmp___0 ;
  size_t needed ;
  char const   *p ;
  int tmp___1 ;
  void *tmp___2 ;
  mode_t affected ;
  char op ;
  char const   *tmp___3 ;
  mode_t value ;
  char flag ;
  struct mode_change *change ;
  char const   *tmp___4 ;
  size_t tmp___5 ;

  {
#line 138
  used = (size_t )0;
#line 140
  if (48 <= (int )*mode_string) {
#line 140
    if ((int const   )*mode_string < 56) {
#line 142
      octal_mode = 0U;
#line 146
      while (1) {
#line 148
        tmp = mode_string;
#line 148
        mode_string ++;
#line 148
        octal_mode = (8U * octal_mode + (unsigned int )*tmp) - 48U;
#line 149
        if (4095U < octal_mode) {
#line 150
          return ((struct mode_change *)((void *)0));
        }
#line 146
        if (48 <= (int )*mode_string) {
#line 146
          if (! ((int const   )*mode_string < 56)) {
#line 146
            break;
          }
        } else {
#line 146
          break;
        }
      }
#line 154
      if (*mode_string) {
#line 155
        return ((struct mode_change *)((void *)0));
      }
#line 157
      mode = octal_to_mode(octal_mode);
#line 158
      mentioned = ((mode & 3072U) | 512U) | (unsigned int )((448 | (448 >> 3)) | ((448 >> 3) >> 3));
#line 159
      tmp___0 = make_node_op_equals(mode, mentioned);
#line 159
      return (tmp___0);
    }
  }
#line 164
  needed = (size_t )1;
#line 166
  p = mode_string;
#line 166
  while (*p) {
#line 167
    if ((int const   )*p == 61) {
#line 167
      tmp___1 = 1;
    } else
#line 167
    if ((int const   )*p == 43) {
#line 167
      tmp___1 = 1;
    } else
#line 167
    if ((int const   )*p == 45) {
#line 167
      tmp___1 = 1;
    } else {
#line 167
      tmp___1 = 0;
    }
#line 167
    needed += (size_t )tmp___1;
#line 166
    p ++;
  }
#line 168
  tmp___2 = xnmalloc(needed, sizeof(*mc));
#line 168
  mc = (struct mode_change *)tmp___2;
#line 172
  while (1) {
#line 175
    affected = (mode_t )0;
#line 178
    while (1) {
#line 179
      switch ((int )*mode_string) {
      default: 
#line 182
      goto invalid;
      case 117: 
#line 184
      affected |= 2496U;
#line 185
      break;
      case 103: 
#line 187
      affected |= (unsigned int )(1024 | (448 >> 3));
#line 188
      break;
      case 111: 
#line 190
      affected |= (unsigned int )(512 | ((448 >> 3) >> 3));
#line 191
      break;
      case 97: 
#line 193
      affected |= (unsigned int )((4032 | (448 >> 3)) | ((448 >> 3) >> 3));
#line 194
      break;
      case 61: 
      case 43: 
      case 45: 
#line 196
      goto no_more_affected;
      }
#line 178
      mode_string ++;
    }
    no_more_affected: ;
#line 200
    while (1) {
#line 202
      tmp___3 = mode_string;
#line 202
      mode_string ++;
#line 202
      op = (char )*tmp___3;
#line 204
      flag = (char)3;
#line 207
      tmp___4 = mode_string;
#line 207
      mode_string ++;
#line 207
      switch ((int )*tmp___4) {
      case 117: 
#line 212
      value = (mode_t )448;
#line 213
      break;
      case 103: 
#line 217
      value = (mode_t )(448 >> 3);
#line 218
      break;
      case 111: 
#line 222
      value = (mode_t )((448 >> 3) >> 3);
#line 223
      break;
      default: 
#line 226
      value = (mode_t )0;
#line 227
      flag = (char)1;
#line 229
      mode_string --;
#line 229
      while (1) {
#line 230
        switch ((int )*mode_string) {
        case 114: 
#line 233
        value |= (unsigned int )((256 | (256 >> 3)) | ((256 >> 3) >> 3));
#line 234
        break;
        case 119: 
#line 236
        value |= (unsigned int )((128 | (128 >> 3)) | ((128 >> 3) >> 3));
#line 237
        break;
        case 120: 
#line 239
        value |= (unsigned int )((64 | (64 >> 3)) | ((64 >> 3) >> 3));
#line 240
        break;
        case 88: 
#line 242
        flag = (char)2;
#line 243
        break;
        case 115: 
#line 246
        value |= 3072U;
#line 247
        break;
        case 116: 
#line 250
        value |= 512U;
#line 251
        break;
        default: 
#line 253
        goto no_more_values;
        }
#line 229
        mode_string ++;
      }
      no_more_values: ;
      }
#line 258
      tmp___5 = used;
#line 258
      used ++;
#line 258
      change = mc + tmp___5;
#line 259
      change->op = op;
#line 260
      change->flag = flag;
#line 261
      change->affected = affected;
#line 262
      change->value = value;
#line 263
      if (affected) {
#line 263
        change->mentioned = affected & value;
      } else {
#line 263
        change->mentioned = value;
      }
#line 200
      if (! ((int const   )*mode_string == 61)) {
#line 200
        if (! ((int const   )*mode_string == 43)) {
#line 200
          if (! ((int const   )*mode_string == 45)) {
#line 200
            break;
          }
        }
      }
    }
#line 268
    if ((int const   )*mode_string != 44) {
#line 269
      break;
    }
#line 172
    mode_string ++;
  }
#line 272
  if ((int const   )*mode_string == 0) {
#line 274
    (mc + used)->flag = (char)0;
#line 275
    return (mc);
  }
  invalid: 
#line 279
  free((void *)mc);
#line 280
  return ((struct mode_change *)((void *)0));
}
}
#line 286 "modechange.c"
struct mode_change *mode_create_from_ref(char const   *ref_file ) 
{ struct stat ref_stats ;
  int tmp ;
  struct mode_change *tmp___0 ;

  {
#line 291
  tmp = stat((char const   * __restrict  )ref_file, (struct stat * __restrict  )(& ref_stats));
#line 291
  if (tmp != 0) {
#line 292
    return ((struct mode_change *)((void *)0));
  }
#line 293
  tmp___0 = make_node_op_equals(ref_stats.st_mode, (mode_t )((4032 | (448 >> 3)) | ((448 >> 3) >> 3)));
#line 293
  return (tmp___0);
}
}
#line 309 "modechange.c"
mode_t mode_adjust(mode_t oldmode , _Bool dir , mode_t umask_value , struct mode_change  const  *changes ,
                   mode_t *pmode_bits ) 
{ mode_t newmode ;
  mode_t mode_bits ;
  mode_t affected ;
  mode_t omit_change ;
  int tmp ;
  mode_t value ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  mode_t tmp___3 ;
  mode_t preserved ;
  mode_t tmp___4 ;

  {
#line 314
  newmode = oldmode & (unsigned int )((4032 | (448 >> 3)) | ((448 >> 3) >> 3));
#line 317
  mode_bits = (mode_t )0;
#line 319
  while ((int const   )changes->flag != 0) {
#line 321
    affected = (mode_t )changes->affected;
#line 322
    if (dir) {
#line 322
      tmp = 3072;
    } else {
#line 322
      tmp = 0;
    }
#line 322
    omit_change = (mode_t )((unsigned int const   )tmp & ~ changes->mentioned);
#line 324
    value = (mode_t )changes->value;
#line 326
    switch ((int )changes->flag) {
    case 1: 
#line 329
    break;
    case 3: 
#line 333
    value &= newmode;
#line 336
    if (value & (unsigned int )((256 | (256 >> 3)) | ((256 >> 3) >> 3))) {
#line 336
      tmp___0 = (256 | (256 >> 3)) | ((256 >> 3) >> 3);
    } else {
#line 336
      tmp___0 = 0;
    }
#line 336
    if (value & (unsigned int )((128 | (128 >> 3)) | ((128 >> 3) >> 3))) {
#line 336
      tmp___1 = (128 | (128 >> 3)) | ((128 >> 3) >> 3);
    } else {
#line 336
      tmp___1 = 0;
    }
#line 336
    if (value & (unsigned int )((64 | (64 >> 3)) | ((64 >> 3) >> 3))) {
#line 336
      tmp___2 = (64 | (64 >> 3)) | ((64 >> 3) >> 3);
    } else {
#line 336
      tmp___2 = 0;
    }
#line 336
    value |= (unsigned int )((tmp___0 | tmp___1) | tmp___2);
#line 342
    break;
    case 2: 
#line 347
    if ((newmode & (unsigned int )((64 | (64 >> 3)) | ((64 >> 3) >> 3))) | (unsigned int )dir) {
#line 348
      value |= (unsigned int )((64 | (64 >> 3)) | ((64 >> 3) >> 3));
    }
#line 349
    break;
    }
#line 355
    if (affected) {
#line 355
      tmp___3 = affected;
    } else {
#line 355
      tmp___3 = ~ umask_value;
    }
#line 355
    value &= tmp___3 & ~ omit_change;
#line 357
    switch ((int )changes->op) {
    case 61: 
#line 364
    if (affected) {
#line 364
      tmp___4 = ~ affected;
    } else {
#line 364
      tmp___4 = (mode_t )0;
    }
#line 364
    preserved = tmp___4 | omit_change;
#line 365
    mode_bits |= (unsigned int )((4032 | (448 >> 3)) | ((448 >> 3) >> 3)) & ~ preserved;
#line 366
    newmode = (newmode & preserved) | value;
#line 367
    break;
    case 43: 
#line 371
    mode_bits |= value;
#line 372
    newmode |= value;
#line 373
    break;
    case 45: 
#line 376
    mode_bits |= value;
#line 377
    newmode &= ~ value;
#line 378
    break;
    }
#line 319
    changes ++;
  }
#line 382
  if (pmode_bits) {
#line 383
    *pmode_bits = mode_bits;
  }
#line 384
  return (newmode);
}
}
#line 1 "mpsort.o"
#pragma merger(0,"/tmp/cil-ODmzwPVm.i","-g,-O2")
#line 2 "mpsort.h"
void mpsort(void const   **base , size_t n , int (*cmp)(void const   * , void const   * ) ) ;
#line 30 "mpsort.c"
static void mpsort_with_tmp(void const   ** __restrict  base , size_t n , void const   ** __restrict  tmp ,
                            int (*cmp)(void const   * , void const   * ) ) ;
#line 36 "mpsort.c"
static void mpsort_into_tmp(void const   ** __restrict  base , size_t n , void const   ** __restrict  tmp ,
                            int (*cmp)(void const   * , void const   * ) ) 
{ size_t n1 ;
  size_t n2 ;
  size_t a ;
  size_t alim ;
  size_t b ;
  size_t blim ;
  void const   *ba ;
  void const   *bb ;
  void const   ** __restrict  tmp___0 ;
  void const   ** __restrict  tmp___1 ;
  int tmp___2 ;

  {
#line 41
  n1 = n / 2UL;
#line 42
  n2 = n - n1;
#line 43
  a = (size_t )0;
#line 44
  alim = n1;
#line 45
  b = n1;
#line 46
  blim = n;
#line 50
  mpsort_with_tmp(base + n1, n2, tmp, cmp);
#line 51
  mpsort_with_tmp(base, n1, tmp, cmp);
#line 53
  ba = *(base + a);
#line 54
  bb = *(base + b);
#line 56
  while (1) {
#line 57
    tmp___2 = (*cmp)(ba, bb);
#line 57
    if (tmp___2 <= 0) {
#line 59
      tmp___0 = tmp;
#line 59
      tmp ++;
#line 59
      *tmp___0 = ba;
#line 60
      a ++;
#line 61
      if (a == alim) {
#line 63
        a = b;
#line 64
        alim = blim;
#line 65
        break;
      }
#line 67
      ba = *(base + a);
    } else {
#line 71
      tmp___1 = tmp;
#line 71
      tmp ++;
#line 71
      *tmp___1 = bb;
#line 72
      b ++;
#line 73
      if (b == blim) {
#line 74
        break;
      }
#line 75
      bb = *(base + b);
    }
  }
#line 78
  memcpy((void * __restrict  )tmp, (void const   * __restrict  )(base + a), (alim - a) * sizeof(*base));
#line 79
  return;
}
}
#line 85 "mpsort.c"
static void mpsort_with_tmp(void const   ** __restrict  base , size_t n , void const   ** __restrict  tmp ,
                            int (*cmp)(void const   * , void const   * ) ) 
{ void const   *p0 ;
  void const   *p1 ;
  int tmp___0 ;
  size_t n1 ;
  size_t n2 ;
  size_t i ;
  size_t t ;
  size_t tlim ;
  size_t b ;
  size_t blim ;
  void const   *bb ;
  void const   *tt ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
#line 90
  if (n <= 2UL) {
#line 92
    if (n == 2UL) {
#line 94
      p0 = *(base + 0);
#line 95
      p1 = *(base + 1);
#line 96
      tmp___0 = (*cmp)(p0, p1);
#line 96
      if (! (tmp___0 <= 0)) {
#line 98
        *(base + 0) = p1;
#line 99
        *(base + 1) = p0;
      }
    }
  } else {
#line 105
    n1 = n / 2UL;
#line 106
    n2 = n - n1;
#line 108
    t = (size_t )0;
#line 109
    tlim = n1;
#line 110
    b = n1;
#line 111
    blim = n;
#line 115
    mpsort_with_tmp(base + n1, n2, tmp, cmp);
#line 117
    if (n1 < 2UL) {
#line 118
      *(tmp + 0) = *(base + 0);
    } else {
#line 120
      mpsort_into_tmp(base, n1, tmp, cmp);
    }
#line 122
    tt = *(tmp + t);
#line 123
    bb = *(base + b);
#line 125
    i = (size_t )0;
#line 125
    while (1) {
#line 126
      tmp___3 = (*cmp)(tt, bb);
#line 126
      if (tmp___3 <= 0) {
#line 128
        tmp___1 = i;
#line 128
        i ++;
#line 128
        *(base + tmp___1) = tt;
#line 129
        t ++;
#line 130
        if (t == tlim) {
#line 131
          break;
        }
#line 132
        tt = *(tmp + t);
      } else {
#line 136
        tmp___2 = i;
#line 136
        i ++;
#line 136
        *(base + tmp___2) = bb;
#line 137
        b ++;
#line 138
        if (b == blim) {
#line 140
          memcpy((void * __restrict  )(base + i), (void const   * __restrict  )(tmp + t),
                 (tlim - t) * sizeof(*base));
#line 141
          break;
        }
#line 143
        bb = *(base + b);
      }
    }
  }
#line 146
  return;
}
}
#line 152 "mpsort.c"
void mpsort(void const   **base , size_t n , int (*cmp)(void const   * , void const   * ) ) 
{ 

  {
#line 155
  mpsort_with_tmp((void const   ** __restrict  )base, n, (void const   ** __restrict  )(base + n),
                  cmp);
#line 156
  return;
}
}
#line 1 "nproc.o"
#pragma merger(0,"/tmp/cil-SfPDResb.i","-g,-O2")
#line 45 "nproc.h"
unsigned long num_processors(enum nproc_query query ) ;
#line 188 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long strtoul(char const   * __restrict  __nptr ,
                                                           char ** __restrict  __endptr ,
                                                           int __base )  __attribute__((__warn_unused_result__,
__nonnull__(1))) ;
#line 616 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) long sysconf(int __name ) ;
#line 201 "/usr/include/bits/sched.h"
extern  __attribute__((__nothrow__)) int __sched_cpucount(size_t __setsize , cpu_set_t const   *__setp ) ;
#line 122 "/usr/include/sched.h"
extern  __attribute__((__nothrow__)) int sched_getaffinity(__pid_t __pid , size_t __cpusetsize ,
                                                           cpu_set_t *__cpuset ) ;
#line 68 "nproc.c"
static unsigned long num_processors_via_affinity_mask(void) 
{ cpu_set_t set ;
  unsigned long count ;
  int tmp ;
  int tmp___0 ;

  {
#line 131
  tmp___0 = sched_getaffinity(0, sizeof(set), & set);
#line 131
  if (tmp___0 == 0) {
#line 137
    tmp = __sched_cpucount(sizeof(cpu_set_t ), (cpu_set_t const   *)(& set));
#line 137
    count = (unsigned long )tmp;
#line 146
    if (count > 0UL) {
#line 147
      return (count);
    }
  }
#line 199
  return (0UL);
}
}
#line 202 "nproc.c"
unsigned long num_processors(enum nproc_query query ) 
{ char const   *envvalue ;
  char *tmp ;
  int __c ;
  int tmp___0 ;
  char *endptr ;
  unsigned long value ;
  unsigned long tmp___1 ;
  int __c___0 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  int __c___1 ;
  int tmp___4 ;
  unsigned long nprocs ;
  unsigned long tmp___5 ;
  long nprocs___0 ;
  long tmp___6 ;
  long nprocs___1 ;
  long tmp___7 ;
  unsigned long nprocs_current ;
  unsigned long tmp___8 ;

  {
#line 205
  if ((unsigned int )query == 2U) {
#line 211
    tmp = getenv("OMP_NUM_THREADS");
#line 211
    envvalue = (char const   *)tmp;
#line 213
    if ((unsigned long )envvalue != (unsigned long )((void *)0)) {
#line 215
      while (1) {
#line 215
        if ((int const   )*envvalue != 0) {
#line 215
          __c = (int )*envvalue;
#line 215
          if (__c == 32) {
#line 215
            tmp___0 = 1;
          } else
#line 215
          if (__c == 9) {
#line 215
            tmp___0 = 1;
          } else
#line 215
          if (__c == 10) {
#line 215
            tmp___0 = 1;
          } else
#line 215
          if (__c == 11) {
#line 215
            tmp___0 = 1;
          } else
#line 215
          if (__c == 12) {
#line 215
            tmp___0 = 1;
          } else
#line 215
          if (__c == 13) {
#line 215
            tmp___0 = 1;
          } else {
#line 215
            tmp___0 = 0;
          }
#line 215
          if (! tmp___0) {
#line 215
            break;
          }
        } else {
#line 215
          break;
        }
#line 216
        envvalue ++;
      }
#line 218
      __c___1 = (int )*envvalue;
#line 218
      if (__c___1 >= 48) {
#line 218
        if (__c___1 <= 57) {
#line 218
          tmp___4 = 1;
        } else {
#line 218
          tmp___4 = 0;
        }
      } else {
#line 218
        tmp___4 = 0;
      }
#line 218
      if (tmp___4) {
#line 220
        endptr = (char *)((void *)0);
#line 221
        tmp___1 = strtoul((char const   * __restrict  )envvalue, (char ** __restrict  )(& endptr),
                          10);
#line 221
        value = tmp___1;
#line 223
        if ((unsigned long )endptr != (unsigned long )((void *)0)) {
#line 225
          while (1) {
#line 225
            if ((int )*endptr != 0) {
#line 225
              __c___0 = (int )*endptr;
#line 225
              if (__c___0 == 32) {
#line 225
                tmp___2 = 1;
              } else
#line 225
              if (__c___0 == 9) {
#line 225
                tmp___2 = 1;
              } else
#line 225
              if (__c___0 == 10) {
#line 225
                tmp___2 = 1;
              } else
#line 225
              if (__c___0 == 11) {
#line 225
                tmp___2 = 1;
              } else
#line 225
              if (__c___0 == 12) {
#line 225
                tmp___2 = 1;
              } else
#line 225
              if (__c___0 == 13) {
#line 225
                tmp___2 = 1;
              } else {
#line 225
                tmp___2 = 0;
              }
#line 225
              if (! tmp___2) {
#line 225
                break;
              }
            } else {
#line 225
              break;
            }
#line 226
            endptr ++;
          }
#line 227
          if ((int )*endptr == 0) {
#line 228
            if (value > 0UL) {
#line 228
              tmp___3 = value;
            } else {
#line 228
              tmp___3 = 1UL;
            }
#line 228
            return (tmp___3);
          }
        }
      }
    }
#line 233
    query = (enum nproc_query )1;
  }
#line 251
  if ((unsigned int )query == 1U) {
#line 255
    tmp___5 = num_processors_via_affinity_mask();
#line 255
    nprocs = tmp___5;
#line 257
    if (nprocs > 0UL) {
#line 258
      return (nprocs);
    }
#line 264
    tmp___6 = sysconf(84);
#line 264
    nprocs___0 = tmp___6;
#line 265
    if (nprocs___0 > 0L) {
#line 266
      return ((unsigned long )nprocs___0);
    }
  } else {
#line 275
    tmp___7 = sysconf(83);
#line 275
    nprocs___1 = tmp___7;
#line 283
    if (nprocs___1 == 1L) {
#line 285
      tmp___8 = num_processors_via_affinity_mask();
#line 285
      nprocs_current = tmp___8;
#line 287
      if (nprocs_current > 0UL) {
#line 288
        nprocs___1 = (long )nprocs_current;
      }
    }
#line 292
    if (nprocs___1 > 0L) {
#line 293
      return ((unsigned long )nprocs___1);
    }
  }
#line 359
  return (1UL);
}
}
#line 1 "openat-die.o"
#pragma merger(0,"/tmp/cil-sr144Gtg.i","-g,-O2")
#line 44 "openat.h"
 __attribute__((__noreturn__)) void openat_restore_fail(int errnum ) ;
#line 45
 __attribute__((__noreturn__)) void openat_save_fail(int errnum ) ;
#line 33 "openat-die.c"
 __attribute__((__noreturn__)) void openat_save_fail(int errnum ) ;
#line 33 "openat-die.c"
void openat_save_fail(int errnum ) 
{ char *tmp ;

  {
#line 37
  tmp = dcgettext((char const   *)((void *)0), "unable to record current working directory",
                  5);
#line 37
  error((int )exit_failure, errnum, (char const   *)tmp);
#line 44
  abort();
}
}
#line 52
 __attribute__((__noreturn__)) void openat_restore_fail(int errnum ) ;
#line 52 "openat-die.c"
void openat_restore_fail(int errnum ) 
{ char *tmp ;

  {
#line 56
  tmp = dcgettext((char const   *)((void *)0), "failed to return to initial working directory",
                  5);
#line 56
  error((int )exit_failure, errnum, (char const   *)tmp);
#line 61
  abort();
}
}
#line 1 "openat-safer.o"
#pragma merger(0,"/tmp/cil-PVqyolHj.i","-g,-O2")
#line 26 "fcntl-safer.h"
int openat_safer(int fd , char const   *file , int flags  , ...) ;
#line 28 "openat-safer.c"
int openat_safer(int fd , char const   *file , int flags  , ...) 
{ mode_t mode ;
  va_list ap ;
  int __attribute__((__artificial__))  tmp ;
  int tmp___0 ;

  {
#line 31
  mode = (mode_t )0;
#line 33
  if (flags & 64) {
#line 36
    __builtin_va_start(ap, flags);
#line 40
    mode = __builtin_va_arg(ap, mode_t );
#line 42
    __builtin_va_end(ap);
  }
#line 45
  tmp = openat(fd, file, flags, mode);
#line 45
  tmp___0 = fd_safer((int )tmp);
#line 45
  return (tmp___0);
}
}
#line 1 "parse-datetime.o"
#pragma merger(0,"/tmp/cil-AV7obLFh.i","-g,-O2")
#line 237 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t const   *__timer ) ;
#line 22 "parse-datetime.h"
_Bool parse_datetime(struct timespec *result , char const   *p , struct timespec  const  *now ) ;
#line 585 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int setenv(char const   *__name , char const   *__value ,
                                                int __replace )  __attribute__((__nonnull__(2))) ;
#line 589
extern  __attribute__((__nothrow__)) int unsetenv(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 771
extern  __attribute__((__nothrow__)) int abs(int __x )  __attribute__((__warn_unused_result__,
__const__)) ;
#line 58 "xalloc.h"
void *xmemdup(void const   *p , size_t s )  __attribute__((__malloc__, __alloc_size__(2))) ;
#line 212 "parse-datetime.y"
static int yylex(union YYSTYPE *lvalp , parser_control *pc ) ;
#line 213
static int yyerror(parser_control const   *pc  __attribute__((__unused__)) , char const   *s  __attribute__((__unused__)) ) ;
#line 214
static long time_zone_hhmm(parser_control *pc , textint s , long mm ) ;
#line 219 "parse-datetime.y"
static void digits_to_date_time(parser_control *pc , textint text_int ) 
{ 

  {
#line 222
  if (pc->dates_seen) {
#line 222
    if (! pc->year.digits) {
#line 222
      if (! pc->rels_seen) {
#line 222
        if (pc->times_seen) {
#line 224
          pc->year = text_int;
        } else
#line 222
        if (2UL < text_int.digits) {
#line 224
          pc->year = text_int;
        } else {
#line 222
          goto _L___1;
        }
      } else {
#line 222
        goto _L___1;
      }
    } else {
#line 222
      goto _L___1;
    }
  } else
  _L___1: 
#line 227
  if (4UL < text_int.digits) {
#line 229
    (pc->dates_seen) ++;
#line 230
    pc->day = text_int.value % 100L;
#line 231
    pc->month = (text_int.value / 100L) % 100L;
#line 232
    pc->year.value = text_int.value / 10000L;
#line 233
    pc->year.digits = text_int.digits - 4UL;
  } else {
#line 237
    (pc->times_seen) ++;
#line 238
    if (text_int.digits <= 2UL) {
#line 240
      pc->hour = text_int.value;
#line 241
      pc->minutes = 0L;
    } else {
#line 245
      pc->hour = text_int.value / 100L;
#line 246
      pc->minutes = text_int.value % 100L;
    }
#line 248
    pc->seconds.tv_sec = (__time_t )0;
#line 249
    pc->seconds.tv_nsec = 0L;
#line 250
    pc->meridian = 2;
  }
#line 253
  return;
}
}
#line 256 "parse-datetime.y"
static void apply_relative_time(parser_control *pc , relative_time rel , int factor ) 
{ 

  {
#line 259
  pc->rel.ns += (long )factor * rel.ns;
#line 260
  pc->rel.seconds += (long_time_t )factor * rel.seconds;
#line 261
  pc->rel.minutes += (long )factor * rel.minutes;
#line 262
  pc->rel.hour += (long )factor * rel.hour;
#line 263
  pc->rel.day += (long )factor * rel.day;
#line 264
  pc->rel.month += (long )factor * rel.month;
#line 265
  pc->rel.year += (long )factor * rel.year;
#line 266
  pc->rels_seen = (_Bool)1;
#line 267
  return;
}
}
#line 270 "parse-datetime.y"
static void set_hhmmss(parser_control *pc , long hour , long minutes , time_t sec ,
                       long nsec ) 
{ 

  {
#line 274
  pc->hour = hour;
#line 275
  pc->minutes = minutes;
#line 276
  pc->seconds.tv_sec = sec;
#line 277
  pc->seconds.tv_nsec = nsec;
#line 278
  return;
}
}
#line 689 "parse-datetime.c"
static yytype_uint8 const   yytranslate[278]  = 
#line 689 "parse-datetime.c"
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )26,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )27, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )25,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )23,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )24,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22};
#line 815 "parse-datetime.c"
static yytype_uint8 const   yyr1[92]  = 
#line 815
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )28,      (yytype_uint8 const   )29,      (yytype_uint8 const   )29, 
        (yytype_uint8 const   )30,      (yytype_uint8 const   )31,      (yytype_uint8 const   )31,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )32,      (yytype_uint8 const   )32,      (yytype_uint8 const   )32,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )32,      (yytype_uint8 const   )32,      (yytype_uint8 const   )32,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )34,      (yytype_uint8 const   )35,      (yytype_uint8 const   )35, 
        (yytype_uint8 const   )35,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )36,      (yytype_uint8 const   )37,      (yytype_uint8 const   )37,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )39,      (yytype_uint8 const   )39,      (yytype_uint8 const   )40,      (yytype_uint8 const   )40, 
        (yytype_uint8 const   )40,      (yytype_uint8 const   )40,      (yytype_uint8 const   )40,      (yytype_uint8 const   )40, 
        (yytype_uint8 const   )40,      (yytype_uint8 const   )41,      (yytype_uint8 const   )41,      (yytype_uint8 const   )41, 
        (yytype_uint8 const   )41,      (yytype_uint8 const   )42,      (yytype_uint8 const   )42,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )42,      (yytype_uint8 const   )42,      (yytype_uint8 const   )42,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )42,      (yytype_uint8 const   )42,      (yytype_uint8 const   )43,      (yytype_uint8 const   )44, 
        (yytype_uint8 const   )44,      (yytype_uint8 const   )44,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )46, 
        (yytype_uint8 const   )46,      (yytype_uint8 const   )46,      (yytype_uint8 const   )46,      (yytype_uint8 const   )46, 
        (yytype_uint8 const   )46,      (yytype_uint8 const   )47,      (yytype_uint8 const   )48,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )49,      (yytype_uint8 const   )50,      (yytype_uint8 const   )50, 
        (yytype_uint8 const   )51,      (yytype_uint8 const   )52,      (yytype_uint8 const   )53,      (yytype_uint8 const   )53};
#line 830 "parse-datetime.c"
static yytype_uint8 const   yyr2[92]  = 
#line 830
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )5,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )4,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2};
#line 847 "parse-datetime.c"
static yytype_uint8 const   yydefact[114]  = 
#line 847
  {      (yytype_uint8 const   )5,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )85,      (yytype_uint8 const   )87,      (yytype_uint8 const   )84, 
        (yytype_uint8 const   )86,      (yytype_uint8 const   )4,      (yytype_uint8 const   )82,      (yytype_uint8 const   )83, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )56,      (yytype_uint8 const   )59,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )68,      (yytype_uint8 const   )73,      (yytype_uint8 const   )62,      (yytype_uint8 const   )81, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )35,      (yytype_uint8 const   )28,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )30,      (yytype_uint8 const   )0,      (yytype_uint8 const   )88, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )31,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )16,      (yytype_uint8 const   )8,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )12,      (yytype_uint8 const   )11, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )13,      (yytype_uint8 const   )52,      (yytype_uint8 const   )74, 
        (yytype_uint8 const   )53,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )0,      (yytype_uint8 const   )45,      (yytype_uint8 const   )54, 
        (yytype_uint8 const   )57,      (yytype_uint8 const   )63,      (yytype_uint8 const   )66,      (yytype_uint8 const   )69, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )39,      (yytype_uint8 const   )36,      (yytype_uint8 const   )90, 
        (yytype_uint8 const   )32,      (yytype_uint8 const   )75,      (yytype_uint8 const   )76,      (yytype_uint8 const   )78, 
        (yytype_uint8 const   )79,      (yytype_uint8 const   )80,      (yytype_uint8 const   )77,      (yytype_uint8 const   )55, 
        (yytype_uint8 const   )58,      (yytype_uint8 const   )64,      (yytype_uint8 const   )67,      (yytype_uint8 const   )70, 
        (yytype_uint8 const   )61,      (yytype_uint8 const   )40,      (yytype_uint8 const   )18,      (yytype_uint8 const   )47, 
        (yytype_uint8 const   )90,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )22, 
        (yytype_uint8 const   )89,      (yytype_uint8 const   )71,      (yytype_uint8 const   )72,      (yytype_uint8 const   )33, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )51,      (yytype_uint8 const   )44,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )34,      (yytype_uint8 const   )43,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )50,      (yytype_uint8 const   )27,      (yytype_uint8 const   )25,      (yytype_uint8 const   )41, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )17,      (yytype_uint8 const   )46,      (yytype_uint8 const   )91, 
        (yytype_uint8 const   )19,      (yytype_uint8 const   )90,      (yytype_uint8 const   )0,      (yytype_uint8 const   )23, 
        (yytype_uint8 const   )26,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )25, 
        (yytype_uint8 const   )42,      (yytype_uint8 const   )25,      (yytype_uint8 const   )20,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )25};
#line 864 "parse-datetime.c"
static yytype_int8 const   yydefgoto[26]  = 
#line 864
  {      (yytype_int8 const   )-1,      (yytype_int8 const   )2,      (yytype_int8 const   )3,      (yytype_int8 const   )4, 
        (yytype_int8 const   )31,      (yytype_int8 const   )32,      (yytype_int8 const   )33,      (yytype_int8 const   )34, 
        (yytype_int8 const   )35,      (yytype_int8 const   )103,      (yytype_int8 const   )104,      (yytype_int8 const   )36, 
        (yytype_int8 const   )37,      (yytype_int8 const   )38,      (yytype_int8 const   )39,      (yytype_int8 const   )40, 
        (yytype_int8 const   )41,      (yytype_int8 const   )42,      (yytype_int8 const   )43,      (yytype_int8 const   )44, 
        (yytype_int8 const   )9,      (yytype_int8 const   )10,      (yytype_int8 const   )11,      (yytype_int8 const   )45, 
        (yytype_int8 const   )46,      (yytype_int8 const   )93};
#line 874 "parse-datetime.c"
static yytype_int8 const   yypact[114]  = 
#line 874
  {      (yytype_int8 const   )38,      (yytype_int8 const   )27,      (yytype_int8 const   )77,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )46,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )62,      (yytype_int8 const   )-93,      (yytype_int8 const   )82,      (yytype_int8 const   )-3, 
        (yytype_int8 const   )66,      (yytype_int8 const   )3,      (yytype_int8 const   )74,      (yytype_int8 const   )-4, 
        (yytype_int8 const   )83,      (yytype_int8 const   )84,      (yytype_int8 const   )75,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )71,      (yytype_int8 const   )-93,      (yytype_int8 const   )93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )78,      (yytype_int8 const   )72,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )25, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )21, 
        (yytype_int8 const   )19,      (yytype_int8 const   )79,      (yytype_int8 const   )80,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )81,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )85, 
        (yytype_int8 const   )86,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-6,      (yytype_int8 const   )76, 
        (yytype_int8 const   )17,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )87,      (yytype_int8 const   )69,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )88,      (yytype_int8 const   )89,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )18,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )69,      (yytype_int8 const   )91};
#line 891 "parse-datetime.c"
static yytype_int8 const   yypgoto[26]  = 
#line 891
  {      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )20,      (yytype_int8 const   )-68,      (yytype_int8 const   )-27,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )60,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-92,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )43};
#line 903 "parse-datetime.c"
static yytype_uint8 const   yytable[113]  = 
#line 903
  {      (yytype_uint8 const   )79,      (yytype_uint8 const   )67,      (yytype_uint8 const   )68,      (yytype_uint8 const   )69, 
        (yytype_uint8 const   )70,      (yytype_uint8 const   )71,      (yytype_uint8 const   )72,      (yytype_uint8 const   )58, 
        (yytype_uint8 const   )73,      (yytype_uint8 const   )100,      (yytype_uint8 const   )107,      (yytype_uint8 const   )74, 
        (yytype_uint8 const   )75,      (yytype_uint8 const   )101,      (yytype_uint8 const   )110,      (yytype_uint8 const   )76, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )50,      (yytype_uint8 const   )101,      (yytype_uint8 const   )102, 
        (yytype_uint8 const   )113,      (yytype_uint8 const   )77,      (yytype_uint8 const   )59,      (yytype_uint8 const   )78, 
        (yytype_uint8 const   )61,      (yytype_uint8 const   )62,      (yytype_uint8 const   )63,      (yytype_uint8 const   )64, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )66,      (yytype_uint8 const   )61,      (yytype_uint8 const   )62, 
        (yytype_uint8 const   )63,      (yytype_uint8 const   )64,      (yytype_uint8 const   )65,      (yytype_uint8 const   )66, 
        (yytype_uint8 const   )101,      (yytype_uint8 const   )101,      (yytype_uint8 const   )92,      (yytype_uint8 const   )111, 
        (yytype_uint8 const   )90,      (yytype_uint8 const   )91,      (yytype_uint8 const   )106,      (yytype_uint8 const   )112, 
        (yytype_uint8 const   )88,      (yytype_uint8 const   )111,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )8,      (yytype_uint8 const   )88,      (yytype_uint8 const   )13, 
        (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16,      (yytype_uint8 const   )17, 
        (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )22,      (yytype_uint8 const   )1,      (yytype_uint8 const   )23,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )79,      (yytype_uint8 const   )30,      (yytype_uint8 const   )51, 
        (yytype_uint8 const   )52,      (yytype_uint8 const   )53,      (yytype_uint8 const   )54,      (yytype_uint8 const   )55, 
        (yytype_uint8 const   )56,      (yytype_uint8 const   )12,      (yytype_uint8 const   )57,      (yytype_uint8 const   )61, 
        (yytype_uint8 const   )62,      (yytype_uint8 const   )63,      (yytype_uint8 const   )64,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )66,      (yytype_uint8 const   )60,      (yytype_uint8 const   )48,      (yytype_uint8 const   )80, 
        (yytype_uint8 const   )47,      (yytype_uint8 const   )6,      (yytype_uint8 const   )83,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )81,      (yytype_uint8 const   )82,      (yytype_uint8 const   )26,      (yytype_uint8 const   )84, 
        (yytype_uint8 const   )85,      (yytype_uint8 const   )86,      (yytype_uint8 const   )87,      (yytype_uint8 const   )94, 
        (yytype_uint8 const   )95,      (yytype_uint8 const   )96,      (yytype_uint8 const   )89,      (yytype_uint8 const   )105, 
        (yytype_uint8 const   )97,      (yytype_uint8 const   )98,      (yytype_uint8 const   )99,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )108,      (yytype_uint8 const   )109,      (yytype_uint8 const   )101,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )88};
#line 919 "parse-datetime.c"
static yytype_int8 const   yycheck[113]  = 
#line 919
  {      (yytype_int8 const   )27,      (yytype_int8 const   )5,      (yytype_int8 const   )6,      (yytype_int8 const   )7, 
        (yytype_int8 const   )8,      (yytype_int8 const   )9,      (yytype_int8 const   )10,      (yytype_int8 const   )4, 
        (yytype_int8 const   )12,      (yytype_int8 const   )15,      (yytype_int8 const   )102,      (yytype_int8 const   )15, 
        (yytype_int8 const   )16,      (yytype_int8 const   )19,      (yytype_int8 const   )15,      (yytype_int8 const   )19, 
        (yytype_int8 const   )19,      (yytype_int8 const   )20,      (yytype_int8 const   )19,      (yytype_int8 const   )25, 
        (yytype_int8 const   )112,      (yytype_int8 const   )25,      (yytype_int8 const   )19,      (yytype_int8 const   )27, 
        (yytype_int8 const   )5,      (yytype_int8 const   )6,      (yytype_int8 const   )7,      (yytype_int8 const   )8, 
        (yytype_int8 const   )9,      (yytype_int8 const   )10,      (yytype_int8 const   )5,      (yytype_int8 const   )6, 
        (yytype_int8 const   )7,      (yytype_int8 const   )8,      (yytype_int8 const   )9,      (yytype_int8 const   )10, 
        (yytype_int8 const   )19,      (yytype_int8 const   )19,      (yytype_int8 const   )19,      (yytype_int8 const   )107, 
        (yytype_int8 const   )19,      (yytype_int8 const   )20,      (yytype_int8 const   )25,      (yytype_int8 const   )25, 
        (yytype_int8 const   )25,      (yytype_int8 const   )113,      (yytype_int8 const   )19,      (yytype_int8 const   )20, 
        (yytype_int8 const   )21,      (yytype_int8 const   )22,      (yytype_int8 const   )25,      (yytype_int8 const   )5, 
        (yytype_int8 const   )6,      (yytype_int8 const   )7,      (yytype_int8 const   )8,      (yytype_int8 const   )9, 
        (yytype_int8 const   )10,      (yytype_int8 const   )11,      (yytype_int8 const   )12,      (yytype_int8 const   )13, 
        (yytype_int8 const   )14,      (yytype_int8 const   )23,      (yytype_int8 const   )16,      (yytype_int8 const   )17, 
        (yytype_int8 const   )18,      (yytype_int8 const   )19,      (yytype_int8 const   )20,      (yytype_int8 const   )21, 
        (yytype_int8 const   )22,      (yytype_int8 const   )96,      (yytype_int8 const   )24,      (yytype_int8 const   )5, 
        (yytype_int8 const   )6,      (yytype_int8 const   )7,      (yytype_int8 const   )8,      (yytype_int8 const   )9, 
        (yytype_int8 const   )10,      (yytype_int8 const   )0,      (yytype_int8 const   )12,      (yytype_int8 const   )5, 
        (yytype_int8 const   )6,      (yytype_int8 const   )7,      (yytype_int8 const   )8,      (yytype_int8 const   )9, 
        (yytype_int8 const   )10,      (yytype_int8 const   )25,      (yytype_int8 const   )4,      (yytype_int8 const   )27, 
        (yytype_int8 const   )26,      (yytype_int8 const   )20,      (yytype_int8 const   )30,      (yytype_int8 const   )22, 
        (yytype_int8 const   )9,      (yytype_int8 const   )9,      (yytype_int8 const   )19,      (yytype_int8 const   )24, 
        (yytype_int8 const   )3,      (yytype_int8 const   )19,      (yytype_int8 const   )26,      (yytype_int8 const   )20, 
        (yytype_int8 const   )20,      (yytype_int8 const   )20,      (yytype_int8 const   )59,      (yytype_int8 const   )27, 
        (yytype_int8 const   )84,      (yytype_int8 const   )20,      (yytype_int8 const   )20,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )20,      (yytype_int8 const   )20,      (yytype_int8 const   )19,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )25};
#line 937 "parse-datetime.c"
static yytype_uint8 const   yystos[114]  = 
#line 937
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )23,      (yytype_uint8 const   )29,      (yytype_uint8 const   )30, 
        (yytype_uint8 const   )31,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )22,      (yytype_uint8 const   )48,      (yytype_uint8 const   )49,      (yytype_uint8 const   )50, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )24,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )34,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )39,      (yytype_uint8 const   )40,      (yytype_uint8 const   )41,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )43,      (yytype_uint8 const   )44,      (yytype_uint8 const   )45,      (yytype_uint8 const   )46, 
        (yytype_uint8 const   )47,      (yytype_uint8 const   )51,      (yytype_uint8 const   )52,      (yytype_uint8 const   )26, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8,      (yytype_uint8 const   )9, 
        (yytype_uint8 const   )10,      (yytype_uint8 const   )12,      (yytype_uint8 const   )4,      (yytype_uint8 const   )19, 
        (yytype_uint8 const   )46,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8,      (yytype_uint8 const   )9, 
        (yytype_uint8 const   )10,      (yytype_uint8 const   )12,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )19,      (yytype_uint8 const   )25,      (yytype_uint8 const   )27,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )46,      (yytype_uint8 const   )9,      (yytype_uint8 const   )9,      (yytype_uint8 const   )46, 
        (yytype_uint8 const   )24,      (yytype_uint8 const   )3,      (yytype_uint8 const   )19,      (yytype_uint8 const   )26, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )53,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )19,      (yytype_uint8 const   )53,      (yytype_uint8 const   )20,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )20,      (yytype_uint8 const   )36,      (yytype_uint8 const   )20,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )15,      (yytype_uint8 const   )19,      (yytype_uint8 const   )25,      (yytype_uint8 const   )37, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )27,      (yytype_uint8 const   )25,      (yytype_uint8 const   )50, 
        (yytype_uint8 const   )20,      (yytype_uint8 const   )20,      (yytype_uint8 const   )15,      (yytype_uint8 const   )37, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )50};
#line 1447 "parse-datetime.c"
static void yydestruct(char const   *yymsg , int yytype , YYSTYPE *yyvaluep , parser_control *pc ) 
{ 

  {
#line 1461
  if (! yymsg) {
#line 1462
    yymsg = "Deleting";
  }
#line 1465
  switch (yytype) {
  default: 
#line 1469
  break;
  }
#line 1471
  return;
}
}
#line 1482
int yyparse(parser_control *pc ) ;
#line 1509 "parse-datetime.c"
int yyparse(parser_control *pc ) 
{ int yychar ;
  YYSTYPE yylval ;
  int yynerrs ;
  int yystate ;
  int yyerrstatus ;
  yytype_int16 yyssa[20] ;
  yytype_int16 *yyss ;
  yytype_int16 *yyssp ;
  YYSTYPE yyvsa[20] ;
  YYSTYPE *yyvs ;
  YYSTYPE *yyvsp ;
  unsigned long yystacksize ;
  int yyn ;
  int yyresult ;
  int yytoken ;
  YYSTYPE yyval ;
  int yylen ;
  unsigned long yysize ;
  yytype_int16 *yyss1 ;
  union yyalloc *yyptr ;
  void *tmp ;
  unsigned long yynewbytes ;
  unsigned long yynewbytes___0 ;
  long tmp___0 ;
  relative_time __constr_expr_0 ;
  relative_time __constr_expr_1 ;
  relative_time __constr_expr_2 ;
  relative_time __constr_expr_3 ;
  relative_time __constr_expr_4 ;
  relative_time __constr_expr_5 ;
  relative_time __constr_expr_6 ;
  relative_time __constr_expr_7 ;
  relative_time __constr_expr_8 ;
  relative_time __constr_expr_9 ;
  relative_time __constr_expr_10 ;
  relative_time __constr_expr_11 ;
  relative_time __constr_expr_12 ;
  relative_time __constr_expr_13 ;
  relative_time __constr_expr_14 ;
  relative_time __constr_expr_15 ;
  relative_time __constr_expr_16 ;
  relative_time __constr_expr_17 ;
  relative_time __constr_expr_18 ;
  relative_time __constr_expr_19 ;
  relative_time __constr_expr_20 ;
  relative_time __constr_expr_21 ;
  relative_time __constr_expr_22 ;
  relative_time __constr_expr_23 ;
  relative_time __constr_expr_24 ;
  relative_time __constr_expr_25 ;
  relative_time __constr_expr_26 ;

  {
#line 1569
  yylen = 0;
#line 1571
  yytoken = 0;
#line 1572
  yyss = yyssa;
#line 1573
  yyvs = yyvsa;
#line 1574
  yystacksize = 20UL;
#line 1578
  yystate = 0;
#line 1579
  yyerrstatus = 0;
#line 1580
  yynerrs = 0;
#line 1581
  yychar = -2;
#line 1587
  yyssp = yyss;
#line 1588
  yyvsp = yyvs;
#line 1590
  goto yysetstate;
  yynewstate: 
#line 1598
  yyssp ++;
  yysetstate: 
#line 1601
  *yyssp = (yytype_int16 )yystate;
#line 1603
  if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1606
    yysize = (unsigned long )((yyssp - yyss) + 1);
#line 1633
    if (20UL <= yystacksize) {
#line 1634
      goto yyexhaustedlab;
    }
#line 1635
    yystacksize *= 2UL;
#line 1636
    if (20UL < yystacksize) {
#line 1637
      yystacksize = 20UL;
    }
#line 1640
    yyss1 = yyss;
#line 1641
    tmp = malloc(yystacksize * (sizeof(yytype_int16 ) + sizeof(YYSTYPE )) + (sizeof(union yyalloc ) - 1UL));
#line 1641
    yyptr = (union yyalloc *)tmp;
#line 1643
    if (! yyptr) {
#line 1644
      goto yyexhaustedlab;
    }
#line 1645
    while (1) {
#line 1645
      __builtin_memcpy((void *)(& yyptr->yyss_alloc), (void const   *)yyss, yysize * sizeof(*yyss));
#line 1645
      yyss = & yyptr->yyss_alloc;
#line 1645
      yynewbytes = yystacksize * sizeof(*yyss) + (sizeof(union yyalloc ) - 1UL);
#line 1645
      yyptr += yynewbytes / sizeof(*yyptr);
#line 1645
      break;
    }
#line 1646
    while (1) {
#line 1646
      __builtin_memcpy((void *)(& yyptr->yyvs_alloc), (void const   *)yyvs, yysize * sizeof(*yyvs));
#line 1646
      yyvs = & yyptr->yyvs_alloc;
#line 1646
      yynewbytes___0 = yystacksize * sizeof(*yyvs) + (sizeof(union yyalloc ) - 1UL);
#line 1646
      yyptr += yynewbytes___0 / sizeof(*yyptr);
#line 1646
      break;
    }
#line 1648
    if ((unsigned long )yyss1 != (unsigned long )(yyssa)) {
#line 1649
      free((void *)yyss1);
    }
#line 1654
    yyssp = (yyss + yysize) - 1;
#line 1655
    yyvsp = (yyvs + yysize) - 1;
#line 1660
    if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1661
      goto yyabortlab;
    }
  }
#line 1666
  if (yystate == 12) {
#line 1667
    goto yyacceptlab;
  }
#line 1669
  goto yybackup;
  yybackup: 
#line 1680
  yyn = (int )yypact[yystate];
#line 1681
  if (yyn == -93) {
#line 1682
    goto yydefault;
  }
#line 1687
  if (yychar == -2) {
#line 1690
    yychar = yylex(& yylval, pc);
  }
#line 1693
  if (yychar <= 0) {
#line 1695
    yytoken = 0;
#line 1695
    yychar = yytoken;
  } else
#line 1700
  if ((unsigned int )yychar <= 277U) {
#line 1700
    yytoken = (int )yytranslate[yychar];
  } else {
#line 1700
    yytoken = 2;
  }
#line 1706
  yyn += yytoken;
#line 1707
  if (yyn < 0) {
#line 1708
    goto yydefault;
  } else
#line 1707
  if (112 < yyn) {
#line 1708
    goto yydefault;
  } else
#line 1707
  if ((int const   )yycheck[yyn] != (int const   )yytoken) {
#line 1708
    goto yydefault;
  }
#line 1709
  yyn = (int )yytable[yyn];
#line 1710
  if (yyn <= 0) {
#line 1712
    if (yyn == 0) {
#line 1713
      goto yyerrlab;
    } else
#line 1712
    if (yyn == -1) {
#line 1713
      goto yyerrlab;
    }
#line 1714
    yyn = - yyn;
#line 1715
    goto yyreduce;
  }
#line 1720
  if (yyerrstatus) {
#line 1721
    yyerrstatus --;
  }
#line 1727
  yychar = -2;
#line 1729
  yystate = yyn;
#line 1730
  yyvsp ++;
#line 1730
  *yyvsp = yylval;
#line 1732
  goto yynewstate;
  yydefault: 
#line 1739
  yyn = (int )yydefact[yystate];
#line 1740
  if (yyn == 0) {
#line 1741
    goto yyerrlab;
  }
#line 1742
  goto yyreduce;
  yyreduce: 
#line 1750
  yylen = (int )yyr2[yyn];
#line 1760
  yyval = *(yyvsp + (1 - yylen));
#line 1764
  switch (yyn) {
  case 4: 
#line 325 "parse-datetime.y"
  pc->seconds = (yyvsp + 0)->timespec;
#line 326
  pc->timespec_seen = (_Bool)1;
#line 328
  break;
  case 7: 
#line 337
  (pc->times_seen) ++;
#line 337
  (pc->dates_seen) ++;
#line 338
  break;
  case 8: 
#line 339
  (pc->times_seen) ++;
#line 340
  break;
  case 9: 
#line 341
  (pc->local_zones_seen) ++;
#line 342
  break;
  case 10: 
#line 343
  (pc->zones_seen) ++;
#line 344
  break;
  case 11: 
#line 345
  (pc->dates_seen) ++;
#line 346
  break;
  case 12: 
#line 347
  (pc->days_seen) ++;
#line 348
  break;
  case 18: 
#line 364
  set_hhmmss(pc, (yyvsp + -1)->textintval.value, 0L, (time_t )0, 0L);
#line 365
  pc->meridian = (int )(yyvsp + 0)->intval;
#line 367
  break;
  case 19: 
#line 369
  set_hhmmss(pc, (yyvsp + -3)->textintval.value, (yyvsp + -1)->textintval.value, (time_t )0,
             0L);
#line 370
  pc->meridian = (int )(yyvsp + 0)->intval;
#line 372
  break;
  case 20: 
#line 374
  set_hhmmss(pc, (yyvsp + -5)->textintval.value, (yyvsp + -3)->textintval.value, (yyvsp + -1)->timespec.tv_sec,
             (yyvsp + -1)->timespec.tv_nsec);
#line 375
  pc->meridian = (int )(yyvsp + 0)->intval;
#line 377
  break;
  case 22: 
#line 383
  set_hhmmss(pc, (yyvsp + -1)->textintval.value, 0L, (time_t )0, 0L);
#line 384
  pc->meridian = 2;
#line 386
  break;
  case 23: 
#line 388
  set_hhmmss(pc, (yyvsp + -3)->textintval.value, (yyvsp + -1)->textintval.value, (time_t )0,
             0L);
#line 389
  pc->meridian = 2;
#line 391
  break;
  case 24: 
#line 393
  set_hhmmss(pc, (yyvsp + -5)->textintval.value, (yyvsp + -3)->textintval.value, (yyvsp + -1)->timespec.tv_sec,
             (yyvsp + -1)->timespec.tv_nsec);
#line 394
  pc->meridian = 2;
#line 396
  break;
  case 27: 
#line 406
  (pc->zones_seen) ++;
#line 407
  pc->time_zone = time_zone_hhmm(pc, (yyvsp + -1)->textintval, (yyvsp + 0)->intval);
#line 409
  break;
  case 28: 
#line 414
  pc->local_isdst = (int )(yyvsp + 0)->intval;
#line 415
  pc->dsts_seen += (size_t )(0L < (yyvsp + 0)->intval);
#line 417
  break;
  case 29: 
#line 419
  pc->local_isdst = 1;
#line 420
  pc->dsts_seen += (size_t )((0L < (yyvsp + -1)->intval) + 1);
#line 422
  break;
  case 30: 
#line 428
  pc->time_zone = (yyvsp + 0)->intval;
#line 429
  break;
  case 31: 
#line 430
  pc->time_zone = 420L;
#line 431
  break;
  case 32: 
#line 432
  pc->time_zone = (yyvsp + -1)->intval;
#line 433
  apply_relative_time(pc, (yyvsp + 0)->rel, 1);
#line 434
  break;
  case 33: 
#line 435
  pc->time_zone = 420L;
#line 436
  apply_relative_time(pc, (yyvsp + 0)->rel, 1);
#line 437
  break;
  case 34: 
#line 438
  tmp___0 = time_zone_hhmm(pc, (yyvsp + -1)->textintval, (yyvsp + 0)->intval);
#line 438
  pc->time_zone = (yyvsp + -2)->intval + tmp___0;
#line 439
  break;
  case 35: 
#line 440
  pc->time_zone = (yyvsp + 0)->intval + 60L;
#line 441
  break;
  case 36: 
#line 442
  pc->time_zone = (yyvsp + -1)->intval + 60L;
#line 443
  break;
  case 37: 
#line 448
  pc->day_ordinal = 0L;
#line 449
  pc->day_number = (int )(yyvsp + 0)->intval;
#line 451
  break;
  case 38: 
#line 453
  pc->day_ordinal = 0L;
#line 454
  pc->day_number = (int )(yyvsp + -1)->intval;
#line 456
  break;
  case 39: 
#line 458
  pc->day_ordinal = (yyvsp + -1)->intval;
#line 459
  pc->day_number = (int )(yyvsp + 0)->intval;
#line 461
  break;
  case 40: 
#line 463
  pc->day_ordinal = (yyvsp + -1)->textintval.value;
#line 464
  pc->day_number = (int )(yyvsp + 0)->intval;
#line 466
  break;
  case 41: 
#line 471
  pc->month = (yyvsp + -2)->textintval.value;
#line 472
  pc->day = (yyvsp + 0)->textintval.value;
#line 474
  break;
  case 42: 
#line 481
  if (4UL <= (yyvsp + -4)->textintval.digits) {
#line 483
    pc->year = (yyvsp + -4)->textintval;
#line 484
    pc->month = (yyvsp + -2)->textintval.value;
#line 485
    pc->day = (yyvsp + 0)->textintval.value;
  } else {
#line 489
    pc->month = (yyvsp + -4)->textintval.value;
#line 490
    pc->day = (yyvsp + -2)->textintval.value;
#line 491
    pc->year = (yyvsp + 0)->textintval;
  }
#line 494
  break;
  case 43: 
#line 497
  pc->day = (yyvsp + -2)->textintval.value;
#line 498
  pc->month = (yyvsp + -1)->intval;
#line 499
  pc->year.value = - (yyvsp + 0)->textintval.value;
#line 500
  pc->year.digits = (yyvsp + 0)->textintval.digits;
#line 502
  break;
  case 44: 
#line 505
  pc->month = (yyvsp + -2)->intval;
#line 506
  pc->day = - (yyvsp + -1)->textintval.value;
#line 507
  pc->year.value = - (yyvsp + 0)->textintval.value;
#line 508
  pc->year.digits = (yyvsp + 0)->textintval.digits;
#line 510
  break;
  case 45: 
#line 512
  pc->month = (yyvsp + -1)->intval;
#line 513
  pc->day = (yyvsp + 0)->textintval.value;
#line 515
  break;
  case 46: 
#line 517
  pc->month = (yyvsp + -3)->intval;
#line 518
  pc->day = (yyvsp + -2)->textintval.value;
#line 519
  pc->year = (yyvsp + 0)->textintval;
#line 521
  break;
  case 47: 
#line 523
  pc->day = (yyvsp + -1)->textintval.value;
#line 524
  pc->month = (yyvsp + 0)->intval;
#line 526
  break;
  case 48: 
#line 528
  pc->day = (yyvsp + -2)->textintval.value;
#line 529
  pc->month = (yyvsp + -1)->intval;
#line 530
  pc->year = (yyvsp + 0)->textintval;
#line 532
  break;
  case 50: 
#line 539
  pc->year = (yyvsp + -2)->textintval;
#line 540
  pc->month = - (yyvsp + -1)->textintval.value;
#line 541
  pc->day = - (yyvsp + 0)->textintval.value;
#line 543
  break;
  case 51: 
#line 547
  apply_relative_time(pc, (yyvsp + -1)->rel, -1);
#line 548
  break;
  case 52: 
#line 549
  apply_relative_time(pc, (yyvsp + 0)->rel, 1);
#line 550
  break;
  case 53: 
#line 551
  apply_relative_time(pc, (yyvsp + 0)->rel, 1);
#line 552
  break;
  case 54: 
#line 556
  __constr_expr_0.year = 0L;
#line 556
  __constr_expr_0.month = 0L;
#line 556
  __constr_expr_0.day = 0L;
#line 556
  __constr_expr_0.hour = 0L;
#line 556
  __constr_expr_0.minutes = 0L;
#line 556
  __constr_expr_0.seconds = (long_time_t )0;
#line 556
  __constr_expr_0.ns = 0L;
#line 556
  yyval.rel = __constr_expr_0;
#line 556
  yyval.rel.year = (yyvsp + -1)->intval;
#line 557
  break;
  case 55: 
#line 558
  __constr_expr_1.year = 0L;
#line 558
  __constr_expr_1.month = 0L;
#line 558
  __constr_expr_1.day = 0L;
#line 558
  __constr_expr_1.hour = 0L;
#line 558
  __constr_expr_1.minutes = 0L;
#line 558
  __constr_expr_1.seconds = (long_time_t )0;
#line 558
  __constr_expr_1.ns = 0L;
#line 558
  yyval.rel = __constr_expr_1;
#line 558
  yyval.rel.year = (yyvsp + -1)->textintval.value;
#line 559
  break;
  case 56: 
#line 560
  __constr_expr_2.year = 0L;
#line 560
  __constr_expr_2.month = 0L;
#line 560
  __constr_expr_2.day = 0L;
#line 560
  __constr_expr_2.hour = 0L;
#line 560
  __constr_expr_2.minutes = 0L;
#line 560
  __constr_expr_2.seconds = (long_time_t )0;
#line 560
  __constr_expr_2.ns = 0L;
#line 560
  yyval.rel = __constr_expr_2;
#line 560
  yyval.rel.year = 1L;
#line 561
  break;
  case 57: 
#line 562
  __constr_expr_3.year = 0L;
#line 562
  __constr_expr_3.month = 0L;
#line 562
  __constr_expr_3.day = 0L;
#line 562
  __constr_expr_3.hour = 0L;
#line 562
  __constr_expr_3.minutes = 0L;
#line 562
  __constr_expr_3.seconds = (long_time_t )0;
#line 562
  __constr_expr_3.ns = 0L;
#line 562
  yyval.rel = __constr_expr_3;
#line 562
  yyval.rel.month = (yyvsp + -1)->intval;
#line 563
  break;
  case 58: 
#line 564
  __constr_expr_4.year = 0L;
#line 564
  __constr_expr_4.month = 0L;
#line 564
  __constr_expr_4.day = 0L;
#line 564
  __constr_expr_4.hour = 0L;
#line 564
  __constr_expr_4.minutes = 0L;
#line 564
  __constr_expr_4.seconds = (long_time_t )0;
#line 564
  __constr_expr_4.ns = 0L;
#line 564
  yyval.rel = __constr_expr_4;
#line 564
  yyval.rel.month = (yyvsp + -1)->textintval.value;
#line 565
  break;
  case 59: 
#line 566
  __constr_expr_5.year = 0L;
#line 566
  __constr_expr_5.month = 0L;
#line 566
  __constr_expr_5.day = 0L;
#line 566
  __constr_expr_5.hour = 0L;
#line 566
  __constr_expr_5.minutes = 0L;
#line 566
  __constr_expr_5.seconds = (long_time_t )0;
#line 566
  __constr_expr_5.ns = 0L;
#line 566
  yyval.rel = __constr_expr_5;
#line 566
  yyval.rel.month = 1L;
#line 567
  break;
  case 60: 
#line 568
  __constr_expr_6.year = 0L;
#line 568
  __constr_expr_6.month = 0L;
#line 568
  __constr_expr_6.day = 0L;
#line 568
  __constr_expr_6.hour = 0L;
#line 568
  __constr_expr_6.minutes = 0L;
#line 568
  __constr_expr_6.seconds = (long_time_t )0;
#line 568
  __constr_expr_6.ns = 0L;
#line 568
  yyval.rel = __constr_expr_6;
#line 568
  yyval.rel.day = (yyvsp + -1)->intval * (yyvsp + 0)->intval;
#line 569
  break;
  case 61: 
#line 570
  __constr_expr_7.year = 0L;
#line 570
  __constr_expr_7.month = 0L;
#line 570
  __constr_expr_7.day = 0L;
#line 570
  __constr_expr_7.hour = 0L;
#line 570
  __constr_expr_7.minutes = 0L;
#line 570
  __constr_expr_7.seconds = (long_time_t )0;
#line 570
  __constr_expr_7.ns = 0L;
#line 570
  yyval.rel = __constr_expr_7;
#line 570
  yyval.rel.day = (yyvsp + -1)->textintval.value * (yyvsp + 0)->intval;
#line 571
  break;
  case 62: 
#line 572
  __constr_expr_8.year = 0L;
#line 572
  __constr_expr_8.month = 0L;
#line 572
  __constr_expr_8.day = 0L;
#line 572
  __constr_expr_8.hour = 0L;
#line 572
  __constr_expr_8.minutes = 0L;
#line 572
  __constr_expr_8.seconds = (long_time_t )0;
#line 572
  __constr_expr_8.ns = 0L;
#line 572
  yyval.rel = __constr_expr_8;
#line 572
  yyval.rel.day = (yyvsp + 0)->intval;
#line 573
  break;
  case 63: 
#line 574
  __constr_expr_9.year = 0L;
#line 574
  __constr_expr_9.month = 0L;
#line 574
  __constr_expr_9.day = 0L;
#line 574
  __constr_expr_9.hour = 0L;
#line 574
  __constr_expr_9.minutes = 0L;
#line 574
  __constr_expr_9.seconds = (long_time_t )0;
#line 574
  __constr_expr_9.ns = 0L;
#line 574
  yyval.rel = __constr_expr_9;
#line 574
  yyval.rel.hour = (yyvsp + -1)->intval;
#line 575
  break;
  case 64: 
#line 576
  __constr_expr_10.year = 0L;
#line 576
  __constr_expr_10.month = 0L;
#line 576
  __constr_expr_10.day = 0L;
#line 576
  __constr_expr_10.hour = 0L;
#line 576
  __constr_expr_10.minutes = 0L;
#line 576
  __constr_expr_10.seconds = (long_time_t )0;
#line 576
  __constr_expr_10.ns = 0L;
#line 576
  yyval.rel = __constr_expr_10;
#line 576
  yyval.rel.hour = (yyvsp + -1)->textintval.value;
#line 577
  break;
  case 65: 
#line 578
  __constr_expr_11.year = 0L;
#line 578
  __constr_expr_11.month = 0L;
#line 578
  __constr_expr_11.day = 0L;
#line 578
  __constr_expr_11.hour = 0L;
#line 578
  __constr_expr_11.minutes = 0L;
#line 578
  __constr_expr_11.seconds = (long_time_t )0;
#line 578
  __constr_expr_11.ns = 0L;
#line 578
  yyval.rel = __constr_expr_11;
#line 578
  yyval.rel.hour = 1L;
#line 579
  break;
  case 66: 
#line 580
  __constr_expr_12.year = 0L;
#line 580
  __constr_expr_12.month = 0L;
#line 580
  __constr_expr_12.day = 0L;
#line 580
  __constr_expr_12.hour = 0L;
#line 580
  __constr_expr_12.minutes = 0L;
#line 580
  __constr_expr_12.seconds = (long_time_t )0;
#line 580
  __constr_expr_12.ns = 0L;
#line 580
  yyval.rel = __constr_expr_12;
#line 580
  yyval.rel.minutes = (yyvsp + -1)->intval;
#line 581
  break;
  case 67: 
#line 582
  __constr_expr_13.year = 0L;
#line 582
  __constr_expr_13.month = 0L;
#line 582
  __constr_expr_13.day = 0L;
#line 582
  __constr_expr_13.hour = 0L;
#line 582
  __constr_expr_13.minutes = 0L;
#line 582
  __constr_expr_13.seconds = (long_time_t )0;
#line 582
  __constr_expr_13.ns = 0L;
#line 582
  yyval.rel = __constr_expr_13;
#line 582
  yyval.rel.minutes = (yyvsp + -1)->textintval.value;
#line 583
  break;
  case 68: 
#line 584
  __constr_expr_14.year = 0L;
#line 584
  __constr_expr_14.month = 0L;
#line 584
  __constr_expr_14.day = 0L;
#line 584
  __constr_expr_14.hour = 0L;
#line 584
  __constr_expr_14.minutes = 0L;
#line 584
  __constr_expr_14.seconds = (long_time_t )0;
#line 584
  __constr_expr_14.ns = 0L;
#line 584
  yyval.rel = __constr_expr_14;
#line 584
  yyval.rel.minutes = 1L;
#line 585
  break;
  case 69: 
#line 586
  __constr_expr_15.year = 0L;
#line 586
  __constr_expr_15.month = 0L;
#line 586
  __constr_expr_15.day = 0L;
#line 586
  __constr_expr_15.hour = 0L;
#line 586
  __constr_expr_15.minutes = 0L;
#line 586
  __constr_expr_15.seconds = (long_time_t )0;
#line 586
  __constr_expr_15.ns = 0L;
#line 586
  yyval.rel = __constr_expr_15;
#line 586
  yyval.rel.seconds = (yyvsp + -1)->intval;
#line 587
  break;
  case 70: 
#line 588
  __constr_expr_16.year = 0L;
#line 588
  __constr_expr_16.month = 0L;
#line 588
  __constr_expr_16.day = 0L;
#line 588
  __constr_expr_16.hour = 0L;
#line 588
  __constr_expr_16.minutes = 0L;
#line 588
  __constr_expr_16.seconds = (long_time_t )0;
#line 588
  __constr_expr_16.ns = 0L;
#line 588
  yyval.rel = __constr_expr_16;
#line 588
  yyval.rel.seconds = (yyvsp + -1)->textintval.value;
#line 589
  break;
  case 71: 
#line 590
  __constr_expr_17.year = 0L;
#line 590
  __constr_expr_17.month = 0L;
#line 590
  __constr_expr_17.day = 0L;
#line 590
  __constr_expr_17.hour = 0L;
#line 590
  __constr_expr_17.minutes = 0L;
#line 590
  __constr_expr_17.seconds = (long_time_t )0;
#line 590
  __constr_expr_17.ns = 0L;
#line 590
  yyval.rel = __constr_expr_17;
#line 590
  yyval.rel.seconds = (yyvsp + -1)->timespec.tv_sec;
#line 590
  yyval.rel.ns = (yyvsp + -1)->timespec.tv_nsec;
#line 591
  break;
  case 72: 
#line 592
  __constr_expr_18.year = 0L;
#line 592
  __constr_expr_18.month = 0L;
#line 592
  __constr_expr_18.day = 0L;
#line 592
  __constr_expr_18.hour = 0L;
#line 592
  __constr_expr_18.minutes = 0L;
#line 592
  __constr_expr_18.seconds = (long_time_t )0;
#line 592
  __constr_expr_18.ns = 0L;
#line 592
  yyval.rel = __constr_expr_18;
#line 592
  yyval.rel.seconds = (yyvsp + -1)->timespec.tv_sec;
#line 592
  yyval.rel.ns = (yyvsp + -1)->timespec.tv_nsec;
#line 593
  break;
  case 73: 
#line 594
  __constr_expr_19.year = 0L;
#line 594
  __constr_expr_19.month = 0L;
#line 594
  __constr_expr_19.day = 0L;
#line 594
  __constr_expr_19.hour = 0L;
#line 594
  __constr_expr_19.minutes = 0L;
#line 594
  __constr_expr_19.seconds = (long_time_t )0;
#line 594
  __constr_expr_19.ns = 0L;
#line 594
  yyval.rel = __constr_expr_19;
#line 594
  yyval.rel.seconds = (long_time_t )1;
#line 595
  break;
  case 75: 
#line 600
  __constr_expr_20.year = 0L;
#line 600
  __constr_expr_20.month = 0L;
#line 600
  __constr_expr_20.day = 0L;
#line 600
  __constr_expr_20.hour = 0L;
#line 600
  __constr_expr_20.minutes = 0L;
#line 600
  __constr_expr_20.seconds = (long_time_t )0;
#line 600
  __constr_expr_20.ns = 0L;
#line 600
  yyval.rel = __constr_expr_20;
#line 600
  yyval.rel.year = (yyvsp + -1)->textintval.value;
#line 601
  break;
  case 76: 
#line 602
  __constr_expr_21.year = 0L;
#line 602
  __constr_expr_21.month = 0L;
#line 602
  __constr_expr_21.day = 0L;
#line 602
  __constr_expr_21.hour = 0L;
#line 602
  __constr_expr_21.minutes = 0L;
#line 602
  __constr_expr_21.seconds = (long_time_t )0;
#line 602
  __constr_expr_21.ns = 0L;
#line 602
  yyval.rel = __constr_expr_21;
#line 602
  yyval.rel.month = (yyvsp + -1)->textintval.value;
#line 603
  break;
  case 77: 
#line 604
  __constr_expr_22.year = 0L;
#line 604
  __constr_expr_22.month = 0L;
#line 604
  __constr_expr_22.day = 0L;
#line 604
  __constr_expr_22.hour = 0L;
#line 604
  __constr_expr_22.minutes = 0L;
#line 604
  __constr_expr_22.seconds = (long_time_t )0;
#line 604
  __constr_expr_22.ns = 0L;
#line 604
  yyval.rel = __constr_expr_22;
#line 604
  yyval.rel.day = (yyvsp + -1)->textintval.value * (yyvsp + 0)->intval;
#line 605
  break;
  case 78: 
#line 606
  __constr_expr_23.year = 0L;
#line 606
  __constr_expr_23.month = 0L;
#line 606
  __constr_expr_23.day = 0L;
#line 606
  __constr_expr_23.hour = 0L;
#line 606
  __constr_expr_23.minutes = 0L;
#line 606
  __constr_expr_23.seconds = (long_time_t )0;
#line 606
  __constr_expr_23.ns = 0L;
#line 606
  yyval.rel = __constr_expr_23;
#line 606
  yyval.rel.hour = (yyvsp + -1)->textintval.value;
#line 607
  break;
  case 79: 
#line 608
  __constr_expr_24.year = 0L;
#line 608
  __constr_expr_24.month = 0L;
#line 608
  __constr_expr_24.day = 0L;
#line 608
  __constr_expr_24.hour = 0L;
#line 608
  __constr_expr_24.minutes = 0L;
#line 608
  __constr_expr_24.seconds = (long_time_t )0;
#line 608
  __constr_expr_24.ns = 0L;
#line 608
  yyval.rel = __constr_expr_24;
#line 608
  yyval.rel.minutes = (yyvsp + -1)->textintval.value;
#line 609
  break;
  case 80: 
#line 610
  __constr_expr_25.year = 0L;
#line 610
  __constr_expr_25.month = 0L;
#line 610
  __constr_expr_25.day = 0L;
#line 610
  __constr_expr_25.hour = 0L;
#line 610
  __constr_expr_25.minutes = 0L;
#line 610
  __constr_expr_25.seconds = (long_time_t )0;
#line 610
  __constr_expr_25.ns = 0L;
#line 610
  yyval.rel = __constr_expr_25;
#line 610
  yyval.rel.seconds = (yyvsp + -1)->textintval.value;
#line 611
  break;
  case 81: 
#line 615
  __constr_expr_26.year = 0L;
#line 615
  __constr_expr_26.month = 0L;
#line 615
  __constr_expr_26.day = 0L;
#line 615
  __constr_expr_26.hour = 0L;
#line 615
  __constr_expr_26.minutes = 0L;
#line 615
  __constr_expr_26.seconds = (long_time_t )0;
#line 615
  __constr_expr_26.ns = 0L;
#line 615
  yyval.rel = __constr_expr_26;
#line 615
  yyval.rel.day = (yyvsp + 0)->intval;
#line 616
  break;
  case 85: 
#line 623
  yyval.timespec.tv_sec = (yyvsp + 0)->textintval.value;
#line 623
  yyval.timespec.tv_nsec = 0L;
#line 624
  break;
  case 87: 
#line 629
  yyval.timespec.tv_sec = (yyvsp + 0)->textintval.value;
#line 629
  yyval.timespec.tv_nsec = 0L;
#line 630
  break;
  case 88: 
#line 634
  digits_to_date_time(pc, (yyvsp + 0)->textintval);
#line 635
  break;
  case 89: 
#line 642
  digits_to_date_time(pc, (yyvsp + -1)->textintval);
#line 643
  apply_relative_time(pc, (yyvsp + 0)->rel, 1);
#line 645
  break;
  case 90: 
#line 649
  yyval.intval = -1L;
#line 650
  break;
  case 91: 
#line 651
  yyval.intval = (yyvsp + 0)->textintval.value;
#line 652
  break;
  default: 
#line 2375 "parse-datetime.c"
  break;
  }
#line 2379
  yyvsp -= yylen;
#line 2379
  yyssp -= yylen;
#line 2380
  yylen = 0;
#line 2383
  yyvsp ++;
#line 2383
  *yyvsp = yyval;
#line 2389
  yyn = (int )yyr1[yyn];
#line 2391
  yystate = (int )((int const   )yypgoto[yyn - 28] + (int const   )*yyssp);
#line 2392
  if (0 <= yystate) {
#line 2392
    if (yystate <= 112) {
#line 2392
      if ((int const   )yycheck[yystate] == (int const   )*yyssp) {
#line 2393
        yystate = (int )yytable[yystate];
      } else {
#line 2395
        yystate = (int )yydefgoto[yyn - 28];
      }
    } else {
#line 2395
      yystate = (int )yydefgoto[yyn - 28];
    }
  } else {
#line 2395
    yystate = (int )yydefgoto[yyn - 28];
  }
#line 2397
  goto yynewstate;
  yyerrlab: 
#line 2405
  if (! yyerrstatus) {
#line 2407
    yynerrs ++;
#line 2409
    yyerror((parser_control const   *)pc, "syntax error");
  }
#line 2447
  if (yyerrstatus == 3) {
#line 2452
    if (yychar <= 0) {
#line 2455
      if (yychar == 0) {
#line 2456
        goto yyabortlab;
      }
    } else {
#line 2460
      yydestruct("Error: discarding", yytoken, & yylval, pc);
#line 2462
      yychar = -2;
    }
  }
#line 2468
  goto yyerrlab1;
#line 2484
  yyvsp -= yylen;
#line 2484
  yyssp -= yylen;
#line 2485
  yylen = 0;
#line 2487
  yystate = (int )*yyssp;
#line 2488
  goto yyerrlab1;
  yyerrlab1: 
#line 2495
  yyerrstatus = 3;
#line 2497
  while (1) {
#line 2499
    yyn = (int )yypact[yystate];
#line 2500
    if (yyn != -93) {
#line 2502
      yyn ++;
#line 2503
      if (0 <= yyn) {
#line 2503
        if (yyn <= 112) {
#line 2503
          if ((int const   )yycheck[yyn] == 1) {
#line 2505
            yyn = (int )yytable[yyn];
#line 2506
            if (0 < yyn) {
#line 2507
              break;
            }
          }
        }
      }
    }
#line 2512
    if ((unsigned long )yyssp == (unsigned long )yyss) {
#line 2513
      goto yyabortlab;
    }
#line 2516
    yydestruct("Error: popping", (int )yystos[yystate], yyvsp, pc);
#line 2518
    yyvsp --;
#line 2518
    yyssp --;
#line 2519
    yystate = (int )*yyssp;
  }
#line 2523
  yyvsp ++;
#line 2523
  *yyvsp = yylval;
#line 2529
  yystate = yyn;
#line 2530
  goto yynewstate;
  yyacceptlab: 
#line 2537
  yyresult = 0;
#line 2538
  goto yyreturn;
  yyabortlab: 
#line 2544
  yyresult = 1;
#line 2545
  goto yyreturn;
  yyexhaustedlab: 
#line 2552
  yyerror((parser_control const   *)pc, "memory exhausted");
#line 2553
  yyresult = 2;
  yyreturn: 
#line 2558
  if (yychar != -2) {
#line 2559
    yydestruct("Cleanup: discarding lookahead", yytoken, & yylval, pc);
  }
#line 2563
  yyvsp -= yylen;
#line 2563
  yyssp -= yylen;
#line 2565
  while ((unsigned long )yyssp != (unsigned long )yyss) {
#line 2567
    yydestruct("Cleanup: popping", (int )yystos[*yyssp], yyvsp, pc);
#line 2569
    yyvsp --;
#line 2569
    yyssp --;
  }
#line 2572
  if ((unsigned long )yyss != (unsigned long )(yyssa)) {
#line 2573
    free((void *)yyss);
  }
#line 2580
  return (yyresult);
}
}
#line 656 "parse-datetime.y"
static table const   meridian_table[5]  = {      {"AM", 270, 0}, 
        {"A.M.", 270, 0}, 
        {"PM", 270, 1}, 
        {"P.M.", 270, 1}, 
        {(char const   *)((void *)0), 0, 0}};
#line 665 "parse-datetime.y"
static table const   dst_table[1]  = {      {"DST", 259, 0}};
#line 670 "parse-datetime.y"
static table const   month_and_day_table[25]  = 
#line 670
  {      {"JANUARY", 271, 1}, 
        {"FEBRUARY", 271, 2}, 
        {"MARCH", 271, 3}, 
        {"APRIL", 271, 4}, 
        {"MAY", 271, 5}, 
        {"JUNE", 271, 6}, 
        {"JULY", 271, 7}, 
        {"AUGUST", 271, 8}, 
        {"SEPTEMBER", 271, 9}, 
        {"SEPT", 271, 9}, 
        {"OCTOBER", 271, 10}, 
        {"NOVEMBER", 271, 11}, 
        {"DECEMBER", 271, 12}, 
        {"SUNDAY", 267, 0}, 
        {"MONDAY", 267, 1}, 
        {"TUESDAY", 267, 2}, 
        {"TUES", 267, 2}, 
        {"WEDNESDAY", 267, 3}, 
        {"WEDNES", 267, 3}, 
        {"THURSDAY", 267, 4}, 
        {"THUR", 267, 4}, 
        {"THURS", 267, 4}, 
        {"FRIDAY", 267, 5}, 
        {"SATURDAY", 267, 6}, 
        {(char const   *)((void *)0), 0, 0}};
#line 699 "parse-datetime.y"
static table const   time_units_table[11]  = 
#line 699
  {      {"YEAR", 260, 1}, 
        {"MONTH", 261, 1}, 
        {"FORTNIGHT", 265, 14}, 
        {"WEEK", 265, 7}, 
        {"DAY", 265, 1}, 
        {"HOUR", 262, 1}, 
        {"MINUTE", 263, 1}, 
        {"MIN", 263, 1}, 
        {"SECOND", 264, 1}, 
        {"SEC", 264, 1}, 
        {(char const   *)((void *)0), 0, 0}};
#line 715 "parse-datetime.y"
static table const   relative_time_table[20]  = 
#line 715
  {      {"TOMORROW", 266, 1}, 
        {"YESTERDAY", 266, -1}, 
        {"TODAY", 266, 0}, 
        {"NOW", 266, 0}, 
        {"LAST", 272, -1}, 
        {"THIS", 272, 0}, 
        {"NEXT", 272, 1}, 
        {"FIRST", 272, 1}, 
        {"THIRD", 272, 3}, 
        {"FOURTH", 272, 4}, 
        {"FIFTH", 272, 5}, 
        {"SIXTH", 272, 6}, 
        {"SEVENTH", 272, 7}, 
        {"EIGHTH", 272, 8}, 
        {"NINTH", 272, 9}, 
        {"TENTH", 272, 10}, 
        {"ELEVENTH", 272, 11}, 
        {"TWELFTH", 272, 12}, 
        {"AGO", 258, 1}, 
        {(char const   *)((void *)0), 0, 0}};
#line 743 "parse-datetime.y"
static table const   universal_time_zone_table[4]  = {      {"GMT", 273, 0}, 
        {"UT", 273, 0}, 
        {"UTC", 273, 0}, 
        {(char const   *)((void *)0), 0, 0}};
#line 756 "parse-datetime.y"
static table const   time_zone_table[48]  = 
#line 756
  {      {"WET", 273, 0}, 
        {"WEST", 268, 0}, 
        {"BST", 268, 0}, 
        {"ART", 273, -180}, 
        {"BRT", 273, -180}, 
        {"BRST", 268, -180}, 
        {"NST", 273, -210}, 
        {"NDT", 268, -210}, 
        {"AST", 273, -240}, 
        {"ADT", 268, -240}, 
        {"CLT", 273, -240}, 
        {"CLST", 268, -240}, 
        {"EST", 273, -300}, 
        {"EDT", 268, -300}, 
        {"CST", 273, -360}, 
        {"CDT", 268, -360}, 
        {"MST", 273, -420}, 
        {"MDT", 268, -420}, 
        {"PST", 273, -480}, 
        {"PDT", 268, -480}, 
        {"AKST", 273, -540}, 
        {"AKDT", 268, -540}, 
        {"HST", 273, -600}, 
        {"HAST", 273, -600}, 
        {"HADT", 268, -600}, 
        {"SST", 273, -720}, 
        {"WAT", 273, 60}, 
        {"CET", 273, 60}, 
        {"CEST", 268, 60}, 
        {"MET", 273, 60}, 
        {"MEZ", 273, 60}, 
        {"MEST", 268, 60}, 
        {"MESZ", 268, 60}, 
        {"EET", 273, 120}, 
        {"EEST", 268, 120}, 
        {"CAT", 273, 120}, 
        {"SAST", 273, 120}, 
        {"EAT", 273, 180}, 
        {"MSK", 273, 180}, 
        {"MSD", 268, 180}, 
        {"IST", 273, 330}, 
        {"SGT", 273, 480}, 
        {"KST", 273, 540}, 
        {"JST", 273, 540}, 
        {"GST", 273, 600}, 
        {"NZST", 273, 720}, 
        {"NZDT", 268, 720}, 
        {(char const   *)((void *)0), 0, 0}};
#line 812 "parse-datetime.y"
static table const   military_table[26]  = 
#line 812
  {      {"A", 273, -60}, 
        {"B", 273, -120}, 
        {"C", 273, -180}, 
        {"D", 273, -240}, 
        {"E", 273, -300}, 
        {"F", 273, -360}, 
        {"G", 273, -420}, 
        {"H", 273, -480}, 
        {"I", 273, -540}, 
        {"K", 273, -600}, 
        {"L", 273, -660}, 
        {"M", 273, -720}, 
        {"N", 273, 60}, 
        {"O", 273, 120}, 
        {"P", 273, 180}, 
        {"Q", 273, 240}, 
        {"R", 273, 300}, 
        {"S", 273, 360}, 
        {"T", 'T', 0}, 
        {"U", 273, 480}, 
        {"V", 273, 540}, 
        {"W", 273, 600}, 
        {"X", 273, 660}, 
        {"Y", 273, 720}, 
        {"Z", 273, 0}, 
        {(char const   *)((void *)0), 0, 0}};
#line 851 "parse-datetime.y"
static long time_zone_hhmm(parser_control *pc , textint s , long mm ) 
{ long n_minutes ;
  long tmp ;
  int tmp___0 ;

  {
#line 858
  if (s.digits <= 2UL) {
#line 858
    if (mm < 0L) {
#line 859
      s.value *= 100L;
    }
  }
#line 861
  if (mm < 0L) {
#line 862
    n_minutes = (s.value / 100L) * 60L + s.value % 100L;
  } else {
#line 864
    if (s.negative) {
#line 864
      tmp = - mm;
    } else {
#line 864
      tmp = mm;
    }
#line 864
    n_minutes = s.value * 60L + tmp;
  }
#line 869
  tmp___0 = abs((int )n_minutes);
#line 869
  if (1440 < tmp___0) {
#line 870
    (pc->zones_seen) ++;
  }
#line 872
  return (n_minutes);
}
}
#line 875 "parse-datetime.y"
static int to_hour(long hours , int meridian ) 
{ long tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
#line 878
  switch (meridian) {
  default: 
#line 882
  if (0L <= hours) {
#line 882
    if (hours < 24L) {
#line 882
      tmp = hours;
    } else {
#line 882
      tmp = -1L;
    }
  } else {
#line 882
    tmp = -1L;
  }
#line 882
  return ((int )tmp);
  case 0: 
#line 884
  if (0L < hours) {
#line 884
    if (hours < 12L) {
#line 884
      tmp___1 = hours;
    } else {
#line 884
      goto _L;
    }
  } else {
    _L: 
#line 884
    if (hours == 12L) {
#line 884
      tmp___0 = 0;
    } else {
#line 884
      tmp___0 = -1;
    }
#line 884
    tmp___1 = (long )tmp___0;
  }
#line 884
  return ((int )tmp___1);
  case 1: 
#line 886
  if (0L < hours) {
#line 886
    if (hours < 12L) {
#line 886
      tmp___3 = hours + 12L;
    } else {
#line 886
      goto _L___0;
    }
  } else {
    _L___0: 
#line 886
    if (hours == 12L) {
#line 886
      tmp___2 = 12;
    } else {
#line 886
      tmp___2 = -1;
    }
#line 886
    tmp___3 = (long )tmp___2;
  }
#line 886
  return ((int )tmp___3);
  }
}
}
#line 890 "parse-datetime.y"
static long to_year(textint textyear ) 
{ long year___0 ;
  int tmp ;

  {
#line 893
  year___0 = textyear.value;
#line 895
  if (year___0 < 0L) {
#line 896
    year___0 = - year___0;
  } else
#line 900
  if (textyear.digits == 2UL) {
#line 901
    if (year___0 < 69L) {
#line 901
      tmp = 2000;
    } else {
#line 901
      tmp = 1900;
    }
#line 901
    year___0 += (long )tmp;
  }
#line 903
  return (year___0);
}
}
#line 906 "parse-datetime.y"
static table const   *lookup_zone(parser_control const   *pc , char const   *name ) 
{ table const   *tp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;

  {
#line 911
  tp = universal_time_zone_table;
#line 911
  while (tp->name) {
#line 912
    if (0) {
#line 912
      __s1_len = __builtin_strlen(name);
#line 912
      __s2_len = __builtin_strlen((char const   *)tp->name);
#line 912
      if (! ((size_t )((void const   *)(name + 1)) - (size_t )((void const   *)name) == 1UL)) {
#line 912
        goto _L___0;
      } else
#line 912
      if (__s1_len >= 4UL) {
        _L___0: 
#line 912
        if (! ((size_t )((void const   *)(tp->name + 1)) - (size_t )((void const   *)tp->name) == 1UL)) {
#line 912
          tmp___5 = 1;
        } else
#line 912
        if (__s2_len >= 4UL) {
#line 912
          tmp___5 = 1;
        } else {
#line 912
          tmp___5 = 0;
        }
      } else {
#line 912
        tmp___5 = 0;
      }
#line 912
      if (tmp___5) {
#line 912
        tmp___0 = __builtin_strcmp(name, (char const   *)tp->name);
#line 912
        tmp___4 = tmp___0;
      } else {
#line 912
        tmp___3 = __builtin_strcmp(name, (char const   *)tp->name);
#line 912
        tmp___4 = tmp___3;
      }
    } else {
#line 912
      tmp___3 = __builtin_strcmp(name, (char const   *)tp->name);
#line 912
      tmp___4 = tmp___3;
    }
#line 912
    if (tmp___4 == 0) {
#line 913
      return (tp);
    }
#line 911
    tp ++;
  }
#line 917
  tp = (table const   *)(pc->local_time_zone_table);
#line 917
  while (tp->name) {
#line 918
    if (0) {
#line 918
      __s1_len___0 = __builtin_strlen(name);
#line 918
      __s2_len___0 = __builtin_strlen((char const   *)tp->name);
#line 918
      if (! ((size_t )((void const   *)(name + 1)) - (size_t )((void const   *)name) == 1UL)) {
#line 918
        goto _L___2;
      } else
#line 918
      if (__s1_len___0 >= 4UL) {
        _L___2: 
#line 918
        if (! ((size_t )((void const   *)(tp->name + 1)) - (size_t )((void const   *)tp->name) == 1UL)) {
#line 918
          tmp___12 = 1;
        } else
#line 918
        if (__s2_len___0 >= 4UL) {
#line 918
          tmp___12 = 1;
        } else {
#line 918
          tmp___12 = 0;
        }
      } else {
#line 918
        tmp___12 = 0;
      }
#line 918
      if (tmp___12) {
#line 918
        tmp___7 = __builtin_strcmp(name, (char const   *)tp->name);
#line 918
        tmp___11 = tmp___7;
      } else {
#line 918
        tmp___10 = __builtin_strcmp(name, (char const   *)tp->name);
#line 918
        tmp___11 = tmp___10;
      }
    } else {
#line 918
      tmp___10 = __builtin_strcmp(name, (char const   *)tp->name);
#line 918
      tmp___11 = tmp___10;
    }
#line 918
    if (tmp___11 == 0) {
#line 919
      return (tp);
    }
#line 917
    tp ++;
  }
#line 921
  tp = time_zone_table;
#line 921
  while (tp->name) {
#line 922
    if (0) {
#line 922
      __s1_len___1 = __builtin_strlen(name);
#line 922
      __s2_len___1 = __builtin_strlen((char const   *)tp->name);
#line 922
      if (! ((size_t )((void const   *)(name + 1)) - (size_t )((void const   *)name) == 1UL)) {
#line 922
        goto _L___4;
      } else
#line 922
      if (__s1_len___1 >= 4UL) {
        _L___4: 
#line 922
        if (! ((size_t )((void const   *)(tp->name + 1)) - (size_t )((void const   *)tp->name) == 1UL)) {
#line 922
          tmp___19 = 1;
        } else
#line 922
        if (__s2_len___1 >= 4UL) {
#line 922
          tmp___19 = 1;
        } else {
#line 922
          tmp___19 = 0;
        }
      } else {
#line 922
        tmp___19 = 0;
      }
#line 922
      if (tmp___19) {
#line 922
        tmp___14 = __builtin_strcmp(name, (char const   *)tp->name);
#line 922
        tmp___18 = tmp___14;
      } else {
#line 922
        tmp___17 = __builtin_strcmp(name, (char const   *)tp->name);
#line 922
        tmp___18 = tmp___17;
      }
    } else {
#line 922
      tmp___17 = __builtin_strcmp(name, (char const   *)tp->name);
#line 922
      tmp___18 = tmp___17;
    }
#line 922
    if (tmp___18 == 0) {
#line 923
      return (tp);
    }
#line 921
    tp ++;
  }
#line 925
  return ((table const   *)((void *)0));
}
}
#line 955 "parse-datetime.y"
static table const   *lookup_word(parser_control const   *pc , char *word ) 
{ char *p ;
  char *q ;
  size_t wordlen ;
  table const   *tp ;
  _Bool period_found ;
  _Bool abbrev ;
  unsigned char ch ;
  int __c ;
  int tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___1 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___11 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___22 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___30 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___37 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___44 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  int tmp___51 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  char tmp___57 ;

  {
#line 966
  p = word;
#line 966
  while (*p) {
#line 968
    ch = (unsigned char )*p;
#line 969
    __c = (int )ch;
#line 969
    if (__c >= 97) {
#line 969
      if (__c <= 122) {
#line 969
        tmp = (__c - 97) + 65;
      } else {
#line 969
        tmp = __c;
      }
    } else {
#line 969
      tmp = __c;
    }
#line 969
    *p = (char )tmp;
#line 966
    p ++;
  }
#line 972
  tp = meridian_table;
#line 972
  while (tp->name) {
#line 973
    if (0) {
#line 973
      __s1_len = __builtin_strlen((char const   *)word);
#line 973
      __s2_len = __builtin_strlen((char const   *)tp->name);
#line 973
      if (! ((size_t )((void const   *)(word + 1)) - (size_t )((void const   *)word) == 1UL)) {
#line 973
        goto _L___0;
      } else
#line 973
      if (__s1_len >= 4UL) {
        _L___0: 
#line 973
        if (! ((size_t )((void const   *)(tp->name + 1)) - (size_t )((void const   *)tp->name) == 1UL)) {
#line 973
          tmp___6 = 1;
        } else
#line 973
        if (__s2_len >= 4UL) {
#line 973
          tmp___6 = 1;
        } else {
#line 973
          tmp___6 = 0;
        }
      } else {
#line 973
        tmp___6 = 0;
      }
#line 973
      if (tmp___6) {
#line 973
        tmp___1 = __builtin_strcmp((char const   *)word, (char const   *)tp->name);
#line 973
        tmp___5 = tmp___1;
      } else {
#line 973
        tmp___4 = __builtin_strcmp((char const   *)word, (char const   *)tp->name);
#line 973
        tmp___5 = tmp___4;
      }
    } else {
#line 973
      tmp___4 = __builtin_strcmp((char const   *)word, (char const   *)tp->name);
#line 973
      tmp___5 = tmp___4;
    }
#line 973
    if (tmp___5 == 0) {
#line 974
      return (tp);
    }
#line 972
    tp ++;
  }
#line 977
  wordlen = strlen((char const   *)word);
#line 978
  if (wordlen == 3UL) {
#line 978
    tmp___7 = 1;
  } else
#line 978
  if (wordlen == 4UL) {
#line 978
    if ((int )*(word + 3) == 46) {
#line 978
      tmp___7 = 1;
    } else {
#line 978
      tmp___7 = 0;
    }
  } else {
#line 978
    tmp___7 = 0;
  }
#line 978
  abbrev = (_Bool )tmp___7;
#line 980
  tp = month_and_day_table;
#line 980
  while (tp->name) {
#line 981
    if (abbrev) {
#line 981
      if (0) {
#line 981
        if (0) {
#line 981
          __s1_len___0 = __builtin_strlen((char const   *)word);
#line 981
          __s2_len___0 = __builtin_strlen((char const   *)tp->name);
#line 981
          if (! ((size_t )((void const   *)(word + 1)) - (size_t )((void const   *)word) == 1UL)) {
#line 981
            goto _L___2;
          } else
#line 981
          if (__s1_len___0 >= 4UL) {
            _L___2: 
#line 981
            if (! ((size_t )((void const   *)(tp->name + 1)) - (size_t )((void const   *)tp->name) == 1UL)) {
#line 981
              tmp___16 = 1;
            } else
#line 981
            if (__s2_len___0 >= 4UL) {
#line 981
              tmp___16 = 1;
            } else {
#line 981
              tmp___16 = 0;
            }
          } else {
#line 981
            tmp___16 = 0;
          }
#line 981
          if (tmp___16) {
#line 981
            tmp___11 = __builtin_strcmp((char const   *)word, (char const   *)tp->name);
#line 981
            tmp___15 = tmp___11;
          } else {
#line 981
            tmp___14 = __builtin_strcmp((char const   *)word, (char const   *)tp->name);
#line 981
            tmp___15 = tmp___14;
          }
        } else {
#line 981
          tmp___14 = __builtin_strcmp((char const   *)word, (char const   *)tp->name);
#line 981
          tmp___15 = tmp___14;
        }
#line 981
        tmp___18 = tmp___15;
      } else {
#line 981
        tmp___17 = strncmp((char const   *)word, (char const   *)tp->name, (size_t )3);
#line 981
        tmp___18 = tmp___17;
      }
#line 981
      tmp___28 = tmp___18;
    } else {
#line 981
      if (0) {
#line 981
        __s1_len___1 = __builtin_strlen((char const   *)word);
#line 981
        __s2_len___1 = __builtin_strlen((char const   *)tp->name);
#line 981
        if (! ((size_t )((void const   *)(word + 1)) - (size_t )((void const   *)word) == 1UL)) {
#line 981
          goto _L___4;
        } else
#line 981
        if (__s1_len___1 >= 4UL) {
          _L___4: 
#line 981
          if (! ((size_t )((void const   *)(tp->name + 1)) - (size_t )((void const   *)tp->name) == 1UL)) {
#line 981
            tmp___27 = 1;
          } else
#line 981
          if (__s2_len___1 >= 4UL) {
#line 981
            tmp___27 = 1;
          } else {
#line 981
            tmp___27 = 0;
          }
        } else {
#line 981
          tmp___27 = 0;
        }
#line 981
        if (tmp___27) {
#line 981
          tmp___22 = __builtin_strcmp((char const   *)word, (char const   *)tp->name);
#line 981
          tmp___26 = tmp___22;
        } else {
#line 981
          tmp___25 = __builtin_strcmp((char const   *)word, (char const   *)tp->name);
#line 981
          tmp___26 = tmp___25;
        }
      } else {
#line 981
        tmp___25 = __builtin_strcmp((char const   *)word, (char const   *)tp->name);
#line 981
        tmp___26 = tmp___25;
      }
#line 981
      tmp___28 = tmp___26;
    }
#line 981
    if (tmp___28 == 0) {
#line 982
      return (tp);
    }
#line 980
    tp ++;
  }
#line 984
  tp = lookup_zone(pc, (char const   *)word);
#line 984
  if (tp) {
#line 985
    return (tp);
  }
#line 987
  if (0) {
#line 987
    __s1_len___2 = __builtin_strlen((char const   *)word);
#line 987
    __s2_len___2 = __builtin_strlen((char const   *)dst_table[0].name);
#line 987
    if (! ((size_t )((void const   *)(word + 1)) - (size_t )((void const   *)word) == 1UL)) {
#line 987
      goto _L___6;
    } else
#line 987
    if (__s1_len___2 >= 4UL) {
      _L___6: 
#line 987
      if (! ((size_t )((void const   *)(dst_table[0].name + 1)) - (size_t )((void const   *)dst_table[0].name) == 1UL)) {
#line 987
        tmp___35 = 1;
      } else
#line 987
      if (__s2_len___2 >= 4UL) {
#line 987
        tmp___35 = 1;
      } else {
#line 987
        tmp___35 = 0;
      }
    } else {
#line 987
      tmp___35 = 0;
    }
#line 987
    if (tmp___35) {
#line 987
      tmp___30 = __builtin_strcmp((char const   *)word, (char const   *)dst_table[0].name);
#line 987
      tmp___34 = tmp___30;
    } else {
#line 987
      tmp___33 = __builtin_strcmp((char const   *)word, (char const   *)dst_table[0].name);
#line 987
      tmp___34 = tmp___33;
    }
  } else {
#line 987
    tmp___33 = __builtin_strcmp((char const   *)word, (char const   *)dst_table[0].name);
#line 987
    tmp___34 = tmp___33;
  }
#line 987
  if (tmp___34 == 0) {
#line 988
    return (dst_table);
  }
#line 990
  tp = time_units_table;
#line 990
  while (tp->name) {
#line 991
    if (0) {
#line 991
      __s1_len___3 = __builtin_strlen((char const   *)word);
#line 991
      __s2_len___3 = __builtin_strlen((char const   *)tp->name);
#line 991
      if (! ((size_t )((void const   *)(word + 1)) - (size_t )((void const   *)word) == 1UL)) {
#line 991
        goto _L___8;
      } else
#line 991
      if (__s1_len___3 >= 4UL) {
        _L___8: 
#line 991
        if (! ((size_t )((void const   *)(tp->name + 1)) - (size_t )((void const   *)tp->name) == 1UL)) {
#line 991
          tmp___42 = 1;
        } else
#line 991
        if (__s2_len___3 >= 4UL) {
#line 991
          tmp___42 = 1;
        } else {
#line 991
          tmp___42 = 0;
        }
      } else {
#line 991
        tmp___42 = 0;
      }
#line 991
      if (tmp___42) {
#line 991
        tmp___37 = __builtin_strcmp((char const   *)word, (char const   *)tp->name);
#line 991
        tmp___41 = tmp___37;
      } else {
#line 991
        tmp___40 = __builtin_strcmp((char const   *)word, (char const   *)tp->name);
#line 991
        tmp___41 = tmp___40;
      }
    } else {
#line 991
      tmp___40 = __builtin_strcmp((char const   *)word, (char const   *)tp->name);
#line 991
      tmp___41 = tmp___40;
    }
#line 991
    if (tmp___41 == 0) {
#line 992
      return (tp);
    }
#line 990
    tp ++;
  }
#line 995
  if ((int )*(word + (wordlen - 1UL)) == 83) {
#line 997
    *(word + (wordlen - 1UL)) = (char )'\000';
#line 998
    tp = time_units_table;
#line 998
    while (tp->name) {
#line 999
      if (0) {
#line 999
        __s1_len___4 = __builtin_strlen((char const   *)word);
#line 999
        __s2_len___4 = __builtin_strlen((char const   *)tp->name);
#line 999
        if (! ((size_t )((void const   *)(word + 1)) - (size_t )((void const   *)word) == 1UL)) {
#line 999
          goto _L___10;
        } else
#line 999
        if (__s1_len___4 >= 4UL) {
          _L___10: 
#line 999
          if (! ((size_t )((void const   *)(tp->name + 1)) - (size_t )((void const   *)tp->name) == 1UL)) {
#line 999
            tmp___49 = 1;
          } else
#line 999
          if (__s2_len___4 >= 4UL) {
#line 999
            tmp___49 = 1;
          } else {
#line 999
            tmp___49 = 0;
          }
        } else {
#line 999
          tmp___49 = 0;
        }
#line 999
        if (tmp___49) {
#line 999
          tmp___44 = __builtin_strcmp((char const   *)word, (char const   *)tp->name);
#line 999
          tmp___48 = tmp___44;
        } else {
#line 999
          tmp___47 = __builtin_strcmp((char const   *)word, (char const   *)tp->name);
#line 999
          tmp___48 = tmp___47;
        }
      } else {
#line 999
        tmp___47 = __builtin_strcmp((char const   *)word, (char const   *)tp->name);
#line 999
        tmp___48 = tmp___47;
      }
#line 999
      if (tmp___48 == 0) {
#line 1000
        return (tp);
      }
#line 998
      tp ++;
    }
#line 1001
    *(word + (wordlen - 1UL)) = (char )'S';
  }
#line 1004
  tp = relative_time_table;
#line 1004
  while (tp->name) {
#line 1005
    if (0) {
#line 1005
      __s1_len___5 = __builtin_strlen((char const   *)word);
#line 1005
      __s2_len___5 = __builtin_strlen((char const   *)tp->name);
#line 1005
      if (! ((size_t )((void const   *)(word + 1)) - (size_t )((void const   *)word) == 1UL)) {
#line 1005
        goto _L___12;
      } else
#line 1005
      if (__s1_len___5 >= 4UL) {
        _L___12: 
#line 1005
        if (! ((size_t )((void const   *)(tp->name + 1)) - (size_t )((void const   *)tp->name) == 1UL)) {
#line 1005
          tmp___56 = 1;
        } else
#line 1005
        if (__s2_len___5 >= 4UL) {
#line 1005
          tmp___56 = 1;
        } else {
#line 1005
          tmp___56 = 0;
        }
      } else {
#line 1005
        tmp___56 = 0;
      }
#line 1005
      if (tmp___56) {
#line 1005
        tmp___51 = __builtin_strcmp((char const   *)word, (char const   *)tp->name);
#line 1005
        tmp___55 = tmp___51;
      } else {
#line 1005
        tmp___54 = __builtin_strcmp((char const   *)word, (char const   *)tp->name);
#line 1005
        tmp___55 = tmp___54;
      }
    } else {
#line 1005
      tmp___54 = __builtin_strcmp((char const   *)word, (char const   *)tp->name);
#line 1005
      tmp___55 = tmp___54;
    }
#line 1005
    if (tmp___55 == 0) {
#line 1006
      return (tp);
    }
#line 1004
    tp ++;
  }
#line 1009
  if (wordlen == 1UL) {
#line 1010
    tp = military_table;
#line 1010
    while (tp->name) {
#line 1011
      if ((int )*(word + 0) == (int )*(tp->name + 0)) {
#line 1012
        return (tp);
      }
#line 1010
      tp ++;
    }
  }
#line 1015
  period_found = (_Bool)0;
#line 1015
  q = word;
#line 1015
  p = q;
#line 1015
  while (1) {
#line 1015
    tmp___57 = *q;
#line 1015
    *p = tmp___57;
#line 1015
    if (! tmp___57) {
#line 1015
      break;
    }
#line 1016
    if ((int )*q == 46) {
#line 1017
      period_found = (_Bool)1;
    } else {
#line 1019
      p ++;
    }
#line 1015
    q ++;
  }
#line 1020
  if (period_found) {
#line 1020
    tp = lookup_zone(pc, (char const   *)word);
#line 1020
    if (tp) {
#line 1021
      return (tp);
    }
  }
#line 1023
  return ((table const   *)((void *)0));
}
}
#line 1026 "parse-datetime.y"
static int yylex(union YYSTYPE *lvalp , parser_control *pc ) 
{ unsigned char c ;
  size_t count ;
  int __c ;
  int tmp ;
  char const   *p ;
  int sign ;
  unsigned long value ;
  int __c___0 ;
  int tmp___0 ;
  unsigned long value1 ;
  time_t s ;
  int ns ;
  int digits ;
  unsigned long value1___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char buff[20] ;
  char *p___0 ;
  table const   *tp ;
  char *tmp___5 ;
  int __c___1 ;
  int tmp___6 ;
  int __c___2 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;

  {
#line 1032
  while (1) {
#line 1034
    while (1) {
#line 1034
      c = (unsigned char )*(pc->input);
#line 1034
      __c = (int )c;
#line 1034
      if (__c == 32) {
#line 1034
        tmp = 1;
      } else
#line 1034
      if (__c == 9) {
#line 1034
        tmp = 1;
      } else
#line 1034
      if (__c == 10) {
#line 1034
        tmp = 1;
      } else
#line 1034
      if (__c == 11) {
#line 1034
        tmp = 1;
      } else
#line 1034
      if (__c == 12) {
#line 1034
        tmp = 1;
      } else
#line 1034
      if (__c == 13) {
#line 1034
        tmp = 1;
      } else {
#line 1034
        tmp = 0;
      }
#line 1034
      if (! tmp) {
#line 1034
        break;
      }
#line 1035
      (pc->input) ++;
    }
#line 1037
    if ((unsigned int )c - 48U <= 9U) {
#line 1037
      goto _L___2;
    } else
#line 1037
    if ((int )c == 45) {
#line 1037
      goto _L___2;
    } else
#line 1037
    if ((int )c == 43) {
      _L___2: 
#line 1042
      if ((int )c == 45) {
#line 1042
        goto _L;
      } else
#line 1042
      if ((int )c == 43) {
        _L: 
#line 1044
        if ((int )c == 45) {
#line 1044
          sign = -1;
        } else {
#line 1044
          sign = 1;
        }
#line 1045
        while (1) {
#line 1045
          (pc->input) ++;
#line 1045
          c = (unsigned char )*(pc->input);
#line 1045
          __c___0 = (int )c;
#line 1045
          if (__c___0 == 32) {
#line 1045
            tmp___0 = 1;
          } else
#line 1045
          if (__c___0 == 9) {
#line 1045
            tmp___0 = 1;
          } else
#line 1045
          if (__c___0 == 10) {
#line 1045
            tmp___0 = 1;
          } else
#line 1045
          if (__c___0 == 11) {
#line 1045
            tmp___0 = 1;
          } else
#line 1045
          if (__c___0 == 12) {
#line 1045
            tmp___0 = 1;
          } else
#line 1045
          if (__c___0 == 13) {
#line 1045
            tmp___0 = 1;
          } else {
#line 1045
            tmp___0 = 0;
          }
#line 1045
          if (! tmp___0) {
#line 1045
            break;
          }
#line 1046
          continue;
        }
#line 1047
        if (! ((unsigned int )c - 48U <= 9U)) {
#line 1049
          goto __Cont;
        }
      } else {
#line 1052
        sign = 0;
      }
#line 1053
      p = pc->input;
#line 1054
      value = 0UL;
#line 1054
      while (1) {
#line 1056
        value1 = value + (unsigned long )((int )c - 48);
#line 1057
        if (value1 < value) {
#line 1058
          return ('?');
        }
#line 1059
        value = value1;
#line 1060
        p ++;
#line 1060
        c = (unsigned char )*p;
#line 1061
        if (! ((unsigned int )c - 48U <= 9U)) {
#line 1062
          break;
        }
#line 1063
        if (1844674407370955161UL < value) {
#line 1064
          return ('?');
        }
#line 1054
        value *= 10UL;
      }
#line 1066
      if ((int )c == 46) {
#line 1066
        goto _L___1;
      } else
#line 1066
      if ((int )c == 44) {
        _L___1: 
#line 1066
        if ((unsigned int )*(p + 1) - 48U <= 9U) {
#line 1074
          if (sign < 0) {
#line 1076
            s = (time_t )(- value);
#line 1077
            if (0L < s) {
#line 1078
              return ('?');
            }
#line 1079
            value1___0 = (unsigned long )(- s);
          } else {
#line 1083
            s = (time_t )value;
#line 1084
            if (s < 0L) {
#line 1085
              return ('?');
            }
#line 1086
            value1___0 = (unsigned long )s;
          }
#line 1088
          if (value != value1___0) {
#line 1089
            return ('?');
          }
#line 1092
          p ++;
#line 1093
          tmp___1 = p;
#line 1093
          p ++;
#line 1093
          ns = (int )((int const   )*tmp___1 - 48);
#line 1094
          digits = 2;
#line 1094
          while (digits <= 9) {
#line 1096
            ns *= 10;
#line 1097
            if ((unsigned int )*p - 48U <= 9U) {
#line 1098
              tmp___2 = p;
#line 1098
              p ++;
#line 1098
              ns += (int )((int const   )*tmp___2 - 48);
            }
#line 1094
            digits ++;
          }
#line 1102
          if (sign < 0) {
#line 1103
            while ((unsigned int )*p - 48U <= 9U) {
#line 1104
              if ((int const   )*p != 48) {
#line 1106
                ns ++;
#line 1107
                break;
              }
#line 1103
              p ++;
            }
          }
#line 1109
          while ((unsigned int )*p - 48U <= 9U) {
#line 1110
            p ++;
          }
#line 1115
          if (sign < 0) {
#line 1115
            if (ns) {
#line 1117
              s --;
#line 1118
              if (! (s < 0L)) {
#line 1119
                return ('?');
              }
#line 1120
              ns = 1000000000 - ns;
            }
          }
#line 1123
          lvalp->timespec.tv_sec = s;
#line 1124
          lvalp->timespec.tv_nsec = (long )ns;
#line 1125
          pc->input = p;
#line 1126
          if (sign) {
#line 1126
            tmp___3 = 276;
          } else {
#line 1126
            tmp___3 = 277;
          }
#line 1126
          return (tmp___3);
        } else {
#line 1066
          goto _L___0;
        }
      } else {
        _L___0: 
#line 1130
        lvalp->textintval.negative = (_Bool )(sign < 0);
#line 1131
        if (sign < 0) {
#line 1133
          lvalp->textintval.value = (long )(- value);
#line 1134
          if (0L < lvalp->textintval.value) {
#line 1135
            return ('?');
          }
        } else {
#line 1139
          lvalp->textintval.value = (long )value;
#line 1140
          if (lvalp->textintval.value < 0L) {
#line 1141
            return ('?');
          }
        }
#line 1143
        lvalp->textintval.digits = (size_t )(p - pc->input);
#line 1144
        pc->input = p;
#line 1145
        if (sign) {
#line 1145
          tmp___4 = 274;
        } else {
#line 1145
          tmp___4 = 275;
        }
#line 1145
        return (tmp___4);
      }
    }
#line 1149
    __c___2 = (int )c;
#line 1149
    if ((__c___2 & -33) >= 65) {
#line 1149
      if ((__c___2 & -33) <= 90) {
#line 1149
        tmp___7 = 1;
      } else {
#line 1149
        tmp___7 = 0;
      }
    } else {
#line 1149
      tmp___7 = 0;
    }
#line 1149
    if (tmp___7) {
#line 1152
      p___0 = buff;
#line 1161
      while (1) {
#line 1157
        if ((unsigned long )(p___0 - buff) < sizeof(buff) - 1UL) {
#line 1158
          tmp___5 = p___0;
#line 1158
          p___0 ++;
#line 1158
          *tmp___5 = (char )c;
        }
#line 1159
        (pc->input) ++;
#line 1159
        c = (unsigned char )*(pc->input);
#line 1161
        __c___1 = (int )c;
#line 1161
        if ((__c___1 & -33) >= 65) {
#line 1161
          if ((__c___1 & -33) <= 90) {
#line 1161
            tmp___6 = 1;
          } else {
#line 1161
            tmp___6 = 0;
          }
        } else {
#line 1161
          tmp___6 = 0;
        }
#line 1161
        if (! tmp___6) {
#line 1161
          if (! ((int )c == 46)) {
#line 1155
            break;
          }
        }
      }
#line 1163
      *p___0 = (char )'\000';
#line 1164
      tp = lookup_word((parser_control const   *)pc, buff);
#line 1165
      if (! tp) {
#line 1166
        return ('?');
      }
#line 1167
      lvalp->intval = (long )tp->value;
#line 1168
      return ((int )tp->type);
    }
#line 1171
    if ((int )c != 40) {
#line 1172
      tmp___8 = pc->input;
#line 1172
      (pc->input) ++;
#line 1172
      return ((int )*tmp___8);
    }
#line 1173
    count = (size_t )0;
#line 1174
    while (1) {
#line 1176
      tmp___9 = pc->input;
#line 1176
      (pc->input) ++;
#line 1176
      c = (unsigned char )*tmp___9;
#line 1177
      if ((int )c == 0) {
#line 1178
        return ((int )c);
      }
#line 1179
      if ((int )c == 40) {
#line 1180
        count ++;
      } else
#line 1181
      if ((int )c == 41) {
#line 1182
        count --;
      }
#line 1174
      if (! (count != 0UL)) {
#line 1174
        break;
      }
    }
    __Cont: ;
  }
}
}
#line 1189 "parse-datetime.y"
static int yyerror(parser_control const   *pc  __attribute__((__unused__)) , char const   *s  __attribute__((__unused__)) ) 
{ 

  {
#line 1193
  return (0);
}
}
#line 1200 "parse-datetime.y"
static _Bool mktime_ok(struct tm  const  *tm0 , struct tm  const  *tm1 , time_t t ) 
{ struct tm *tmp ;

  {
#line 1203
  if (t == -1L) {
#line 1208
    tmp = localtime((time_t const   *)(& t));
#line 1208
    tm1 = (struct tm  const  *)tmp;
#line 1209
    if (! tm1) {
#line 1210
      return ((_Bool)0);
    }
  }
#line 1213
  return ((_Bool )(! ((((((tm0->tm_sec ^ tm1->tm_sec) | (tm0->tm_min ^ tm1->tm_min)) | (tm0->tm_hour ^ tm1->tm_hour)) | (tm0->tm_mday ^ tm1->tm_mday)) | (tm0->tm_mon ^ tm1->tm_mon)) | (tm0->tm_year ^ tm1->tm_year))));
}
}
#line 1227 "parse-datetime.y"
static char *get_tz(char *tzbuf ) 
{ char *tz ;
  char *tmp ;
  size_t tzsize ;
  size_t tmp___0 ;
  void __attribute__((__artificial__))  *tmp___1 ;
  void *tmp___2 ;

  {
#line 1230
  tmp = getenv("TZ");
#line 1230
  tz = tmp;
#line 1231
  if (tz) {
#line 1233
    tmp___0 = strlen((char const   *)tz);
#line 1233
    tzsize = tmp___0 + 1UL;
#line 1234
    if (tzsize <= 100UL) {
#line 1234
      tmp___1 = memcpy((void * __restrict  )tzbuf, (void const   * __restrict  )tz,
                       tzsize);
#line 1234
      tz = (char *)tmp___1;
    } else {
#line 1234
      tmp___2 = xmemdup((void const   *)tz, tzsize);
#line 1234
      tz = (char *)tmp___2;
    }
  }
#line 1238
  return (tz);
}
}
#line 1245 "parse-datetime.y"
_Bool parse_datetime(struct timespec *result , char const   *p , struct timespec  const  *now ) 
{ time_t Start ;
  long Start_ns ;
  struct tm  const  *tmp ;
  struct tm tm ;
  struct tm tm0 ;
  parser_control pc ;
  struct timespec gettime_buffer ;
  unsigned char c ;
  _Bool tz_was_altered ;
  char *tz0 ;
  char tz0buf[100] ;
  _Bool ok ;
  struct tm *tmp___0 ;
  int __c ;
  int tmp___1 ;
  char const   *tzbase ;
  size_t tzsize ;
  char const   *s ;
  char *z ;
  char *tz1 ;
  char tz1buf[100] ;
  _Bool large_tz ;
  _Bool setenv_ok ;
  void *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  relative_time __constr_expr_0 ;
  int quarter ;
  time_t probe ;
  struct tm  const  *probe_tm ;
  struct tm *tmp___18 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___20 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  long tmp___27 ;
  long time_zone ;
  long abs_time_zone ;
  long tmp___28 ;
  long abs_time_zone_hour ;
  int abs_time_zone_min ;
  char tz1buf___0[sizeof("XXX+0:00") + (sizeof(pc.time_zone) * 8UL) / 3UL] ;
  int tmp___29 ;
  _Bool tmp___30 ;
  _Bool tmp___31 ;
  int tmp___32 ;
  int year___0 ;
  int month ;
  int day ;
  long delta ;
  time_t t1 ;
  long sum_ns ;
  long normalized_ns ;
  time_t t0 ;
  long d1 ;
  time_t t1___0 ;
  long d2 ;
  time_t t2 ;
  long_time_t d3 ;
  long_time_t t3 ;
  long d4 ;
  long_time_t t4 ;
  time_t t5 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;

  {
#line 1257
  tz_was_altered = (_Bool)0;
#line 1258
  tz0 = (char *)((void *)0);
#line 1260
  ok = (_Bool)1;
#line 1262
  if (! now) {
#line 1264
    gettime(& gettime_buffer);
#line 1265
    now = (struct timespec  const  *)(& gettime_buffer);
  }
#line 1268
  Start = (time_t )now->tv_sec;
#line 1269
  Start_ns = (long )now->tv_nsec;
#line 1271
  tmp___0 = localtime(& now->tv_sec);
#line 1271
  tmp = (struct tm  const  *)tmp___0;
#line 1272
  if (! tmp) {
#line 1273
    return ((_Bool)0);
  }
#line 1275
  while (1) {
#line 1275
    c = (unsigned char )*p;
#line 1275
    __c = (int )c;
#line 1275
    if (__c == 32) {
#line 1275
      tmp___1 = 1;
    } else
#line 1275
    if (__c == 9) {
#line 1275
      tmp___1 = 1;
    } else
#line 1275
    if (__c == 10) {
#line 1275
      tmp___1 = 1;
    } else
#line 1275
    if (__c == 11) {
#line 1275
      tmp___1 = 1;
    } else
#line 1275
    if (__c == 12) {
#line 1275
      tmp___1 = 1;
    } else
#line 1275
    if (__c == 13) {
#line 1275
      tmp___1 = 1;
    } else {
#line 1275
      tmp___1 = 0;
    }
#line 1275
    if (! tmp___1) {
#line 1275
      break;
    }
#line 1276
    p ++;
  }
#line 1278
  if (0) {
#line 1278
    if (0) {
#line 1278
      __s1_len = __builtin_strlen(p);
#line 1278
      __s2_len = __builtin_strlen("TZ=\"");
#line 1278
      if (! ((size_t )((void const   *)(p + 1)) - (size_t )((void const   *)p) == 1UL)) {
#line 1278
        goto _L___0;
      } else
#line 1278
      if (__s1_len >= 4UL) {
        _L___0: 
#line 1278
        if (! ((size_t )((void const   *)("TZ=\"" + 1)) - (size_t )((void const   *)"TZ=\"") == 1UL)) {
#line 1278
          tmp___13 = 1;
        } else
#line 1278
        if (__s2_len >= 4UL) {
#line 1278
          tmp___13 = 1;
        } else {
#line 1278
          tmp___13 = 0;
        }
      } else {
#line 1278
        tmp___13 = 0;
      }
#line 1278
      if (tmp___13) {
#line 1278
        tmp___8 = __builtin_strcmp(p, "TZ=\"");
#line 1278
        tmp___12 = tmp___8;
      } else {
#line 1278
        tmp___11 = __builtin_strcmp(p, "TZ=\"");
#line 1278
        tmp___12 = tmp___11;
      }
    } else {
#line 1278
      tmp___11 = __builtin_strcmp(p, "TZ=\"");
#line 1278
      tmp___12 = tmp___11;
    }
#line 1278
    tmp___15 = tmp___12;
  } else {
#line 1278
    tmp___14 = strncmp(p, "TZ=\"", (size_t )4);
#line 1278
    tmp___15 = tmp___14;
  }
#line 1278
  if (tmp___15 == 0) {
#line 1280
    tzbase = p + 4;
#line 1281
    tzsize = (size_t )1;
#line 1284
    s = tzbase;
#line 1284
    while (*s) {
#line 1285
      if ((int const   )*s == 92) {
#line 1287
        s ++;
#line 1288
        if (! ((int const   )*s == 92)) {
#line 1288
          if (! ((int const   )*s == 34)) {
#line 1289
            break;
          }
        }
      } else
#line 1291
      if ((int const   )*s == 34) {
#line 1296
        large_tz = (_Bool )(100UL < tzsize);
#line 1299
        free((void *)tz0);
#line 1300
        tz0 = get_tz(tz0buf);
#line 1301
        if (large_tz) {
#line 1301
          tmp___2 = xmalloc(tzsize);
#line 1301
          tz1 = (char *)tmp___2;
        } else {
#line 1301
          tz1 = tz1buf;
        }
#line 1301
        z = tz1;
#line 1302
        s = tzbase;
#line 1302
        while ((int const   )*s != 34) {
#line 1303
          tmp___3 = z;
#line 1303
          z ++;
#line 1303
          s += (int const   )*s == 92;
#line 1303
          *tmp___3 = (char )*s;
#line 1302
          s ++;
        }
#line 1304
        *z = (char )'\000';
#line 1305
        tmp___4 = setenv("TZ", (char const   *)tz1, 1);
#line 1305
        setenv_ok = (_Bool )(tmp___4 == 0);
#line 1306
        if (large_tz) {
#line 1307
          free((void *)tz1);
        }
#line 1308
        if (! setenv_ok) {
#line 1309
          goto fail;
        }
#line 1310
        tz_was_altered = (_Bool)1;
#line 1311
        p = s + 1;
      }
#line 1284
      s ++;
#line 1284
      tzsize ++;
    }
  }
#line 1318
  if ((int const   )*p == 0) {
#line 1319
    p = "0";
  }
#line 1321
  pc.input = p;
#line 1322
  pc.year.value = (long )tmp->tm_year;
#line 1323
  pc.year.value += 1900L;
#line 1324
  pc.year.digits = (size_t )0;
#line 1325
  pc.month = (long )(tmp->tm_mon + 1);
#line 1326
  pc.day = (long )tmp->tm_mday;
#line 1327
  pc.hour = (long )tmp->tm_hour;
#line 1328
  pc.minutes = (long )tmp->tm_min;
#line 1329
  pc.seconds.tv_sec = (__time_t )tmp->tm_sec;
#line 1330
  pc.seconds.tv_nsec = Start_ns;
#line 1331
  tm.tm_isdst = (int )tmp->tm_isdst;
#line 1333
  pc.meridian = 2;
#line 1334
  __constr_expr_0.year = 0L;
#line 1334
  __constr_expr_0.month = 0L;
#line 1334
  __constr_expr_0.day = 0L;
#line 1334
  __constr_expr_0.hour = 0L;
#line 1334
  __constr_expr_0.minutes = 0L;
#line 1334
  __constr_expr_0.seconds = (long_time_t )0;
#line 1334
  __constr_expr_0.ns = 0L;
#line 1334
  pc.rel = __constr_expr_0;
#line 1335
  pc.timespec_seen = (_Bool)0;
#line 1336
  pc.rels_seen = (_Bool)0;
#line 1337
  pc.dates_seen = (size_t )0;
#line 1338
  pc.days_seen = (size_t )0;
#line 1339
  pc.times_seen = (size_t )0;
#line 1340
  pc.local_zones_seen = (size_t )0;
#line 1341
  pc.dsts_seen = (size_t )0;
#line 1342
  pc.zones_seen = (size_t )0;
#line 1345
  pc.local_time_zone_table[0].name = (char const   *)tmp->tm_zone;
#line 1346
  pc.local_time_zone_table[0].type = 269;
#line 1347
  pc.local_time_zone_table[0].value = (int )tmp->tm_isdst;
#line 1348
  pc.local_time_zone_table[1].name = (char const   *)((void *)0);
#line 1354
  quarter = 1;
#line 1354
  while (quarter <= 3) {
#line 1356
    probe = Start + (time_t )(quarter * 7776000);
#line 1357
    tmp___18 = localtime((time_t const   *)(& probe));
#line 1357
    probe_tm = (struct tm  const  *)tmp___18;
#line 1358
    if (probe_tm) {
#line 1358
      if (probe_tm->tm_zone) {
#line 1358
        if (probe_tm->tm_isdst != (int const   )pc.local_time_zone_table[0].value) {
#line 1362
          pc.local_time_zone_table[1].name = (char const   *)probe_tm->tm_zone;
#line 1363
          pc.local_time_zone_table[1].type = 269;
#line 1364
          pc.local_time_zone_table[1].value = (int )probe_tm->tm_isdst;
#line 1365
          pc.local_time_zone_table[2].name = (char const   *)((void *)0);
#line 1367
          break;
        }
      }
    }
#line 1354
    quarter ++;
  }
#line 1392
  if (pc.local_time_zone_table[0].name) {
#line 1392
    if (pc.local_time_zone_table[1].name) {
#line 1392
      if (0) {
#line 1392
        __s1_len___0 = __builtin_strlen(pc.local_time_zone_table[0].name);
#line 1392
        __s2_len___0 = __builtin_strlen(pc.local_time_zone_table[1].name);
#line 1392
        if (! ((size_t )((void const   *)(pc.local_time_zone_table[0].name + 1)) - (size_t )((void const   *)pc.local_time_zone_table[0].name) == 1UL)) {
#line 1392
          goto _L___2;
        } else
#line 1392
        if (__s1_len___0 >= 4UL) {
          _L___2: 
#line 1392
          if (! ((size_t )((void const   *)(pc.local_time_zone_table[1].name + 1)) - (size_t )((void const   *)pc.local_time_zone_table[1].name) == 1UL)) {
#line 1392
            tmp___25 = 1;
          } else
#line 1392
          if (__s2_len___0 >= 4UL) {
#line 1392
            tmp___25 = 1;
          } else {
#line 1392
            tmp___25 = 0;
          }
        } else {
#line 1392
          tmp___25 = 0;
        }
#line 1392
        if (tmp___25) {
#line 1392
          tmp___20 = __builtin_strcmp(pc.local_time_zone_table[0].name, pc.local_time_zone_table[1].name);
#line 1392
          tmp___24 = tmp___20;
        } else {
#line 1392
          tmp___23 = __builtin_strcmp(pc.local_time_zone_table[0].name, pc.local_time_zone_table[1].name);
#line 1392
          tmp___24 = tmp___23;
        }
      } else {
#line 1392
        tmp___23 = __builtin_strcmp(pc.local_time_zone_table[0].name, pc.local_time_zone_table[1].name);
#line 1392
        tmp___24 = tmp___23;
      }
#line 1392
      if (! tmp___24) {
#line 1398
        pc.local_time_zone_table[0].value = -1;
#line 1399
        pc.local_time_zone_table[1].name = (char const   *)((void *)0);
      }
    }
  }
#line 1402
  tmp___26 = yyparse(& pc);
#line 1402
  if (tmp___26 != 0) {
#line 1403
    goto fail;
  }
#line 1405
  if (pc.timespec_seen) {
#line 1406
    *result = pc.seconds;
  } else {
#line 1409
    if (1UL < ((((pc.times_seen | pc.dates_seen) | pc.days_seen) | pc.dsts_seen) | (pc.local_zones_seen + pc.zones_seen))) {
#line 1411
      goto fail;
    }
#line 1413
    tmp___27 = to_year(pc.year);
#line 1413
    tm.tm_year = (int )(tmp___27 - 1900L);
#line 1414
    tm.tm_mon = (int )(pc.month - 1L);
#line 1415
    tm.tm_mday = (int )pc.day;
#line 1416
    if (pc.times_seen) {
#line 1416
      goto _L___3;
    } else
#line 1416
    if (pc.rels_seen) {
#line 1416
      if (! pc.dates_seen) {
#line 1416
        if (! pc.days_seen) {
          _L___3: 
#line 1418
          tm.tm_hour = to_hour(pc.hour, pc.meridian);
#line 1419
          if (tm.tm_hour < 0) {
#line 1420
            goto fail;
          }
#line 1421
          tm.tm_min = (int )pc.minutes;
#line 1422
          tm.tm_sec = (int )pc.seconds.tv_sec;
        } else {
#line 1426
          tm.tm_sec = 0;
#line 1426
          tm.tm_min = tm.tm_sec;
#line 1426
          tm.tm_hour = tm.tm_min;
#line 1427
          pc.seconds.tv_nsec = 0L;
        }
      } else {
#line 1426
        tm.tm_sec = 0;
#line 1426
        tm.tm_min = tm.tm_sec;
#line 1426
        tm.tm_hour = tm.tm_min;
#line 1427
        pc.seconds.tv_nsec = 0L;
      }
    } else {
#line 1426
      tm.tm_sec = 0;
#line 1426
      tm.tm_min = tm.tm_sec;
#line 1426
      tm.tm_hour = tm.tm_min;
#line 1427
      pc.seconds.tv_nsec = 0L;
    }
#line 1431
    if ((pc.dates_seen | pc.days_seen) | pc.times_seen) {
#line 1432
      tm.tm_isdst = -1;
    }
#line 1436
    if (pc.local_zones_seen) {
#line 1437
      tm.tm_isdst = pc.local_isdst;
    }
#line 1439
    tm0 = tm;
#line 1441
    Start = mktime(& tm);
#line 1443
    tmp___31 = mktime_ok((struct tm  const  *)(& tm0), (struct tm  const  *)(& tm),
                         Start);
#line 1443
    if (! tmp___31) {
#line 1445
      if (! pc.zones_seen) {
#line 1446
        goto fail;
      } else {
#line 1459
        time_zone = pc.time_zone;
#line 1460
        if (time_zone < 0L) {
#line 1460
          tmp___28 = - time_zone;
        } else {
#line 1460
          tmp___28 = time_zone;
        }
#line 1460
        abs_time_zone = tmp___28;
#line 1461
        abs_time_zone_hour = abs_time_zone / 60L;
#line 1462
        abs_time_zone_min = (int )(abs_time_zone % 60L);
#line 1465
        if (! tz_was_altered) {
#line 1466
          tz0 = get_tz(tz0buf);
        }
#line 1467
        sprintf((char * __restrict  )(tz1buf___0), (char const   * __restrict  )"XXX%s%ld:%02d",
                "-" + (time_zone < 0L), abs_time_zone_hour, abs_time_zone_min);
#line 1469
        tmp___29 = setenv("TZ", (char const   *)(tz1buf___0), 1);
#line 1469
        if (tmp___29 != 0) {
#line 1470
          goto fail;
        }
#line 1471
        tz_was_altered = (_Bool)1;
#line 1472
        tm = tm0;
#line 1473
        Start = mktime(& tm);
#line 1474
        tmp___30 = mktime_ok((struct tm  const  *)(& tm0), (struct tm  const  *)(& tm),
                             Start);
#line 1474
        if (! tmp___30) {
#line 1475
          goto fail;
        }
      }
    }
#line 1479
    if (pc.days_seen) {
#line 1479
      if (! pc.dates_seen) {
#line 1481
        if (0L < pc.day_ordinal) {
#line 1481
          if (tm.tm_wday != pc.day_number) {
#line 1481
            tmp___32 = 1;
          } else {
#line 1481
            tmp___32 = 0;
          }
        } else {
#line 1481
          tmp___32 = 0;
        }
#line 1481
        tm.tm_mday = (int )((long )tm.tm_mday + ((long )(((pc.day_number - tm.tm_wday) + 7) % 7) + 7L * (pc.day_ordinal - (long )tmp___32)));
#line 1485
        tm.tm_isdst = -1;
#line 1486
        Start = mktime(& tm);
#line 1487
        if (Start == -1L) {
#line 1488
          goto fail;
        }
      }
    }
#line 1492
    if ((pc.rel.year | pc.rel.month) | pc.rel.day) {
#line 1494
      year___0 = (int )((long )tm.tm_year + pc.rel.year);
#line 1495
      month = (int )((long )tm.tm_mon + pc.rel.month);
#line 1496
      day = (int )((long )tm.tm_mday + pc.rel.day);
#line 1497
      if ((((year___0 < tm.tm_year) ^ (pc.rel.year < 0L)) | ((month < tm.tm_mon) ^ (pc.rel.month < 0L))) | ((day < tm.tm_mday) ^ (pc.rel.day < 0L))) {
#line 1500
        goto fail;
      }
#line 1501
      tm.tm_year = year___0;
#line 1502
      tm.tm_mon = month;
#line 1503
      tm.tm_mday = day;
#line 1504
      tm.tm_hour = tm0.tm_hour;
#line 1505
      tm.tm_min = tm0.tm_min;
#line 1506
      tm.tm_sec = tm0.tm_sec;
#line 1507
      tm.tm_isdst = tm0.tm_isdst;
#line 1508
      Start = mktime(& tm);
#line 1509
      if (Start == -1L) {
#line 1510
        goto fail;
      }
    }
#line 1515
    if (pc.zones_seen) {
#line 1517
      delta = pc.time_zone * 60L;
#line 1520
      delta -= tm.tm_gmtoff;
#line 1528
      t1 = Start - delta;
#line 1529
      if ((Start < t1) != (delta < 0L)) {
#line 1530
        goto fail;
      }
#line 1531
      Start = t1;
    }
#line 1542
    sum_ns = pc.seconds.tv_nsec + pc.rel.ns;
#line 1543
    normalized_ns = (sum_ns % 1000000000L + 1000000000L) % 1000000000L;
#line 1544
    t0 = Start;
#line 1545
    d1 = 3600L * pc.rel.hour;
#line 1546
    t1___0 = t0 + d1;
#line 1547
    d2 = 60L * pc.rel.minutes;
#line 1548
    t2 = t1___0 + d2;
#line 1549
    d3 = pc.rel.seconds;
#line 1550
    t3 = t2 + d3;
#line 1551
    d4 = (sum_ns - normalized_ns) / 1000000000L;
#line 1552
    t4 = t3 + d4;
#line 1553
    t5 = t4;
#line 1555
    if (((((((d1 / 3600L ^ pc.rel.hour) | (d2 / 60L ^ pc.rel.minutes)) | (long )((t1___0 < t0) ^ (d1 < 0L))) | (long )((t2 < t1___0) ^ (d2 < 0L))) | (long )((t3 < t2) ^ (d3 < 0L))) | (long )((t4 < t3) ^ (d4 < 0L))) | (long )(t5 != t4)) {
#line 1562
      goto fail;
    }
#line 1564
    result->tv_sec = t5;
#line 1565
    result->tv_nsec = normalized_ns;
  }
#line 1569
  goto done;
  fail: 
#line 1572
  ok = (_Bool)0;
  done: 
#line 1574
  if (tz_was_altered) {
#line 1575
    if (tz0) {
#line 1575
      tmp___33 = setenv("TZ", (char const   *)tz0, 1);
#line 1575
      tmp___35 = tmp___33;
    } else {
#line 1575
      tmp___34 = unsetenv("TZ");
#line 1575
      tmp___35 = tmp___34;
    }
#line 1575
    ok = (_Bool )((int )ok & (tmp___35 == 0));
  }
#line 1576
  if ((unsigned long )tz0 != (unsigned long )(tz0buf)) {
#line 1577
    free((void *)tz0);
  }
#line 1578
  return (ok);
}
}
#line 1 "physmem.o"
#pragma merger(0,"/tmp/cil-WwMfVP89.i","-g,-O2")
#line 23 "physmem.h"
double physmem_total(void) ;
#line 24
double physmem_available(void) ;
#line 81 "physmem.c"
double physmem_total(void) 
{ double pages ;
  long tmp ;
  double pagesize ;
  long tmp___0 ;

  {
#line 86
  tmp = sysconf(85);
#line 86
  pages = (double )tmp;
#line 87
  tmp___0 = sysconf(30);
#line 87
  pagesize = (double )tmp___0;
#line 88
  if ((double )0 <= pages) {
#line 88
    if ((double )0 <= pagesize) {
#line 89
      return (pages * pagesize);
    }
  }
#line 181
  return ((double )67108864);
}
}
#line 185 "physmem.c"
double physmem_available(void) 
{ double pages ;
  long tmp ;
  double pagesize ;
  long tmp___0 ;
  double tmp___1 ;

  {
#line 190
  tmp = sysconf(86);
#line 190
  pages = (double )tmp;
#line 191
  tmp___0 = sysconf(30);
#line 191
  pagesize = (double )tmp___0;
#line 192
  if ((double )0 <= pages) {
#line 192
    if ((double )0 <= pagesize) {
#line 193
      return (pages * pagesize);
    }
  }
#line 282
  tmp___1 = physmem_total();
#line 282
  return (tmp___1 / (double )4);
}
}
#line 1 "posixtm.o"
#pragma merger(0,"/tmp/cil-on_zPMlc.i","-g,-O2")
#line 186 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 34 "posixtm.h"
_Bool posixtime(time_t *p , char const   *s , unsigned int syntax_bits ) ;
#line 60 "posixtm.c"
static int year(struct tm *tm , int const   *digit_pair , size_t n , unsigned int syntax_bits ) 
{ time_t now ;
  struct tm *tmp ;

  {
#line 63
  switch ((int )n) {
  case 1: 
#line 66
  tm->tm_year = (int )*digit_pair;
#line 70
  if (*(digit_pair + 0) <= 68) {
#line 72
    if (syntax_bits & 16U) {
#line 73
      return (1);
    }
#line 74
    tm->tm_year += 100;
  }
#line 76
  break;
  case 2: 
#line 79
  if (! (syntax_bits & 4U)) {
#line 80
    return (1);
  }
#line 81
  tm->tm_year = (int )((*(digit_pair + 0) * 100 + *(digit_pair + 1)) - 1900);
#line 82
  break;
  case 0: 
#line 90
  time(& now);
#line 91
  tmp = localtime((time_t const   *)(& now));
#line 92
  if (! tmp) {
#line 93
    return (1);
  }
#line 94
  tm->tm_year = tmp->tm_year;
#line 96
  break;
  default: 
#line 99
  abort();
  }
#line 102
  return (0);
}
}
#line 105 "posixtm.c"
static int posix_time_parse(struct tm *tm , char const   *s , unsigned int syntax_bits ) 
{ char const   *dot ;
  int pair[6] ;
  int *p ;
  size_t i ;
  size_t s_len ;
  size_t tmp ;
  size_t len ;
  size_t tmp___2 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  int seconds ;

  {
#line 108
  dot = (char const   *)((void *)0);
#line 113
  tmp = strlen(s);
#line 113
  s_len = tmp;
#line 114
  if (syntax_bits & 8U) {
#line 114
    tmp___4 = __builtin_strchr((char *)s, '.');
#line 114
    dot = (char const   *)tmp___4;
#line 114
    if (dot) {
#line 114
      tmp___2 = (size_t )(dot - s);
    } else {
#line 114
      tmp___2 = s_len;
    }
  } else {
#line 114
    tmp___2 = s_len;
  }
#line 114
  len = tmp___2;
#line 118
  if (len != 8UL) {
#line 118
    if (len != 10UL) {
#line 118
      if (len != 12UL) {
#line 119
        return (1);
      }
    }
  }
#line 121
  if (dot) {
#line 123
    if (! (syntax_bits & 8U)) {
#line 124
      return (1);
    }
#line 126
    if (s_len - len != 3UL) {
#line 127
      return (1);
    }
  }
#line 130
  i = (size_t )0;
#line 130
  while (i < len) {
#line 131
    if (! ((unsigned int )*(s + i) - 48U <= 9U)) {
#line 132
      return (1);
    }
#line 130
    i ++;
  }
#line 134
  len /= 2UL;
#line 135
  i = (size_t )0;
#line 135
  while (i < len) {
#line 136
    pair[i] = (10 * (int )((int const   )*(s + 2UL * i) - 48) + (int )*(s + (2UL * i + 1UL))) - 48;
#line 135
    i ++;
  }
#line 138
  p = pair;
#line 139
  if (syntax_bits & 1U) {
#line 141
    tmp___5 = year(tm, (int const   *)p, len - 4UL, syntax_bits);
#line 141
    if (tmp___5) {
#line 142
      return (1);
    }
#line 143
    p += len - 4UL;
#line 144
    len = (size_t )4;
  }
#line 148
  tmp___6 = p;
#line 148
  p ++;
#line 148
  tm->tm_mon = *tmp___6 - 1;
#line 149
  tmp___7 = p;
#line 149
  p ++;
#line 149
  tm->tm_mday = *tmp___7;
#line 150
  tmp___8 = p;
#line 150
  p ++;
#line 150
  tm->tm_hour = *tmp___8;
#line 151
  tmp___9 = p;
#line 151
  p ++;
#line 151
  tm->tm_min = *tmp___9;
#line 152
  len -= 4UL;
#line 155
  if (syntax_bits & 2U) {
#line 157
    tmp___10 = year(tm, (int const   *)p, len, syntax_bits);
#line 157
    if (tmp___10) {
#line 158
      return (1);
    }
  }
#line 162
  if (! dot) {
#line 164
    tm->tm_sec = 0;
  } else {
#line 170
    dot ++;
#line 171
    if (! ((unsigned int )*(dot + 0) - 48U <= 9U)) {
#line 172
      return (1);
    } else
#line 171
    if (! ((unsigned int )*(dot + 1) - 48U <= 9U)) {
#line 172
      return (1);
    }
#line 173
    seconds = (10 * (int )((int const   )*(dot + 0) - 48) + (int )*(dot + 1)) - 48;
#line 175
    tm->tm_sec = seconds;
  }
#line 178
  return (0);
}
}
#line 183 "posixtm.c"
_Bool posixtime(time_t *p , char const   *s , unsigned int syntax_bits ) 
{ struct tm tm0 ;
  struct tm tm1 ;
  struct tm  const  *tm ;
  time_t t ;
  int tmp ;
  struct tm *tmp___0 ;
  time_t dummy ;
  char buf___1[16] ;
  char *b ;
  char __attribute__((__artificial__))  *tmp___1 ;
  _Bool tmp___2 ;

  {
#line 191
  tmp = posix_time_parse(& tm0, s, syntax_bits);
#line 191
  if (tmp) {
#line 192
    return ((_Bool)0);
  }
#line 194
  tm1 = tm0;
#line 195
  tm1.tm_isdst = -1;
#line 196
  t = mktime(& tm1);
#line 198
  if (t != -1L) {
#line 199
    tm = (struct tm  const  *)(& tm1);
  } else {
#line 204
    tmp___0 = localtime((time_t const   *)(& t));
#line 204
    tm = (struct tm  const  *)tmp___0;
#line 205
    if (! tm) {
#line 206
      return ((_Bool)0);
    }
  }
#line 211
  if ((((((tm0.tm_year ^ (int )tm->tm_year) | (tm0.tm_mon ^ (int )tm->tm_mon)) | (tm0.tm_mday ^ (int )tm->tm_mday)) | (tm0.tm_hour ^ (int )tm->tm_hour)) | (tm0.tm_min ^ (int )tm->tm_min)) | (tm0.tm_sec ^ (int )tm->tm_sec)) {
#line 219
    if (tm0.tm_sec != 60) {
#line 220
      return ((_Bool)0);
    }
#line 226
    tmp___1 = stpcpy((char * __restrict  )(buf___1), (char const   * __restrict  )s);
#line 226
    b = (char *)tmp___1;
#line 227
    strcpy((char * __restrict  )(b - 2), (char const   * __restrict  )"59");
#line 228
    tmp___2 = posixtime(& dummy, (char const   *)(buf___1), syntax_bits);
#line 228
    if (! tmp___2) {
#line 229
      return ((_Bool)0);
    }
  }
#line 233
  *p = t;
#line 234
  return ((_Bool)1);
}
}
#line 1 "posixver.o"
#pragma merger(0,"/tmp/cil-ShGSTOeq.i","-g,-O2")
#line 1 "posixver.h"
int posix2_version(void) ;
#line 39 "posixver.c"
int posix2_version(void) 
{ long v ;
  char const   *s ;
  char *tmp ;
  char *e ;
  long i ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 42
  v = 200809L;
#line 43
  tmp = getenv("_POSIX2_VERSION");
#line 43
  s = (char const   *)tmp;
#line 45
  if (s) {
#line 45
    if (*s) {
#line 48
      tmp___0 = strtol((char const   * __restrict  )s, (char ** __restrict  )(& e),
                       10);
#line 48
      i = tmp___0;
#line 49
      if (! *e) {
#line 50
        v = i;
      }
    }
  }
#line 53
  if (v < (-0x7FFFFFFF-1)) {
#line 53
    tmp___2 = (-0x7FFFFFFF-1);
  } else {
#line 53
    if (v < 2147483647L) {
#line 53
      tmp___1 = v;
    } else {
#line 53
      tmp___1 = 2147483647L;
    }
#line 53
    tmp___2 = tmp___1;
  }
#line 53
  return ((int )tmp___2);
}
}
#line 1 "printf-frexp.o"
#pragma merger(0,"/tmp/cil-bzo9m3Ho.i","-g,-O2")
#line 23 "printf-frexp.h"
double printf_frexp(double x , int *expptr ) ;
#line 104 "/usr/include/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double frexp(double __x , int *__exponent ) ;
#line 107
extern  __attribute__((__nothrow__)) double ldexp(double __x , int __exponent ) ;
#line 350
__inline extern  __attribute__((__nothrow__)) int __signbit(double __x )  __attribute__((__const__)) ;
#line 350
__inline extern  __attribute__((__nothrow__)) int __signbitf(float __x )  __attribute__((__const__)) ;
#line 350
__inline extern  __attribute__((__nothrow__)) int __signbitl(long double __x )  __attribute__((__const__)) ;
#line 37 "/usr/include/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int __signbitf(float __x )  __attribute__((__const__)) ;
#line 37 "/usr/include/bits/mathinline.h"
__inline extern int __signbitf(float __x ) 
{ int __m ;

  {
#line 45
  __asm__  ("pmovmskb %1, %0": "=r" (__m): "x" (__x));
#line 46
  return (__m & 8);
}
}
#line 49
__inline extern  __attribute__((__nothrow__)) int __signbit(double __x )  __attribute__((__const__)) ;
#line 49 "/usr/include/bits/mathinline.h"
__inline extern int __signbit(double __x ) 
{ int __m ;

  {
#line 57
  __asm__  ("pmovmskb %1, %0": "=r" (__m): "x" (__x));
#line 58
  return (__m & 128);
}
}
#line 64 "printf-frexp.c"
double printf_frexp(double x , int *expptr ) 
{ int exponent ;

  {
#line 74
  x = frexp(x, & exponent);
#line 76
  x += x;
#line 77
  exponent --;
#line 79
  if (exponent < -1022) {
#line 81
    x = ldexp(x, exponent - -1022);
#line 82
    exponent = -1022;
  }
#line 186
  *expptr = exponent;
#line 187
  return (x);
}
}
#line 1 "printf-frexpl.o"
#pragma merger(0,"/tmp/cil-uah7zclW.i","-g,-O2")
#line 23 "printf-frexpl.h"
long double printf_frexpl(long double x , int *expptr ) ;
#line 104 "/usr/include/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) long double frexpl(long double __x , int *__exponent ) ;
#line 107
extern  __attribute__((__nothrow__)) long double ldexpl(long double __x , int __exponent ) ;
#line 64 "printf-frexp.c"
long double printf_frexpl(long double x , int *expptr ) 
{ int exponent ;
  fpucw_t oldcw ;
  fpucw_t _cw ;
  fpucw_t _ncw ;
  fpucw_t _ncw___0 ;

  {
#line 70
  __asm__  volatile   ("fnstcw %0": "=m" (_cw));
#line 70
  oldcw = _cw;
#line 70
  _ncw = (fpucw_t )(((int )oldcw & -769) | 768);
#line 70
  __asm__  volatile   ("fldcw %0": : "m" (_ncw));
#line 74
  x = frexpl(x, & exponent);
#line 76
  x += x;
#line 77
  exponent --;
#line 79
  if (exponent < -16382) {
#line 81
    x = ldexpl(x, exponent - -16382);
#line 82
    exponent = -16382;
  }
#line 184
  _ncw___0 = oldcw;
#line 184
  __asm__  volatile   ("fldcw %0": : "m" (_ncw___0));
#line 186
  *expptr = exponent;
#line 187
  return (x);
}
}
#line 1 "priv-set.o"
#pragma merger(0,"/tmp/cil-fQpo8Tdw.i","-g,-O2")
#line 1 "progname.o"
#pragma merger(0,"/tmp/cil-gaptO2Fa.i","-g,-O2")
#line 32 "progname.h"
char const   *program_name ;
#line 37
void set_program_name(char const   *argv0 ) ;
#line 55 "/usr/include/errno.h"
extern char *program_invocation_name ;
#line 55
extern char *program_invocation_short_name ;
#line 682 "/usr/include/stdio.h"
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 33 "progname.c"
char const   *program_name  =    (char const   *)((void *)0);
#line 38 "progname.c"
void set_program_name(char const   *argv0 ) 
{ char const   *slash ;
  char const   *base ;
  char *tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___3 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___16 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;

  {
#line 51
  if ((unsigned long )argv0 == (unsigned long )((void *)0)) {
#line 54
    fputs((char const   * __restrict  )"A NULL argv[0] was passed through an exec system call.\n",
          (FILE * __restrict  )stderr);
#line 56
    abort();
  }
#line 59
  tmp = strrchr(argv0, '/');
#line 59
  slash = (char const   *)tmp;
#line 60
  if ((unsigned long )slash != (unsigned long )((void *)0)) {
#line 60
    base = slash + 1;
  } else {
#line 60
    base = argv0;
  }
#line 61
  if (base - argv0 >= 7) {
#line 61
    if (0) {
#line 61
      if (0) {
#line 61
        __s1_len___0 = __builtin_strlen(base - 7);
#line 61
        __s2_len___0 = __builtin_strlen("/.libs/");
#line 61
        if (! ((size_t )((void const   *)((base - 7) + 1)) - (size_t )((void const   *)(base - 7)) == 1UL)) {
#line 61
          goto _L___2;
        } else
#line 61
        if (__s1_len___0 >= 4UL) {
          _L___2: 
#line 61
          if (! ((size_t )((void const   *)("/.libs/" + 1)) - (size_t )((void const   *)"/.libs/") == 1UL)) {
#line 61
            tmp___21 = 1;
          } else
#line 61
          if (__s2_len___0 >= 4UL) {
#line 61
            tmp___21 = 1;
          } else {
#line 61
            tmp___21 = 0;
          }
        } else {
#line 61
          tmp___21 = 0;
        }
#line 61
        if (tmp___21) {
#line 61
          tmp___16 = __builtin_strcmp(base - 7, "/.libs/");
#line 61
          tmp___20 = tmp___16;
        } else {
#line 61
          tmp___19 = __builtin_strcmp(base - 7, "/.libs/");
#line 61
          tmp___20 = tmp___19;
        }
      } else {
#line 61
        tmp___19 = __builtin_strcmp(base - 7, "/.libs/");
#line 61
        tmp___20 = tmp___19;
      }
#line 61
      tmp___23 = tmp___20;
    } else {
#line 61
      tmp___22 = strncmp(base - 7, "/.libs/", (size_t )7);
#line 61
      tmp___23 = tmp___22;
    }
#line 61
    if (tmp___23 == 0) {
#line 63
      argv0 = base;
#line 64
      if (0) {
#line 64
        if (0) {
#line 64
          __s1_len = __builtin_strlen(base);
#line 64
          __s2_len = __builtin_strlen("lt-");
#line 64
          if (! ((size_t )((void const   *)(base + 1)) - (size_t )((void const   *)base) == 1UL)) {
#line 64
            goto _L___0;
          } else
#line 64
          if (__s1_len >= 4UL) {
            _L___0: 
#line 64
            if (! ((size_t )((void const   *)("lt-" + 1)) - (size_t )((void const   *)"lt-") == 1UL)) {
#line 64
              tmp___8 = 1;
            } else
#line 64
            if (__s2_len >= 4UL) {
#line 64
              tmp___8 = 1;
            } else {
#line 64
              tmp___8 = 0;
            }
          } else {
#line 64
            tmp___8 = 0;
          }
#line 64
          if (tmp___8) {
#line 64
            tmp___3 = __builtin_strcmp(base, "lt-");
#line 64
            tmp___7 = tmp___3;
          } else {
#line 64
            tmp___6 = __builtin_strcmp(base, "lt-");
#line 64
            tmp___7 = tmp___6;
          }
        } else {
#line 64
          tmp___6 = __builtin_strcmp(base, "lt-");
#line 64
          tmp___7 = tmp___6;
        }
#line 64
        tmp___10 = tmp___7;
      } else {
#line 64
        tmp___9 = strncmp(base, "lt-", (size_t )3);
#line 64
        tmp___10 = tmp___9;
      }
#line 64
      if (tmp___10 == 0) {
#line 66
        argv0 = base + 3;
#line 70
        program_invocation_short_name = (char *)argv0;
      }
    }
  }
#line 84
  program_name = argv0;
#line 90
  program_invocation_name = (char *)argv0;
#line 92
  return;
}
}
#line 1 "propername.o"
#pragma merger(0,"/tmp/cil-6xF3RmjC.i","-g,-O2")
#line 92 "propername.h"
char const   *proper_name(char const   *name ) ;
#line 98
char const   *proper_name_utf8(char const   *name_ascii , char const   *name_utf8 ) ;
#line 33 "trim.h"
char *trim2(char const   *s , int how ) ;
#line 112 "/usr/include/wctype.h"
extern  __attribute__((__nothrow__)) int iswalnum(wint_t __wc ) ;
#line 69 "xstriconv.h"
char *xstr_iconv(char const   *src , char const   *from_codeset , char const   *to_codeset ) ;
#line 48 "propername.c"
static _Bool mbsstr_trimmed_wordbounded(char const   *string , char const   *sub ) 
{ char *tsub ;
  char *tmp ;
  _Bool found ;
  char const   *tsub_in_string ;
  char *tmp___0 ;
  mbui_iterator_t string_iter ;
  _Bool word_boundary_before ;
  _Bool word_boundary_after ;
  mbchar_t last_char_before_tsub ;
  int tmp___1 ;
  int tmp___2 ;
  mbui_iterator_t tsub_iter ;
  int tmp___3 ;
  int tmp___4 ;
  mbchar_t first_char_after_tsub ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  _Bool word_boundary_before___0 ;
  char const   *p ;
  _Bool word_boundary_after___0 ;
  unsigned short const   **tmp___8 ;
  size_t tmp___9 ;
  unsigned short const   **tmp___10 ;
  size_t tmp___11 ;

  {
#line 51
  tmp = trim2(sub, 2);
#line 51
  tsub = tmp;
#line 52
  found = (_Bool)0;
#line 54
  while ((int const   )*string != 0) {
#line 56
    tmp___0 = mbsstr(string, (char const   *)tsub);
#line 56
    tsub_in_string = (char const   *)tmp___0;
#line 57
    if ((unsigned long )tsub_in_string == (unsigned long )((void *)0)) {
#line 58
      break;
    } else {
#line 61
      tmp___11 = __ctype_get_mb_cur_max();
#line 61
      if (tmp___11 > 1UL) {
#line 67
        string_iter.cur.ptr = string;
#line 67
        string_iter.in_shift = (_Bool)0;
#line 67
        memset((void *)(& string_iter.state), '\000', sizeof(mbstate_t ));
#line 67
        string_iter.next_done = (_Bool)0;
#line 68
        word_boundary_before = (_Bool)1;
#line 69
        if ((unsigned long )string_iter.cur.ptr < (unsigned long )tsub_in_string) {
#line 72
          while (1) {
#line 74
            mbuiter_multi_next(& string_iter);
#line 74
            if (string_iter.cur.wc_valid) {
#line 74
              if (string_iter.cur.wc == 0) {
#line 74
                tmp___1 = 0;
              } else {
#line 74
                tmp___1 = 1;
              }
            } else {
#line 74
              tmp___1 = 1;
            }
#line 74
            if (! tmp___1) {
#line 75
              abort();
            }
#line 76
            last_char_before_tsub = string_iter.cur;
#line 77
            string_iter.cur.ptr += string_iter.cur.bytes;
#line 77
            string_iter.next_done = (_Bool)0;
#line 72
            if (! ((unsigned long )string_iter.cur.ptr < (unsigned long )tsub_in_string)) {
#line 72
              break;
            }
          }
#line 80
          if (last_char_before_tsub.wc_valid) {
#line 80
            tmp___2 = iswalnum((wint_t )last_char_before_tsub.wc);
#line 80
            if (tmp___2) {
#line 81
              word_boundary_before = (_Bool)0;
            }
          }
        }
#line 84
        string_iter.cur.ptr = tsub_in_string;
#line 84
        string_iter.in_shift = (_Bool)0;
#line 84
        memset((void *)(& string_iter.state), '\000', sizeof(mbstate_t ));
#line 84
        string_iter.next_done = (_Bool)0;
#line 88
        tsub_iter.cur.ptr = (char const   *)tsub;
#line 88
        tsub_iter.in_shift = (_Bool)0;
#line 88
        memset((void *)(& tsub_iter.state), '\000', sizeof(mbstate_t ));
#line 88
        tsub_iter.next_done = (_Bool)0;
#line 88
        while (1) {
#line 88
          mbuiter_multi_next(& tsub_iter);
#line 88
          if (tsub_iter.cur.wc_valid) {
#line 88
            if (tsub_iter.cur.wc == 0) {
#line 88
              tmp___4 = 0;
            } else {
#line 88
              tmp___4 = 1;
            }
          } else {
#line 88
            tmp___4 = 1;
          }
#line 88
          if (! tmp___4) {
#line 88
            break;
          }
#line 92
          mbuiter_multi_next(& string_iter);
#line 92
          if (string_iter.cur.wc_valid) {
#line 92
            if (string_iter.cur.wc == 0) {
#line 92
              tmp___3 = 0;
            } else {
#line 92
              tmp___3 = 1;
            }
          } else {
#line 92
            tmp___3 = 1;
          }
#line 92
          if (! tmp___3) {
#line 93
            abort();
          }
#line 94
          string_iter.cur.ptr += string_iter.cur.bytes;
#line 94
          string_iter.next_done = (_Bool)0;
#line 88
          tsub_iter.cur.ptr += tsub_iter.cur.bytes;
#line 88
          tsub_iter.next_done = (_Bool)0;
        }
#line 97
        word_boundary_after = (_Bool)1;
#line 98
        mbuiter_multi_next(& string_iter);
#line 98
        if (string_iter.cur.wc_valid) {
#line 98
          if (string_iter.cur.wc == 0) {
#line 98
            tmp___6 = 0;
          } else {
#line 98
            tmp___6 = 1;
          }
        } else {
#line 98
          tmp___6 = 1;
        }
#line 98
        if (tmp___6) {
#line 100
          first_char_after_tsub = string_iter.cur;
#line 101
          if (first_char_after_tsub.wc_valid) {
#line 101
            tmp___5 = iswalnum((wint_t )first_char_after_tsub.wc);
#line 101
            if (tmp___5) {
#line 102
              word_boundary_after = (_Bool)0;
            }
          }
        }
#line 105
        if (word_boundary_before) {
#line 105
          if (word_boundary_after) {
#line 107
            found = (_Bool)1;
#line 108
            break;
          }
        }
#line 111
        string_iter.cur.ptr = tsub_in_string;
#line 111
        string_iter.in_shift = (_Bool)0;
#line 111
        memset((void *)(& string_iter.state), '\000', sizeof(mbstate_t ));
#line 111
        string_iter.next_done = (_Bool)0;
#line 112
        mbuiter_multi_next(& string_iter);
#line 112
        if (string_iter.cur.wc_valid) {
#line 112
          if (string_iter.cur.wc == 0) {
#line 112
            tmp___7 = 0;
          } else {
#line 112
            tmp___7 = 1;
          }
        } else {
#line 112
          tmp___7 = 1;
        }
#line 112
        if (! tmp___7) {
#line 113
          break;
        }
#line 114
        string = tsub_in_string + string_iter.cur.bytes;
      } else {
#line 122
        word_boundary_before___0 = (_Bool)1;
#line 123
        if ((unsigned long )string < (unsigned long )tsub_in_string) {
#line 124
          tmp___8 = __ctype_b_loc();
#line 124
          if ((int const   )*(*tmp___8 + (int )((unsigned char )*(tsub_in_string + -1))) & 8) {
#line 125
            word_boundary_before___0 = (_Bool)0;
          }
        }
#line 127
        tmp___9 = strlen((char const   *)tsub);
#line 127
        p = tsub_in_string + tmp___9;
#line 128
        word_boundary_after___0 = (_Bool)1;
#line 129
        if ((int const   )*p != 0) {
#line 130
          tmp___10 = __ctype_b_loc();
#line 130
          if ((int const   )*(*tmp___10 + (int )((unsigned char )*p)) & 8) {
#line 131
            word_boundary_after___0 = (_Bool)0;
          }
        }
#line 133
        if (word_boundary_before___0) {
#line 133
          if (word_boundary_after___0) {
#line 135
            found = (_Bool)1;
#line 136
            break;
          }
        }
#line 139
        if ((int const   )*tsub_in_string == 0) {
#line 140
          break;
        }
#line 141
        string = tsub_in_string + 1;
      }
    }
  }
#line 145
  free((void *)tsub);
#line 146
  return (found);
}
}
#line 151 "propername.c"
char const   *proper_name(char const   *name ) 
{ char const   *translation ;
  char *tmp ;
  char *result ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  _Bool tmp___7 ;

  {
#line 155
  tmp = dcgettext((char const   *)((void *)0), name, 5);
#line 155
  translation = (char const   *)tmp;
#line 157
  if ((unsigned long )translation != (unsigned long )name) {
#line 160
    tmp___7 = mbsstr_trimmed_wordbounded(translation, name);
#line 160
    if (tmp___7) {
#line 161
      return (translation);
    } else {
#line 165
      if (sizeof(char ) == 1UL) {
#line 165
        tmp___0 = strlen(translation);
#line 165
        tmp___1 = strlen(name);
#line 165
        tmp___2 = xmalloc((((tmp___0 + 2UL) + tmp___1) + 1UL) + 1UL);
#line 165
        tmp___6 = tmp___2;
      } else {
#line 165
        tmp___3 = strlen(translation);
#line 165
        tmp___4 = strlen(name);
#line 165
        tmp___5 = xnmalloc((((tmp___3 + 2UL) + tmp___4) + 1UL) + 1UL, sizeof(char ));
#line 165
        tmp___6 = tmp___5;
      }
#line 165
      result = (char *)tmp___6;
#line 168
      sprintf((char * __restrict  )result, (char const   * __restrict  )"%s (%s)",
              translation, name);
#line 169
      return ((char const   *)result);
    }
  } else {
#line 173
    return (name);
  }
}
}
#line 181 "propername.c"
char const   *proper_name_utf8(char const   *name_ascii , char const   *name_utf8 ) 
{ char const   *translation ;
  char *tmp ;
  char const   *locale_code ;
  char const   *tmp___0 ;
  char *alloc_name_converted ;
  char *alloc_name_converted_translit ;
  char const   *name_converted ;
  char const   *name_converted_translit ;
  char const   *name ;
  char *converted_translit ;
  size_t len ;
  size_t tmp___1 ;
  char *locale_code_translit ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  char *tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  char *result ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  _Bool tmp___16 ;
  _Bool tmp___17 ;
  _Bool tmp___18 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___20 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;

  {
#line 185
  tmp = dcgettext((char const   *)((void *)0), name_ascii, 5);
#line 185
  translation = (char const   *)tmp;
#line 188
  tmp___0 = locale_charset();
#line 188
  locale_code = tmp___0;
#line 189
  alloc_name_converted = (char *)((void *)0);
#line 190
  alloc_name_converted_translit = (char *)((void *)0);
#line 191
  name_converted = (char const   *)((void *)0);
#line 192
  name_converted_translit = (char const   *)((void *)0);
#line 195
  tmp___7 = c_strcasecmp(locale_code, "UTF-8");
#line 195
  if (tmp___7 != 0) {
#line 198
    alloc_name_converted = xstr_iconv(name_utf8, "UTF-8", locale_code);
#line 198
    name_converted = (char const   *)alloc_name_converted;
#line 207
    tmp___1 = strlen(locale_code);
#line 207
    len = tmp___1;
#line 208
    if (sizeof(char ) == 1UL) {
#line 208
      tmp___2 = xmalloc((len + 10UL) + 1UL);
#line 208
      tmp___4 = tmp___2;
    } else {
#line 208
      tmp___3 = xnmalloc((len + 10UL) + 1UL, sizeof(char ));
#line 208
      tmp___4 = tmp___3;
    }
#line 208
    locale_code_translit = (char *)tmp___4;
#line 209
    memcpy((void * __restrict  )locale_code_translit, (void const   * __restrict  )locale_code,
           len);
#line 210
    memcpy((void * __restrict  )(locale_code_translit + len), (void const   * __restrict  )"//TRANSLIT",
           (size_t )11);
#line 212
    converted_translit = xstr_iconv(name_utf8, "UTF-8", (char const   *)locale_code_translit);
#line 215
    free((void *)locale_code_translit);
#line 217
    if ((unsigned long )converted_translit != (unsigned long )((void *)0)) {
#line 224
      tmp___6 = __builtin_strchr(converted_translit, '?');
#line 224
      if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
#line 225
        free((void *)converted_translit);
      } else {
#line 228
        alloc_name_converted_translit = converted_translit;
#line 228
        name_converted_translit = (char const   *)alloc_name_converted_translit;
      }
    }
  } else {
#line 237
    name_converted = name_utf8;
#line 238
    name_converted_translit = name_utf8;
  }
#line 242
  if ((unsigned long )name_converted != (unsigned long )((void *)0)) {
#line 242
    name = name_converted;
  } else {
#line 242
    if ((unsigned long )name_converted_translit != (unsigned long )((void *)0)) {
#line 242
      tmp___8 = name_converted_translit;
    } else {
#line 242
      tmp___8 = name_ascii;
    }
#line 242
    name = tmp___8;
  }
#line 249
  if (0) {
#line 249
    __s1_len = __builtin_strlen(translation);
#line 249
    __s2_len = __builtin_strlen(name_ascii);
#line 249
    if (! ((size_t )((void const   *)(translation + 1)) - (size_t )((void const   *)translation) == 1UL)) {
#line 249
      goto _L___3;
    } else
#line 249
    if (__s1_len >= 4UL) {
      _L___3: 
#line 249
      if (! ((size_t )((void const   *)(name_ascii + 1)) - (size_t )((void const   *)name_ascii) == 1UL)) {
#line 249
        tmp___25 = 1;
      } else
#line 249
      if (__s2_len >= 4UL) {
#line 249
        tmp___25 = 1;
      } else {
#line 249
        tmp___25 = 0;
      }
    } else {
#line 249
      tmp___25 = 0;
    }
#line 249
    if (tmp___25) {
#line 249
      tmp___20 = __builtin_strcmp(translation, name_ascii);
#line 249
      tmp___24 = tmp___20;
    } else {
#line 249
      tmp___23 = __builtin_strcmp(translation, name_ascii);
#line 249
      tmp___24 = tmp___23;
    }
  } else {
#line 249
    tmp___23 = __builtin_strcmp(translation, name_ascii);
#line 249
    tmp___24 = tmp___23;
  }
#line 249
  if (tmp___24 != 0) {
#line 252
    tmp___16 = mbsstr_trimmed_wordbounded(translation, name_ascii);
#line 252
    if (tmp___16) {
#line 252
      goto _L;
    } else
#line 252
    if ((unsigned long )name_converted != (unsigned long )((void *)0)) {
#line 252
      tmp___17 = mbsstr_trimmed_wordbounded(translation, name_converted);
#line 252
      if (tmp___17) {
#line 252
        goto _L;
      } else {
#line 252
        goto _L___1;
      }
    } else
    _L___1: 
#line 252
    if ((unsigned long )name_converted_translit != (unsigned long )((void *)0)) {
#line 252
      tmp___18 = mbsstr_trimmed_wordbounded(translation, name_converted_translit);
#line 252
      if (tmp___18) {
        _L: 
#line 258
        if ((unsigned long )alloc_name_converted != (unsigned long )((void *)0)) {
#line 259
          free((void *)alloc_name_converted);
        }
#line 260
        if ((unsigned long )alloc_name_converted_translit != (unsigned long )((void *)0)) {
#line 261
          free((void *)alloc_name_converted_translit);
        }
#line 262
        return (translation);
      } else {
#line 252
        goto _L___0;
      }
    } else {
      _L___0: 
#line 267
      if (sizeof(char ) == 1UL) {
#line 267
        tmp___9 = strlen(translation);
#line 267
        tmp___10 = strlen(name);
#line 267
        tmp___11 = xmalloc((((tmp___9 + 2UL) + tmp___10) + 1UL) + 1UL);
#line 267
        tmp___15 = tmp___11;
      } else {
#line 267
        tmp___12 = strlen(translation);
#line 267
        tmp___13 = strlen(name);
#line 267
        tmp___14 = xnmalloc((((tmp___12 + 2UL) + tmp___13) + 1UL) + 1UL, sizeof(char ));
#line 267
        tmp___15 = tmp___14;
      }
#line 267
      result = (char *)tmp___15;
#line 270
      sprintf((char * __restrict  )result, (char const   * __restrict  )"%s (%s)",
              translation, name);
#line 272
      if ((unsigned long )alloc_name_converted != (unsigned long )((void *)0)) {
#line 273
        free((void *)alloc_name_converted);
      }
#line 274
      if ((unsigned long )alloc_name_converted_translit != (unsigned long )((void *)0)) {
#line 275
        free((void *)alloc_name_converted_translit);
      }
#line 276
      return ((char const   *)result);
    }
  } else {
#line 281
    if ((unsigned long )alloc_name_converted != (unsigned long )((void *)0)) {
#line 281
      if ((unsigned long )alloc_name_converted != (unsigned long )name) {
#line 282
        free((void *)alloc_name_converted);
      }
    }
#line 283
    if ((unsigned long )alloc_name_converted_translit != (unsigned long )((void *)0)) {
#line 283
      if ((unsigned long )alloc_name_converted_translit != (unsigned long )name) {
#line 285
        free((void *)alloc_name_converted_translit);
      }
    }
#line 286
    return (name);
  }
}
}
#line 1 "quote.o"
#pragma merger(0,"/tmp/cil-8tfy6zmw.i","-g,-O2")
#line 28 "quote.c"
char const   *quote_n(int n , char const   *name ) 
{ char *tmp ;

  {
#line 31
  tmp = quotearg_n_style(n, (enum quoting_style )6, name);
#line 31
  return ((char const   *)tmp);
}
}
#line 36 "quote.c"
char const   *quote(char const   *name ) 
{ char const   *tmp ;

  {
#line 39
  tmp = quote_n(0, name);
#line 39
  return (tmp);
}
}
#line 1 "quotearg.o"
#pragma merger(0,"/tmp/cil-oyrYr0EJ.i","-g,-O2")
#line 234 "quotearg.h"
char const   * const  quoting_style_args[9] ;
#line 235
enum quoting_style  const  quoting_style_vals[8] ;
#line 245
struct quoting_options *clone_quoting_options(struct quoting_options *o ) ;
#line 248
enum quoting_style get_quoting_style(struct quoting_options *o ) ;
#line 252
void set_quoting_style(struct quoting_options *o , enum quoting_style s ) ;
#line 261
int set_char_quoting(struct quoting_options *o , char c , int i ) ;
#line 267
int set_quoting_flags(struct quoting_options *o , int i ) ;
#line 278
void set_custom_quoting(struct quoting_options *o , char const   *left_quote , char const   *right_quote ) ;
#line 293
size_t quotearg_buffer(char *buffer , size_t buffersize , char const   *arg , size_t argsize ,
                       struct quoting_options  const  *o ) ;
#line 300
char *quotearg_alloc(char const   *arg , size_t argsize , struct quoting_options  const  *o ) ;
#line 309
char *quotearg_alloc_mem(char const   *arg , size_t argsize , size_t *size , struct quoting_options  const  *o ) ;
#line 319
char *quotearg_n(int n , char const   *arg ) ;
#line 322
char *quotearg(char const   *arg ) ;
#line 327
char *quotearg_n_mem(int n , char const   *arg , size_t argsize ) ;
#line 330
char *quotearg_mem(char const   *arg , size_t argsize ) ;
#line 340
char *quotearg_n_style_mem(int n , enum quoting_style s , char const   *arg , size_t argsize ) ;
#line 344
char *quotearg_style(enum quoting_style s , char const   *arg ) ;
#line 347
char *quotearg_style_mem(enum quoting_style s , char const   *arg , size_t argsize ) ;
#line 352
char *quotearg_char(char const   *arg , char ch ) ;
#line 355
char *quotearg_char_mem(char const   *arg , size_t argsize , char ch ) ;
#line 361
char *quotearg_colon_mem(char const   *arg , size_t argsize ) ;
#line 367
char *quotearg_n_custom(int n , char const   *left_quote , char const   *right_quote ,
                        char const   *arg ) ;
#line 372
char *quotearg_n_custom_mem(int n , char const   *left_quote , char const   *right_quote ,
                            char const   *arg , size_t argsize ) ;
#line 377
char *quotearg_custom(char const   *left_quote , char const   *right_quote , char const   *arg ) ;
#line 382
char *quotearg_custom_mem(char const   *left_quote , char const   *right_quote , char const   *arg ,
                          size_t argsize ) ;
#line 387
void quotearg_free(void) ;
#line 221 "xalloc.h"
__inline static char *xcharalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 223
__inline static char *xcharalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 223 "xalloc.h"
__inline static char *xcharalloc(size_t n ) 
{ void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 226
  if (sizeof(char ) == 1UL) {
#line 226
    tmp = xmalloc(n);
#line 226
    tmp___1 = tmp;
  } else {
#line 226
    tmp___0 = xnmalloc(n, sizeof(char ));
#line 226
    tmp___1 = tmp___0;
  }
#line 226
  return ((char *)tmp___1);
}
}
#line 65 "quotearg.c"
char const   * const  quoting_style_args[9]  = 
#line 65 "quotearg.c"
  {      (char const   * const  )"literal",      (char const   * const  )"shell",      (char const   * const  )"shell-always",      (char const   * const  )"c", 
        (char const   * const  )"c-maybe",      (char const   * const  )"escape",      (char const   * const  )"locale",      (char const   * const  )"clocale", 
        (char const   * const  )0};
#line 79 "quotearg.c"
enum quoting_style  const  quoting_style_vals[8]  = 
#line 79
  {      (enum quoting_style  const  )0,      (enum quoting_style  const  )1,      (enum quoting_style  const  )2,      (enum quoting_style  const  )3, 
        (enum quoting_style  const  )4,      (enum quoting_style  const  )5,      (enum quoting_style  const  )6,      (enum quoting_style  const  )7};
#line 92 "quotearg.c"
static struct quoting_options default_quoting_options  ;
#line 97 "quotearg.c"
struct quoting_options *clone_quoting_options(struct quoting_options *o ) 
{ int e ;
  int *tmp ;
  struct quoting_options *p ;
  struct quoting_options *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;

  {
#line 100
  tmp = __errno_location();
#line 100
  e = *tmp;
#line 101
  if (o) {
#line 101
    tmp___0 = o;
  } else {
#line 101
    tmp___0 = & default_quoting_options;
  }
#line 101
  tmp___1 = xmemdup((void const   *)tmp___0, sizeof(*o));
#line 101
  p = (struct quoting_options *)tmp___1;
#line 103
  tmp___2 = __errno_location();
#line 103
  *tmp___2 = e;
#line 104
  return (p);
}
}
#line 108 "quotearg.c"
enum quoting_style get_quoting_style(struct quoting_options *o ) 
{ struct quoting_options *tmp ;

  {
#line 111
  if (o) {
#line 111
    tmp = o;
  } else {
#line 111
    tmp = & default_quoting_options;
  }
#line 111
  return (tmp->style);
}
}
#line 116 "quotearg.c"
void set_quoting_style(struct quoting_options *o , enum quoting_style s ) 
{ struct quoting_options *tmp ;

  {
#line 119
  if (o) {
#line 119
    tmp = o;
  } else {
#line 119
    tmp = & default_quoting_options;
  }
#line 119
  tmp->style = s;
#line 120
  return;
}
}
#line 127 "quotearg.c"
int set_char_quoting(struct quoting_options *o , char c , int i ) 
{ unsigned char uc ;
  unsigned int *p ;
  struct quoting_options *tmp ;
  int shift ;
  int r ;

  {
#line 130
  uc = (unsigned char )c;
#line 131
  if (o) {
#line 131
    tmp = o;
  } else {
#line 131
    tmp = & default_quoting_options;
  }
#line 131
  p = tmp->quote_these_too + (unsigned long )uc / (sizeof(int ) * 8UL);
#line 133
  shift = (int )((unsigned long )uc % (sizeof(int ) * 8UL));
#line 134
  r = (int )((*p >> shift) & 1U);
#line 135
  *p ^= (unsigned int )(((i & 1) ^ r) << shift);
#line 136
  return (r);
}
}
#line 143 "quotearg.c"
int set_quoting_flags(struct quoting_options *o , int i ) 
{ int r ;

  {
#line 147
  if (! o) {
#line 148
    o = & default_quoting_options;
  }
#line 149
  r = o->flags;
#line 150
  o->flags = i;
#line 151
  return (r);
}
}
#line 154 "quotearg.c"
void set_custom_quoting(struct quoting_options *o , char const   *left_quote , char const   *right_quote ) 
{ 

  {
#line 158
  if (! o) {
#line 159
    o = & default_quoting_options;
  }
#line 160
  o->style = (enum quoting_style )8;
#line 161
  if (! left_quote) {
#line 162
    abort();
  } else
#line 161
  if (! right_quote) {
#line 162
    abort();
  }
#line 163
  o->left_quote = left_quote;
#line 164
  o->right_quote = right_quote;
#line 165
  return;
}
}
#line 168 "quotearg.c"
static struct quoting_options quoting_options_from_style(enum quoting_style style ) 
{ struct quoting_options o ;

  {
#line 171
  o.style = (enum quoting_style )0;
#line 171
  o.flags = 0;
#line 171
  o.quote_these_too[0] = 0U;
#line 171
  o.quote_these_too[1] = 0U;
#line 171
  o.quote_these_too[2] = 0U;
#line 171
  o.quote_these_too[3] = 0U;
#line 171
  o.quote_these_too[4] = 0U;
#line 171
  o.quote_these_too[5] = 0U;
#line 171
  o.quote_these_too[6] = 0U;
#line 171
  o.quote_these_too[7] = 0U;
#line 171
  o.left_quote = (char const   *)0;
#line 171
  o.right_quote = (char const   *)0;
#line 172
  if ((unsigned int )style == 8U) {
#line 173
    abort();
  }
#line 174
  o.style = style;
#line 175
  return (o);
}
}
#line 180 "quotearg.c"
static char const   *gettext_quote(char const   *msgid , enum quoting_style s ) 
{ char const   *translation ;
  char *tmp ;

  {
#line 183
  tmp = dcgettext((char const   *)((void *)0), msgid, 5);
#line 183
  translation = (char const   *)tmp;
#line 184
  if ((unsigned long )translation == (unsigned long )msgid) {
#line 184
    if ((unsigned int )s == 7U) {
#line 185
      translation = "\"";
    }
  }
#line 186
  return (translation);
}
}
#line 202 "quotearg.c"
static size_t quotearg_buffer_restyled(char *buffer , size_t buffersize , char const   *arg ,
                                       size_t argsize , enum quoting_style quoting_style ,
                                       int flags , unsigned int const   *quote_these_too ,
                                       char const   *left_quote , char const   *right_quote ) 
{ size_t i ;
  size_t len ;
  char const   *quote_string ;
  size_t quote_string_len ;
  _Bool backslash_escapes ;
  _Bool unibyte_locale ;
  size_t tmp ;
  _Bool elide_outer_quotes ;
  unsigned char c ;
  unsigned char esc ;
  _Bool is_right_quote ;
  int tmp___0 ;
  int tmp___1 ;
  size_t m ;
  _Bool printable ;
  unsigned short const   **tmp___2 ;
  mbstate_t mbstate ;
  wchar_t w ;
  size_t bytes ;
  size_t tmp___3 ;
  size_t j ;
  int tmp___4 ;
  int tmp___5 ;
  size_t ilim ;
  int tmp___6 ;
  size_t tmp___7 ;

  {
#line 211
  len = (size_t )0;
#line 212
  quote_string = (char const   *)0;
#line 213
  quote_string_len = (size_t )0;
#line 214
  backslash_escapes = (_Bool)0;
#line 215
  tmp = __ctype_get_mb_cur_max();
#line 215
  unibyte_locale = (_Bool )(tmp == 1UL);
#line 216
  elide_outer_quotes = (_Bool )((flags & 2) != 0);
#line 227
  switch ((int )quoting_style) {
  case 4: 
#line 230
  quoting_style = (enum quoting_style )3;
#line 231
  elide_outer_quotes = (_Bool)1;
  case 3: 
#line 234
  if (! elide_outer_quotes) {
#line 235
    while (1) {
#line 235
      if (len < buffersize) {
#line 235
        *(buffer + len) = (char )'\"';
      }
#line 235
      len ++;
#line 235
      break;
    }
  }
#line 236
  backslash_escapes = (_Bool)1;
#line 237
  quote_string = "\"";
#line 238
  quote_string_len = (size_t )1;
#line 239
  break;
  case 5: 
#line 242
  backslash_escapes = (_Bool)1;
#line 243
  elide_outer_quotes = (_Bool)0;
#line 244
  break;
  case 6: 
  case 7: 
  case 8: 
#line 250
  if ((unsigned int )quoting_style != 8U) {
#line 271
    left_quote = gettext_quote("`", quoting_style);
#line 272
    right_quote = gettext_quote("\'", quoting_style);
  }
#line 274
  if (! elide_outer_quotes) {
#line 275
    quote_string = left_quote;
#line 275
    while (*quote_string) {
#line 276
      while (1) {
#line 276
        if (len < buffersize) {
#line 276
          *(buffer + len) = (char )*quote_string;
        }
#line 276
        len ++;
#line 276
        break;
      }
#line 275
      quote_string ++;
    }
  }
#line 277
  backslash_escapes = (_Bool)1;
#line 278
  quote_string = right_quote;
#line 279
  quote_string_len = strlen(quote_string);
#line 281
  break;
  case 1: 
#line 284
  quoting_style = (enum quoting_style )2;
#line 285
  elide_outer_quotes = (_Bool)1;
  case 2: 
#line 288
  if (! elide_outer_quotes) {
#line 289
    while (1) {
#line 289
      if (len < buffersize) {
#line 289
        *(buffer + len) = (char )'\'';
      }
#line 289
      len ++;
#line 289
      break;
    }
  }
#line 290
  quote_string = "\'";
#line 291
  quote_string_len = (size_t )1;
#line 292
  break;
  case 0: 
#line 295
  elide_outer_quotes = (_Bool)0;
#line 296
  break;
  default: 
#line 299
  abort();
  }
#line 302
  i = (size_t )0;
#line 302
  while (1) {
#line 302
    if (argsize == 0xffffffffffffffffUL) {
#line 302
      tmp___6 = (int const   )*(arg + i) == 0;
    } else {
#line 302
      tmp___6 = i == argsize;
    }
#line 302
    if (tmp___6) {
#line 302
      break;
    }
#line 306
    is_right_quote = (_Bool)0;
#line 308
    if (backslash_escapes) {
#line 308
      if (quote_string_len) {
#line 308
        if (i + quote_string_len <= argsize) {
#line 308
          tmp___0 = memcmp((void const   *)(arg + i), (void const   *)quote_string,
                           quote_string_len);
#line 308
          if (tmp___0 == 0) {
#line 313
            if (elide_outer_quotes) {
#line 314
              goto force_outer_quoting_style;
            }
#line 315
            is_right_quote = (_Bool)1;
          }
        }
      }
    }
#line 318
    c = (unsigned char )*(arg + i);
#line 319
    switch ((int )c) {
    case 0: 
#line 322
    if (backslash_escapes) {
#line 324
      if (elide_outer_quotes) {
#line 325
        goto force_outer_quoting_style;
      }
#line 326
      while (1) {
#line 326
        if (len < buffersize) {
#line 326
          *(buffer + len) = (char )'\\';
        }
#line 326
        len ++;
#line 326
        break;
      }
#line 332
      if (i + 1UL < argsize) {
#line 332
        if (48 <= (int )*(arg + (i + 1UL))) {
#line 332
          if ((int const   )*(arg + (i + 1UL)) <= 57) {
#line 334
            while (1) {
#line 334
              if (len < buffersize) {
#line 334
                *(buffer + len) = (char )'0';
              }
#line 334
              len ++;
#line 334
              break;
            }
#line 335
            while (1) {
#line 335
              if (len < buffersize) {
#line 335
                *(buffer + len) = (char )'0';
              }
#line 335
              len ++;
#line 335
              break;
            }
          }
        }
      }
#line 337
      c = (unsigned char )'0';
    } else
#line 343
    if (flags & 1) {
#line 344
      goto __Cont;
    }
#line 345
    break;
    case 63: 
#line 348
    switch ((int )quoting_style) {
    case 2: 
#line 351
    if (elide_outer_quotes) {
#line 352
      goto force_outer_quoting_style;
    }
#line 353
    break;
    case 3: 
#line 356
    if (flags & 4) {
#line 356
      if (i + 2UL < argsize) {
#line 356
        if ((int const   )*(arg + (i + 1UL)) == 63) {
#line 358
          switch ((int )*(arg + (i + 2UL))) {
          case 33: 
          case 39: 
          case 40: 
          case 41: 
          case 45: 
          case 47: 
          case 60: 
          case 61: 
          case 62: 
#line 365
          if (elide_outer_quotes) {
#line 366
            goto force_outer_quoting_style;
          }
#line 367
          c = (unsigned char )*(arg + (i + 2UL));
#line 368
          i += 2UL;
#line 369
          while (1) {
#line 369
            if (len < buffersize) {
#line 369
              *(buffer + len) = (char )'?';
            }
#line 369
            len ++;
#line 369
            break;
          }
#line 370
          while (1) {
#line 370
            if (len < buffersize) {
#line 370
              *(buffer + len) = (char )'\"';
            }
#line 370
            len ++;
#line 370
            break;
          }
#line 371
          while (1) {
#line 371
            if (len < buffersize) {
#line 371
              *(buffer + len) = (char )'\"';
            }
#line 371
            len ++;
#line 371
            break;
          }
#line 372
          while (1) {
#line 372
            if (len < buffersize) {
#line 372
              *(buffer + len) = (char )'?';
            }
#line 372
            len ++;
#line 372
            break;
          }
#line 373
          break;
          default: 
#line 376
          break;
          }
        }
      }
    }
#line 378
    break;
    default: 
#line 381
    break;
    }
#line 383
    break;
    case 7: 
#line 385
    esc = (unsigned char )'a';
#line 385
    goto c_escape;
    case 8: 
#line 386
    esc = (unsigned char )'b';
#line 386
    goto c_escape;
    case 12: 
#line 387
    esc = (unsigned char )'f';
#line 387
    goto c_escape;
    case 10: 
#line 388
    esc = (unsigned char )'n';
#line 388
    goto c_and_shell_escape;
    case 13: 
#line 389
    esc = (unsigned char )'r';
#line 389
    goto c_and_shell_escape;
    case 9: 
#line 390
    esc = (unsigned char )'t';
#line 390
    goto c_and_shell_escape;
    case 11: 
#line 391
    esc = (unsigned char )'v';
#line 391
    goto c_escape;
    case 92: 
#line 392
    esc = c;
#line 395
    if (backslash_escapes) {
#line 395
      if (elide_outer_quotes) {
#line 395
        if (quote_string_len) {
#line 396
          goto store_c;
        }
      }
    }
    c_and_shell_escape: 
#line 399
    if ((unsigned int )quoting_style == 2U) {
#line 399
      if (elide_outer_quotes) {
#line 401
        goto force_outer_quoting_style;
      }
    }
    c_escape: 
#line 404
    if (backslash_escapes) {
#line 406
      c = esc;
#line 407
      goto store_escape;
    }
#line 409
    break;
    case 123: 
    case 125: 
#line 412
    if (argsize == 0xffffffffffffffffUL) {
#line 412
      tmp___1 = (int const   )*(arg + 1) == 0;
    } else {
#line 412
      tmp___1 = argsize == 1UL;
    }
#line 412
    if (! tmp___1) {
#line 413
      break;
    }
    case 35: 
    case 126: 
#line 416
    if (i != 0UL) {
#line 417
      break;
    }
    case 32: 
    case 33: 
    case 34: 
    case 36: 
    case 38: 
    case 40: 
    case 41: 
    case 42: 
    case 59: 
    case 60: 
    case 61: 
    case 62: 
    case 91: 
    case 94: 
    case 96: 
    case 124: 
#line 432
    if ((unsigned int )quoting_style == 2U) {
#line 432
      if (elide_outer_quotes) {
#line 434
        goto force_outer_quoting_style;
      }
    }
#line 435
    break;
    case 39: 
#line 438
    if ((unsigned int )quoting_style == 2U) {
#line 440
      if (elide_outer_quotes) {
#line 441
        goto force_outer_quoting_style;
      }
#line 442
      while (1) {
#line 442
        if (len < buffersize) {
#line 442
          *(buffer + len) = (char )'\'';
        }
#line 442
        len ++;
#line 442
        break;
      }
#line 443
      while (1) {
#line 443
        if (len < buffersize) {
#line 443
          *(buffer + len) = (char )'\\';
        }
#line 443
        len ++;
#line 443
        break;
      }
#line 444
      while (1) {
#line 444
        if (len < buffersize) {
#line 444
          *(buffer + len) = (char )'\'';
        }
#line 444
        len ++;
#line 444
        break;
      }
    }
#line 446
    break;
    case 37: 
    case 43: 
    case 44: 
    case 45: 
    case 46: 
    case 47: 
    case 48: 
    case 49: 
    case 50: 
    case 51: 
    case 52: 
    case 53: 
    case 54: 
    case 55: 
    case 56: 
    case 57: 
    case 58: 
    case 65: 
    case 66: 
    case 67: 
    case 68: 
    case 69: 
    case 70: 
    case 71: 
    case 72: 
    case 73: 
    case 74: 
    case 75: 
    case 76: 
    case 77: 
    case 78: 
    case 79: 
    case 80: 
    case 81: 
    case 82: 
    case 83: 
    case 84: 
    case 85: 
    case 86: 
    case 87: 
    case 88: 
    case 89: 
    case 90: 
    case 93: 
    case 95: 
    case 97: 
    case 98: 
    case 99: 
    case 100: 
    case 101: 
    case 102: 
    case 103: 
    case 104: 
    case 105: 
    case 106: 
    case 107: 
    case 108: 
    case 109: 
    case 110: 
    case 111: 
    case 112: 
    case 113: 
    case 114: 
    case 115: 
    case 116: 
    case 117: 
    case 118: 
    case 119: 
    case 120: 
    case 121: 
    case 122: 
#line 470
    break;
    default: 
#line 484
    if (unibyte_locale) {
#line 486
      m = (size_t )1;
#line 487
      tmp___2 = __ctype_b_loc();
#line 487
      printable = (_Bool )(((int const   )*(*tmp___2 + (int )c) & 16384) != 0);
    } else {
#line 492
      memset((void *)(& mbstate), 0, sizeof(mbstate));
#line 494
      m = (size_t )0;
#line 495
      printable = (_Bool)1;
#line 496
      if (argsize == 0xffffffffffffffffUL) {
#line 497
        argsize = strlen(arg);
      }
#line 499
      while (1) {
#line 502
        tmp___3 = mbrtowc((wchar_t * __restrict  )(& w), (char const   * __restrict  )(arg + (i + m)),
                          argsize - (i + m), & mbstate);
#line 502
        bytes = tmp___3;
#line 504
        if (bytes == 0UL) {
#line 505
          break;
        } else
#line 506
        if (bytes == 0xffffffffffffffffUL) {
#line 508
          printable = (_Bool)0;
#line 509
          break;
        } else
#line 511
        if (bytes == 0xfffffffffffffffeUL) {
#line 513
          printable = (_Bool)0;
#line 514
          while (1) {
#line 514
            if (i + m < argsize) {
#line 514
              if (! *(arg + (i + m))) {
#line 514
                break;
              }
            } else {
#line 514
              break;
            }
#line 515
            m ++;
          }
#line 516
          break;
        } else {
#line 524
          if (elide_outer_quotes) {
#line 524
            if ((unsigned int )quoting_style == 2U) {
#line 528
              j = (size_t )1;
#line 528
              while (j < bytes) {
#line 529
                switch ((int )*(arg + ((i + m) + j))) {
                case 91: 
                case 92: 
                case 94: 
                case 96: 
                case 124: 
#line 533
                goto force_outer_quoting_style;
                default: 
#line 536
                break;
                }
#line 528
                j ++;
              }
            }
          }
#line 540
          tmp___4 = iswprint((wint_t )w);
#line 540
          if (! tmp___4) {
#line 541
            printable = (_Bool)0;
          }
#line 542
          m += bytes;
        }
#line 499
        tmp___5 = mbsinit((mbstate_t const   *)(& mbstate));
#line 499
        if (tmp___5) {
#line 499
          break;
        }
      }
    }
#line 548
    if (1UL < m) {
#line 548
      goto _L___0;
    } else
#line 548
    if (backslash_escapes) {
#line 548
      if (! printable) {
        _L___0: 
#line 552
        ilim = i + m;
#line 554
        while (1) {
#line 556
          if (backslash_escapes) {
#line 556
            if (! printable) {
#line 558
              if (elide_outer_quotes) {
#line 559
                goto force_outer_quoting_style;
              }
#line 560
              while (1) {
#line 560
                if (len < buffersize) {
#line 560
                  *(buffer + len) = (char )'\\';
                }
#line 560
                len ++;
#line 560
                break;
              }
#line 561
              while (1) {
#line 561
                if (len < buffersize) {
#line 561
                  *(buffer + len) = (char )(48 + ((int )c >> 6));
                }
#line 561
                len ++;
#line 561
                break;
              }
#line 562
              while (1) {
#line 562
                if (len < buffersize) {
#line 562
                  *(buffer + len) = (char )(48 + (((int )c >> 3) & 7));
                }
#line 562
                len ++;
#line 562
                break;
              }
#line 563
              c = (unsigned char )(48 + ((int )c & 7));
            } else {
#line 556
              goto _L;
            }
          } else
          _L: 
#line 565
          if (is_right_quote) {
#line 567
            while (1) {
#line 567
              if (len < buffersize) {
#line 567
                *(buffer + len) = (char )'\\';
              }
#line 567
              len ++;
#line 567
              break;
            }
#line 568
            is_right_quote = (_Bool)0;
          }
#line 570
          if (ilim <= i + 1UL) {
#line 571
            break;
          }
#line 572
          while (1) {
#line 572
            if (len < buffersize) {
#line 572
              *(buffer + len) = (char )c;
            }
#line 572
            len ++;
#line 572
            break;
          }
#line 573
          i ++;
#line 573
          c = (unsigned char )*(arg + i);
        }
#line 576
        goto store_c;
      }
    }
    }
#line 581
    if (backslash_escapes) {
#line 581
      goto _L___3;
    } else
#line 581
    if (elide_outer_quotes) {
      _L___3: 
#line 581
      if (quote_these_too) {
#line 581
        if (! (*(quote_these_too + (unsigned long )c / (sizeof(int ) * 8UL)) & (unsigned int const   )(1 << (unsigned long )c % (sizeof(int ) * 8UL)))) {
#line 581
          goto _L___2;
        }
      } else {
#line 581
        goto _L___2;
      }
    } else
    _L___2: 
#line 581
    if (! is_right_quote) {
#line 585
      goto store_c;
    }
    store_escape: 
#line 588
    if (elide_outer_quotes) {
#line 589
      goto force_outer_quoting_style;
    }
#line 590
    while (1) {
#line 590
      if (len < buffersize) {
#line 590
        *(buffer + len) = (char )'\\';
      }
#line 590
      len ++;
#line 590
      break;
    }
    store_c: 
#line 593
    while (1) {
#line 593
      if (len < buffersize) {
#line 593
        *(buffer + len) = (char )c;
      }
#line 593
      len ++;
#line 593
      break;
    }
    __Cont: 
#line 302
    i ++;
  }
#line 596
  if (len == 0UL) {
#line 596
    if ((unsigned int )quoting_style == 2U) {
#line 596
      if (elide_outer_quotes) {
#line 598
        goto force_outer_quoting_style;
      }
    }
  }
#line 600
  if (quote_string) {
#line 600
    if (! elide_outer_quotes) {
#line 601
      while (*quote_string) {
#line 602
        while (1) {
#line 602
          if (len < buffersize) {
#line 602
            *(buffer + len) = (char )*quote_string;
          }
#line 602
          len ++;
#line 602
          break;
        }
#line 601
        quote_string ++;
      }
    }
  }
#line 604
  if (len < buffersize) {
#line 605
    *(buffer + len) = (char )'\000';
  }
#line 606
  return (len);
  force_outer_quoting_style: 
#line 611
  tmp___7 = quotearg_buffer_restyled(buffer, buffersize, arg, argsize, quoting_style,
                                     flags & -3, (unsigned int const   *)((void *)0),
                                     left_quote, right_quote);
#line 611
  return (tmp___7);
}
}
#line 626 "quotearg.c"
size_t quotearg_buffer(char *buffer , size_t buffersize , char const   *arg , size_t argsize ,
                       struct quoting_options  const  *o ) 
{ struct quoting_options  const  *p ;
  struct quoting_options  const  *tmp ;
  int e ;
  int *tmp___0 ;
  size_t r ;
  size_t tmp___1 ;
  int *tmp___2 ;

  {
#line 631
  if (o) {
#line 631
    tmp = o;
  } else {
#line 631
    tmp = (struct quoting_options  const  *)(& default_quoting_options);
  }
#line 631
  p = tmp;
#line 632
  tmp___0 = __errno_location();
#line 632
  e = *tmp___0;
#line 633
  tmp___1 = quotearg_buffer_restyled(buffer, buffersize, arg, argsize, (enum quoting_style )p->style,
                                     (int )p->flags, (unsigned int const   *)(p->quote_these_too),
                                     (char const   *)p->left_quote, (char const   *)p->right_quote);
#line 633
  r = tmp___1;
#line 636
  tmp___2 = __errno_location();
#line 636
  *tmp___2 = e;
#line 637
  return (r);
}
}
#line 641 "quotearg.c"
char *quotearg_alloc(char const   *arg , size_t argsize , struct quoting_options  const  *o ) 
{ char *tmp ;

  {
#line 645
  tmp = quotearg_alloc_mem(arg, argsize, (size_t *)((void *)0), o);
#line 645
  return (tmp);
}
}
#line 654 "quotearg.c"
char *quotearg_alloc_mem(char const   *arg , size_t argsize , size_t *size , struct quoting_options  const  *o ) 
{ struct quoting_options  const  *p ;
  struct quoting_options  const  *tmp ;
  int e ;
  int *tmp___0 ;
  int flags ;
  int tmp___1 ;
  size_t bufsize___0 ;
  size_t tmp___2 ;
  char *buf___1 ;
  char *tmp___3 ;
  int *tmp___4 ;

  {
#line 658
  if (o) {
#line 658
    tmp = o;
  } else {
#line 658
    tmp = (struct quoting_options  const  *)(& default_quoting_options);
  }
#line 658
  p = tmp;
#line 659
  tmp___0 = __errno_location();
#line 659
  e = *tmp___0;
#line 661
  if (size) {
#line 661
    tmp___1 = 0;
  } else {
#line 661
    tmp___1 = 1;
  }
#line 661
  flags = (int )(p->flags | (int const   )tmp___1);
#line 662
  tmp___2 = quotearg_buffer_restyled((char *)0, (size_t )0, arg, argsize, (enum quoting_style )p->style,
                                     flags, (unsigned int const   *)(p->quote_these_too),
                                     (char const   *)p->left_quote, (char const   *)p->right_quote);
#line 662
  bufsize___0 = tmp___2 + 1UL;
#line 666
  tmp___3 = xcharalloc(bufsize___0);
#line 666
  buf___1 = tmp___3;
#line 667
  quotearg_buffer_restyled(buf___1, bufsize___0, arg, argsize, (enum quoting_style )p->style,
                           flags, (unsigned int const   *)(p->quote_these_too), (char const   *)p->left_quote,
                           (char const   *)p->right_quote);
#line 670
  tmp___4 = __errno_location();
#line 670
  *tmp___4 = e;
#line 671
  if (size) {
#line 672
    *size = bufsize___0 - 1UL;
  }
#line 673
  return (buf___1);
}
}
#line 685 "quotearg.c"
static char slot0[256]  ;
#line 686 "quotearg.c"
static unsigned int nslots  =    1U;
#line 687 "quotearg.c"
static struct slotvec slotvec0  =    {sizeof(slot0), slot0};
#line 688 "quotearg.c"
static struct slotvec *slotvec  =    & slotvec0;
#line 690 "quotearg.c"
void quotearg_free(void) 
{ struct slotvec *sv ;
  unsigned int i ;

  {
#line 693
  sv = slotvec;
#line 695
  i = 1U;
#line 695
  while (i < nslots) {
#line 696
    free((void *)(sv + i)->val);
#line 695
    i ++;
  }
#line 697
  if ((unsigned long )(sv + 0)->val != (unsigned long )(slot0)) {
#line 699
    free((void *)(sv + 0)->val);
#line 700
    slotvec0.size = sizeof(slot0);
#line 701
    slotvec0.val = slot0;
  }
#line 703
  if ((unsigned long )sv != (unsigned long )(& slotvec0)) {
#line 705
    free((void *)sv);
#line 706
    slotvec = & slotvec0;
  }
#line 708
  nslots = 1U;
#line 709
  return;
}
}
#line 719 "quotearg.c"
static char *quotearg_n_options(int n , char const   *arg , size_t argsize , struct quoting_options  const  *options ) 
{ int e ;
  int *tmp ;
  unsigned int n0 ;
  struct slotvec *sv ;
  size_t n1 ;
  _Bool preallocated ;
  int tmp___0 ;
  struct slotvec *tmp___1 ;
  void *tmp___2 ;
  size_t size ;
  char *val ;
  int flags ;
  size_t qsize ;
  size_t tmp___3 ;
  int *tmp___4 ;

  {
#line 723
  tmp = __errno_location();
#line 723
  e = *tmp;
#line 725
  n0 = (unsigned int )n;
#line 726
  sv = slotvec;
#line 728
  if (n < 0) {
#line 729
    abort();
  }
#line 731
  if (nslots <= n0) {
#line 738
    n1 = (size_t )(n0 + 1U);
#line 739
    preallocated = (_Bool )((unsigned long )sv == (unsigned long )(& slotvec0));
#line 741
    if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 741
      tmp___0 = -1;
    } else {
#line 741
      tmp___0 = -2;
    }
#line 741
    if ((size_t )tmp___0 / sizeof(*sv) < n1) {
#line 742
      xalloc_die();
    }
#line 744
    if (preallocated) {
#line 744
      tmp___1 = (struct slotvec *)((void *)0);
    } else {
#line 744
      tmp___1 = sv;
    }
#line 744
    tmp___2 = xrealloc((void *)tmp___1, n1 * sizeof(*sv));
#line 744
    sv = (struct slotvec *)tmp___2;
#line 744
    slotvec = sv;
#line 745
    if (preallocated) {
#line 746
      *sv = slotvec0;
    }
#line 747
    memset((void *)(sv + nslots), 0, (n1 - (size_t )nslots) * sizeof(*sv));
#line 748
    nslots = (unsigned int )n1;
  }
#line 752
  size = (sv + n)->size;
#line 753
  val = (sv + n)->val;
#line 755
  flags = (int )(options->flags | 1);
#line 756
  tmp___3 = quotearg_buffer_restyled(val, size, arg, argsize, (enum quoting_style )options->style,
                                     flags, (unsigned int const   *)(options->quote_these_too),
                                     (char const   *)options->left_quote, (char const   *)options->right_quote);
#line 756
  qsize = tmp___3;
#line 762
  if (size <= qsize) {
#line 764
    size = qsize + 1UL;
#line 764
    (sv + n)->size = size;
#line 765
    if ((unsigned long )val != (unsigned long )(slot0)) {
#line 766
      free((void *)val);
    }
#line 767
    val = xcharalloc(size);
#line 767
    (sv + n)->val = val;
#line 768
    quotearg_buffer_restyled(val, size, arg, argsize, (enum quoting_style )options->style,
                             flags, (unsigned int const   *)(options->quote_these_too),
                             (char const   *)options->left_quote, (char const   *)options->right_quote);
  }
#line 774
  tmp___4 = __errno_location();
#line 774
  *tmp___4 = e;
#line 775
  return (val);
}
}
#line 779 "quotearg.c"
char *quotearg_n(int n , char const   *arg ) 
{ char *tmp ;

  {
#line 782
  tmp = quotearg_n_options(n, arg, (size_t )-1, (struct quoting_options  const  *)(& default_quoting_options));
#line 782
  return (tmp);
}
}
#line 785 "quotearg.c"
char *quotearg_n_mem(int n , char const   *arg , size_t argsize ) 
{ char *tmp ;

  {
#line 788
  tmp = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& default_quoting_options));
#line 788
  return (tmp);
}
}
#line 791 "quotearg.c"
char *quotearg(char const   *arg ) 
{ char *tmp ;

  {
#line 794
  tmp = quotearg_n(0, arg);
#line 794
  return (tmp);
}
}
#line 797 "quotearg.c"
char *quotearg_mem(char const   *arg , size_t argsize ) 
{ char *tmp ;

  {
#line 800
  tmp = quotearg_n_mem(0, arg, argsize);
#line 800
  return (tmp);
}
}
#line 803 "quotearg.c"
char *quotearg_n_style(int n , enum quoting_style s , char const   *arg ) 
{ struct quoting_options o ;
  struct quoting_options tmp ;
  char *tmp___0 ;

  {
#line 806
  tmp = quoting_options_from_style(s);
#line 806
  o = tmp;
#line 807
  tmp___0 = quotearg_n_options(n, arg, (size_t )-1, (struct quoting_options  const  *)(& o));
#line 807
  return (tmp___0);
}
}
#line 810 "quotearg.c"
char *quotearg_n_style_mem(int n , enum quoting_style s , char const   *arg , size_t argsize ) 
{ struct quoting_options o ;
  struct quoting_options tmp ;
  char *tmp___0 ;

  {
#line 814
  tmp = quoting_options_from_style(s);
#line 814
  o = tmp;
#line 815
  tmp___0 = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& o));
#line 815
  return (tmp___0);
}
}
#line 818 "quotearg.c"
char *quotearg_style(enum quoting_style s , char const   *arg ) 
{ char *tmp ;

  {
#line 821
  tmp = quotearg_n_style(0, s, arg);
#line 821
  return (tmp);
}
}
#line 824 "quotearg.c"
char *quotearg_style_mem(enum quoting_style s , char const   *arg , size_t argsize ) 
{ char *tmp ;

  {
#line 827
  tmp = quotearg_n_style_mem(0, s, arg, argsize);
#line 827
  return (tmp);
}
}
#line 830 "quotearg.c"
char *quotearg_char_mem(char const   *arg , size_t argsize , char ch ) 
{ struct quoting_options options ;
  char *tmp ;

  {
#line 834
  options = default_quoting_options;
#line 835
  set_char_quoting(& options, ch, 1);
#line 836
  tmp = quotearg_n_options(0, arg, argsize, (struct quoting_options  const  *)(& options));
#line 836
  return (tmp);
}
}
#line 839 "quotearg.c"
char *quotearg_char(char const   *arg , char ch ) 
{ char *tmp ;

  {
#line 842
  tmp = quotearg_char_mem(arg, (size_t )-1, ch);
#line 842
  return (tmp);
}
}
#line 845 "quotearg.c"
char *quotearg_colon(char const   *arg ) 
{ char *tmp ;

  {
#line 848
  tmp = quotearg_char(arg, (char )':');
#line 848
  return (tmp);
}
}
#line 851 "quotearg.c"
char *quotearg_colon_mem(char const   *arg , size_t argsize ) 
{ char *tmp ;

  {
#line 854
  tmp = quotearg_char_mem(arg, argsize, (char )':');
#line 854
  return (tmp);
}
}
#line 857 "quotearg.c"
char *quotearg_n_custom(int n , char const   *left_quote , char const   *right_quote ,
                        char const   *arg ) 
{ char *tmp ;

  {
#line 861
  tmp = quotearg_n_custom_mem(n, left_quote, right_quote, arg, (size_t )-1);
#line 861
  return (tmp);
}
}
#line 865 "quotearg.c"
char *quotearg_n_custom_mem(int n , char const   *left_quote , char const   *right_quote ,
                            char const   *arg , size_t argsize ) 
{ struct quoting_options o ;
  char *tmp ;

  {
#line 870
  o = default_quoting_options;
#line 871
  set_custom_quoting(& o, left_quote, right_quote);
#line 872
  tmp = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& o));
#line 872
  return (tmp);
}
}
#line 875 "quotearg.c"
char *quotearg_custom(char const   *left_quote , char const   *right_quote , char const   *arg ) 
{ char *tmp ;

  {
#line 879
  tmp = quotearg_n_custom(0, left_quote, right_quote, arg);
#line 879
  return (tmp);
}
}
#line 882 "quotearg.c"
char *quotearg_custom_mem(char const   *left_quote , char const   *right_quote , char const   *arg ,
                          size_t argsize ) 
{ char *tmp ;

  {
#line 886
  tmp = quotearg_n_custom_mem(0, left_quote, right_quote, arg, argsize);
#line 886
  return (tmp);
}
}
#line 1 "randint.o"
#pragma merger(0,"/tmp/cil-7HWZ0uWi.i","-g,-O2")
#line 27 "randread.h"
struct randread_source *randread_new(char const   *name , size_t bytes_bound ) ;
#line 28
void randread(struct randread_source *s , void *buf___1 , size_t size ) ;
#line 31
int randread_free(struct randread_source *s ) ;
#line 35 "randint.h"
struct randint_source *randint_new(struct randread_source *source ) ;
#line 36
struct randint_source *randint_all_new(char const   *name , size_t bytes_bound ) ;
#line 37
struct randread_source *randint_get_source(struct randint_source  const  *s )  __attribute__((__pure__)) ;
#line 39
randint randint_genmax(struct randint_source *s , randint genmax ) ;
#line 49
void randint_free(struct randint_source *s ) ;
#line 50
int randint_all_free(struct randint_source *s ) ;
#line 70 "randint.c"
struct randint_source *randint_new(struct randread_source *source ) 
{ struct randint_source *s ;
  void *tmp ;
  randint tmp___0 ;

  {
#line 73
  tmp = xmalloc(sizeof(*s));
#line 73
  s = (struct randint_source *)tmp;
#line 74
  s->source = source;
#line 75
  tmp___0 = (randint )0;
#line 75
  s->randmax = tmp___0;
#line 75
  s->randnum = tmp___0;
#line 76
  return (s);
}
}
#line 83 "randint.c"
struct randint_source *randint_all_new(char const   *name , size_t bytes_bound ) 
{ struct randread_source *source ;
  struct randread_source *tmp ;
  struct randint_source *tmp___0 ;
  struct randint_source *tmp___1 ;

  {
#line 86
  tmp = randread_new(name, bytes_bound);
#line 86
  source = tmp;
#line 87
  if (source) {
#line 87
    tmp___0 = randint_new(source);
#line 87
    tmp___1 = tmp___0;
  } else {
#line 87
    tmp___1 = (struct randint_source *)((void *)0);
  }
#line 87
  return (tmp___1);
}
}
#line 92
struct randread_source *randint_get_source(struct randint_source  const  *s )  __attribute__((__pure__)) ;
#line 92 "randint.c"
struct randread_source *randint_get_source(struct randint_source  const  *s ) 
{ 

  {
#line 95
  return ((struct randread_source *)s->source);
}
}
#line 104 "randint.c"
__inline static randint shift_left(randint x ) 
{ 

  {
#line 106
  return (x << 8);
}
}
#line 120 "randint.c"
randint randint_genmax(struct randint_source *s , randint genmax ) 
{ struct randread_source *source ;
  randint randnum ;
  randint randmax ;
  randint choices ;
  size_t i ;
  randint rmax ;
  unsigned char buf___1[sizeof(randnum)] ;
  randint tmp ;
  randint tmp___0 ;
  randint tmp___1 ;
  randint tmp___2 ;
  randint excess_choices ;
  randint unusable_choices ;
  randint last_usable_choice ;
  randint reduced_randnum ;

  {
#line 123
  source = s->source;
#line 124
  randnum = s->randnum;
#line 125
  randmax = s->randmax;
#line 126
  choices = genmax + 1UL;
#line 128
  while (1) {
#line 130
    if (randmax < genmax) {
#line 135
      i = (size_t )0;
#line 136
      rmax = randmax;
#line 139
      while (1) {
#line 141
        tmp = shift_left(rmax);
#line 141
        rmax = tmp + 255UL;
#line 142
        i ++;
#line 139
        if (! (rmax < genmax)) {
#line 139
          break;
        }
      }
#line 146
      randread(source, (void *)(buf___1), i);
#line 155
      i = (size_t )0;
#line 157
      while (1) {
#line 159
        tmp___0 = shift_left(randnum);
#line 159
        randnum = tmp___0 + (randint )buf___1[i];
#line 160
        tmp___1 = shift_left(randmax);
#line 160
        randmax = tmp___1 + 255UL;
#line 161
        i ++;
#line 157
        if (! (randmax < genmax)) {
#line 157
          break;
        }
      }
    }
#line 166
    if (randmax == genmax) {
#line 168
      tmp___2 = (randint )0;
#line 168
      s->randmax = tmp___2;
#line 168
      s->randnum = tmp___2;
#line 169
      return (randnum);
    } else {
#line 183
      excess_choices = randmax - genmax;
#line 184
      unusable_choices = excess_choices % choices;
#line 185
      last_usable_choice = randmax - unusable_choices;
#line 186
      reduced_randnum = randnum % choices;
#line 188
      if (randnum <= last_usable_choice) {
#line 190
        s->randnum = randnum / choices;
#line 191
        s->randmax = excess_choices / choices;
#line 192
        return (reduced_randnum);
      }
#line 197
      randnum = reduced_randnum;
#line 198
      randmax = unusable_choices - 1UL;
    }
  }
}
}
#line 205 "randint.c"
void randint_free(struct randint_source *s ) 
{ 

  {
#line 208
  memset((void *)s, 0, sizeof(*s));
#line 209
  free((void *)s);
#line 210
  return;
}
}
#line 215 "randint.c"
int randint_all_free(struct randint_source *s ) 
{ int r ;
  int tmp ;
  int e ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 218
  tmp = randread_free(s->source);
#line 218
  r = tmp;
#line 219
  tmp___0 = __errno_location();
#line 219
  e = *tmp___0;
#line 220
  randint_free(s);
#line 221
  tmp___1 = __errno_location();
#line 221
  *tmp___1 = e;
#line 222
  return (r);
}
}
#line 1 "randperm.o"
#pragma merger(0,"/tmp/cil-0BOtTqI0.i","-g,-O2")
#line 43 "randint.h"
__inline static randint randint_choose(struct randint_source *s , randint choices ) 
{ randint tmp ;

  {
#line 46
  tmp = randint_genmax(s, choices - 1UL);
#line 46
  return (tmp);
}
}
#line 3 "randperm.h"
size_t randperm_bound(size_t h , size_t n )  __attribute__((__const__)) ;
#line 4
size_t *randperm_new(struct randint_source *r , size_t h , size_t n ) ;
#line 33 "randperm.c"
static size_t ceil_lg(size_t n )  __attribute__((__const__)) ;
#line 33
static size_t ceil_lg(size_t n )  __attribute__((__const__)) ;
#line 33 "randperm.c"
static size_t ceil_lg(size_t n ) 
{ size_t b ;

  {
#line 36
  b = (size_t )0;
#line 37
  n --;
#line 37
  while (n != 0UL) {
#line 38
    b ++;
#line 37
    n /= 2UL;
  }
#line 39
  return (b);
}
}
#line 46
size_t randperm_bound(size_t h , size_t n )  __attribute__((__const__)) ;
#line 46 "randperm.c"
size_t randperm_bound(size_t h , size_t n ) 
{ size_t lg_n ;
  size_t tmp ;
  size_t ar ;
  size_t bound ;

  {
#line 51
  tmp = ceil_lg(n);
#line 51
  lg_n = tmp;
#line 54
  ar = lg_n * h;
#line 57
  bound = ((ar + 8UL) - 1UL) / 8UL;
#line 59
  return (bound);
}
}
#line 64 "randperm.c"
static void swap(size_t *v , size_t i , size_t j ) 
{ size_t t ;

  {
#line 67
  t = *(v + i);
#line 68
  *(v + i) = *(v + j);
#line 69
  *(v + j) = t;
#line 70
  return;
}
}
#line 83 "randperm.c"
static size_t sparse_hash_(void const   *x , size_t table_size ) 
{ struct sparse_ent_  const  *ent ;

  {
#line 86
  ent = (struct sparse_ent_  const  *)x;
#line 87
  return ((size_t )(ent->index % (unsigned long const   )table_size));
}
}
#line 90 "randperm.c"
static _Bool sparse_cmp_(void const   *x , void const   *y ) 
{ struct sparse_ent_  const  *ent1 ;
  struct sparse_ent_  const  *ent2 ;

  {
#line 93
  ent1 = (struct sparse_ent_  const  *)x;
#line 94
  ent2 = (struct sparse_ent_  const  *)y;
#line 95
  return ((_Bool )(ent1->index == ent2->index));
}
}
#line 104 "randperm.c"
static sparse_map *sparse_new(size_t size_hint ) 
{ Hash_table *tmp ;

  {
#line 107
  tmp = hash_initialize(size_hint, (Hash_tuning const   *)((void *)0), & sparse_hash_,
                        & sparse_cmp_, & free);
#line 107
  return (tmp);
}
}
#line 114 "randperm.c"
static void sparse_swap(sparse_map *sv , size_t *v , size_t i , size_t j ) 
{ struct sparse_ent_ *v1 ;
  struct sparse_ent_ __constr_expr_0 ;
  void *tmp ;
  struct sparse_ent_ *v2 ;
  struct sparse_ent_ __constr_expr_1 ;
  void *tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  size_t t ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
#line 117
  __constr_expr_0.index = i;
#line 117
  __constr_expr_0.val = (size_t )0;
#line 117
  tmp = hash_delete(sv, (void const   *)(& __constr_expr_0));
#line 117
  v1 = (struct sparse_ent_ *)tmp;
#line 118
  __constr_expr_1.index = j;
#line 118
  __constr_expr_1.val = (size_t )0;
#line 118
  tmp___0 = hash_delete(sv, (void const   *)(& __constr_expr_1));
#line 118
  v2 = (struct sparse_ent_ *)tmp___0;
#line 121
  if (! v1) {
#line 123
    tmp___1 = xmalloc(sizeof(*v1));
#line 123
    v1 = (struct sparse_ent_ *)tmp___1;
#line 124
    tmp___2 = i;
#line 124
    v1->val = tmp___2;
#line 124
    v1->index = tmp___2;
  }
#line 126
  if (! v2) {
#line 128
    tmp___3 = xmalloc(sizeof(*v2));
#line 128
    v2 = (struct sparse_ent_ *)tmp___3;
#line 129
    tmp___4 = j;
#line 129
    v2->val = tmp___4;
#line 129
    v2->index = tmp___4;
  }
#line 132
  t = v1->val;
#line 133
  v1->val = v2->val;
#line 134
  v2->val = t;
#line 135
  tmp___5 = hash_insert(sv, (void const   *)v1);
#line 135
  if (! tmp___5) {
#line 136
    xalloc_die();
  }
#line 137
  tmp___6 = hash_insert(sv, (void const   *)v2);
#line 137
  if (! tmp___6) {
#line 138
    xalloc_die();
  }
#line 140
  *(v + i) = v1->val;
#line 141
  return;
}
}
#line 143 "randperm.c"
static void sparse_free(sparse_map *sv ) 
{ 

  {
#line 146
  hash_free(sv);
#line 147
  return;
}
}
#line 154 "randperm.c"
size_t *randperm_new(struct randint_source *r , size_t h , size_t n ) 
{ size_t *v ;
  void *tmp ;
  _Bool sparse ;
  int tmp___0 ;
  size_t i ;
  sparse_map *sv ;
  void *tmp___1 ;
  void *tmp___2 ;
  size_t j ;
  randint tmp___3 ;
  void *tmp___4 ;

  {
#line 159
  switch ((int )h) {
  case 0: 
#line 162
  v = (size_t *)((void *)0);
#line 163
  break;
  case 1: 
#line 166
  tmp = xmalloc(sizeof(*v));
#line 166
  v = (size_t *)tmp;
#line 167
  *(v + 0) = randint_choose(r, n);
#line 168
  break;
  default: 
#line 199
  if (n >= 131072UL) {
#line 199
    if (n / h >= 32UL) {
#line 199
      tmp___0 = 1;
    } else {
#line 199
      tmp___0 = 0;
    }
  } else {
#line 199
    tmp___0 = 0;
  }
#line 199
  sparse = (_Bool )tmp___0;
#line 204
  if (sparse) {
#line 206
    sv = sparse_new(h * 2UL);
#line 207
    if ((unsigned long )sv == (unsigned long )((void *)0)) {
#line 208
      xalloc_die();
    }
#line 209
    tmp___1 = xnmalloc(h, sizeof(*v));
#line 209
    v = (size_t *)tmp___1;
  } else {
#line 213
    sv = (sparse_map *)((void *)0);
#line 214
    tmp___2 = xnmalloc(n, sizeof(*v));
#line 214
    v = (size_t *)tmp___2;
#line 215
    i = (size_t )0;
#line 215
    while (i < n) {
#line 216
      *(v + i) = i;
#line 215
      i ++;
    }
  }
#line 219
  i = (size_t )0;
#line 219
  while (i < h) {
#line 221
    tmp___3 = randint_choose(r, n - i);
#line 221
    j = i + tmp___3;
#line 222
    if (sparse) {
#line 223
      sparse_swap(sv, v, i, j);
    } else {
#line 225
      swap(v, i, j);
    }
#line 219
    i ++;
  }
#line 228
  if (sparse) {
#line 229
    sparse_free(sv);
  } else {
#line 231
    tmp___4 = xnrealloc((void *)v, h, sizeof(*v));
#line 231
    v = (size_t *)tmp___4;
  }
#line 233
  break;
  }
#line 236
  return (v);
}
}
#line 1 "randread.o"
#pragma merger(0,"/tmp/cil-v3MUAwyu.i","-g,-O2")
#line 29 "randread.h"
void randread_set_handler(struct randread_source *s , void (*handler)(void const   * ) ) ;
#line 30
void randread_set_handler_arg(struct randread_source *s , void const   *handler_arg ) ;
#line 333 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int setvbuf(FILE * __restrict  __stream , char * __restrict  __buf ,
                                                 int __modes , size_t __n ) ;
#line 625 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t getppid(void) ;
#line 694
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 700
extern  __attribute__((__nothrow__)) __gid_t getgid(void) ;
#line 62 "rand-isaac.h"
void isaac_seed(struct isaac_state *s ) ;
#line 63
void isaac_refill(struct isaac_state *s , isaac_word *result ) ;
#line 123 "randread.c"
static  __attribute__((__noreturn__)) void randread_error(void const   *file_name___1 ) ;
#line 123
static  __attribute__((__noreturn__)) void randread_error(void const   *file_name___1 ) ;
#line 123 "randread.c"
static void randread_error(void const   *file_name___1 ) 
{ char *tmp ;
  char const   *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;

  {
#line 126
  if (file_name___1) {
#line 127
    tmp = quotearg_colon((char const   *)file_name___1);
#line 127
    tmp___2 = __errno_location();
#line 127
    if (*tmp___2 == 0) {
#line 127
      tmp___1 = "%s: end of file";
    } else {
#line 127
      tmp___1 = "%s: read error";
    }
#line 127
    tmp___3 = dcgettext((char const   *)((void *)0), tmp___1, 5);
#line 127
    tmp___4 = __errno_location();
#line 127
    error((int )exit_failure, *tmp___4, (char const   *)tmp___3, tmp);
  }
#line 130
  abort();
}
}
#line 136 "randread.c"
static struct randread_source *simple_new(FILE *source , void const   *handler_arg ) 
{ struct randread_source *s ;
  void *tmp ;

  {
#line 139
  tmp = xmalloc(sizeof(*s));
#line 139
  s = (struct randread_source *)tmp;
#line 140
  s->source = source;
#line 141
  s->handler = & randread_error;
#line 142
  s->handler_arg = handler_arg;
#line 143
  return (s);
}
}
#line 150 "randread.c"
static void get_nonce(void *buffer , size_t bufsize___0 , size_t bytes_bound ) 
{ char *buf___1 ;
  ssize_t seeded ;
  int fd ;
  int __attribute__((__artificial__))  tmp ;
  size_t tmp___0 ;
  ssize_t __attribute__((__artificial__))  tmp___1 ;
  struct timeval v ;
  size_t nbytes ;
  unsigned long tmp___2 ;
  pid_t v___0 ;
  size_t nbytes___0 ;
  unsigned long tmp___3 ;
  pid_t v___1 ;
  size_t nbytes___1 ;
  unsigned long tmp___4 ;
  uid_t v___2 ;
  size_t nbytes___2 ;
  unsigned long tmp___5 ;
  uid_t v___3 ;
  size_t nbytes___3 ;
  unsigned long tmp___6 ;
  ssize_t __attribute__((__artificial__))  tmp___7 ;

  {
#line 153
  buf___1 = (char *)buffer;
#line 154
  seeded = (ssize_t )0;
#line 157
  tmp = open("/dev/urandom", 0);
#line 157
  fd = (int )tmp;
#line 158
  if (0 <= fd) {
#line 160
    if (bufsize___0 < bytes_bound) {
#line 160
      tmp___0 = bufsize___0;
    } else {
#line 160
      tmp___0 = bytes_bound;
    }
#line 160
    tmp___7 = (ssize_t __attribute__((__artificial__))  )read(fd, (void *)buf___1,
                                                              tmp___0);
#line 160
    tmp___1 = tmp___7;
#line 160
    seeded = (ssize_t )tmp___1;
#line 161
    if (seeded < 0L) {
#line 162
      seeded = (ssize_t )0;
    }
#line 163
    close(fd);
  }
#line 177
  if ((size_t )seeded < bufsize___0) {
#line 177
    if (sizeof(v) < bufsize___0 - (size_t )seeded) {
#line 177
      tmp___2 = sizeof(v);
    } else {
#line 177
      tmp___2 = bufsize___0 - (size_t )seeded;
    }
#line 177
    nbytes = tmp___2;
#line 177
    gettimeofday((struct timeval * __restrict  )(& v), (__timezone_ptr_t )((void *)0));
#line 177
    memcpy((void * __restrict  )(buf___1 + seeded), (void const   * __restrict  )(& v),
           nbytes);
#line 177
    seeded = (ssize_t )((size_t )seeded + nbytes);
  }
#line 178
  if ((size_t )seeded < bufsize___0) {
#line 178
    if (sizeof(v___0) < bufsize___0 - (size_t )seeded) {
#line 178
      tmp___3 = sizeof(v___0);
    } else {
#line 178
      tmp___3 = bufsize___0 - (size_t )seeded;
    }
#line 178
    nbytes___0 = tmp___3;
#line 178
    v___0 = getpid();
#line 178
    memcpy((void * __restrict  )(buf___1 + seeded), (void const   * __restrict  )(& v___0),
           nbytes___0);
#line 178
    seeded = (ssize_t )((size_t )seeded + nbytes___0);
  }
#line 179
  if ((size_t )seeded < bufsize___0) {
#line 179
    if (sizeof(v___1) < bufsize___0 - (size_t )seeded) {
#line 179
      tmp___4 = sizeof(v___1);
    } else {
#line 179
      tmp___4 = bufsize___0 - (size_t )seeded;
    }
#line 179
    nbytes___1 = tmp___4;
#line 179
    v___1 = getppid();
#line 179
    memcpy((void * __restrict  )(buf___1 + seeded), (void const   * __restrict  )(& v___1),
           nbytes___1);
#line 179
    seeded = (ssize_t )((size_t )seeded + nbytes___1);
  }
#line 180
  if ((size_t )seeded < bufsize___0) {
#line 180
    if (sizeof(v___2) < bufsize___0 - (size_t )seeded) {
#line 180
      tmp___5 = sizeof(v___2);
    } else {
#line 180
      tmp___5 = bufsize___0 - (size_t )seeded;
    }
#line 180
    nbytes___2 = tmp___5;
#line 180
    v___2 = getuid();
#line 180
    memcpy((void * __restrict  )(buf___1 + seeded), (void const   * __restrict  )(& v___2),
           nbytes___2);
#line 180
    seeded = (ssize_t )((size_t )seeded + nbytes___2);
  }
#line 181
  if ((size_t )seeded < bufsize___0) {
#line 181
    if (sizeof(v___3) < bufsize___0 - (size_t )seeded) {
#line 181
      tmp___6 = sizeof(v___3);
    } else {
#line 181
      tmp___6 = bufsize___0 - (size_t )seeded;
    }
#line 181
    nbytes___3 = tmp___6;
#line 181
    v___3 = getgid();
#line 181
    memcpy((void * __restrict  )(buf___1 + seeded), (void const   * __restrict  )(& v___3),
           nbytes___3);
#line 181
    seeded = (ssize_t )((size_t )seeded + nbytes___3);
  }
#line 189
  return;
}
}
#line 203 "randread.c"
struct randread_source *randread_new(char const   *name , size_t bytes_bound ) 
{ struct randread_source *tmp ;
  FILE *source ;
  struct randread_source *s ;
  unsigned long tmp___0 ;

  {
#line 206
  if (bytes_bound == 0UL) {
#line 207
    tmp = simple_new((FILE *)((void *)0), (void const   *)((void *)0));
#line 207
    return (tmp);
  } else {
#line 210
    source = (FILE *)((void *)0);
#line 213
    if (name) {
#line 214
      source = fopen_safer(name, "rb");
#line 214
      if (! source) {
#line 215
        return ((struct randread_source *)((void *)0));
      }
    }
#line 217
    s = simple_new(source, (void const   *)name);
#line 219
    if (source) {
#line 220
      if (sizeof(s->buf.c) < bytes_bound) {
#line 220
        tmp___0 = sizeof(s->buf.c);
      } else {
#line 220
        tmp___0 = bytes_bound;
      }
#line 220
      setvbuf((FILE * __restrict  )source, (char * __restrict  )(s->buf.c), 0, tmp___0);
    } else {
#line 223
      s->buf.isaac.buffered = (size_t )0;
#line 224
      get_nonce((void *)(s->buf.isaac.state.m), sizeof(s->buf.isaac.state.m), bytes_bound);
#line 226
      isaac_seed(& s->buf.isaac.state);
    }
#line 229
    return (s);
  }
}
}
#line 241 "randread.c"
void randread_set_handler(struct randread_source *s , void (*handler)(void const   * ) ) 
{ 

  {
#line 244
  s->handler = handler;
#line 245
  return;
}
}
#line 247 "randread.c"
void randread_set_handler_arg(struct randread_source *s , void const   *handler_arg ) 
{ 

  {
#line 250
  s->handler_arg = handler_arg;
#line 251
  return;
}
}
#line 257 "randread.c"
static void readsource(struct randread_source *s , unsigned char *p , size_t size ) 
{ size_t inbytes ;
  size_t __attribute__((__artificial__))  tmp ;
  int fread_errno ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___3 ;
  size_t __attribute__((__artificial__))  tmp___4 ;

  {
#line 260
  while (1) {
#line 262
    tmp___4 = (size_t __attribute__((__artificial__))  )fread_unlocked((void * __restrict  )p,
                                                                       sizeof(*p),
                                                                       size, (FILE * __restrict  )s->source);
#line 262
    tmp = tmp___4;
#line 262
    inbytes = (size_t )tmp;
#line 263
    tmp___0 = __errno_location();
#line 263
    fread_errno = *tmp___0;
#line 264
    p += inbytes;
#line 265
    size -= inbytes;
#line 266
    if (size == 0UL) {
#line 267
      break;
    }
#line 268
    tmp___1 = __errno_location();
#line 268
    tmp___3 = ferror_unlocked(s->source);
#line 268
    if (tmp___3) {
#line 268
      *tmp___1 = fread_errno;
    } else {
#line 268
      *tmp___1 = 0;
    }
#line 269
    (*(s->handler))(s->handler_arg);
  }
#line 271
  return;
}
}
#line 277 "randread.c"
static void readisaac(struct isaac *isaac , unsigned char *p , size_t size ) 
{ size_t inbytes ;
  isaac_word *wp ;

  {
#line 280
  inbytes = isaac->buffered;
#line 282
  while (1) {
#line 284
    if (size <= inbytes) {
#line 286
      memcpy((void * __restrict  )p, (void const   * __restrict  )((isaac->data.b + (unsigned long )(1 << 8) * sizeof(isaac_word )) - inbytes),
             size);
#line 287
      isaac->buffered = inbytes - size;
#line 288
      return;
    }
#line 291
    memcpy((void * __restrict  )p, (void const   * __restrict  )((isaac->data.b + (unsigned long )(1 << 8) * sizeof(isaac_word )) - inbytes),
           inbytes);
#line 292
    p += inbytes;
#line 293
    size -= inbytes;
#line 299
    wp = (isaac_word *)p;
#line 300
    while ((unsigned long )(1 << 8) * sizeof(isaac_word ) <= size) {
#line 302
      isaac_refill(& isaac->state, wp);
#line 303
      wp += 1 << 8;
#line 304
      size -= (unsigned long )(1 << 8) * sizeof(isaac_word );
#line 305
      if (size == 0UL) {
#line 307
        isaac->buffered = (size_t )0;
#line 308
        return;
      }
    }
#line 311
    p = (unsigned char *)wp;
#line 314
    isaac_refill(& isaac->state, isaac->data.w);
#line 315
    inbytes = (unsigned long )(1 << 8) * sizeof(isaac_word );
  }
}
}
#line 323 "randread.c"
void randread(struct randread_source *s , void *buf___1 , size_t size ) 
{ 

  {
#line 326
  if (s->source) {
#line 327
    readsource(s, (unsigned char *)buf___1, size);
  } else {
#line 329
    readisaac(& s->buf.isaac, (unsigned char *)buf___1, size);
  }
#line 330
  return;
}
}
#line 338 "randread.c"
int randread_free(struct randread_source *s ) 
{ FILE *source ;
  int tmp ;
  int tmp___0 ;

  {
#line 341
  source = s->source;
#line 342
  memset((void *)s, 0, sizeof(*s));
#line 343
  free((void *)s);
#line 344
  if (source) {
#line 344
    tmp = rpl_fclose(source);
#line 344
    tmp___0 = tmp;
  } else {
#line 344
    tmp___0 = 0;
  }
#line 344
  return (tmp___0);
}
}
#line 1 "rand-isaac.o"
#pragma merger(0,"/tmp/cil-44Mo5Xx5.i","-g,-O2")
#line 54 "rand-isaac.c"
__inline static isaac_word just(isaac_word a ) 
{ isaac_word desired_bits ;

  {
#line 57
  desired_bits = ((1UL << 1) << ((1 << 6) - 1)) - 1UL;
#line 58
  return (a & desired_bits);
}
}
#line 64 "rand-isaac.c"
__inline static isaac_word ind(isaac_word const   *m , isaac_word x ) 
{ isaac_word tmp ;

  {
#line 67
  if (sizeof(*m) * 8UL == (unsigned long )(1 << 6)) {
#line 67
    tmp = *((isaac_word *)((char *)m + (x & (unsigned long )((1 << 8) - 1) * sizeof(*m))));
  } else {
#line 67
    tmp = (isaac_word )*(m + (x / (isaac_word )((1 << 6) / 8) & (unsigned long )((1 << 8) - 1)));
  }
#line 67
  return (tmp);
}
}
#line 74 "rand-isaac.c"
void isaac_refill(struct isaac_state *s , isaac_word *result ) 
{ isaac_word a ;
  isaac_word b ;
  isaac_word *m ;
  isaac_word *r ;
  isaac_word x ;
  isaac_word y ;
  isaac_word tmp ;
  isaac_word tmp___0 ;
  isaac_word tmp___1 ;
  isaac_word tmp___2 ;
  isaac_word x___0 ;
  isaac_word y___0 ;
  isaac_word tmp___3 ;
  isaac_word tmp___4 ;
  isaac_word tmp___5 ;
  isaac_word tmp___6 ;
  isaac_word tmp___7 ;
  isaac_word tmp___8 ;
  isaac_word x___1 ;
  isaac_word y___1 ;
  isaac_word tmp___9 ;
  isaac_word tmp___10 ;
  isaac_word tmp___11 ;
  isaac_word tmp___12 ;
  isaac_word x___2 ;
  isaac_word y___2 ;
  isaac_word tmp___13 ;
  isaac_word tmp___14 ;
  isaac_word tmp___15 ;
  isaac_word tmp___16 ;
  isaac_word tmp___17 ;
  isaac_word tmp___18 ;
  isaac_word x___3 ;
  isaac_word y___3 ;
  isaac_word tmp___19 ;
  isaac_word tmp___20 ;
  isaac_word tmp___21 ;
  isaac_word tmp___22 ;
  isaac_word x___4 ;
  isaac_word y___4 ;
  isaac_word tmp___23 ;
  isaac_word tmp___24 ;
  isaac_word tmp___25 ;
  isaac_word tmp___26 ;
  isaac_word tmp___27 ;
  isaac_word tmp___28 ;
  isaac_word x___5 ;
  isaac_word y___5 ;
  isaac_word tmp___29 ;
  isaac_word tmp___30 ;
  isaac_word tmp___31 ;
  isaac_word tmp___32 ;
  isaac_word x___6 ;
  isaac_word y___6 ;
  isaac_word tmp___33 ;
  isaac_word tmp___34 ;
  isaac_word tmp___35 ;
  isaac_word tmp___36 ;
  isaac_word tmp___37 ;
  isaac_word tmp___38 ;

  {
#line 78
  a = s->a;
#line 79
  (s->c) ++;
#line 79
  b = s->b + s->c;
#line 82
  m = s->m;
#line 83
  r = result;
#line 101
  while (1) {
#line 103
    if (1 << 6 == 32) {
#line 103
      tmp = a;
    } else {
#line 103
      tmp = (isaac_word )0;
    }
#line 103
    if (1 << 6 == 32) {
#line 103
      tmp___0 = a << 13;
    } else {
#line 103
      tmp___0 = ~ (a ^ (a << 21));
    }
#line 103
    a = (tmp ^ tmp___0) + *(m + 128);
#line 103
    x = *(m + 0);
#line 103
    tmp___1 = ind((isaac_word const   *)(s->m), x);
#line 103
    y = (tmp___1 + a) + b;
#line 103
    *(m + 0) = y;
#line 103
    tmp___2 = ind((isaac_word const   *)(s->m), y >> 8);
#line 103
    b = just(tmp___2 + x);
#line 103
    *(r + 0) = b;
#line 104
    if (1 << 6 == 32) {
#line 104
      tmp___3 = a;
    } else {
#line 104
      tmp___3 = (isaac_word )0;
    }
#line 104
    if (1 << 6 == 32) {
#line 104
      tmp___4 = just(a);
#line 104
      tmp___6 = tmp___4 >> 6;
    } else {
#line 104
      tmp___5 = just(a);
#line 104
      tmp___6 = a ^ (tmp___5 >> 5);
    }
#line 104
    a = (tmp___3 ^ tmp___6) + *(m + 129);
#line 104
    x___0 = *(m + 1);
#line 104
    tmp___7 = ind((isaac_word const   *)(s->m), x___0);
#line 104
    y___0 = (tmp___7 + a) + b;
#line 104
    *(m + 1) = y___0;
#line 104
    tmp___8 = ind((isaac_word const   *)(s->m), y___0 >> 8);
#line 104
    b = just(tmp___8 + x___0);
#line 104
    *(r + 1) = b;
#line 105
    if (1 << 6 == 32) {
#line 105
      tmp___9 = a;
    } else {
#line 105
      tmp___9 = (isaac_word )0;
    }
#line 105
    if (1 << 6 == 32) {
#line 105
      tmp___10 = a << 2;
    } else {
#line 105
      tmp___10 = a ^ (a << 12);
    }
#line 105
    a = (tmp___9 ^ tmp___10) + *(m + 130);
#line 105
    x___1 = *(m + 2);
#line 105
    tmp___11 = ind((isaac_word const   *)(s->m), x___1);
#line 105
    y___1 = (tmp___11 + a) + b;
#line 105
    *(m + 2) = y___1;
#line 105
    tmp___12 = ind((isaac_word const   *)(s->m), y___1 >> 8);
#line 105
    b = just(tmp___12 + x___1);
#line 105
    *(r + 2) = b;
#line 106
    if (1 << 6 == 32) {
#line 106
      tmp___13 = a;
    } else {
#line 106
      tmp___13 = (isaac_word )0;
    }
#line 106
    if (1 << 6 == 32) {
#line 106
      tmp___14 = just(a);
#line 106
      tmp___16 = tmp___14 >> 16;
    } else {
#line 106
      tmp___15 = just(a);
#line 106
      tmp___16 = a ^ (tmp___15 >> 33);
    }
#line 106
    a = (tmp___13 ^ tmp___16) + *(m + 131);
#line 106
    x___2 = *(m + 3);
#line 106
    tmp___17 = ind((isaac_word const   *)(s->m), x___2);
#line 106
    y___2 = (tmp___17 + a) + b;
#line 106
    *(m + 3) = y___2;
#line 106
    tmp___18 = ind((isaac_word const   *)(s->m), y___2 >> 8);
#line 106
    b = just(tmp___18 + x___2);
#line 106
    *(r + 3) = b;
#line 107
    r += 4;
#line 101
    m += 4;
#line 101
    if (! ((unsigned long )m < (unsigned long )(s->m + 128))) {
#line 101
      break;
    }
  }
#line 111
  while (1) {
#line 113
    if (1 << 6 == 32) {
#line 113
      tmp___19 = a;
    } else {
#line 113
      tmp___19 = (isaac_word )0;
    }
#line 113
    if (1 << 6 == 32) {
#line 113
      tmp___20 = a << 13;
    } else {
#line 113
      tmp___20 = ~ (a ^ (a << 21));
    }
#line 113
    a = (tmp___19 ^ tmp___20) + *(m + -128);
#line 113
    x___3 = *(m + 0);
#line 113
    tmp___21 = ind((isaac_word const   *)(s->m), x___3);
#line 113
    y___3 = (tmp___21 + a) + b;
#line 113
    *(m + 0) = y___3;
#line 113
    tmp___22 = ind((isaac_word const   *)(s->m), y___3 >> 8);
#line 113
    b = just(tmp___22 + x___3);
#line 113
    *(r + 0) = b;
#line 114
    if (1 << 6 == 32) {
#line 114
      tmp___23 = a;
    } else {
#line 114
      tmp___23 = (isaac_word )0;
    }
#line 114
    if (1 << 6 == 32) {
#line 114
      tmp___24 = just(a);
#line 114
      tmp___26 = tmp___24 >> 6;
    } else {
#line 114
      tmp___25 = just(a);
#line 114
      tmp___26 = a ^ (tmp___25 >> 5);
    }
#line 114
    a = (tmp___23 ^ tmp___26) + *(m + -127);
#line 114
    x___4 = *(m + 1);
#line 114
    tmp___27 = ind((isaac_word const   *)(s->m), x___4);
#line 114
    y___4 = (tmp___27 + a) + b;
#line 114
    *(m + 1) = y___4;
#line 114
    tmp___28 = ind((isaac_word const   *)(s->m), y___4 >> 8);
#line 114
    b = just(tmp___28 + x___4);
#line 114
    *(r + 1) = b;
#line 115
    if (1 << 6 == 32) {
#line 115
      tmp___29 = a;
    } else {
#line 115
      tmp___29 = (isaac_word )0;
    }
#line 115
    if (1 << 6 == 32) {
#line 115
      tmp___30 = a << 2;
    } else {
#line 115
      tmp___30 = a ^ (a << 12);
    }
#line 115
    a = (tmp___29 ^ tmp___30) + *(m + -126);
#line 115
    x___5 = *(m + 2);
#line 115
    tmp___31 = ind((isaac_word const   *)(s->m), x___5);
#line 115
    y___5 = (tmp___31 + a) + b;
#line 115
    *(m + 2) = y___5;
#line 115
    tmp___32 = ind((isaac_word const   *)(s->m), y___5 >> 8);
#line 115
    b = just(tmp___32 + x___5);
#line 115
    *(r + 2) = b;
#line 116
    if (1 << 6 == 32) {
#line 116
      tmp___33 = a;
    } else {
#line 116
      tmp___33 = (isaac_word )0;
    }
#line 116
    if (1 << 6 == 32) {
#line 116
      tmp___34 = just(a);
#line 116
      tmp___36 = tmp___34 >> 16;
    } else {
#line 116
      tmp___35 = just(a);
#line 116
      tmp___36 = a ^ (tmp___35 >> 33);
    }
#line 116
    a = (tmp___33 ^ tmp___36) + *(m + -125);
#line 116
    x___6 = *(m + 3);
#line 116
    tmp___37 = ind((isaac_word const   *)(s->m), x___6);
#line 116
    y___6 = (tmp___37 + a) + b;
#line 116
    *(m + 3) = y___6;
#line 116
    tmp___38 = ind((isaac_word const   *)(s->m), y___6 >> 8);
#line 116
    b = just(tmp___38 + x___6);
#line 116
    *(r + 3) = b;
#line 117
    r += 4;
#line 111
    m += 4;
#line 111
    if (! ((unsigned long )m < (unsigned long )(s->m + (1 << 8)))) {
#line 111
      break;
    }
  }
#line 121
  s->a = a;
#line 122
  s->b = b;
#line 123
  return;
}
}
#line 232 "rand-isaac.c"
void isaac_seed(struct isaac_state *s ) 
{ isaac_word a ;
  unsigned long tmp ;
  isaac_word b ;
  unsigned long tmp___0 ;
  isaac_word c ;
  unsigned long tmp___1 ;
  isaac_word d ;
  unsigned long tmp___2 ;
  isaac_word e ;
  unsigned long tmp___3 ;
  isaac_word f ;
  unsigned long tmp___4 ;
  isaac_word g ;
  unsigned long tmp___5 ;
  isaac_word h ;
  unsigned long tmp___6 ;
  int i ;
  isaac_word tmp___7 ;
  isaac_word tmp___8 ;
  isaac_word tmp___9 ;
  isaac_word tmp___10 ;
  int i___0 ;
  isaac_word tmp___11 ;
  isaac_word tmp___12 ;
  isaac_word tmp___13 ;
  isaac_word tmp___14 ;
  isaac_word tmp___15 ;
  isaac_word tmp___16 ;

  {
#line 235
  if (1 << 6 == 32) {
#line 235
    tmp = 325574490UL;
  } else {
#line 235
    tmp = 7240739780546808700UL;
  }
#line 235
  a = tmp;
#line 236
  if (1 << 6 == 32) {
#line 236
    tmp___0 = 2514026585UL;
  } else {
#line 236
    tmp___0 = 0xb9f8b322c73ac862UL;
  }
#line 236
  b = tmp___0;
#line 237
  if (1 << 6 == 32) {
#line 237
    tmp___1 = 3273014859UL;
  } else {
#line 237
    tmp___1 = 0x8c0ea5053d4712a0UL;
  }
#line 237
  c = tmp___1;
#line 238
  if (1 << 6 == 32) {
#line 238
    tmp___2 = 255990488UL;
  } else {
#line 238
    tmp___2 = 0xb29b2e824a595524UL;
  }
#line 238
  d = tmp___2;
#line 239
  if (1 << 6 == 32) {
#line 239
    tmp___3 = 3643427448UL;
  } else {
#line 239
    tmp___3 = 0x82f053db8355e0ceUL;
  }
#line 239
  e = tmp___3;
#line 240
  if (1 << 6 == 32) {
#line 240
    tmp___4 = 2769960009UL;
  } else {
#line 240
    tmp___4 = 5259722845879046933UL;
  }
#line 240
  f = tmp___4;
#line 241
  if (1 << 6 == 32) {
#line 241
    tmp___5 = 3304057371UL;
  } else {
#line 241
    tmp___5 = 0xae985bf2cbfc89edUL;
  }
#line 241
  g = tmp___5;
#line 242
  if (1 << 6 == 32) {
#line 242
    tmp___6 = 811634969UL;
  } else {
#line 242
    tmp___6 = 0x98f5704f6c44c0abUL;
  }
#line 242
  h = tmp___6;
#line 254
  i = 0;
#line 254
  while (i < 1 << 8) {
#line 254
    a += s->m[i];
#line 254
    b += s->m[i + 1];
#line 254
    c += s->m[i + 2];
#line 254
    d += s->m[i + 3];
#line 254
    e += s->m[i + 4];
#line 254
    f += s->m[i + 5];
#line 254
    g += s->m[i + 6];
#line 254
    h += s->m[i + 7];
#line 254
    a -= e;
#line 254
    tmp___7 = just(h);
#line 254
    f ^= tmp___7 >> 9;
#line 254
    h += a;
#line 254
    b -= f;
#line 254
    g ^= a << 9;
#line 254
    a += b;
#line 254
    c -= g;
#line 254
    tmp___8 = just(b);
#line 254
    h ^= tmp___8 >> 23;
#line 254
    b += c;
#line 254
    d -= h;
#line 254
    a ^= c << 15;
#line 254
    c += d;
#line 254
    e -= a;
#line 254
    tmp___9 = just(d);
#line 254
    b ^= tmp___9 >> 14;
#line 254
    d += e;
#line 254
    f -= b;
#line 254
    c ^= e << 20;
#line 254
    e += f;
#line 254
    g -= c;
#line 254
    tmp___10 = just(f);
#line 254
    d ^= tmp___10 >> 17;
#line 254
    f += g;
#line 254
    h -= d;
#line 254
    e ^= g << 14;
#line 254
    g += h;
#line 254
    s->m[i] = a;
#line 254
    s->m[i + 1] = b;
#line 254
    s->m[i + 2] = c;
#line 254
    s->m[i + 3] = d;
#line 254
    s->m[i + 4] = e;
#line 254
    s->m[i + 5] = f;
#line 254
    s->m[i + 6] = g;
#line 254
    s->m[i + 7] = h;
#line 254
    i += 8;
  }
#line 255
  i___0 = 0;
#line 255
  while (i___0 < 1 << 8) {
#line 255
    a += s->m[i___0];
#line 255
    b += s->m[i___0 + 1];
#line 255
    c += s->m[i___0 + 2];
#line 255
    d += s->m[i___0 + 3];
#line 255
    e += s->m[i___0 + 4];
#line 255
    f += s->m[i___0 + 5];
#line 255
    g += s->m[i___0 + 6];
#line 255
    h += s->m[i___0 + 7];
#line 255
    a -= e;
#line 255
    tmp___11 = just(h);
#line 255
    f ^= tmp___11 >> 9;
#line 255
    h += a;
#line 255
    b -= f;
#line 255
    g ^= a << 9;
#line 255
    a += b;
#line 255
    c -= g;
#line 255
    tmp___12 = just(b);
#line 255
    h ^= tmp___12 >> 23;
#line 255
    b += c;
#line 255
    d -= h;
#line 255
    a ^= c << 15;
#line 255
    c += d;
#line 255
    e -= a;
#line 255
    tmp___13 = just(d);
#line 255
    b ^= tmp___13 >> 14;
#line 255
    d += e;
#line 255
    f -= b;
#line 255
    c ^= e << 20;
#line 255
    e += f;
#line 255
    g -= c;
#line 255
    tmp___14 = just(f);
#line 255
    d ^= tmp___14 >> 17;
#line 255
    f += g;
#line 255
    h -= d;
#line 255
    e ^= g << 14;
#line 255
    g += h;
#line 255
    s->m[i___0] = a;
#line 255
    s->m[i___0 + 1] = b;
#line 255
    s->m[i___0 + 2] = c;
#line 255
    s->m[i___0 + 3] = d;
#line 255
    s->m[i___0 + 4] = e;
#line 255
    s->m[i___0 + 5] = f;
#line 255
    s->m[i___0 + 6] = g;
#line 255
    s->m[i___0 + 7] = h;
#line 255
    i___0 += 8;
  }
#line 257
  tmp___16 = (isaac_word )0;
#line 257
  s->c = tmp___16;
#line 257
  tmp___15 = tmp___16;
#line 257
  s->b = tmp___15;
#line 257
  s->a = tmp___15;
#line 258
  return;
}
}
#line 1 "read-file.o"
#pragma merger(0,"/tmp/cil-y_NeEj3u.i","-g,-O2")
#line 771 "/usr/include/stdio.h"
extern __off_t ftello(FILE *__stream )  __attribute__((__warn_unused_result__)) ;
#line 30 "read-file.h"
char *fread_file(FILE *stream , size_t *length ) ;
#line 32
char *read_file(char const   *filename , size_t *length ) ;
#line 34
char *read_binary_file(char const   *filename , size_t *length ) ;
#line 45 "read-file.c"
char *fread_file(FILE *stream , size_t *length ) 
{ char *buf___1 ;
  size_t alloc ;
  struct stat st ;
  off_t pos ;
  __off_t tmp ;
  off_t alloc_off ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  size_t size ;
  int save_errno ;
  size_t requested ;
  size_t count ;
  size_t __attribute__((__artificial__))  tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  char *smaller_buf ;
  void *tmp___7 ;
  char *new_buf ;
  int *tmp___8 ;
  void *tmp___9 ;
  int *tmp___10 ;
  size_t __attribute__((__artificial__))  tmp___11 ;

  {
#line 48
  buf___1 = (char *)((void *)0);
#line 49
  alloc = (size_t )8192;
#line 56
  tmp___1 = fileno(stream);
#line 56
  tmp___2 = fstat(tmp___1, & st);
#line 56
  if (tmp___2 >= 0) {
#line 56
    if ((st.st_mode & 61440U) == 32768U) {
#line 58
      tmp = ftello(stream);
#line 58
      pos = tmp;
#line 60
      if (pos >= 0L) {
#line 60
        if (pos < st.st_size) {
#line 62
          alloc_off = st.st_size - pos;
#line 65
          if (0xfffffffffffffffeUL < (unsigned long )alloc_off) {
#line 67
            tmp___0 = __errno_location();
#line 67
            *tmp___0 = 12;
#line 68
            return ((char *)((void *)0));
          }
#line 71
          alloc = (size_t )(alloc_off + 1L);
        }
      }
    }
  }
#line 76
  tmp___3 = malloc(alloc);
#line 76
  buf___1 = (char *)tmp___3;
#line 76
  if (! buf___1) {
#line 77
    return ((char *)((void *)0));
  }
#line 80
  size = (size_t )0;
#line 83
  while (1) {
#line 87
    requested = alloc - size;
#line 88
    tmp___11 = (size_t __attribute__((__artificial__))  )fread((void * __restrict  )(buf___1 + size),
                                                               (size_t )1, requested,
                                                               (FILE * __restrict  )stream);
#line 88
    tmp___4 = tmp___11;
#line 88
    count = (size_t )tmp___4;
#line 89
    size += count;
#line 91
    if (count != requested) {
#line 93
      tmp___5 = __errno_location();
#line 93
      save_errno = *tmp___5;
#line 94
      tmp___6 = ferror(stream);
#line 94
      if (tmp___6) {
#line 95
        break;
      }
#line 98
      if (size < alloc - 1UL) {
#line 100
        tmp___7 = realloc((void *)buf___1, size + 1UL);
#line 100
        smaller_buf = (char *)tmp___7;
#line 101
        if ((unsigned long )smaller_buf != (unsigned long )((void *)0)) {
#line 102
          buf___1 = smaller_buf;
        }
      }
#line 105
      *(buf___1 + size) = (char )'\000';
#line 106
      *length = size;
#line 107
      return (buf___1);
    }
#line 113
    if (alloc == 0xffffffffffffffffUL) {
#line 115
      save_errno = 12;
#line 116
      break;
    }
#line 119
    if (alloc < 0xffffffffffffffffUL - alloc / 2UL) {
#line 120
      alloc += alloc / 2UL;
    } else {
#line 122
      alloc = 0xffffffffffffffffUL;
    }
#line 124
    tmp___9 = realloc((void *)buf___1, alloc);
#line 124
    new_buf = (char *)tmp___9;
#line 124
    if (! new_buf) {
#line 126
      tmp___8 = __errno_location();
#line 126
      save_errno = *tmp___8;
#line 127
      break;
    }
#line 130
    buf___1 = new_buf;
  }
#line 134
  free((void *)buf___1);
#line 135
  tmp___10 = __errno_location();
#line 135
  *tmp___10 = save_errno;
#line 136
  return ((char *)((void *)0));
}
}
#line 140 "read-file.c"
static char *internal_read_file(char const   *filename , size_t *length , char const   *mode ) 
{ FILE *stream ;
  FILE *tmp ;
  char *out ;
  int save_errno ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
#line 143
  tmp = fopen((char const   * __restrict  )filename, (char const   * __restrict  )mode);
#line 143
  stream = tmp;
#line 147
  if (! stream) {
#line 148
    return ((char *)((void *)0));
  }
#line 150
  out = fread_file(stream, length);
#line 152
  tmp___0 = __errno_location();
#line 152
  save_errno = *tmp___0;
#line 154
  tmp___3 = rpl_fclose(stream);
#line 154
  if (tmp___3 != 0) {
#line 156
    if (out) {
#line 158
      tmp___1 = __errno_location();
#line 158
      save_errno = *tmp___1;
#line 159
      free((void *)out);
    }
#line 161
    tmp___2 = __errno_location();
#line 161
    *tmp___2 = save_errno;
#line 162
    return ((char *)((void *)0));
  }
#line 165
  return (out);
}
}
#line 174 "read-file.c"
char *read_file(char const   *filename , size_t *length ) 
{ char *tmp ;

  {
#line 177
  tmp = internal_read_file(filename, length, "r");
#line 177
  return (tmp);
}
}
#line 187 "read-file.c"
char *read_binary_file(char const   *filename , size_t *length ) 
{ char *tmp ;

  {
#line 190
  tmp = internal_read_file(filename, length, "rb");
#line 190
  return (tmp);
}
}
#line 1 "readtokens.o"
#pragma merger(0,"/tmp/cil-mIT4Qyw4.i","-g,-O2")
#line 33 "readtokens.h"
void init_tokenbuffer(token_buffer *tokenbuffer ) ;
#line 35
size_t readtoken(FILE *stream , char const   *delim , size_t n_delim , token_buffer *tokenbuffer ) ;
#line 38
size_t readtokens(FILE *stream , size_t projected_n_tokens , char const   *delim ,
                  size_t n_delim , char ***tokens_out , size_t **token_lengths ) ;
#line 42 "readtokens.c"
void init_tokenbuffer(token_buffer *tokenbuffer ) 
{ 

  {
#line 45
  tokenbuffer->size = (size_t )0;
#line 46
  tokenbuffer->buffer = (char *)((void *)0);
#line 47
  return;
}
}
#line 71 "readtokens.c"
static char const   *saved_delim  =    (char const   *)((void *)0);
#line 72 "readtokens.c"
static char isdelim[256]  ;
#line 62 "readtokens.c"
size_t readtoken(FILE *stream , char const   *delim , size_t n_delim , token_buffer *tokenbuffer ) 
{ char *p ;
  int c ;
  size_t i ;
  size_t n ;
  _Bool same_delimiters ;
  size_t j ;
  unsigned char ch ;
  void *tmp ;
  size_t tmp___0 ;

  {
#line 75
  if ((unsigned long )delim == (unsigned long )((void *)0)) {
#line 75
    if ((unsigned long )saved_delim == (unsigned long )((void *)0)) {
#line 76
      abort();
    }
  }
#line 78
  same_delimiters = (_Bool)0;
#line 79
  if ((unsigned long )delim != (unsigned long )saved_delim) {
#line 79
    if ((unsigned long )saved_delim != (unsigned long )((void *)0)) {
#line 81
      same_delimiters = (_Bool)1;
#line 82
      i = (size_t )0;
#line 82
      while (i < n_delim) {
#line 84
        if ((int const   )*(delim + i) != (int const   )*(saved_delim + i)) {
#line 86
          same_delimiters = (_Bool)0;
#line 87
          break;
        }
#line 82
        i ++;
      }
    }
  }
#line 92
  if (! same_delimiters) {
#line 95
    saved_delim = delim;
#line 96
    memset((void *)(isdelim), 0, sizeof(isdelim));
#line 97
    j = (size_t )0;
#line 97
    while (j < n_delim) {
#line 99
      ch = (unsigned char )*(delim + j);
#line 100
      isdelim[ch] = (char)1;
#line 97
      j ++;
    }
  }
#line 106
  c = getc_unlocked(stream);
#line 106
  while (1) {
#line 106
    if (c >= 0) {
#line 106
      if (! isdelim[c]) {
#line 106
        break;
      }
    } else {
#line 106
      break;
    }
#line 106
    c = getc_unlocked(stream);
  }
#line 111
  p = tokenbuffer->buffer;
#line 112
  n = tokenbuffer->size;
#line 113
  i = (size_t )0;
#line 114
  while (1) {
#line 116
    if (c < 0) {
#line 116
      if (i == 0UL) {
#line 117
        return ((size_t )-1);
      }
    }
#line 119
    if (i == n) {
#line 120
      tmp = x2nrealloc((void *)p, & n, sizeof(*p));
#line 120
      p = (char *)tmp;
    }
#line 122
    if (c < 0) {
#line 124
      *(p + i) = (char)0;
#line 125
      break;
    }
#line 127
    if (isdelim[c]) {
#line 129
      *(p + i) = (char)0;
#line 130
      break;
    }
#line 132
    tmp___0 = i;
#line 132
    i ++;
#line 132
    *(p + tmp___0) = (char )c;
#line 133
    c = getc_unlocked(stream);
  }
#line 136
  tokenbuffer->buffer = p;
#line 137
  tokenbuffer->size = n;
#line 138
  return (i);
}
}
#line 148 "readtokens.c"
size_t readtokens(FILE *stream , size_t projected_n_tokens , char const   *delim ,
                  size_t n_delim , char ***tokens_out , size_t **token_lengths ) 
{ token_buffer tb ;
  token_buffer *token ;
  char **tokens ;
  size_t *lengths ;
  size_t sz ;
  size_t n_tokens ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  size_t token_length ;
  size_t tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void __attribute__((__artificial__))  *tmp___6 ;

  {
#line 156
  token = & tb;
#line 162
  if (projected_n_tokens == 0UL) {
#line 163
    projected_n_tokens = (size_t )64;
  } else {
#line 165
    projected_n_tokens ++;
  }
#line 167
  sz = projected_n_tokens;
#line 168
  tmp = xnmalloc(sz, sizeof(*tokens));
#line 168
  tokens = (char **)tmp;
#line 169
  tmp___0 = xnmalloc(sz, sizeof(*lengths));
#line 169
  lengths = (size_t *)tmp___0;
#line 171
  n_tokens = (size_t )0;
#line 172
  init_tokenbuffer(token);
#line 173
  while (1) {
#line 176
    tmp___2 = readtoken(stream, delim, n_delim, token);
#line 176
    token_length = tmp___2;
#line 177
    if (n_tokens >= sz) {
#line 179
      tmp___3 = x2nrealloc((void *)tokens, & sz, sizeof(*tokens));
#line 179
      tokens = (char **)tmp___3;
#line 180
      tmp___4 = xnrealloc((void *)lengths, sz, sizeof(*lengths));
#line 180
      lengths = (size_t *)tmp___4;
    }
#line 183
    if (token_length == 0xffffffffffffffffUL) {
#line 186
      *(tokens + n_tokens) = (char *)((void *)0);
#line 187
      *(lengths + n_tokens) = (size_t )0;
#line 188
      break;
    }
#line 190
    tmp___5 = xnmalloc(token_length + 1UL, sizeof(*tmp___1));
#line 190
    tmp___1 = (char *)tmp___5;
#line 191
    *(lengths + n_tokens) = token_length;
#line 192
    tmp___6 = memcpy((void * __restrict  )tmp___1, (void const   * __restrict  )token->buffer,
                     token_length + 1UL);
#line 192
    *(tokens + n_tokens) = (char *)tmp___6;
#line 193
    n_tokens ++;
  }
#line 196
  free((void *)token->buffer);
#line 197
  *tokens_out = tokens;
#line 198
  if ((unsigned long )token_lengths != (unsigned long )((void *)0)) {
#line 199
    *token_lengths = lengths;
  } else {
#line 201
    free((void *)lengths);
  }
#line 202
  return (n_tokens);
}
}
#line 1 "readtokens0.o"
#pragma merger(0,"/tmp/cil-oA7qXEd3.i","-g,-O2")
#line 180 "obstack.h"
extern void _obstack_newchunk(struct obstack * , int  ) ;
#line 181
extern int _obstack_begin(struct obstack * , int  , int  , void *(*)(long  ) , void (*)(void * ) ) ;
#line 193
extern void obstack_free(struct obstack *obstack , void *block ) ;
#line 38 "readtokens0.h"
void readtokens0_init(struct Tokens *t ) ;
#line 39
void readtokens0_free(struct Tokens *t ) ;
#line 40
_Bool readtokens0(FILE *in , struct Tokens *t ) ;
#line 29 "readtokens0.c"
void readtokens0_init(struct Tokens *t ) 
{ 

  {
#line 32
  t->n_tok = (size_t )0;
#line 33
  t->tok = (char **)((void *)0);
#line 34
  t->tok_len = (size_t *)((void *)0);
#line 35
  _obstack_begin(& t->o_data, 0, 0, (void *(*)(long  ))(& malloc), & free);
#line 36
  _obstack_begin(& t->o_tok, 0, 0, (void *(*)(long  ))(& malloc), & free);
#line 37
  _obstack_begin(& t->o_tok_len, 0, 0, (void *(*)(long  ))(& malloc), & free);
#line 38
  return;
}
}
#line 40 "readtokens0.c"
void readtokens0_free(struct Tokens *t ) 
{ struct obstack *__o ;
  void *__obj ;
  char *tmp ;
  struct obstack *__o___0 ;
  void *__obj___0 ;
  char *tmp___0 ;
  struct obstack *__o___1 ;
  void *__obj___1 ;
  char *tmp___1 ;

  {
#line 43
  __o = & t->o_data;
#line 43
  __obj = (void *)0;
#line 43
  if ((unsigned long )__obj > (unsigned long )((void *)__o->chunk)) {
#line 43
    if ((unsigned long )__obj < (unsigned long )((void *)__o->chunk_limit)) {
#line 43
      tmp = (char *)__obj;
#line 43
      __o->object_base = tmp;
#line 43
      __o->next_free = tmp;
    } else {
#line 43
      obstack_free(__o, __obj);
    }
  } else {
#line 43
    obstack_free(__o, __obj);
  }
#line 44
  __o___0 = & t->o_tok;
#line 44
  __obj___0 = (void *)0;
#line 44
  if ((unsigned long )__obj___0 > (unsigned long )((void *)__o___0->chunk)) {
#line 44
    if ((unsigned long )__obj___0 < (unsigned long )((void *)__o___0->chunk_limit)) {
#line 44
      tmp___0 = (char *)__obj___0;
#line 44
      __o___0->object_base = tmp___0;
#line 44
      __o___0->next_free = tmp___0;
    } else {
#line 44
      obstack_free(__o___0, __obj___0);
    }
  } else {
#line 44
    obstack_free(__o___0, __obj___0);
  }
#line 45
  __o___1 = & t->o_tok_len;
#line 45
  __obj___1 = (void *)0;
#line 45
  if ((unsigned long )__obj___1 > (unsigned long )((void *)__o___1->chunk)) {
#line 45
    if ((unsigned long )__obj___1 < (unsigned long )((void *)__o___1->chunk_limit)) {
#line 45
      tmp___1 = (char *)__obj___1;
#line 45
      __o___1->object_base = tmp___1;
#line 45
      __o___1->next_free = tmp___1;
    } else {
#line 45
      obstack_free(__o___1, __obj___1);
    }
  } else {
#line 45
    obstack_free(__o___1, __obj___1);
  }
#line 46
  return;
}
}
#line 50 "readtokens0.c"
static void save_token(struct Tokens *t ) 
{ size_t len ;
  struct obstack  const  *__o ;
  char const   *s ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp ;
  char *tmp___0 ;
  struct obstack *__o___0 ;
  struct obstack *__o1___0 ;
  struct obstack *__o___1 ;
  int __len ;

  {
#line 54
  __o = (struct obstack  const  *)(& t->o_data);
#line 54
  len = (size_t )((unsigned int )(__o->next_free - __o->object_base) - 1U);
#line 55
  __o1 = & t->o_data;
#line 55
  __value = (void *)__o1->object_base;
#line 55
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 55
    __o1->maybe_empty_object = 1U;
  }
#line 55
  if (sizeof(long ) < sizeof(void *)) {
#line 55
    tmp = __o1->object_base;
  } else {
#line 55
    tmp = (char *)0;
  }
#line 55
  if (sizeof(long ) < sizeof(void *)) {
#line 55
    tmp___0 = __o1->object_base;
  } else {
#line 55
    tmp___0 = (char *)0;
  }
#line 55
  __o1->next_free = tmp + (((__o1->next_free - tmp___0) + __o1->alignment_mask) & ~ __o1->alignment_mask);
#line 55
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 55
    __o1->next_free = __o1->chunk_limit;
  }
#line 55
  __o1->object_base = __o1->next_free;
#line 55
  s = (char const   *)__value;
#line 56
  __o___0 = & t->o_tok;
#line 56
  if ((unsigned long )(__o___0->next_free + sizeof(void *)) > (unsigned long )__o___0->chunk_limit) {
#line 56
    _obstack_newchunk(__o___0, (int )sizeof(void *));
  }
#line 56
  __o1___0 = __o___0;
#line 56
  *((void const   **)__o1___0->next_free) = (void const   *)s;
#line 56
  __o1___0->next_free += sizeof(void const   *);
#line 57
  __o___1 = & t->o_tok_len;
#line 57
  __len = (int )sizeof(len);
#line 57
  if ((unsigned long )(__o___1->next_free + __len) > (unsigned long )__o___1->chunk_limit) {
#line 57
    _obstack_newchunk(__o___1, __len);
  }
#line 57
  memcpy((void * __restrict  )__o___1->next_free, (void const   * __restrict  )(& len),
         (size_t )__len);
#line 57
  __o___1->next_free += __len;
#line 58
  (t->n_tok) ++;
#line 59
  return;
}
}
#line 65 "readtokens0.c"
_Bool readtokens0(FILE *in , struct Tokens *t ) 
{ int c ;
  int tmp ;
  size_t len ;
  struct obstack  const  *__o ;
  struct obstack *__o___0 ;
  char *tmp___0 ;
  struct obstack *__o___1 ;
  char *tmp___1 ;
  struct obstack *__o___2 ;
  struct obstack *__o1 ;
  struct obstack *__o1___0 ;
  void *__value ;
  char *tmp___2 ;
  char *tmp___3 ;
  struct obstack *__o1___1 ;
  void *__value___0 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 69
  while (1) {
#line 71
    tmp = fgetc(in);
#line 71
    c = tmp;
#line 72
    if (c == -1) {
#line 74
      __o = (struct obstack  const  *)(& t->o_data);
#line 74
      len = (size_t )((unsigned int )(__o->next_free - __o->object_base));
#line 78
      if (len) {
#line 80
        __o___0 = & t->o_data;
#line 80
        if ((unsigned long )(__o___0->next_free + 1) > (unsigned long )__o___0->chunk_limit) {
#line 80
          _obstack_newchunk(__o___0, 1);
        }
#line 80
        tmp___0 = __o___0->next_free;
#line 80
        (__o___0->next_free) ++;
#line 80
        *tmp___0 = (char )'\000';
#line 81
        save_token(t);
      }
#line 84
      break;
    }
#line 87
    __o___1 = & t->o_data;
#line 87
    if ((unsigned long )(__o___1->next_free + 1) > (unsigned long )__o___1->chunk_limit) {
#line 87
      _obstack_newchunk(__o___1, 1);
    }
#line 87
    tmp___1 = __o___1->next_free;
#line 87
    (__o___1->next_free) ++;
#line 87
    *tmp___1 = (char )c;
#line 88
    if (c == 0) {
#line 89
      save_token(t);
    }
  }
#line 94
  __o___2 = & t->o_tok;
#line 94
  if ((unsigned long )(__o___2->next_free + sizeof(void *)) > (unsigned long )__o___2->chunk_limit) {
#line 94
    _obstack_newchunk(__o___2, (int )sizeof(void *));
  }
#line 94
  __o1 = __o___2;
#line 94
  *((void const   **)__o1->next_free) = (void const   *)((void *)0);
#line 94
  __o1->next_free += sizeof(void const   *);
#line 96
  __o1___0 = & t->o_tok;
#line 96
  __value = (void *)__o1___0->object_base;
#line 96
  if ((unsigned long )__o1___0->next_free == (unsigned long )__value) {
#line 96
    __o1___0->maybe_empty_object = 1U;
  }
#line 96
  if (sizeof(long ) < sizeof(void *)) {
#line 96
    tmp___2 = __o1___0->object_base;
  } else {
#line 96
    tmp___2 = (char *)0;
  }
#line 96
  if (sizeof(long ) < sizeof(void *)) {
#line 96
    tmp___3 = __o1___0->object_base;
  } else {
#line 96
    tmp___3 = (char *)0;
  }
#line 96
  __o1___0->next_free = tmp___2 + (((__o1___0->next_free - tmp___3) + __o1___0->alignment_mask) & ~ __o1___0->alignment_mask);
#line 96
  if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 96
    __o1___0->next_free = __o1___0->chunk_limit;
  }
#line 96
  __o1___0->object_base = __o1___0->next_free;
#line 96
  t->tok = (char **)__value;
#line 97
  __o1___1 = & t->o_tok_len;
#line 97
  __value___0 = (void *)__o1___1->object_base;
#line 97
  if ((unsigned long )__o1___1->next_free == (unsigned long )__value___0) {
#line 97
    __o1___1->maybe_empty_object = 1U;
  }
#line 97
  if (sizeof(long ) < sizeof(void *)) {
#line 97
    tmp___4 = __o1___1->object_base;
  } else {
#line 97
    tmp___4 = (char *)0;
  }
#line 97
  if (sizeof(long ) < sizeof(void *)) {
#line 97
    tmp___5 = __o1___1->object_base;
  } else {
#line 97
    tmp___5 = (char *)0;
  }
#line 97
  __o1___1->next_free = tmp___4 + (((__o1___1->next_free - tmp___5) + __o1___1->alignment_mask) & ~ __o1___1->alignment_mask);
#line 97
  if (__o1___1->next_free - (char *)__o1___1->chunk > __o1___1->chunk_limit - (char *)__o1___1->chunk) {
#line 97
    __o1___1->next_free = __o1___1->chunk_limit;
  }
#line 97
  __o1___1->object_base = __o1___1->next_free;
#line 97
  t->tok_len = (size_t *)__value___0;
#line 98
  tmp___6 = ferror(in);
#line 98
  if (tmp___6) {
#line 98
    tmp___7 = 0;
  } else {
#line 98
    tmp___7 = 1;
  }
#line 98
  return ((_Bool )tmp___7);
}
}
#line 1 "safe-read.o"
#pragma merger(0,"/tmp/cil-DPlbovAN.i","-g,-O2")
#line 55 "safe-read.c"
size_t safe_read(int fd , void *buf___1 , size_t count ) 
{ ssize_t result ;
  ssize_t __attribute__((__artificial__))  tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  ssize_t __attribute__((__artificial__))  tmp___2 ;

  {
#line 64
  while (1) {
#line 66
    tmp___2 = (ssize_t __attribute__((__artificial__))  )read(fd, buf___1, count);
#line 66
    tmp = tmp___2;
#line 66
    result = (ssize_t )tmp;
#line 68
    if (0L <= result) {
#line 69
      return ((size_t )result);
    } else {
#line 70
      tmp___1 = __errno_location();
#line 70
      if (*tmp___1 == 4) {
#line 71
        goto __Cont;
      } else {
#line 72
        tmp___0 = __errno_location();
#line 72
        if (*tmp___0 == 22) {
#line 72
          if (2147475456UL < count) {
#line 73
            count = (size_t )2147475456;
          } else {
#line 75
            return ((size_t )result);
          }
        } else {
#line 75
          return ((size_t )result);
        }
      }
    }
    __Cont: ;
  }
}
}
#line 1 "safe-write.o"
#pragma merger(0,"/tmp/cil-ohokMdhK.i","-g,-O2")
#line 363 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n )  __attribute__((__warn_unused_result__)) ;
#line 55 "safe-read.c"
size_t safe_write(int fd , void const   *buf___1 , size_t count ) 
{ ssize_t result ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 64
  while (1) {
#line 66
    tmp = write(fd, buf___1, count);
#line 66
    result = tmp;
#line 68
    if (0L <= result) {
#line 69
      return ((size_t )result);
    } else {
#line 70
      tmp___1 = __errno_location();
#line 70
      if (*tmp___1 == 4) {
#line 71
        goto __Cont;
      } else {
#line 72
        tmp___0 = __errno_location();
#line 72
        if (*tmp___0 == 22) {
#line 72
          if (2147475456UL < count) {
#line 73
            count = (size_t )2147475456;
          } else {
#line 75
            return ((size_t )result);
          }
        } else {
#line 75
          return ((size_t )result);
        }
      }
    }
    __Cont: ;
  }
}
}
#line 1 "same.o"
#pragma merger(0,"/tmp/cil-cQzva3c7.i","-g,-O2")
#line 50 "same.c"
_Bool same_name(char const   *source , char const   *dest ) 
{ char const   *source_basename ;
  char *tmp ;
  char const   *dest_basename ;
  char *tmp___0 ;
  size_t source_baselen ;
  size_t tmp___1 ;
  size_t dest_baselen ;
  size_t tmp___2 ;
  _Bool identical_basenames ;
  int tmp___3 ;
  int tmp___4 ;
  _Bool compare_dirs ;
  _Bool same ;
  struct stat source_dir_stats ;
  struct stat dest_dir_stats ;
  char *source_dirname ;
  char *dest_dirname ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 54
  tmp = last_component(source);
#line 54
  source_basename = (char const   *)tmp;
#line 55
  tmp___0 = last_component(dest);
#line 55
  dest_basename = (char const   *)tmp___0;
#line 56
  tmp___1 = base_len(source_basename);
#line 56
  source_baselen = tmp___1;
#line 57
  tmp___2 = base_len(dest_basename);
#line 57
  dest_baselen = tmp___2;
#line 58
  if (source_baselen == dest_baselen) {
#line 58
    tmp___3 = memcmp((void const   *)source_basename, (void const   *)dest_basename,
                     dest_baselen);
#line 58
    if (tmp___3 == 0) {
#line 58
      tmp___4 = 1;
    } else {
#line 58
      tmp___4 = 0;
    }
  } else {
#line 58
    tmp___4 = 0;
  }
#line 58
  identical_basenames = (_Bool )tmp___4;
#line 61
  compare_dirs = identical_basenames;
#line 62
  same = (_Bool)0;
#line 75
  if (compare_dirs) {
#line 82
    source_dirname = dir_name(source);
#line 83
    dest_dirname = dir_name(dest);
#line 85
    tmp___6 = stat((char const   * __restrict  )source_dirname, (struct stat * __restrict  )(& source_dir_stats));
#line 85
    if (tmp___6) {
#line 88
      tmp___5 = __errno_location();
#line 88
      error(1, *tmp___5, "%s", source_dirname);
    }
#line 91
    tmp___8 = stat((char const   * __restrict  )dest_dirname, (struct stat * __restrict  )(& dest_dir_stats));
#line 91
    if (tmp___8) {
#line 94
      tmp___7 = __errno_location();
#line 94
      error(1, *tmp___7, "%s", dest_dirname);
    }
#line 97
    if (source_dir_stats.st_ino == dest_dir_stats.st_ino) {
#line 97
      if (source_dir_stats.st_dev == dest_dir_stats.st_dev) {
#line 97
        tmp___9 = 1;
      } else {
#line 97
        tmp___9 = 0;
      }
    } else {
#line 97
      tmp___9 = 0;
    }
#line 97
    same = (_Bool )tmp___9;
#line 118
    free((void *)source_dirname);
#line 119
    free((void *)dest_dirname);
  }
#line 122
  return (same);
}
}
#line 1 "save-cwd.o"
#pragma merger(0,"/tmp/cil-0qLmlpro.i","-g,-O2")
#line 30 "save-cwd.h"
int save_cwd(struct saved_cwd *cwd ) ;
#line 31
int restore_cwd(struct saved_cwd  const  *cwd ) ;
#line 32
void free_cwd(struct saved_cwd *cwd ) ;
#line 498 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int fchdir(int __fd )  __attribute__((__warn_unused_result__)) ;
#line 880 "./unistd.h"
char *rpl_getcwd(char *buf___1 , size_t size ) ;
#line 29 "chdir-long.h"
int chdir_long(char *dir ) ;
#line 62 "save-cwd.c"
int save_cwd(struct saved_cwd *cwd ) 
{ int tmp ;

  {
#line 65
  cwd->name = (char *)((void *)0);
#line 67
  cwd->desc = open_safer(".", 0);
#line 70
  if (cwd->desc < 0) {
#line 72
    cwd->name = rpl_getcwd((char *)((void *)0), (size_t )0);
#line 73
    if (cwd->name) {
#line 73
      tmp = 0;
    } else {
#line 73
      tmp = -1;
    }
#line 73
    return (tmp);
  }
#line 76
  set_cloexec_flag(cwd->desc, (_Bool)1);
#line 77
  return (0);
}
}
#line 84 "save-cwd.c"
int restore_cwd(struct saved_cwd  const  *cwd ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 87
  if (0 <= (int )cwd->desc) {
#line 88
    tmp = fchdir((int )cwd->desc);
#line 88
    return (tmp);
  } else {
#line 90
    tmp___0 = chdir_long((char *)cwd->name);
#line 90
    return (tmp___0);
  }
}
}
#line 93 "save-cwd.c"
void free_cwd(struct saved_cwd *cwd ) 
{ 

  {
#line 96
  if (cwd->desc >= 0) {
#line 97
    close(cwd->desc);
  }
#line 98
  free((void *)cwd->name);
#line 99
  return;
}
}
#line 1 "savedir.o"
#pragma merger(0,"/tmp/cil-YVxi3MsA.i","-g,-O2")
#line 25 "savedir.h"
char *streamsavedir(DIR *dirp ) ;
#line 26
char *savedir(char const   *dir ) ;
#line 27
char *fdsavedir(int fd ) ;
#line 50 "savedir.c"
char *streamsavedir(DIR *dirp ) 
{ char *name_space ;
  size_t allocated ;
  size_t used ;
  int save_errno ;
  void *tmp ;
  struct dirent  const  *dp ;
  char const   *entry ;
  int *tmp___0 ;
  struct dirent *tmp___1 ;
  size_t entry_size ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;

  {
#line 54
  allocated = (size_t )512;
#line 55
  used = (size_t )0;
#line 58
  if ((unsigned long )dirp == (unsigned long )((void *)0)) {
#line 59
    return ((char *)((void *)0));
  }
#line 61
  tmp = xmalloc(allocated);
#line 61
  name_space = (char *)tmp;
#line 63
  while (1) {
#line 68
    tmp___0 = __errno_location();
#line 68
    *tmp___0 = 0;
#line 69
    tmp___1 = readdir(dirp);
#line 69
    dp = (struct dirent  const  *)tmp___1;
#line 70
    if (! dp) {
#line 71
      break;
    }
#line 75
    entry = (char const   *)(dp->d_name);
#line 76
    if ((int const   )*(entry + 0) != 46) {
#line 76
      tmp___5 = 0;
    } else {
#line 76
      if ((int const   )*(entry + 1) != 46) {
#line 76
        tmp___4 = 1;
      } else {
#line 76
        tmp___4 = 2;
      }
#line 76
      tmp___5 = tmp___4;
    }
#line 76
    if ((int const   )*(entry + tmp___5) != 0) {
#line 78
      tmp___2 = strlen((char const   *)(dp->d_name));
#line 78
      entry_size = tmp___2 + 1UL;
#line 79
      if (used + entry_size < used) {
#line 80
        xalloc_die();
      }
#line 81
      if (allocated <= used + entry_size) {
#line 83
        while (1) {
#line 85
          if (2UL * allocated < allocated) {
#line 86
            xalloc_die();
          }
#line 87
          allocated *= 2UL;
#line 83
          if (! (allocated <= used + entry_size)) {
#line 83
            break;
          }
        }
#line 91
        tmp___3 = xrealloc((void *)name_space, allocated);
#line 91
        name_space = (char *)tmp___3;
      }
#line 93
      memcpy((void * __restrict  )(name_space + used), (void const   * __restrict  )entry,
             entry_size);
#line 94
      used += entry_size;
    }
  }
#line 97
  *(name_space + used) = (char )'\000';
#line 98
  tmp___6 = __errno_location();
#line 98
  save_errno = *tmp___6;
#line 99
  if (save_errno != 0) {
#line 101
    free((void *)name_space);
#line 102
    tmp___7 = __errno_location();
#line 102
    *tmp___7 = save_errno;
#line 103
    return ((char *)((void *)0));
  }
#line 105
  return (name_space);
}
}
#line 110 "savedir.c"
static char *savedirstream(DIR *dirp ) 
{ char *name_space ;
  char *tmp ;
  int save_errno ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
#line 113
  tmp = streamsavedir(dirp);
#line 113
  name_space = tmp;
#line 114
  if (dirp) {
#line 114
    tmp___2 = closedir(dirp);
#line 114
    if (tmp___2 != 0) {
#line 116
      tmp___0 = __errno_location();
#line 116
      save_errno = *tmp___0;
#line 117
      free((void *)name_space);
#line 118
      tmp___1 = __errno_location();
#line 118
      *tmp___1 = save_errno;
#line 119
      return ((char *)((void *)0));
    }
  }
#line 121
  return (name_space);
}
}
#line 129 "savedir.c"
char *savedir(char const   *dir ) 
{ DIR *tmp ;
  char *tmp___0 ;

  {
#line 132
  tmp = opendir_safer(dir);
#line 132
  tmp___0 = savedirstream(tmp);
#line 132
  return (tmp___0);
}
}
#line 141 "savedir.c"
char *fdsavedir(int fd ) 
{ DIR *tmp ;
  char *tmp___0 ;

  {
#line 144
  tmp = fdopendir(fd);
#line 144
  tmp___0 = savedirstream(tmp);
#line 144
  return (tmp___0);
}
}
#line 1 "savewd.o"
#pragma merger(0,"/tmp/cil-5AtEW1rz.i","-g,-O2")
#line 70 "savewd.h"
__inline static void savewd_init(struct savewd *wd ) 
{ 

  {
#line 73
  wd->state = (enum __anonenum_state_18 )0;
#line 74
  return;
}
}
#line 117
int savewd_restore(struct savewd *wd , int status ) ;
#line 128
void savewd_finish(struct savewd *wd ) ;
#line 144
int savewd_process_files(int n_files , char **file , int (*act)(char * , struct savewd * ,
                                                                void * ) , void *options ) ;
#line 104 "/usr/include/bits/sigset.h"
__inline extern int __sigismember(__sigset_t const   *__set , int __sig ) ;
#line 105
__inline extern int __sigaddset(__sigset_t *__set , int __sig ) ;
#line 106
__inline extern int __sigdelset(__sigset_t *__set , int __sig ) ;
#line 118 "/usr/include/bits/sigset.h"
__inline extern int __sigismember(__sigset_t const   *__set , int __sig ) 
{ unsigned long __mask ;
  unsigned long __word ;
  int tmp ;

  {
#line 118
  __mask = 1UL << (unsigned long )(__sig - 1) % (8UL * sizeof(unsigned long ));
#line 118
  __word = (unsigned long )(__sig - 1) / (8UL * sizeof(unsigned long ));
#line 118
  if (__set->__val[__word] & __mask) {
#line 118
    tmp = 1;
  } else {
#line 118
    tmp = 0;
  }
#line 118
  return (tmp);
}
}
#line 119 "/usr/include/bits/sigset.h"
__inline extern int __sigaddset(__sigset_t *__set , int __sig ) 
{ unsigned long __mask ;
  unsigned long __word ;

  {
#line 119
  __mask = 1UL << (unsigned long )(__sig - 1) % (8UL * sizeof(unsigned long ));
#line 119
  __word = (unsigned long )(__sig - 1) / (8UL * sizeof(unsigned long ));
#line 119
  __set->__val[__word] |= __mask;
#line 119
  return (0);
}
}
#line 120 "/usr/include/bits/sigset.h"
__inline extern int __sigdelset(__sigset_t *__set , int __sig ) 
{ unsigned long __mask ;
  unsigned long __word ;

  {
#line 120
  __mask = 1UL << (unsigned long )(__sig - 1) % (8UL * sizeof(unsigned long ));
#line 120
  __word = (unsigned long )(__sig - 1) / (8UL * sizeof(unsigned long ));
#line 120
  __set->__val[__word] &= ~ __mask;
#line 120
  return (0);
}
}
#line 138 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int raise(int __sig ) ;
#line 139 "/usr/include/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 494 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int chdir(char const   *__path )  __attribute__((__warn_unused_result__,
__nonnull__(1))) ;
#line 775
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 40 "savewd.c"
static _Bool savewd_save(struct savewd *wd ) 
{ int fd ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
#line 43
  switch ((int )wd->state) {
  case 0: 
#line 48
  tmp = open_safer(".", 0);
#line 48
  fd = tmp;
#line 49
  if (0 <= fd) {
#line 51
    wd->state = (enum __anonenum_state_18 )1;
#line 52
    wd->val.fd = fd;
#line 53
    break;
  }
#line 55
  tmp___1 = __errno_location();
#line 55
  if (*tmp___1 != 13) {
#line 55
    tmp___2 = __errno_location();
#line 55
    if (*tmp___2 != 116) {
#line 57
      wd->state = (enum __anonenum_state_18 )4;
#line 58
      tmp___0 = __errno_location();
#line 58
      wd->val.errnum = *tmp___0;
#line 59
      break;
    }
  }
#line 62
  wd->state = (enum __anonenum_state_18 )3;
#line 63
  wd->val.child = -1;
  case 3: 
#line 66
  if (wd->val.child < 0) {
#line 71
    wd->val.child = fork();
#line 72
    if (wd->val.child != 0) {
#line 74
      if (0 < wd->val.child) {
#line 75
        return ((_Bool)1);
      }
#line 76
      wd->state = (enum __anonenum_state_18 )4;
#line 77
      tmp___3 = __errno_location();
#line 77
      wd->val.errnum = *tmp___3;
    }
  }
#line 80
  break;
  case 1: 
  case 2: 
  case 4: 
  case 5: 
#line 86
  break;
  default: 
#line 89
  __assert_fail("0", "savewd.c", 89U, "savewd_save");
  }
#line 92
  return ((_Bool)0);
}
}
#line 95 "savewd.c"
int savewd_chdir(struct savewd *wd , char const   *dir , int options , int *open_result ) 
{ int fd ;
  int result ;
  int tmp ;
  int __attribute__((__artificial__))  tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  _Bool tmp___5 ;
  int e ;
  int *tmp___6 ;
  int *tmp___7 ;

  {
#line 99
  fd = -1;
#line 100
  result = 0;
#line 104
  if (open_result) {
#line 104
    goto _L;
  } else
#line 104
  if (options & 1) {
    _L: 
#line 107
    if (options & 1) {
#line 107
      tmp = 131072;
    } else {
#line 107
      tmp = 0;
    }
#line 107
    tmp___0 = open(dir, 67840 | tmp);
#line 107
    fd = (int )tmp___0;
#line 111
    if (open_result) {
#line 113
      *(open_result + 0) = fd;
#line 114
      tmp___1 = __errno_location();
#line 114
      *(open_result + 1) = *tmp___1;
    }
#line 117
    if (fd < 0) {
#line 117
      tmp___2 = __errno_location();
#line 117
      if (*tmp___2 != 13) {
#line 118
        result = -1;
      } else
#line 117
      if (options & 2) {
#line 118
        result = -1;
      }
    }
  }
#line 121
  if (result == 0) {
#line 121
    if (0 <= fd) {
#line 121
      if (! (options & 4)) {
#line 121
        goto _L___0;
      }
    } else {
      _L___0: 
#line 123
      tmp___5 = savewd_save(wd);
#line 123
      if (tmp___5) {
#line 125
        open_result = (int *)((void *)0);
#line 126
        result = -2;
      } else {
#line 130
        if (fd < 0) {
#line 130
          tmp___3 = chdir(dir);
#line 130
          result = tmp___3;
        } else {
#line 130
          tmp___4 = fchdir(fd);
#line 130
          result = tmp___4;
        }
#line 132
        if (result == 0) {
#line 133
          switch ((int )wd->state) {
          case 1: 
#line 136
          wd->state = (enum __anonenum_state_18 )2;
#line 137
          break;
          case 4: 
          case 2: 
          case 5: 
#line 142
          break;
          case 3: 
#line 145
          if (! (wd->val.child == 0)) {
#line 145
            __assert_fail("wd->val.child == 0", "savewd.c", 145U, "savewd_chdir");
          }
#line 146
          break;
          default: 
#line 149
          __assert_fail("0", "savewd.c", 149U, "savewd_chdir");
          }
        }
      }
    }
  }
#line 154
  if (0 <= fd) {
#line 154
    if (! open_result) {
#line 156
      tmp___6 = __errno_location();
#line 156
      e = *tmp___6;
#line 157
      close(fd);
#line 158
      tmp___7 = __errno_location();
#line 158
      *tmp___7 = e;
    }
  }
#line 161
  return (result);
}
}
#line 164 "savewd.c"
int savewd_restore(struct savewd *wd , int status ) 
{ int chdir_errno ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  pid_t child ;
  int child_status ;
  int *tmp___2 ;
  __pid_t tmp___3 ;
  union __anonunion_50 __constr_expr_0 ;
  union __anonunion_51 __constr_expr_1 ;
  union __anonunion_52 __constr_expr_2 ;

  {
#line 167
  switch ((int )wd->state) {
  case 0: 
  case 1: 
#line 173
  break;
  case 2: 
#line 177
  tmp___0 = fchdir(wd->val.fd);
#line 177
  if (tmp___0 == 0) {
#line 179
    wd->state = (enum __anonenum_state_18 )1;
#line 180
    break;
  } else {
#line 184
    tmp = __errno_location();
#line 184
    chdir_errno = *tmp;
#line 185
    close(wd->val.fd);
#line 186
    wd->state = (enum __anonenum_state_18 )4;
#line 187
    wd->val.errnum = chdir_errno;
  }
  case 4: 
#line 192
  tmp___1 = __errno_location();
#line 192
  *tmp___1 = wd->val.errnum;
#line 193
  return (-1);
  case 3: 
#line 199
  child = wd->val.child;
#line 200
  if (child == 0) {
#line 201
    _exit(status);
  }
#line 202
  if (0 < child) {
#line 205
    while (1) {
#line 205
      tmp___3 = waitpid(child, & child_status, 0);
#line 205
      if (! (tmp___3 < 0)) {
#line 205
        break;
      }
#line 206
      tmp___2 = __errno_location();
#line 206
      if (! (*tmp___2 == 4)) {
#line 206
        __assert_fail("(*__errno_location ()) == 4", "savewd.c", 206U, "savewd_restore");
      }
    }
#line 207
    wd->val.child = -1;
#line 208
    __constr_expr_1.__in = child_status;
#line 208
    if (! ((__constr_expr_1.__i & 127) == 0)) {
#line 209
      __constr_expr_0.__in = child_status;
#line 209
      raise(__constr_expr_0.__i & 127);
    }
#line 210
    __constr_expr_2.__in = child_status;
#line 210
    return ((__constr_expr_2.__i & 65280) >> 8);
  }
#line 213
  break;
  default: 
#line 216
  __assert_fail("0", "savewd.c", 216U, "savewd_restore");
  }
#line 219
  return (0);
}
}
#line 222 "savewd.c"
void savewd_finish(struct savewd *wd ) 
{ 

  {
#line 225
  switch ((int )wd->state) {
  case 0: 
  case 4: 
#line 229
  break;
  case 1: 
  case 2: 
#line 233
  close(wd->val.fd);
#line 234
  break;
  case 3: 
#line 237
  if (! (wd->val.child < 0)) {
#line 237
    __assert_fail("wd->val.child < 0", "savewd.c", 237U, "savewd_finish");
  }
#line 238
  break;
  default: 
#line 241
  __assert_fail("0", "savewd.c", 241U, "savewd_finish");
  }
#line 244
  wd->state = (enum __anonenum_state_18 )5;
#line 245
  return;
}
}
#line 257 "savewd.c"
__inline static _Bool savewd_delegating(struct savewd  const  *wd ) 
{ int tmp ;

  {
#line 260
  if ((unsigned int const   )wd->state == 3U) {
#line 260
    if (0 < (int )wd->val.child) {
#line 260
      tmp = 1;
    } else {
#line 260
      tmp = 0;
    }
  } else {
#line 260
    tmp = 0;
  }
#line 260
  return ((_Bool )tmp);
}
}
#line 263 "savewd.c"
int savewd_process_files(int n_files , char **file , int (*act)(char * , struct savewd * ,
                                                                void * ) , void *options ) 
{ int i ;
  int last_relative ;
  int exit_status ;
  struct savewd wd ;
  int s ;
  int tmp ;
  _Bool tmp___0 ;
  int r ;
  int tmp___1 ;
  int s___0 ;
  int tmp___2 ;

  {
#line 268
  i = 0;
#line 270
  exit_status = 0;
#line 272
  savewd_init(& wd);
#line 274
  last_relative = n_files - 1;
#line 274
  while (0 <= last_relative) {
#line 275
    if (! ((int )*(*(file + last_relative) + 0) == 47)) {
#line 276
      break;
    }
#line 274
    last_relative --;
  }
#line 278
  while (i < last_relative) {
#line 280
    tmp___0 = savewd_delegating((struct savewd  const  *)(& wd));
#line 280
    if (! tmp___0) {
#line 282
      tmp = (*act)(*(file + i), & wd, options);
#line 282
      s = tmp;
#line 283
      if (exit_status < s) {
#line 284
        exit_status = s;
      }
    }
#line 287
    if (! ((int )*(*(file + (i + 1)) + 0) == 47)) {
#line 289
      tmp___1 = savewd_restore(& wd, exit_status);
#line 289
      r = tmp___1;
#line 290
      if (exit_status < r) {
#line 291
        exit_status = r;
      }
    }
#line 278
    i ++;
  }
#line 295
  savewd_finish(& wd);
#line 297
  while (i < n_files) {
#line 299
    tmp___2 = (*act)(*(file + i), & wd, options);
#line 299
    s___0 = tmp___2;
#line 300
    if (exit_status < s___0) {
#line 301
      exit_status = s___0;
    }
#line 297
    i ++;
  }
#line 304
  return (exit_status);
}
}
#line 1 "settime.o"
#pragma merger(0,"/tmp/cil-MsxcN7lb.i","-g,-O2")
#line 339 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) int clock_settime(clockid_t __clock_id , struct timespec  const  *__tp ) ;
#line 80 "timespec.h"
int settime(struct timespec  const  *ts ) ;
#line 79 "/usr/include/sys/time.h"
extern  __attribute__((__nothrow__)) int settimeofday(struct timeval  const  *__tv ,
                                                      struct timezone  const  *__tz )  __attribute__((__nonnull__(1))) ;
#line 31 "settime.c"
int settime(struct timespec  const  *ts ) 
{ int r ;
  int tmp ;
  int *tmp___0 ;
  struct timeval tv ;
  int tmp___1 ;

  {
#line 36
  tmp = clock_settime(0, ts);
#line 36
  r = tmp;
#line 37
  if (r == 0) {
#line 38
    return (r);
  } else {
#line 37
    tmp___0 = __errno_location();
#line 37
    if (*tmp___0 == 1) {
#line 38
      return (r);
    }
  }
#line 46
  tv.tv_sec = (__time_t )ts->tv_sec;
#line 47
  tv.tv_usec = (__suseconds_t )(ts->tv_nsec / 1000L);
#line 48
  tmp___1 = settimeofday((struct timeval  const  *)(& tv), (struct timezone  const  *)0);
#line 48
  return (tmp___1);
}
}
#line 1 "sockets.o"
#pragma merger(0,"/tmp/cil-5JpnMsaY.i","-g,-O2")
#line 29 "sockets.h"
int gl_sockets_startup(int version  __attribute__((__unused__)) ) ;
#line 30
int gl_sockets_cleanup(void) ;
#line 110 "sockets.c"
int gl_sockets_startup(int version  __attribute__((__unused__)) ) 
{ 

  {
#line 134
  return (0);
}
}
#line 137 "sockets.c"
int gl_sockets_cleanup(void) 
{ 

  {
#line 152
  return (0);
}
}
#line 1 "mkstemp-safer.o"
#pragma merger(0,"/tmp/cil-PHAu3dOE.i","-g,-O2")
#line 20 "stdlib-safer.h"
int mkstemp_safer(char *templ ) ;
#line 620 "/usr/include/stdlib.h"
extern int mkstemp(char *__template )  __attribute__((__warn_unused_result__, __nonnull__(1))) ;
#line 30 "mkstemp-safer.c"
int mkstemp_safer(char *templ ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 33
  tmp = mkstemp(templ);
#line 33
  tmp___0 = fd_safer(tmp);
#line 33
  return (tmp___0);
}
}
#line 1 "strftime.o"
#pragma merger(0,"/tmp/cil-Vgk3scc8.i","-g,-O2")
#line 29 "strftime.h"
size_t nstrftime(char *s , size_t maxsize , char const   *format , struct tm  const  *tp ,
                 int ut , int ns ) ;
#line 319 "strftime.c"
static char *memcpy_lowcase(char *dest , char const   *src , size_t len ) 
{ int __res ;
  __int32_t const   **tmp___0 ;
  size_t tmp___1 ;

  {
#line 323
  while (1) {
#line 323
    tmp___1 = len;
#line 323
    len --;
#line 323
    if (! (tmp___1 > 0UL)) {
#line 323
      break;
    }
#line 324
    if (sizeof((unsigned char )*(src + len)) > 1UL) {
#line 324
      __res = tolower((int )((unsigned char )*(src + len)));
    } else {
#line 324
      tmp___0 = __ctype_tolower_loc();
#line 324
      __res = (int )*(*tmp___0 + (int )((unsigned char )*(src + len)));
    }
#line 324
    *(dest + len) = (char )__res;
  }
#line 325
  return (dest);
}
}
#line 328 "strftime.c"
static char *memcpy_uppcase(char *dest , char const   *src , size_t len ) 
{ int __res ;
  __int32_t const   **tmp___0 ;
  size_t tmp___1 ;

  {
#line 332
  while (1) {
#line 332
    tmp___1 = len;
#line 332
    len --;
#line 332
    if (! (tmp___1 > 0UL)) {
#line 332
      break;
    }
#line 333
    if (sizeof((unsigned char )*(src + len)) > 1UL) {
#line 333
      __res = toupper((int )((unsigned char )*(src + len)));
    } else {
#line 333
      tmp___0 = __ctype_toupper_loc();
#line 333
      __res = (int )*(*tmp___0 + (int )((unsigned char )*(src + len)));
    }
#line 333
    *(dest + len) = (char )__res;
  }
#line 334
  return (dest);
}
}
#line 423 "strftime.c"
static size_t strftime_case____0(_Bool upcase , char *s , size_t maxsize , char const   *format ,
                                 struct tm  const  *tp , int ut , int ns ) 
{ int hour12 ;
  char const   *zone ;
  size_t i ;
  char *p ;
  char const   *f ;
  int pad ;
  int modifier ;
  int digits ;
  int number_value ;
  unsigned int u_number_value ;
  _Bool negative_number ;
  _Bool always_output_a_sign ;
  int tz_colon_mask ;
  char const   *subfmt ;
  char sign_char ;
  char *bufp ;
  char buf___1[3UL + (((sizeof(time_t ) * 8UL - 1UL) * 146UL) / 485UL + 2UL)] ;
  int width ;
  _Bool to_lowcase ;
  _Bool to_uppcase ;
  size_t colons ;
  _Bool change_case ;
  int format_char ;
  size_t _n ;
  size_t _w ;
  int tmp ;
  size_t _incr ;
  size_t tmp___0 ;
  size_t _delta ;
  char const   *tmp___1 ;
  size_t _n___0 ;
  size_t _w___0 ;
  int tmp___2 ;
  size_t _incr___0 ;
  size_t tmp___3 ;
  size_t _delta___0 ;
  size_t len ;
  size_t tmp___4 ;
  size_t _n___1 ;
  size_t _w___1 ;
  int tmp___5 ;
  size_t _incr___1 ;
  size_t tmp___6 ;
  size_t _delta___1 ;
  char ufmt[5] ;
  char *u ;
  char ubuf[1024] ;
  size_t len___0 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  size_t _n___2 ;
  size_t _w___2 ;
  int tmp___11 ;
  size_t _incr___2 ;
  size_t tmp___12 ;
  size_t _delta___2 ;
  int century ;
  int tmp___13 ;
  int tmp___14 ;
  size_t _n___3 ;
  size_t _w___3 ;
  int tmp___15 ;
  size_t _incr___3 ;
  size_t tmp___16 ;
  size_t _delta___3 ;
  int padding ;
  size_t _n___4 ;
  size_t _w___4 ;
  int tmp___17 ;
  size_t _incr___4 ;
  size_t tmp___18 ;
  size_t _delta___4 ;
  size_t _n___5 ;
  size_t _w___5 ;
  int tmp___19 ;
  size_t _incr___5 ;
  size_t tmp___20 ;
  size_t _delta___5 ;
  size_t _n___6 ;
  size_t _w___6 ;
  int tmp___21 ;
  size_t _incr___6 ;
  size_t tmp___22 ;
  size_t _delta___6 ;
  size_t _n___7 ;
  size_t _w___7 ;
  int tmp___23 ;
  size_t _incr___7 ;
  size_t tmp___24 ;
  size_t _delta___7 ;
  int j ;
  size_t _n___8 ;
  size_t _w___8 ;
  int tmp___25 ;
  size_t _incr___8 ;
  size_t tmp___26 ;
  size_t _delta___8 ;
  struct tm ltm ;
  time_t t ;
  int d ;
  int tmp___27 ;
  size_t _n___9 ;
  size_t _w___9 ;
  int tmp___28 ;
  size_t _incr___9 ;
  size_t tmp___29 ;
  size_t _delta___9 ;
  int year___0 ;
  int tmp___30 ;
  int year_adjust ;
  int days ;
  int tmp___31 ;
  int tmp___32 ;
  int d___0 ;
  int tmp___33 ;
  int tmp___34 ;
  int yy ;
  int tmp___35 ;
  int yy___0 ;
  size_t _n___10 ;
  size_t tmp___36 ;
  size_t _w___10 ;
  int tmp___37 ;
  size_t _incr___10 ;
  size_t tmp___38 ;
  size_t _delta___10 ;
  int diff ;
  int hour_diff ;
  int min_diff ;
  int sec_diff ;
  int flen ;
  size_t _n___11 ;
  size_t _w___11 ;
  int tmp___39 ;
  size_t _incr___11 ;
  size_t tmp___40 ;
  size_t _delta___11 ;

  {
#line 436
  hour12 = (int )tp->tm_hour;
#line 461
  i = (size_t )0;
#line 462
  p = s;
#line 477
  zone = (char const   *)((void *)0);
#line 485
  zone = (char const   *)tp->tm_zone;
#line 503
  if (hour12 > 12) {
#line 504
    hour12 -= 12;
  } else
#line 506
  if (hour12 == 0) {
#line 507
    hour12 = 12;
  }
#line 509
  f = format;
#line 509
  while ((int const   )*f != 0) {
#line 511
    pad = 0;
#line 513
    digits = 0;
#line 527
    width = -1;
#line 528
    to_lowcase = (_Bool)0;
#line 529
    to_uppcase = upcase;
#line 531
    change_case = (_Bool)0;
#line 614
    if ((int const   )*f != 37) {
#line 616
      while (1) {
#line 616
        _n = (size_t )1;
#line 616
        if (width < 0) {
#line 616
          tmp = 0;
        } else {
#line 616
          tmp = width;
        }
#line 616
        _w = (size_t )tmp;
#line 616
        if (_n < _w) {
#line 616
          tmp___0 = _w;
        } else {
#line 616
          tmp___0 = _n;
        }
#line 616
        _incr = tmp___0;
#line 616
        if (_incr >= maxsize - i) {
#line 616
          return ((size_t )0);
        }
#line 616
        if (p) {
#line 616
          if (digits == 0) {
#line 616
            if (_n < _w) {
#line 616
              _delta = (size_t )width - _n;
#line 616
              if (pad == 48) {
#line 616
                memset((void *)p, '0', _delta);
#line 616
                p += _delta;
              } else {
#line 616
                memset((void *)p, ' ', _delta);
#line 616
                p += _delta;
              }
            }
          }
#line 616
          *p = (char )*f;
#line 616
          p += _n;
        }
#line 616
        i += _incr;
#line 616
        break;
      }
#line 617
      goto __Cont;
    }
#line 623
    while (1) {
#line 625
      f ++;
#line 625
      switch ((int )*f) {
      case 95: 
      case 45: 
      case 48: 
#line 631
      pad = (int )*f;
#line 632
      continue;
      case 94: 
#line 636
      to_uppcase = (_Bool)1;
#line 637
      continue;
      case 35: 
#line 639
      change_case = (_Bool)1;
#line 640
      continue;
      default: 
#line 643
      break;
      }
#line 645
      break;
    }
#line 649
    if ((unsigned int )*f - 48U <= 9U) {
#line 651
      width = 0;
#line 652
      while (1) {
#line 654
        if (width > 214748364) {
#line 657
          width = 2147483647;
        } else
#line 654
        if (width == 214748364) {
#line 654
          if ((int const   )*f - 48 > 7) {
#line 657
            width = 2147483647;
          } else {
#line 660
            width *= 10;
#line 661
            width += (int )((int const   )*f - 48);
          }
        } else {
#line 660
          width *= 10;
#line 661
          width += (int )((int const   )*f - 48);
        }
#line 663
        f ++;
#line 652
        if (! ((unsigned int )*f - 48U <= 9U)) {
#line 652
          break;
        }
      }
    }
#line 669
    switch ((int )*f) {
    case 69: 
    case 79: 
#line 673
    tmp___1 = f;
#line 673
    f ++;
#line 673
    modifier = (int )*tmp___1;
#line 674
    break;
    default: 
#line 677
    modifier = 0;
#line 678
    break;
    }
#line 682
    format_char = (int )*f;
#line 683
    switch (format_char) {
    case 37: 
#line 706
    if (modifier != 0) {
#line 707
      goto bad_format;
    }
#line 708
    while (1) {
#line 708
      _n___0 = (size_t )1;
#line 708
      if (width < 0) {
#line 708
        tmp___2 = 0;
      } else {
#line 708
        tmp___2 = width;
      }
#line 708
      _w___0 = (size_t )tmp___2;
#line 708
      if (_n___0 < _w___0) {
#line 708
        tmp___3 = _w___0;
      } else {
#line 708
        tmp___3 = _n___0;
      }
#line 708
      _incr___0 = tmp___3;
#line 708
      if (_incr___0 >= maxsize - i) {
#line 708
        return ((size_t )0);
      }
#line 708
      if (p) {
#line 708
        if (digits == 0) {
#line 708
          if (_n___0 < _w___0) {
#line 708
            _delta___0 = (size_t )width - _n___0;
#line 708
            if (pad == 48) {
#line 708
              memset((void *)p, '0', _delta___0);
#line 708
              p += _delta___0;
            } else {
#line 708
              memset((void *)p, ' ', _delta___0);
#line 708
              p += _delta___0;
            }
          }
        }
#line 708
        *p = (char )*f;
#line 708
        p += _n___0;
      }
#line 708
      i += _incr___0;
#line 708
      break;
    }
#line 709
    break;
    case 97: 
#line 712
    if (modifier != 0) {
#line 713
      goto bad_format;
    }
#line 714
    if (change_case) {
#line 716
      to_uppcase = (_Bool)1;
#line 717
      to_lowcase = (_Bool)0;
    }
#line 723
    goto underlying_strftime;
    case 65: 
#line 727
    if (modifier != 0) {
#line 728
      goto bad_format;
    }
#line 729
    if (change_case) {
#line 731
      to_uppcase = (_Bool)1;
#line 732
      to_lowcase = (_Bool)0;
    }
#line 738
    goto underlying_strftime;
    case 98: 
    case 104: 
#line 743
    if (change_case) {
#line 745
      to_uppcase = (_Bool)1;
#line 746
      to_lowcase = (_Bool)0;
    }
#line 748
    if (modifier != 0) {
#line 749
      goto bad_format;
    }
#line 754
    goto underlying_strftime;
    case 66: 
#line 758
    if (modifier != 0) {
#line 759
      goto bad_format;
    }
#line 760
    if (change_case) {
#line 762
      to_uppcase = (_Bool)1;
#line 763
      to_lowcase = (_Bool)0;
    }
#line 769
    goto underlying_strftime;
    case 99: 
#line 773
    if (modifier == 79) {
#line 774
      goto bad_format;
    }
#line 783
    goto underlying_strftime;
    subformat: 
#line 788
    tmp___4 = strftime_case____0(to_uppcase, (char *)((void *)0), (size_t )-1, subfmt,
                                 tp, ut, ns);
#line 788
    len = tmp___4;
#line 792
    while (1) {
#line 792
      _n___1 = len;
#line 792
      if (width < 0) {
#line 792
        tmp___5 = 0;
      } else {
#line 792
        tmp___5 = width;
      }
#line 792
      _w___1 = (size_t )tmp___5;
#line 792
      if (_n___1 < _w___1) {
#line 792
        tmp___6 = _w___1;
      } else {
#line 792
        tmp___6 = _n___1;
      }
#line 792
      _incr___1 = tmp___6;
#line 792
      if (_incr___1 >= maxsize - i) {
#line 792
        return ((size_t )0);
      }
#line 792
      if (p) {
#line 792
        if (digits == 0) {
#line 792
          if (_n___1 < _w___1) {
#line 792
            _delta___1 = (size_t )width - _n___1;
#line 792
            if (pad == 48) {
#line 792
              memset((void *)p, '0', _delta___1);
#line 792
              p += _delta___1;
            } else {
#line 792
              memset((void *)p, ' ', _delta___1);
#line 792
              p += _delta___1;
            }
          }
        }
#line 792
        strftime_case____0(to_uppcase, p, maxsize - i, subfmt, tp, ut, ns);
#line 792
        p += _n___1;
      }
#line 792
      i += _incr___1;
#line 792
      break;
    }
#line 797
    break;
    underlying_strftime: 
#line 805
    u = ufmt;
#line 818
    tmp___7 = u;
#line 818
    u ++;
#line 818
    *tmp___7 = (char )' ';
#line 819
    tmp___8 = u;
#line 819
    u ++;
#line 819
    *tmp___8 = (char )'%';
#line 820
    if (modifier != 0) {
#line 821
      tmp___9 = u;
#line 821
      u ++;
#line 821
      *tmp___9 = (char )modifier;
    }
#line 822
    tmp___10 = u;
#line 822
    u ++;
#line 822
    *tmp___10 = (char )format_char;
#line 823
    *u = (char )'\000';
#line 824
    len___0 = strftime((char * __restrict  )(ubuf), sizeof(ubuf), (char const   * __restrict  )(ufmt),
                       (struct tm  const  * __restrict  )tp);
#line 825
    if (len___0 != 0UL) {
#line 826
      while (1) {
#line 826
        _n___2 = len___0 - 1UL;
#line 826
        if (width < 0) {
#line 826
          tmp___11 = 0;
        } else {
#line 826
          tmp___11 = width;
        }
#line 826
        _w___2 = (size_t )tmp___11;
#line 826
        if (_n___2 < _w___2) {
#line 826
          tmp___12 = _w___2;
        } else {
#line 826
          tmp___12 = _n___2;
        }
#line 826
        _incr___2 = tmp___12;
#line 826
        if (_incr___2 >= maxsize - i) {
#line 826
          return ((size_t )0);
        }
#line 826
        if (p) {
#line 826
          if (digits == 0) {
#line 826
            if (_n___2 < _w___2) {
#line 826
              _delta___2 = (size_t )width - _n___2;
#line 826
              if (pad == 48) {
#line 826
                memset((void *)p, '0', _delta___2);
#line 826
                p += _delta___2;
              } else {
#line 826
                memset((void *)p, ' ', _delta___2);
#line 826
                p += _delta___2;
              }
            }
          }
#line 826
          if (to_lowcase) {
#line 826
            memcpy_lowcase(p, (char const   *)(ubuf + 1), _n___2);
          } else
#line 826
          if (to_uppcase) {
#line 826
            memcpy_uppcase(p, (char const   *)(ubuf + 1), _n___2);
          } else {
#line 826
            memcpy((void * __restrict  )((void *)p), (void const   * __restrict  )((void const   *)(ubuf + 1)),
                   _n___2);
          }
#line 826
          p += _n___2;
        }
#line 826
        i += _incr___2;
#line 826
        break;
      }
    }
#line 828
    break;
    case 67: 
#line 832
    if (modifier == 79) {
#line 833
      goto bad_format;
    }
#line 834
    if (modifier == 69) {
#line 850
      goto underlying_strftime;
    }
#line 855
    century = (int )(tp->tm_year / 100 + 19);
#line 856
    if (tp->tm_year % 100 < 0) {
#line 856
      if (0 < century) {
#line 856
        tmp___13 = 1;
      } else {
#line 856
        tmp___13 = 0;
      }
    } else {
#line 856
      tmp___13 = 0;
    }
#line 856
    century -= tmp___13;
#line 857
    digits = 2;
#line 857
    negative_number = (_Bool )(tp->tm_year < -1900);
#line 857
    u_number_value = (unsigned int )century;
#line 857
    goto do_signed_number;
    case 120: 
#line 861
    if (modifier == 79) {
#line 862
      goto bad_format;
    }
#line 871
    goto underlying_strftime;
    case 68: 
#line 874
    if (modifier != 0) {
#line 875
      goto bad_format;
    }
#line 876
    subfmt = "%m/%d/%y";
#line 877
    goto subformat;
    case 100: 
#line 880
    if (modifier == 69) {
#line 881
      goto bad_format;
    }
#line 883
    digits = 2;
#line 883
    number_value = (int )tp->tm_mday;
#line 883
    goto do_number;
    case 101: 
#line 886
    if (modifier == 69) {
#line 887
      goto bad_format;
    }
#line 889
    digits = 2;
#line 889
    number_value = (int )tp->tm_mday;
#line 889
    goto do_number_spacepad;
    do_tz_offset: 
#line 895
    always_output_a_sign = (_Bool)1;
#line 896
    goto do_number_body;
    do_number_spacepad: 
#line 900
    if (pad != 48) {
#line 900
      if (pad != 45) {
#line 901
        pad = '_';
      }
    }
    do_number: 
#line 905
    negative_number = (_Bool )(number_value < 0);
#line 906
    u_number_value = (unsigned int )number_value;
    do_signed_number: 
#line 909
    always_output_a_sign = (_Bool)0;
#line 910
    tz_colon_mask = 0;
    do_number_body: 
#line 918
    if (modifier == 79) {
#line 918
      if (! negative_number) {
#line 936
        goto underlying_strftime;
      }
    }
#line 940
    bufp = buf___1 + sizeof(buf___1) / sizeof(buf___1[0]);
#line 942
    if (negative_number) {
#line 943
      u_number_value = - u_number_value;
    }
#line 945
    while (1) {
#line 947
      if (tz_colon_mask & 1) {
#line 948
        bufp --;
#line 948
        *bufp = (char )':';
      }
#line 949
      tz_colon_mask >>= 1;
#line 950
      bufp --;
#line 950
      *bufp = (char )(u_number_value % 10U + 48U);
#line 951
      u_number_value /= 10U;
#line 945
      if (! (u_number_value != 0U)) {
#line 945
        if (! (tz_colon_mask != 0)) {
#line 945
          break;
        }
      }
    }
    do_number_sign_and_padding: 
#line 956
    if (digits < width) {
#line 957
      digits = width;
    }
#line 959
    if (negative_number) {
#line 959
      sign_char = (char )'-';
    } else {
#line 959
      if (always_output_a_sign) {
#line 959
        tmp___14 = '+';
      } else {
#line 959
        tmp___14 = 0;
      }
#line 959
      sign_char = (char )tmp___14;
    }
#line 963
    if (pad == 45) {
#line 965
      if (sign_char) {
#line 966
        while (1) {
#line 966
          _n___3 = (size_t )1;
#line 966
          if (width < 0) {
#line 966
            tmp___15 = 0;
          } else {
#line 966
            tmp___15 = width;
          }
#line 966
          _w___3 = (size_t )tmp___15;
#line 966
          if (_n___3 < _w___3) {
#line 966
            tmp___16 = _w___3;
          } else {
#line 966
            tmp___16 = _n___3;
          }
#line 966
          _incr___3 = tmp___16;
#line 966
          if (_incr___3 >= maxsize - i) {
#line 966
            return ((size_t )0);
          }
#line 966
          if (p) {
#line 966
            if (digits == 0) {
#line 966
              if (_n___3 < _w___3) {
#line 966
                _delta___3 = (size_t )width - _n___3;
#line 966
                if (pad == 48) {
#line 966
                  memset((void *)p, '0', _delta___3);
#line 966
                  p += _delta___3;
                } else {
#line 966
                  memset((void *)p, ' ', _delta___3);
#line 966
                  p += _delta___3;
                }
              }
            }
#line 966
            *p = sign_char;
#line 966
            p += _n___3;
          }
#line 966
          i += _incr___3;
#line 966
          break;
        }
      }
    } else {
#line 970
      padding = (digits - ((buf___1 + sizeof(buf___1) / sizeof(buf___1[0])) - bufp)) - ! (! sign_char);
#line 973
      if (padding > 0) {
#line 975
        if (pad == 95) {
#line 977
          if ((size_t )padding >= maxsize - i) {
#line 978
            return ((size_t )0);
          }
#line 980
          if (p) {
#line 981
            memset((void *)p, ' ', (size_t )padding);
#line 981
            p += padding;
          }
#line 982
          i += (size_t )padding;
#line 983
          if (width > padding) {
#line 983
            width -= padding;
          } else {
#line 983
            width = 0;
          }
#line 984
          if (sign_char) {
#line 985
            while (1) {
#line 985
              _n___4 = (size_t )1;
#line 985
              if (width < 0) {
#line 985
                tmp___17 = 0;
              } else {
#line 985
                tmp___17 = width;
              }
#line 985
              _w___4 = (size_t )tmp___17;
#line 985
              if (_n___4 < _w___4) {
#line 985
                tmp___18 = _w___4;
              } else {
#line 985
                tmp___18 = _n___4;
              }
#line 985
              _incr___4 = tmp___18;
#line 985
              if (_incr___4 >= maxsize - i) {
#line 985
                return ((size_t )0);
              }
#line 985
              if (p) {
#line 985
                if (digits == 0) {
#line 985
                  if (_n___4 < _w___4) {
#line 985
                    _delta___4 = (size_t )width - _n___4;
#line 985
                    if (pad == 48) {
#line 985
                      memset((void *)p, '0', _delta___4);
#line 985
                      p += _delta___4;
                    } else {
#line 985
                      memset((void *)p, ' ', _delta___4);
#line 985
                      p += _delta___4;
                    }
                  }
                }
#line 985
                *p = sign_char;
#line 985
                p += _n___4;
              }
#line 985
              i += _incr___4;
#line 985
              break;
            }
          }
        } else {
#line 989
          if ((size_t )digits >= maxsize - i) {
#line 990
            return ((size_t )0);
          }
#line 992
          if (sign_char) {
#line 993
            while (1) {
#line 993
              _n___5 = (size_t )1;
#line 993
              if (width < 0) {
#line 993
                tmp___19 = 0;
              } else {
#line 993
                tmp___19 = width;
              }
#line 993
              _w___5 = (size_t )tmp___19;
#line 993
              if (_n___5 < _w___5) {
#line 993
                tmp___20 = _w___5;
              } else {
#line 993
                tmp___20 = _n___5;
              }
#line 993
              _incr___5 = tmp___20;
#line 993
              if (_incr___5 >= maxsize - i) {
#line 993
                return ((size_t )0);
              }
#line 993
              if (p) {
#line 993
                if (digits == 0) {
#line 993
                  if (_n___5 < _w___5) {
#line 993
                    _delta___5 = (size_t )width - _n___5;
#line 993
                    if (pad == 48) {
#line 993
                      memset((void *)p, '0', _delta___5);
#line 993
                      p += _delta___5;
                    } else {
#line 993
                      memset((void *)p, ' ', _delta___5);
#line 993
                      p += _delta___5;
                    }
                  }
                }
#line 993
                *p = sign_char;
#line 993
                p += _n___5;
              }
#line 993
              i += _incr___5;
#line 993
              break;
            }
          }
#line 995
          if (p) {
#line 996
            memset((void *)p, '0', (size_t )padding);
#line 996
            p += padding;
          }
#line 997
          i += (size_t )padding;
#line 998
          width = 0;
        }
      } else
#line 1003
      if (sign_char) {
#line 1004
        while (1) {
#line 1004
          _n___6 = (size_t )1;
#line 1004
          if (width < 0) {
#line 1004
            tmp___21 = 0;
          } else {
#line 1004
            tmp___21 = width;
          }
#line 1004
          _w___6 = (size_t )tmp___21;
#line 1004
          if (_n___6 < _w___6) {
#line 1004
            tmp___22 = _w___6;
          } else {
#line 1004
            tmp___22 = _n___6;
          }
#line 1004
          _incr___6 = tmp___22;
#line 1004
          if (_incr___6 >= maxsize - i) {
#line 1004
            return ((size_t )0);
          }
#line 1004
          if (p) {
#line 1004
            if (digits == 0) {
#line 1004
              if (_n___6 < _w___6) {
#line 1004
                _delta___6 = (size_t )width - _n___6;
#line 1004
                if (pad == 48) {
#line 1004
                  memset((void *)p, '0', _delta___6);
#line 1004
                  p += _delta___6;
                } else {
#line 1004
                  memset((void *)p, ' ', _delta___6);
#line 1004
                  p += _delta___6;
                }
              }
            }
#line 1004
            *p = sign_char;
#line 1004
            p += _n___6;
          }
#line 1004
          i += _incr___6;
#line 1004
          break;
        }
      }
    }
#line 1008
    while (1) {
#line 1008
      _n___7 = (size_t )((buf___1 + sizeof(buf___1) / sizeof(buf___1[0])) - bufp);
#line 1008
      if (width < 0) {
#line 1008
        tmp___23 = 0;
      } else {
#line 1008
        tmp___23 = width;
      }
#line 1008
      _w___7 = (size_t )tmp___23;
#line 1008
      if (_n___7 < _w___7) {
#line 1008
        tmp___24 = _w___7;
      } else {
#line 1008
        tmp___24 = _n___7;
      }
#line 1008
      _incr___7 = tmp___24;
#line 1008
      if (_incr___7 >= maxsize - i) {
#line 1008
        return ((size_t )0);
      }
#line 1008
      if (p) {
#line 1008
        if (digits == 0) {
#line 1008
          if (_n___7 < _w___7) {
#line 1008
            _delta___7 = (size_t )width - _n___7;
#line 1008
            if (pad == 48) {
#line 1008
              memset((void *)p, '0', _delta___7);
#line 1008
              p += _delta___7;
            } else {
#line 1008
              memset((void *)p, ' ', _delta___7);
#line 1008
              p += _delta___7;
            }
          }
        }
#line 1008
        if (to_lowcase) {
#line 1008
          memcpy_lowcase(p, (char const   *)bufp, _n___7);
        } else
#line 1008
        if (to_uppcase) {
#line 1008
          memcpy_uppcase(p, (char const   *)bufp, _n___7);
        } else {
#line 1008
          memcpy((void * __restrict  )((void *)p), (void const   * __restrict  )((void const   *)bufp),
                 _n___7);
        }
#line 1008
        p += _n___7;
      }
#line 1008
      i += _incr___7;
#line 1008
      break;
    }
#line 1009
    break;
    case 70: 
#line 1012
    if (modifier != 0) {
#line 1013
      goto bad_format;
    }
#line 1014
    subfmt = "%Y-%m-%d";
#line 1015
    goto subformat;
    case 72: 
#line 1018
    if (modifier == 69) {
#line 1019
      goto bad_format;
    }
#line 1021
    digits = 2;
#line 1021
    number_value = (int )tp->tm_hour;
#line 1021
    goto do_number;
    case 73: 
#line 1024
    if (modifier == 69) {
#line 1025
      goto bad_format;
    }
#line 1027
    digits = 2;
#line 1027
    number_value = hour12;
#line 1027
    goto do_number;
    case 107: 
#line 1030
    if (modifier == 69) {
#line 1031
      goto bad_format;
    }
#line 1033
    digits = 2;
#line 1033
    number_value = (int )tp->tm_hour;
#line 1033
    goto do_number_spacepad;
    case 108: 
#line 1036
    if (modifier == 69) {
#line 1037
      goto bad_format;
    }
#line 1039
    digits = 2;
#line 1039
    number_value = hour12;
#line 1039
    goto do_number_spacepad;
    case 106: 
#line 1042
    if (modifier == 69) {
#line 1043
      goto bad_format;
    }
#line 1045
    digits = 3;
#line 1045
    negative_number = (_Bool )(tp->tm_yday < -1);
#line 1045
    u_number_value = (unsigned int )tp->tm_yday + 1U;
#line 1045
    goto do_signed_number;
    case 77: 
#line 1048
    if (modifier == 69) {
#line 1049
      goto bad_format;
    }
#line 1051
    digits = 2;
#line 1051
    number_value = (int )tp->tm_min;
#line 1051
    goto do_number;
    case 109: 
#line 1054
    if (modifier == 69) {
#line 1055
      goto bad_format;
    }
#line 1057
    digits = 2;
#line 1057
    negative_number = (_Bool )(tp->tm_mon < -1);
#line 1057
    u_number_value = (unsigned int )tp->tm_mon + 1U;
#line 1057
    goto do_signed_number;
    case 78: 
#line 1061
    if (modifier == 69) {
#line 1062
      goto bad_format;
    }
#line 1064
    number_value = ns;
#line 1065
    if (width == -1) {
#line 1066
      width = 9;
    } else {
#line 1071
      j = width;
#line 1071
      while (j < 9) {
#line 1072
        number_value /= 10;
#line 1071
        j ++;
      }
    }
#line 1075
    digits = width;
#line 1075
    number_value = number_value;
#line 1075
    goto do_number;
    case 110: 
#line 1079
    while (1) {
#line 1079
      _n___8 = (size_t )1;
#line 1079
      if (width < 0) {
#line 1079
        tmp___25 = 0;
      } else {
#line 1079
        tmp___25 = width;
      }
#line 1079
      _w___8 = (size_t )tmp___25;
#line 1079
      if (_n___8 < _w___8) {
#line 1079
        tmp___26 = _w___8;
      } else {
#line 1079
        tmp___26 = _n___8;
      }
#line 1079
      _incr___8 = tmp___26;
#line 1079
      if (_incr___8 >= maxsize - i) {
#line 1079
        return ((size_t )0);
      }
#line 1079
      if (p) {
#line 1079
        if (digits == 0) {
#line 1079
          if (_n___8 < _w___8) {
#line 1079
            _delta___8 = (size_t )width - _n___8;
#line 1079
            if (pad == 48) {
#line 1079
              memset((void *)p, '0', _delta___8);
#line 1079
              p += _delta___8;
            } else {
#line 1079
              memset((void *)p, ' ', _delta___8);
#line 1079
              p += _delta___8;
            }
          }
        }
#line 1079
        *p = (char )'\n';
#line 1079
        p += _n___8;
      }
#line 1079
      i += _incr___8;
#line 1079
      break;
    }
#line 1080
    break;
    case 80: 
#line 1083
    to_lowcase = (_Bool)1;
#line 1085
    format_char = 'p';
    case 112: 
#line 1090
    if (change_case) {
#line 1092
      to_uppcase = (_Bool)0;
#line 1093
      to_lowcase = (_Bool)1;
    }
#line 1099
    goto underlying_strftime;
    case 82: 
#line 1103
    subfmt = "%H:%M";
#line 1104
    goto subformat;
    case 114: 
#line 1114
    goto underlying_strftime;
    case 83: 
#line 1118
    if (modifier == 69) {
#line 1119
      goto bad_format;
    }
#line 1121
    digits = 2;
#line 1121
    number_value = (int )tp->tm_sec;
#line 1121
    goto do_number;
    case 115: 
#line 1128
    ltm = (struct tm )*tp;
#line 1129
    t = mktime(& ltm);
#line 1134
    bufp = buf___1 + sizeof(buf___1) / sizeof(buf___1[0]);
#line 1135
    negative_number = (_Bool )(t < 0L);
#line 1137
    while (1) {
#line 1139
      d = (int )(t % 10L);
#line 1140
      t /= 10L;
#line 1141
      bufp --;
#line 1141
      if (negative_number) {
#line 1141
        tmp___27 = - d;
      } else {
#line 1141
        tmp___27 = d;
      }
#line 1141
      *bufp = (char )(tmp___27 + 48);
#line 1137
      if (! (t != 0L)) {
#line 1137
        break;
      }
    }
#line 1145
    digits = 1;
#line 1146
    always_output_a_sign = (_Bool)0;
#line 1147
    goto do_number_sign_and_padding;
    case 88: 
#line 1151
    if (modifier == 79) {
#line 1152
      goto bad_format;
    }
#line 1161
    goto underlying_strftime;
    case 84: 
#line 1164
    subfmt = "%H:%M:%S";
#line 1165
    goto subformat;
    case 116: 
#line 1168
    while (1) {
#line 1168
      _n___9 = (size_t )1;
#line 1168
      if (width < 0) {
#line 1168
        tmp___28 = 0;
      } else {
#line 1168
        tmp___28 = width;
      }
#line 1168
      _w___9 = (size_t )tmp___28;
#line 1168
      if (_n___9 < _w___9) {
#line 1168
        tmp___29 = _w___9;
      } else {
#line 1168
        tmp___29 = _n___9;
      }
#line 1168
      _incr___9 = tmp___29;
#line 1168
      if (_incr___9 >= maxsize - i) {
#line 1168
        return ((size_t )0);
      }
#line 1168
      if (p) {
#line 1168
        if (digits == 0) {
#line 1168
          if (_n___9 < _w___9) {
#line 1168
            _delta___9 = (size_t )width - _n___9;
#line 1168
            if (pad == 48) {
#line 1168
              memset((void *)p, '0', _delta___9);
#line 1168
              p += _delta___9;
            } else {
#line 1168
              memset((void *)p, ' ', _delta___9);
#line 1168
              p += _delta___9;
            }
          }
        }
#line 1168
        *p = (char )'\t';
#line 1168
        p += _n___9;
      }
#line 1168
      i += _incr___9;
#line 1168
      break;
    }
#line 1169
    break;
    case 117: 
#line 1172
    digits = 1;
#line 1172
    number_value = (int )(((tp->tm_wday - 1) + 7) % 7 + 1);
#line 1172
    goto do_number;
    case 85: 
#line 1175
    if (modifier == 69) {
#line 1176
      goto bad_format;
    }
#line 1178
    digits = 2;
#line 1178
    number_value = (int )(((tp->tm_yday - tp->tm_wday) + 7) / 7);
#line 1178
    goto do_number;
    case 86: 
    case 103: 
    case 71: 
#line 1183
    if (modifier == 69) {
#line 1184
      goto bad_format;
    }
#line 1190
    if (tp->tm_year < 0) {
#line 1190
      tmp___30 = 300;
    } else {
#line 1190
      tmp___30 = -100;
    }
#line 1190
    year___0 = (int )(tp->tm_year + (int const   )tmp___30);
#line 1194
    year_adjust = 0;
#line 1195
    tmp___31 = iso_week_days((int )tp->tm_yday, (int )tp->tm_wday);
#line 1195
    days = tmp___31;
#line 1197
    if (days < 0) {
#line 1200
      year_adjust = -1;
#line 1201
      if ((year___0 - 1) % 4 == 0) {
#line 1201
        if ((year___0 - 1) % 100 != 0) {
#line 1201
          tmp___32 = 1;
        } else
#line 1201
        if ((year___0 - 1) % 400 == 0) {
#line 1201
          tmp___32 = 1;
        } else {
#line 1201
          tmp___32 = 0;
        }
      } else {
#line 1201
        tmp___32 = 0;
      }
#line 1201
      days = iso_week_days((int )(tp->tm_yday + (int const   )(365 + tmp___32)), (int )tp->tm_wday);
    } else {
#line 1206
      if (year___0 % 4 == 0) {
#line 1206
        if (year___0 % 100 != 0) {
#line 1206
          tmp___33 = 1;
        } else
#line 1206
        if (year___0 % 400 == 0) {
#line 1206
          tmp___33 = 1;
        } else {
#line 1206
          tmp___33 = 0;
        }
      } else {
#line 1206
        tmp___33 = 0;
      }
#line 1206
      tmp___34 = iso_week_days((int )(tp->tm_yday - (int const   )(365 + tmp___33)),
                               (int )tp->tm_wday);
#line 1206
      d___0 = tmp___34;
#line 1208
      if (0 <= d___0) {
#line 1211
        year_adjust = 1;
#line 1212
        days = d___0;
      }
    }
#line 1216
    switch ((int )*f) {
    case 103: 
#line 1220
    yy = (int )((tp->tm_year % 100 + (int const   )year_adjust) % 100);
#line 1221
    digits = 2;
#line 1221
    if (0 <= yy) {
#line 1221
      number_value = yy;
    } else {
#line 1221
      if (tp->tm_year < (int const   )(-1900 - year_adjust)) {
#line 1221
        tmp___35 = - yy;
      } else {
#line 1221
        tmp___35 = yy + 100;
      }
#line 1221
      number_value = tmp___35;
    }
#line 1221
    goto do_number;
    case 71: 
#line 1229
    digits = 4;
#line 1229
    negative_number = (_Bool )(tp->tm_year < (int const   )(-1900 - year_adjust));
#line 1229
    u_number_value = ((unsigned int )tp->tm_year + 1900U) + (unsigned int )year_adjust;
#line 1229
    goto do_signed_number;
    default: 
#line 1234
    digits = 2;
#line 1234
    number_value = days / 7 + 1;
#line 1234
    goto do_number;
    }
    case 87: 
#line 1239
    if (modifier == 69) {
#line 1240
      goto bad_format;
    }
#line 1242
    digits = 2;
#line 1242
    number_value = (int )(((tp->tm_yday - ((tp->tm_wday - 1) + 7) % 7) + 7) / 7);
#line 1242
    goto do_number;
    case 119: 
#line 1245
    if (modifier == 69) {
#line 1246
      goto bad_format;
    }
#line 1248
    digits = 1;
#line 1248
    number_value = (int )tp->tm_wday;
#line 1248
    goto do_number;
    case 89: 
#line 1251
    if (modifier == 69) {
#line 1265
      goto underlying_strftime;
    }
#line 1268
    if (modifier == 79) {
#line 1269
      goto bad_format;
    } else {
#line 1271
      digits = 4;
    }
#line 1271
    negative_number = (_Bool )(tp->tm_year < -1900);
#line 1271
    u_number_value = (unsigned int )tp->tm_year + 1900U;
#line 1271
    goto do_signed_number;
    case 121: 
#line 1275
    if (modifier == 69) {
#line 1286
      goto underlying_strftime;
    }
#line 1291
    yy___0 = (int )(tp->tm_year % 100);
#line 1292
    if (yy___0 < 0) {
#line 1293
      if (tp->tm_year < -1900) {
#line 1293
        yy___0 = - yy___0;
      } else {
#line 1293
        yy___0 += 100;
      }
    }
#line 1294
    digits = 2;
#line 1294
    number_value = yy___0;
#line 1294
    goto do_number;
    case 90: 
#line 1298
    if (change_case) {
#line 1300
      to_uppcase = (_Bool)0;
#line 1301
      to_lowcase = (_Bool)1;
    }
#line 1309
    if (! zone) {
#line 1310
      zone = "";
    }
#line 1322
    while (1) {
#line 1322
      tmp___36 = strlen(zone);
#line 1322
      _n___10 = tmp___36;
#line 1322
      if (width < 0) {
#line 1322
        tmp___37 = 0;
      } else {
#line 1322
        tmp___37 = width;
      }
#line 1322
      _w___10 = (size_t )tmp___37;
#line 1322
      if (_n___10 < _w___10) {
#line 1322
        tmp___38 = _w___10;
      } else {
#line 1322
        tmp___38 = _n___10;
      }
#line 1322
      _incr___10 = tmp___38;
#line 1322
      if (_incr___10 >= maxsize - i) {
#line 1322
        return ((size_t )0);
      }
#line 1322
      if (p) {
#line 1322
        if (digits == 0) {
#line 1322
          if (_n___10 < _w___10) {
#line 1322
            _delta___10 = (size_t )width - _n___10;
#line 1322
            if (pad == 48) {
#line 1322
              memset((void *)p, '0', _delta___10);
#line 1322
              p += _delta___10;
            } else {
#line 1322
              memset((void *)p, ' ', _delta___10);
#line 1322
              p += _delta___10;
            }
          }
        }
#line 1322
        if (to_lowcase) {
#line 1322
          memcpy_lowcase(p, zone, _n___10);
        } else
#line 1322
        if (to_uppcase) {
#line 1322
          memcpy_uppcase(p, zone, _n___10);
        } else {
#line 1322
          memcpy((void * __restrict  )((void *)p), (void const   * __restrict  )((void const   *)zone),
                 _n___10);
        }
#line 1322
        p += _n___10;
      }
#line 1322
      i += _incr___10;
#line 1322
      break;
    }
#line 1324
    break;
    case 58: 
#line 1329
    colons = (size_t )1;
#line 1329
    while ((int const   )*(f + colons) == 58) {
#line 1330
      goto __Cont___0;
      __Cont___0: 
#line 1329
      colons ++;
    }
#line 1331
    if ((int const   )*(f + colons) != 122) {
#line 1332
      goto bad_format;
    }
#line 1333
    f += colons;
#line 1334
    goto do_z_conversion;
    case 122: 
#line 1337
    colons = (size_t )0;
    do_z_conversion: 
#line 1340
    if (tp->tm_isdst < 0) {
#line 1341
      break;
    }
#line 1349
    diff = (int )tp->tm_gmtoff;
#line 1386
    hour_diff = (diff / 60) / 60;
#line 1387
    min_diff = (diff / 60) % 60;
#line 1388
    sec_diff = diff % 60;
#line 1390
    switch ((int )colons) {
    case 0: 
#line 1393
    digits = 5;
#line 1393
    negative_number = (_Bool )(diff < 0);
#line 1393
    tz_colon_mask = 0;
#line 1393
    u_number_value = (unsigned int )(hour_diff * 100 + min_diff);
#line 1393
    goto do_tz_offset;
    tz_hh_mm: 
    case 1: 
#line 1396
    digits = 6;
#line 1396
    negative_number = (_Bool )(diff < 0);
#line 1396
    tz_colon_mask = 4;
#line 1396
    u_number_value = (unsigned int )(hour_diff * 100 + min_diff);
#line 1396
    goto do_tz_offset;
    tz_hh_mm_ss: 
    case 2: 
#line 1399
    digits = 9;
#line 1399
    negative_number = (_Bool )(diff < 0);
#line 1399
    tz_colon_mask = 20;
#line 1399
    u_number_value = (unsigned int )((hour_diff * 10000 + min_diff * 100) + sec_diff);
#line 1399
    goto do_tz_offset;
    case 3: 
#line 1403
    if (sec_diff != 0) {
#line 1404
      goto tz_hh_mm_ss;
    }
#line 1405
    if (min_diff != 0) {
#line 1406
      goto tz_hh_mm;
    }
#line 1407
    digits = 3;
#line 1407
    negative_number = (_Bool )(diff < 0);
#line 1407
    tz_colon_mask = 0;
#line 1407
    u_number_value = (unsigned int )hour_diff;
#line 1407
    goto do_tz_offset;
    default: 
#line 1410
    goto bad_format;
    }
    case 0: 
#line 1415
    f --;
    bad_format: 
    default: 
#line 1424
    flen = 1;
#line 1424
    while ((int const   )*(f + (1 - flen)) != 37) {
#line 1425
      goto __Cont___1;
      __Cont___1: 
#line 1424
      flen ++;
    }
#line 1426
    while (1) {
#line 1426
      _n___11 = (size_t )flen;
#line 1426
      if (width < 0) {
#line 1426
        tmp___39 = 0;
      } else {
#line 1426
        tmp___39 = width;
      }
#line 1426
      _w___11 = (size_t )tmp___39;
#line 1426
      if (_n___11 < _w___11) {
#line 1426
        tmp___40 = _w___11;
      } else {
#line 1426
        tmp___40 = _n___11;
      }
#line 1426
      _incr___11 = tmp___40;
#line 1426
      if (_incr___11 >= maxsize - i) {
#line 1426
        return ((size_t )0);
      }
#line 1426
      if (p) {
#line 1426
        if (digits == 0) {
#line 1426
          if (_n___11 < _w___11) {
#line 1426
            _delta___11 = (size_t )width - _n___11;
#line 1426
            if (pad == 48) {
#line 1426
              memset((void *)p, '0', _delta___11);
#line 1426
              p += _delta___11;
            } else {
#line 1426
              memset((void *)p, ' ', _delta___11);
#line 1426
              p += _delta___11;
            }
          }
        }
#line 1426
        if (to_lowcase) {
#line 1426
          memcpy_lowcase(p, f + (1 - flen), _n___11);
        } else
#line 1426
        if (to_uppcase) {
#line 1426
          memcpy_uppcase(p, f + (1 - flen), _n___11);
        } else {
#line 1426
          memcpy((void * __restrict  )((void *)p), (void const   * __restrict  )((void const   *)(f + (1 - flen))),
                 _n___11);
        }
#line 1426
        p += _n___11;
      }
#line 1426
      i += _incr___11;
#line 1426
      break;
    }
#line 1428
    break;
    }
    __Cont: 
#line 509
    f ++;
  }
#line 1433
  if (p) {
#line 1433
    if (maxsize != 0UL) {
#line 1434
      *p = (char )'\000';
    }
  }
#line 1437
  return (i);
}
}
#line 1446 "strftime.c"
size_t nstrftime(char *s , size_t maxsize , char const   *format , struct tm  const  *tp ,
                 int ut , int ns ) 
{ size_t tmp ;

  {
#line 1451
  tmp = strftime_case____0((_Bool)0, s, maxsize, format, tp, ut, ns);
#line 1451
  return (tmp);
}
}
#line 1 "striconv.o"
#pragma merger(0,"/tmp/cil-0_WHvV_A.i","-g,-O2")
#line 38 "/usr/include/iconv.h"
extern iconv_t iconv_open(char const   *__tocode , char const   *__fromcode ) ;
#line 43
extern size_t iconv(iconv_t __cd , char ** __restrict  __inbuf , size_t * __restrict  __inbytesleft ,
                    char ** __restrict  __outbuf , size_t * __restrict  __outbytesleft ) ;
#line 52
extern int iconv_close(iconv_t __cd ) ;
#line 47 "striconv.h"
int mem_cd_iconv(char const   *src , size_t srclen , iconv_t cd , char **resultp ,
                 size_t *lengthp ) ;
#line 58
char *str_cd_iconv(char const   *src , iconv_t cd ) ;
#line 69
char *str_iconv(char const   *src , char const   *from_codeset , char const   *to_codeset ) ;
#line 45 "striconv.c"
int mem_cd_iconv(char const   *src , size_t srclen , iconv_t cd , char **resultp ,
                 size_t *lengthp ) 
{ size_t length ;
  char *result ;
  size_t count ;
  union __anonunion_tmp_21 tmp ;
  char const   *inptr ;
  size_t insize ;
  char *outptr ;
  size_t outsize ;
  size_t res ;
  size_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *outptr___0 ;
  size_t outsize___0 ;
  size_t res___0 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  char const   *inptr___0 ;
  size_t insize___0 ;
  char *outptr___1 ;
  size_t outsize___1 ;
  size_t res___1 ;
  size_t tmp___6 ;
  int *tmp___7 ;
  size_t res___2 ;
  size_t tmp___8 ;
  int saved_errno ;
  int *tmp___9 ;
  int *tmp___10 ;

  {
#line 58
  iconv(cd, (char ** __restrict  )((void *)0), (size_t * __restrict  )((void *)0),
        (char ** __restrict  )((void *)0), (size_t * __restrict  )((void *)0));
#line 63
  count = (size_t )0;
#line 68
  inptr = src;
#line 69
  insize = srclen;
#line 71
  while (insize > 0UL) {
#line 73
    outptr = tmp.buf;
#line 74
    outsize = (size_t )4096;
#line 75
    tmp___0 = iconv(cd, (char ** __restrict  )((char **)(& inptr)), (size_t * __restrict  )(& insize),
                    (char ** __restrict  )(& outptr), (size_t * __restrict  )(& outsize));
#line 75
    res = tmp___0;
#line 79
    if (res == 0xffffffffffffffffUL) {
#line 81
      tmp___2 = __errno_location();
#line 81
      if (! (*tmp___2 == 7)) {
#line 83
        tmp___1 = __errno_location();
#line 83
        if (*tmp___1 == 22) {
#line 84
          break;
        } else {
#line 86
          return (-1);
        }
      }
    }
#line 99
    count += (size_t )(outptr - tmp.buf);
  }
#line 106
  outptr___0 = tmp.buf;
#line 107
  outsize___0 = (size_t )4096;
#line 108
  tmp___3 = iconv(cd, (char ** __restrict  )((void *)0), (size_t * __restrict  )((void *)0),
                  (char ** __restrict  )(& outptr___0), (size_t * __restrict  )(& outsize___0));
#line 108
  res___0 = tmp___3;
#line 110
  if (res___0 == 0xffffffffffffffffUL) {
#line 111
    return (-1);
  }
#line 112
  count += (size_t )(outptr___0 - tmp.buf);
#line 115
  length = count;
#line 119
  if (length == 0UL) {
#line 121
    *lengthp = (size_t )0;
#line 122
    return (0);
  }
#line 124
  if ((unsigned long )*resultp != (unsigned long )((void *)0)) {
#line 124
    if (*lengthp >= length) {
#line 125
      result = *resultp;
    } else {
#line 124
      goto _L;
    }
  } else {
    _L: 
#line 128
    tmp___4 = malloc(length);
#line 128
    result = (char *)tmp___4;
#line 129
    if ((unsigned long )result == (unsigned long )((void *)0)) {
#line 131
      tmp___5 = __errno_location();
#line 131
      *tmp___5 = 12;
#line 132
      return (-1);
    }
  }
#line 141
  iconv(cd, (char ** __restrict  )((void *)0), (size_t * __restrict  )((void *)0),
        (char ** __restrict  )((void *)0), (size_t * __restrict  )((void *)0));
#line 146
  inptr___0 = src;
#line 147
  insize___0 = srclen;
#line 148
  outptr___1 = result;
#line 149
  outsize___1 = length;
#line 151
  while (insize___0 > 0UL) {
#line 153
    tmp___6 = iconv(cd, (char ** __restrict  )((char **)(& inptr___0)), (size_t * __restrict  )(& insize___0),
                    (char ** __restrict  )(& outptr___1), (size_t * __restrict  )(& outsize___1));
#line 153
    res___1 = tmp___6;
#line 157
    if (res___1 == 0xffffffffffffffffUL) {
#line 159
      tmp___7 = __errno_location();
#line 159
      if (*tmp___7 == 22) {
#line 160
        break;
      } else {
#line 162
        goto fail;
      }
    }
  }
#line 181
  tmp___8 = iconv(cd, (char ** __restrict  )((void *)0), (size_t * __restrict  )((void *)0),
                  (char ** __restrict  )(& outptr___1), (size_t * __restrict  )(& outsize___1));
#line 181
  res___2 = tmp___8;
#line 183
  if (res___2 == 0xffffffffffffffffUL) {
#line 184
    goto fail;
  }
#line 187
  if (outsize___1 != 0UL) {
#line 188
    abort();
  }
#line 191
  *resultp = result;
#line 192
  *lengthp = length;
#line 194
  return (0);
  fail: 
#line 198
  if ((unsigned long )result != (unsigned long )*resultp) {
#line 200
    tmp___9 = __errno_location();
#line 200
    saved_errno = *tmp___9;
#line 201
    free((void *)result);
#line 202
    tmp___10 = __errno_location();
#line 202
    *tmp___10 = saved_errno;
  }
#line 204
  return (-1);
}
}
#line 209 "striconv.c"
char *str_cd_iconv(char const   *src , iconv_t cd ) 
{ char *result ;
  size_t result_size ;
  size_t length ;
  char const   *inptr ;
  size_t inbytes_remaining ;
  size_t tmp ;
  size_t approx_sqrt_SIZE_MAX ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *outptr ;
  size_t outbytes_remaining ;
  size_t res ;
  size_t tmp___2 ;
  size_t used ;
  size_t newsize ;
  char *newresult ;
  int *tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  size_t res___0 ;
  size_t tmp___8 ;
  size_t used___0 ;
  size_t newsize___0 ;
  char *newresult___0 ;
  int *tmp___9 ;
  void *tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  char *smaller_result ;
  void *tmp___14 ;
  int saved_errno ;
  int *tmp___15 ;
  int *tmp___16 ;

  {
#line 258
  inptr = src;
#line 259
  tmp = strlen(src);
#line 259
  inbytes_remaining = tmp;
#line 264
  result_size = inbytes_remaining;
#line 266
  approx_sqrt_SIZE_MAX = 0xffffffffffffffffUL >> (sizeof(size_t ) * 8UL) / 2UL;
#line 267
  if (result_size <= approx_sqrt_SIZE_MAX / 16UL) {
#line 268
    result_size *= 16UL;
  }
#line 270
  result_size ++;
#line 272
  tmp___0 = malloc(result_size);
#line 272
  result = (char *)tmp___0;
#line 273
  if ((unsigned long )result == (unsigned long )((void *)0)) {
#line 275
    tmp___1 = __errno_location();
#line 275
    *tmp___1 = 12;
#line 276
    return ((char *)((void *)0));
  }
#line 284
  iconv(cd, (char ** __restrict  )((void *)0), (size_t * __restrict  )((void *)0),
        (char ** __restrict  )((void *)0), (size_t * __restrict  )((void *)0));
#line 289
  outptr = result;
#line 290
  outbytes_remaining = result_size - 1UL;
#line 292
  while (1) {
#line 296
    tmp___2 = iconv(cd, (char ** __restrict  )((char **)(& inptr)), (size_t * __restrict  )(& inbytes_remaining),
                    (char ** __restrict  )(& outptr), (size_t * __restrict  )(& outbytes_remaining));
#line 296
    res = tmp___2;
#line 300
    if (res == 0xffffffffffffffffUL) {
#line 302
      tmp___7 = __errno_location();
#line 302
      if (*tmp___7 == 22) {
#line 303
        break;
      } else {
#line 304
        tmp___6 = __errno_location();
#line 304
        if (*tmp___6 == 7) {
#line 306
          used = (size_t )(outptr - result);
#line 307
          newsize = result_size * 2UL;
#line 310
          if (! (newsize > result_size)) {
#line 312
            tmp___3 = __errno_location();
#line 312
            *tmp___3 = 12;
#line 313
            goto failed;
          }
#line 315
          tmp___4 = realloc((void *)result, newsize);
#line 315
          newresult = (char *)tmp___4;
#line 316
          if ((unsigned long )newresult == (unsigned long )((void *)0)) {
#line 318
            tmp___5 = __errno_location();
#line 318
            *tmp___5 = 12;
#line 319
            goto failed;
          }
#line 321
          result = newresult;
#line 322
          result_size = newsize;
#line 323
          outptr = result + used;
#line 324
          outbytes_remaining = (result_size - 1UL) - used;
        } else {
#line 327
          goto failed;
        }
      }
    } else {
#line 330
      break;
    }
  }
#line 336
  while (1) {
#line 339
    tmp___8 = iconv(cd, (char ** __restrict  )((void *)0), (size_t * __restrict  )((void *)0),
                    (char ** __restrict  )(& outptr), (size_t * __restrict  )(& outbytes_remaining));
#line 339
    res___0 = tmp___8;
#line 341
    if (res___0 == 0xffffffffffffffffUL) {
#line 343
      tmp___12 = __errno_location();
#line 343
      if (*tmp___12 == 7) {
#line 345
        used___0 = (size_t )(outptr - result);
#line 346
        newsize___0 = result_size * 2UL;
#line 349
        if (! (newsize___0 > result_size)) {
#line 351
          tmp___9 = __errno_location();
#line 351
          *tmp___9 = 12;
#line 352
          goto failed;
        }
#line 354
        tmp___10 = realloc((void *)result, newsize___0);
#line 354
        newresult___0 = (char *)tmp___10;
#line 355
        if ((unsigned long )newresult___0 == (unsigned long )((void *)0)) {
#line 357
          tmp___11 = __errno_location();
#line 357
          *tmp___11 = 12;
#line 358
          goto failed;
        }
#line 360
        result = newresult___0;
#line 361
        result_size = newsize___0;
#line 362
        outptr = result + used___0;
#line 363
        outbytes_remaining = (result_size - 1UL) - used___0;
      } else {
#line 366
        goto failed;
      }
    } else {
#line 369
      break;
    }
  }
#line 374
  tmp___13 = outptr;
#line 374
  outptr ++;
#line 374
  *tmp___13 = (char )'\000';
#line 376
  length = (size_t )(outptr - result);
#line 380
  if (length < result_size) {
#line 382
    tmp___14 = realloc((void *)result, length);
#line 382
    smaller_result = (char *)tmp___14;
#line 384
    if ((unsigned long )smaller_result != (unsigned long )((void *)0)) {
#line 385
      result = smaller_result;
    }
  }
#line 388
  return (result);
  failed: 
#line 392
  tmp___15 = __errno_location();
#line 392
  saved_errno = *tmp___15;
#line 393
  free((void *)result);
#line 394
  tmp___16 = __errno_location();
#line 394
  *tmp___16 = saved_errno;
#line 395
  return ((char *)((void *)0));
}
}
#line 403 "striconv.c"
char *str_iconv(char const   *src , char const   *from_codeset , char const   *to_codeset ) 
{ char *result ;
  char *tmp___4 ;
  int *tmp___5 ;
  iconv_t cd ;
  char *result___0 ;
  int saved_errno ;
  int *tmp___6 ;
  int *tmp___7 ;
  int saved_errno___0 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 406
  if ((int const   )*src == 0) {
#line 406
    goto _L;
  } else {
#line 406
    tmp___11 = c_strcasecmp(from_codeset, to_codeset);
#line 406
    if (tmp___11 == 0) {
      _L: 
#line 408
      tmp___4 = __strdup(src);
#line 408
      result = tmp___4;
#line 410
      if ((unsigned long )result == (unsigned long )((void *)0)) {
#line 411
        tmp___5 = __errno_location();
#line 411
        *tmp___5 = 12;
      }
#line 412
      return (result);
    } else {
#line 430
      cd = iconv_open(to_codeset, from_codeset);
#line 431
      if ((unsigned long )cd == (unsigned long )((iconv_t )-1)) {
#line 432
        return ((char *)((void *)0));
      }
#line 434
      result___0 = str_cd_iconv(src, cd);
#line 436
      if ((unsigned long )result___0 == (unsigned long )((void *)0)) {
#line 439
        tmp___6 = __errno_location();
#line 439
        saved_errno = *tmp___6;
#line 440
        iconv_close(cd);
#line 441
        tmp___7 = __errno_location();
#line 441
        *tmp___7 = saved_errno;
      } else {
#line 445
        tmp___10 = iconv_close(cd);
#line 445
        if (tmp___10 < 0) {
#line 449
          tmp___8 = __errno_location();
#line 449
          saved_errno___0 = *tmp___8;
#line 450
          free((void *)result___0);
#line 451
          tmp___9 = __errno_location();
#line 451
          *tmp___9 = saved_errno___0;
#line 452
          return ((char *)((void *)0));
        }
      }
#line 455
      return (result___0);
    }
  }
}
}
#line 1 "strnlen1.o"
#pragma merger(0,"/tmp/cil-PT4ALSOV.i","-g,-O2")
#line 27 "strnlen1.c"
size_t strnlen1(char const   *string , size_t maxlen ) 
{ char const   *end ;
  void *tmp ;

  {
#line 30
  tmp = memchr((void const   *)string, '\000', maxlen);
#line 30
  end = (char const   *)tmp;
#line 31
  if ((unsigned long )end != (unsigned long )((void *)0)) {
#line 32
    return ((size_t )((end - string) + 1));
  } else {
#line 34
    return (maxlen);
  }
}
}
#line 1 "tempname.o"
#pragma merger(0,"/tmp/cil-ej3yjBll.i","-g,-O2")
#line 50 "tempname.h"
int gen_tempname(char *tmpl , int suffixlen , int flags , int kind ) ;
#line 51
int gen_tempname_len(char *tmpl , int suffixlen , int flags , int kind , size_t x_suffix_len ) ;
#line 184 "tempname.c"
__inline static _Bool __attribute__((__pure__))  check_x_suffix(char const   *s ,
                                                                size_t len ) 
{ unsigned long tmp___8 ;

  {
#line 187
  tmp___8 = __builtin_strspn(s, "X");
#line 187
  return ((_Bool __attribute__((__pure__))  )(len <= tmp___8));
}
}
#line 191 "tempname.c"
static char const   letters[63]  = 
#line 191
  {      (char const   )'a',      (char const   )'b',      (char const   )'c',      (char const   )'d', 
        (char const   )'e',      (char const   )'f',      (char const   )'g',      (char const   )'h', 
        (char const   )'i',      (char const   )'j',      (char const   )'k',      (char const   )'l', 
        (char const   )'m',      (char const   )'n',      (char const   )'o',      (char const   )'p', 
        (char const   )'q',      (char const   )'r',      (char const   )'s',      (char const   )'t', 
        (char const   )'u',      (char const   )'v',      (char const   )'w',      (char const   )'x', 
        (char const   )'y',      (char const   )'z',      (char const   )'A',      (char const   )'B', 
        (char const   )'C',      (char const   )'D',      (char const   )'E',      (char const   )'F', 
        (char const   )'G',      (char const   )'H',      (char const   )'I',      (char const   )'J', 
        (char const   )'K',      (char const   )'L',      (char const   )'M',      (char const   )'N', 
        (char const   )'O',      (char const   )'P',      (char const   )'Q',      (char const   )'R', 
        (char const   )'S',      (char const   )'T',      (char const   )'U',      (char const   )'V', 
        (char const   )'W',      (char const   )'X',      (char const   )'Y',      (char const   )'Z', 
        (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'\000'};
#line 208 "tempname.c"
int gen_tempname_len(char *tmpl , int suffixlen , int flags , int kind , size_t x_suffix_len ) 
{ size_t len ;
  char *XXXXXX ;
  unsigned int count ;
  int fd ;
  int save_errno ;
  int *tmp ;
  struct stat st ;
  struct randint_source *rand_src ;
  unsigned int attempts ;
  int *tmp___0 ;
  _Bool __attribute__((__pure__))  tmp___1 ;
  size_t i ;
  randint tmp___2 ;
  int __attribute__((__artificial__))  tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int saved_errno ;
  int *tmp___10 ;
  int *tmp___11 ;

  {
#line 215
  fd = -1;
#line 216
  tmp = __errno_location();
#line 216
  save_errno = *tmp;
#line 234
  attempts = 238328U;
#line 237
  len = strlen((char const   *)tmpl);
#line 238
  if (len < x_suffix_len + (size_t )suffixlen) {
#line 242
    tmp___0 = __errno_location();
#line 242
    *tmp___0 = 22;
#line 243
    return (-1);
  } else {
#line 238
    tmp___1 = check_x_suffix((char const   *)(tmpl + ((len - x_suffix_len) - (size_t )suffixlen)),
                             x_suffix_len);
#line 238
    if (! tmp___1) {
#line 242
      tmp___0 = __errno_location();
#line 242
      *tmp___0 = 22;
#line 243
      return (-1);
    }
  }
#line 247
  XXXXXX = tmpl + ((len - x_suffix_len) - (size_t )suffixlen);
#line 250
  rand_src = randint_all_new((char const   *)((void *)0), x_suffix_len);
#line 251
  if (! rand_src) {
#line 252
    return (-1);
  }
#line 254
  count = 0U;
#line 254
  while (count < attempts) {
#line 258
    i = (size_t )0;
#line 258
    while (i < x_suffix_len) {
#line 259
      tmp___2 = randint_genmax(rand_src, sizeof(letters) - 2UL);
#line 259
      *(XXXXXX + i) = (char )letters[tmp___2];
#line 258
      i ++;
    }
#line 261
    switch (kind) {
    case 0: 
#line 264
    tmp___3 = open((char const   *)tmpl, (((flags & -4) | 2) | 64) | 128, 384);
#line 264
    fd = (int )tmp___3;
#line 267
    break;
    case 1: 
#line 270
    fd = mkdir((char const   *)tmpl, (__mode_t )448);
#line 271
    break;
    case 2: 
#line 278
    tmp___6 = lstat((char const   * __restrict  )tmpl, (struct stat * __restrict  )(& st));
#line 278
    if (tmp___6 < 0) {
#line 280
      tmp___5 = __errno_location();
#line 280
      if (*tmp___5 == 2) {
#line 282
        tmp___4 = __errno_location();
#line 282
        *tmp___4 = save_errno;
#line 283
        fd = 0;
#line 284
        goto done;
      } else {
#line 289
        fd = -1;
#line 290
        goto done;
      }
    }
#line 293
    goto __Cont;
    default: 
#line 296
    __assert_fail("! \"invalid KIND in __gen_tempname\"", "tempname.c", 296U, "gen_tempname_len");
#line 297
    abort();
    }
#line 300
    if (fd >= 0) {
#line 302
      tmp___7 = __errno_location();
#line 302
      *tmp___7 = save_errno;
#line 303
      goto done;
    } else {
#line 305
      tmp___8 = __errno_location();
#line 305
      if (*tmp___8 != 17) {
#line 307
        fd = -1;
#line 308
        goto done;
      }
    }
    __Cont: 
#line 254
    count ++;
  }
#line 312
  randint_all_free(rand_src);
#line 315
  tmp___9 = __errno_location();
#line 315
  *tmp___9 = 17;
#line 316
  return (-1);
  done: 
#line 320
  tmp___10 = __errno_location();
#line 320
  saved_errno = *tmp___10;
#line 321
  randint_all_free(rand_src);
#line 322
  tmp___11 = __errno_location();
#line 322
  *tmp___11 = saved_errno;
#line 324
  return (fd);
}
}
#line 327 "tempname.c"
int gen_tempname(char *tmpl , int suffixlen , int flags , int kind ) 
{ int tmp ;

  {
#line 330
  tmp = gen_tempname_len(tmpl, suffixlen, flags, kind, (size_t )6);
#line 330
  return (tmp);
}
}
#line 1 "threadlib.o"
#pragma merger(0,"/tmp/cil-tTwHArME.i","-g,-O2")
#line 1 "tls.o"
#pragma merger(0,"/tmp/cil-xo72We8h.i","-g,-O2")
#line 70 "./glthread/tls.h"
#pragma weak pthread_key_create
#line 71
#pragma weak pthread_getspecific
#line 72
#pragma weak pthread_setspecific
#line 73
#pragma weak pthread_key_delete
#line 75
#pragma weak pthread_self
#line 79
#pragma weak pthread_cancel
#line 1 "trim.o"
#pragma merger(0,"/tmp/cil-ObCOUqiD.i","-g,-O2")
#line 147 "/usr/include/wctype.h"
extern  __attribute__((__nothrow__)) int iswspace(wint_t __wc ) ;
#line 115 "mbiter.h"
__inline static void mbiter_multi_next(struct mbiter_multi *iter ) 
{ int tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;

  {
#line 118
  if (iter->next_done) {
#line 119
    return;
  }
#line 120
  if (iter->in_shift) {
#line 121
    goto with_shift;
  }
#line 123
  tmp___1 = is_basic((char )*(iter->cur.ptr));
#line 123
  if (tmp___1) {
#line 128
    iter->cur.bytes = (size_t )1;
#line 129
    iter->cur.wc = (wchar_t )*(iter->cur.ptr);
#line 130
    iter->cur.wc_valid = (_Bool)1;
  } else {
#line 134
    tmp = mbsinit((mbstate_t const   *)(& iter->state));
#line 134
    if (! tmp) {
#line 134
      __assert_fail("mbsinit (&iter->state)", "mbiter.h", 134U, "mbiter_multi_next");
    }
#line 135
    iter->in_shift = (_Bool)1;
    with_shift: 
#line 137
    iter->cur.bytes = mbrtowc((wchar_t * __restrict  )(& iter->cur.wc), (char const   * __restrict  )iter->cur.ptr,
                              (size_t )(iter->limit - iter->cur.ptr), & iter->state);
#line 139
    if (iter->cur.bytes == 0xffffffffffffffffUL) {
#line 142
      iter->cur.bytes = (size_t )1;
#line 143
      iter->cur.wc_valid = (_Bool)0;
    } else
#line 147
    if (iter->cur.bytes == 0xfffffffffffffffeUL) {
#line 150
      iter->cur.bytes = (size_t )(iter->limit - iter->cur.ptr);
#line 151
      iter->cur.wc_valid = (_Bool)0;
    } else {
#line 157
      if (iter->cur.bytes == 0UL) {
#line 160
        iter->cur.bytes = (size_t )1;
#line 161
        if (! ((int const   )*(iter->cur.ptr) == 0)) {
#line 161
          __assert_fail("*iter->cur.ptr == \'\\0\'", "mbiter.h", 161U, "mbiter_multi_next");
        }
#line 162
        if (! (iter->cur.wc == 0)) {
#line 162
          __assert_fail("iter->cur.wc == 0", "mbiter.h", 162U, "mbiter_multi_next");
        }
      }
#line 164
      iter->cur.wc_valid = (_Bool)1;
#line 168
      tmp___0 = mbsinit((mbstate_t const   *)(& iter->state));
#line 168
      if (tmp___0) {
#line 169
        iter->in_shift = (_Bool)0;
      }
    }
  }
#line 172
  iter->next_done = (_Bool)1;
#line 173
  return;
}
}
#line 40 "trim.c"
char *trim2(char const   *s , int how ) 
{ char *d ;
  char *tmp___4 ;
  mbi_iterator_t i ;
  size_t tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  unsigned int state ;
  char *r ;
  size_t tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char *p ;
  unsigned short const   **tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  unsigned short const   **tmp___17 ;
  size_t tmp___18 ;

  {
#line 45
  tmp___4 = __strdup(s);
#line 45
  d = tmp___4;
#line 47
  if (! d) {
#line 48
    xalloc_die();
  }
#line 50
  tmp___18 = __ctype_get_mb_cur_max();
#line 50
  if (tmp___18 > 1UL) {
#line 55
    if (how != 0) {
#line 57
      i.cur.ptr = (char const   *)d;
#line 57
      tmp___5 = strlen((char const   *)d);
#line 57
      i.limit = i.cur.ptr + tmp___5;
#line 57
      i.in_shift = (_Bool)0;
#line 57
      memset((void *)(& i.state), '\000', sizeof(mbstate_t ));
#line 57
      i.next_done = (_Bool)0;
#line 59
      while (1) {
#line 59
        if ((unsigned long )i.cur.ptr < (unsigned long )i.limit) {
#line 59
          mbiter_multi_next(& i);
#line 59
          if (i.cur.wc_valid) {
#line 59
            tmp___6 = iswspace((wint_t )i.cur.wc);
#line 59
            if (! tmp___6) {
#line 59
              break;
            }
          } else {
#line 59
            break;
          }
        } else {
#line 59
          break;
        }
#line 59
        i.cur.ptr += i.cur.bytes;
#line 59
        i.next_done = (_Bool)0;
      }
#line 62
      tmp___7 = strlen(i.cur.ptr);
#line 62
      memmove((void *)d, (void const   *)i.cur.ptr, tmp___7 + 1UL);
    }
#line 66
    if (how != 1) {
#line 68
      state = 0U;
#line 71
      i.cur.ptr = (char const   *)d;
#line 71
      tmp___8 = strlen((char const   *)d);
#line 71
      i.limit = i.cur.ptr + tmp___8;
#line 71
      i.in_shift = (_Bool)0;
#line 71
      memset((void *)(& i.state), '\000', sizeof(mbstate_t ));
#line 71
      i.next_done = (_Bool)0;
#line 73
      while (1) {
#line 73
        if ((unsigned long )i.cur.ptr < (unsigned long )i.limit) {
#line 73
          mbiter_multi_next(& i);
        } else {
#line 73
          break;
        }
#line 75
        if (state == 0U) {
#line 75
          if (i.cur.wc_valid) {
#line 75
            tmp___9 = iswspace((wint_t )i.cur.wc);
#line 75
            if (tmp___9) {
#line 76
              goto __Cont;
            }
          }
        }
#line 78
        if (state == 0U) {
#line 78
          if (i.cur.wc_valid) {
#line 78
            tmp___10 = iswspace((wint_t )i.cur.wc);
#line 78
            if (! tmp___10) {
#line 80
              state = 1U;
#line 81
              goto __Cont;
            }
          } else {
#line 80
            state = 1U;
#line 81
            goto __Cont;
          }
        }
#line 84
        if (state == 1U) {
#line 84
          if (i.cur.wc_valid) {
#line 84
            tmp___11 = iswspace((wint_t )i.cur.wc);
#line 84
            if (! tmp___11) {
#line 85
              goto __Cont;
            }
          } else {
#line 85
            goto __Cont;
          }
        }
#line 87
        if (state == 1U) {
#line 87
          if (i.cur.wc_valid) {
#line 87
            tmp___13 = iswspace((wint_t )i.cur.wc);
#line 87
            if (tmp___13) {
#line 89
              state = 2U;
#line 90
              r = (char *)i.cur.ptr;
            } else {
#line 87
              goto _L;
            }
          } else {
#line 87
            goto _L;
          }
        } else
        _L: 
#line 92
        if (state == 2U) {
#line 92
          if (i.cur.wc_valid) {
#line 92
            tmp___12 = iswspace((wint_t )i.cur.wc);
#line 92
            if (! tmp___12) {
#line 98
              state = 1U;
            }
          } else {
#line 98
            state = 1U;
          }
        } else {
#line 98
          state = 1U;
        }
        __Cont: 
#line 73
        i.cur.ptr += i.cur.bytes;
#line 73
        i.next_done = (_Bool)0;
      }
#line 102
      if (state == 2U) {
#line 103
        *r = (char )'\000';
      }
    }
  } else {
#line 111
    if (how != 0) {
#line 113
      p = d;
#line 113
      while (1) {
#line 113
        if (*p) {
#line 113
          tmp___14 = __ctype_b_loc();
#line 113
          if (! ((int const   )*(*tmp___14 + (int )((unsigned char )*p)) & 8192)) {
#line 113
            break;
          }
        } else {
#line 113
          break;
        }
#line 113
        p ++;
      }
#line 116
      tmp___15 = strlen((char const   *)p);
#line 116
      memmove((void *)d, (void const   *)p, tmp___15 + 1UL);
    }
#line 120
    if (how != 1) {
#line 122
      tmp___16 = strlen((char const   *)d);
#line 122
      p = (d + tmp___16) - 1;
#line 122
      while (1) {
#line 122
        if ((unsigned long )p >= (unsigned long )d) {
#line 122
          tmp___17 = __ctype_b_loc();
#line 122
          if (! ((int const   )*(*tmp___17 + (int )((unsigned char )*p)) & 8192)) {
#line 122
            break;
          }
        } else {
#line 122
          break;
        }
#line 124
        *p = (char )'\000';
#line 122
        p --;
      }
    }
  }
#line 128
  return (d);
}
}
#line 1 "unicodeio.o"
#pragma merger(0,"/tmp/cil-dAqw1FYr.i","-g,-O2")
#line 30 "unicodeio.h"
long unicode_to_mb(unsigned int code , long (*success)(char const   *buf , size_t buflen ,
                                                       void *callback_arg ) , long (*failure)(unsigned int code ,
                                                                                              char const   *msg ,
                                                                                              void *callback_arg ) ,
                   void *callback_arg ) ;
#line 40
void print_unicode_char(FILE *stream , unsigned int code , int exit_on_error ) ;
#line 45
long fwrite_success_callback(char const   *buf___1 , size_t buflen , void *callback_arg ) ;
#line 308 "unistr.h"
int u8_uctomb_aux(uint8_t *s , ucs4_t uc , int n ) ;
#line 314 "unistr.h"
__inline static int u8_uctomb(uint8_t *s , ucs4_t uc , int n ) 
{ int tmp ;

  {
#line 317
  if (uc < 128U) {
#line 317
    if (n > 0) {
#line 319
      *(s + 0) = (uint8_t )uc;
#line 320
      return (1);
    } else {
#line 323
      tmp = u8_uctomb_aux(s, uc, n);
#line 323
      return (tmp);
    }
  } else {
#line 323
    tmp = u8_uctomb_aux(s, uc, n);
#line 323
    return (tmp);
  }
}
}
#line 72 "unicodeio.c"
static int initialized  ;
#line 73 "unicodeio.c"
static int is_utf8  ;
#line 75 "unicodeio.c"
static iconv_t utf8_to_local  ;
#line 64 "unicodeio.c"
long unicode_to_mb(unsigned int code , long (*success)(char const   *buf , size_t buflen ,
                                                       void *callback_arg ) , long (*failure)(unsigned int code ,
                                                                                              char const   *msg ,
                                                                                              void *callback_arg ) ,
                   void *callback_arg ) 
{ char inbuf[6] ;
  int count ;
  char const   *charset ;
  char const   *tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___1 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  char outbuf[25] ;
  char const   *inptr ;
  size_t inbytesleft ;
  char *outptr ;
  size_t outbytesleft ;
  size_t res ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;

  {
#line 81
  if (! initialized) {
#line 83
    tmp = locale_charset();
#line 83
    charset = tmp;
#line 85
    if (0) {
#line 85
      __s1_len = __builtin_strlen(charset);
#line 85
      __s2_len = __builtin_strlen("UTF-8");
#line 85
      if (! ((size_t )((void const   *)(charset + 1)) - (size_t )((void const   *)charset) == 1UL)) {
#line 85
        goto _L___0;
      } else
#line 85
      if (__s1_len >= 4UL) {
        _L___0: 
#line 85
        if (! ((size_t )((void const   *)("UTF-8" + 1)) - (size_t )((void const   *)"UTF-8") == 1UL)) {
#line 85
          tmp___6 = 1;
        } else
#line 85
        if (__s2_len >= 4UL) {
#line 85
          tmp___6 = 1;
        } else {
#line 85
          tmp___6 = 0;
        }
      } else {
#line 85
        tmp___6 = 0;
      }
#line 85
      if (tmp___6) {
#line 85
        tmp___1 = __builtin_strcmp(charset, "UTF-8");
#line 85
        tmp___5 = tmp___1;
      } else {
#line 85
        tmp___4 = __builtin_strcmp(charset, "UTF-8");
#line 85
        tmp___5 = tmp___4;
      }
    } else {
#line 85
      tmp___4 = __builtin_strcmp(charset, "UTF-8");
#line 85
      tmp___5 = tmp___4;
    }
#line 85
    if (tmp___5) {
#line 85
      tmp___7 = 0;
    } else {
#line 85
      tmp___7 = 1;
    }
#line 85
    is_utf8 = tmp___7;
#line 87
    if (! is_utf8) {
#line 89
      utf8_to_local = iconv_open(charset, "UTF-8");
#line 90
      if ((unsigned long )utf8_to_local == (unsigned long )((iconv_t )-1)) {
#line 92
        utf8_to_local = iconv_open("ASCII", "UTF-8");
      }
    }
#line 95
    initialized = 1;
  }
#line 99
  if (! is_utf8) {
#line 102
    if ((unsigned long )utf8_to_local == (unsigned long )((iconv_t )-1)) {
#line 103
      tmp___8 = (*failure)(code, "iconv function not usable", callback_arg);
#line 103
      return (tmp___8);
    }
  }
#line 110
  count = u8_uctomb((unsigned char *)(inbuf), code, (int )sizeof(inbuf));
#line 111
  if (count < 0) {
#line 112
    tmp___9 = (*failure)(code, "character out of range", callback_arg);
#line 112
    return (tmp___9);
  }
#line 115
  if (! is_utf8) {
#line 124
    inptr = (char const   *)(inbuf);
#line 125
    inbytesleft = (size_t )count;
#line 126
    outptr = outbuf;
#line 127
    outbytesleft = sizeof(outbuf);
#line 130
    res = iconv(utf8_to_local, (char ** __restrict  )((char **)(& inptr)), (size_t * __restrict  )(& inbytesleft),
                (char ** __restrict  )(& outptr), (size_t * __restrict  )(& outbytesleft));
#line 133
    if (inbytesleft > 0UL) {
#line 139
      tmp___10 = (*failure)(code, (char const   *)((void *)0), callback_arg);
#line 139
      return (tmp___10);
    } else
#line 133
    if (res == 0xffffffffffffffffUL) {
#line 139
      tmp___10 = (*failure)(code, (char const   *)((void *)0), callback_arg);
#line 139
      return (tmp___10);
    }
#line 148
    res = iconv(utf8_to_local, (char ** __restrict  )((void *)0), (size_t * __restrict  )((void *)0),
                (char ** __restrict  )(& outptr), (size_t * __restrict  )(& outbytesleft));
#line 149
    if (res == 0xffffffffffffffffUL) {
#line 150
      tmp___11 = (*failure)(code, (char const   *)((void *)0), callback_arg);
#line 150
      return (tmp___11);
    }
#line 153
    tmp___12 = (*success)((char const   *)(outbuf), (size_t )(outptr - outbuf), callback_arg);
#line 153
    return (tmp___12);
  }
#line 158
  tmp___13 = (*success)((char const   *)(inbuf), (size_t )count, callback_arg);
#line 158
  return (tmp___13);
}
}
#line 163 "unicodeio.c"
long fwrite_success_callback(char const   *buf___1 , size_t buflen , void *callback_arg ) 
{ FILE *stream ;
  size_t __attribute__((__nonnull__(1,4)))  __x ;
  size_t __attribute__((__nonnull__(1,4)))  tmp ;

  {
#line 166
  stream = (FILE *)callback_arg;
#line 172
  tmp = rpl_fwrite((void const   *)buf___1, (size_t )1, buflen, stream);
#line 172
  __x = tmp;
#line 173
  return (0L);
}
}
#line 177 "unicodeio.c"
static long exit_failure_callback(unsigned int code , char const   *msg , void *callback_arg  __attribute__((__unused__)) ) 
{ char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 181
  if ((unsigned long )msg == (unsigned long )((void *)0)) {
#line 182
    tmp = dcgettext((char const   *)((void *)0), "cannot convert U+%04X to local character set",
                    5);
#line 182
    error(1, 0, (char const   *)tmp, code);
  } else {
#line 184
    tmp___0 = dcgettext((char const   *)((void *)0), msg, 5);
#line 184
    tmp___1 = dcgettext((char const   *)((void *)0), "cannot convert U+%04X to local character set: %s",
                        5);
#line 184
    error(1, 0, (char const   *)tmp___1, code, tmp___0);
  }
#line 186
  return (-1L);
}
}
#line 191 "unicodeio.c"
static long fallback_failure_callback(unsigned int code , char const   *msg  __attribute__((__unused__)) ,
                                      void *callback_arg ) 
{ FILE *stream ;

  {
#line 196
  stream = (FILE *)callback_arg;
#line 198
  if (code < 65536U) {
#line 199
    fprintf((FILE * __restrict  )stream, (char const   * __restrict  )"\\u%04X", code);
  } else {
#line 201
    fprintf((FILE * __restrict  )stream, (char const   * __restrict  )"\\U%08X", code);
  }
#line 202
  return (-1L);
}
}
#line 208 "unicodeio.c"
void print_unicode_char(FILE *stream , unsigned int code , int exit_on_error ) 
{ long (*tmp)(unsigned int code , char const   *msg , void *callback_arg  __attribute__((__unused__)) ) ;

  {
#line 211
  if (exit_on_error) {
#line 211
    tmp = & exit_failure_callback;
  } else {
#line 211
    tmp = & fallback_failure_callback;
  }
#line 211
  unicode_to_mb(code, & fwrite_success_callback, tmp, (void *)stream);
#line 216
  return;
}
}
#line 1 "dup-safer.o"
#pragma merger(0,"/tmp/cil-AYi53tKk.i","-g,-O2")
#line 30 "dup-safer.c"
int dup_safer(int fd ) 
{ int tmp ;

  {
#line 33
  tmp = rpl_fcntl(fd, 0, 3);
#line 33
  return (tmp);
}
}
#line 1 "fd-safer.o"
#pragma merger(0,"/tmp/cil-ukxG3iMV.i","-g,-O2")
#line 36 "fd-safer.c"
int fd_safer(int fd ) 
{ int f ;
  int tmp ;
  int e ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 39
  if (0 <= fd) {
#line 39
    if (fd <= 2) {
#line 41
      tmp = dup_safer(fd);
#line 41
      f = tmp;
#line 42
      tmp___0 = __errno_location();
#line 42
      e = *tmp___0;
#line 43
      close(fd);
#line 44
      tmp___1 = __errno_location();
#line 44
      *tmp___1 = e;
#line 45
      fd = f;
    }
  }
#line 48
  return (fd);
}
}
#line 1 "pipe-safer.o"
#pragma merger(0,"/tmp/cil-fayStalQ.i","-g,-O2")
#line 22 "unistd-safer.h"
int pipe_safer(int *fd ) ;
#line 414 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int pipe(int *__pipedes )  __attribute__((__warn_unused_result__)) ;
#line 30 "pipe-safer.c"
int pipe_safer(int *fd ) 
{ int i ;
  int e ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
#line 34
  tmp___1 = pipe(fd);
#line 34
  if (tmp___1 == 0) {
#line 37
    i = 0;
#line 37
    while (i < 2) {
#line 39
      *(fd + i) = fd_safer(*(fd + i));
#line 40
      if (*(fd + i) < 0) {
#line 42
        tmp = __errno_location();
#line 42
        e = *tmp;
#line 43
        close(*(fd + (1 - i)));
#line 44
        tmp___0 = __errno_location();
#line 44
        *tmp___0 = e;
#line 45
        return (-1);
      }
#line 37
      i ++;
    }
#line 49
    return (0);
  }
#line 55
  return (-1);
}
}
#line 1 "u8-mbtoucr.o"
#pragma merger(0,"/tmp/cil-EauEI7tM.i","-g,-O2")
#line 286 "./unistr.h"
int u8_mbtoucr(ucs4_t *puc , uint8_t const   *s , size_t n ) ;
#line 25 "unistr/u8-mbtoucr.c"
int u8_mbtoucr(ucs4_t *puc , uint8_t const   *s , size_t n ) 
{ uint8_t c ;

  {
#line 28
  c = (uint8_t )*s;
#line 30
  if ((int )c < 128) {
#line 32
    *puc = (ucs4_t )c;
#line 33
    return (1);
  } else
#line 35
  if ((int )c >= 194) {
#line 37
    if ((int )c < 224) {
#line 39
      if (n >= 2UL) {
#line 41
        if (((int const   )*(s + 1) ^ 128) < 64) {
#line 43
          *puc = ((unsigned int )((int )c & 31) << 6) | (unsigned int )((int const   )*(s + 1) ^ 128);
#line 45
          return (2);
        }
      } else {
#line 52
        *puc = (ucs4_t )65533;
#line 53
        return (-2);
      }
    } else
#line 56
    if ((int )c < 240) {
#line 58
      if (n >= 2UL) {
#line 60
        if (((int const   )*(s + 1) ^ 128) < 64) {
#line 60
          if ((int )c >= 225) {
#line 60
            goto _L___0;
          } else
#line 60
          if ((int const   )*(s + 1) >= 160) {
            _L___0: 
#line 60
            if ((int )c != 237) {
#line 60
              goto _L;
            } else
#line 60
            if ((int const   )*(s + 1) < 160) {
              _L: 
#line 64
              if (n >= 3UL) {
#line 66
                if (((int const   )*(s + 2) ^ 128) < 64) {
#line 68
                  *puc = (((unsigned int )((int )c & 15) << 12) | ((unsigned int )((int const   )*(s + 1) ^ 128) << 6)) | (unsigned int )((int const   )*(s + 2) ^ 128);
#line 71
                  return (3);
                }
              } else {
#line 78
                *puc = (ucs4_t )65533;
#line 79
                return (-2);
              }
            }
          }
        }
      } else {
#line 87
        *puc = (ucs4_t )65533;
#line 88
        return (-2);
      }
    } else
#line 91
    if ((int )c < 248) {
#line 93
      if (n >= 2UL) {
#line 95
        if (((int const   )*(s + 1) ^ 128) < 64) {
#line 95
          if ((int )c >= 241) {
#line 95
            goto _L___2;
          } else
#line 95
          if ((int const   )*(s + 1) >= 144) {
            _L___2: 
#line 95
            if ((int )c < 244) {
#line 95
              goto _L___1;
            } else
#line 95
            if ((int )c == 244) {
#line 95
              if ((int const   )*(s + 1) < 144) {
                _L___1: 
#line 102
                if (n >= 3UL) {
#line 104
                  if (((int const   )*(s + 2) ^ 128) < 64) {
#line 106
                    if (n >= 4UL) {
#line 108
                      if (((int const   )*(s + 3) ^ 128) < 64) {
#line 110
                        *puc = ((((unsigned int )((int )c & 7) << 18) | ((unsigned int )((int const   )*(s + 1) ^ 128) << 12)) | ((unsigned int )((int const   )*(s + 2) ^ 128) << 6)) | (unsigned int )((int const   )*(s + 3) ^ 128);
#line 114
                        return (4);
                      }
                    } else {
#line 121
                      *puc = (ucs4_t )65533;
#line 122
                      return (-2);
                    }
                  }
                } else {
#line 130
                  *puc = (ucs4_t )65533;
#line 131
                  return (-2);
                }
              }
            }
          }
        }
      } else {
#line 139
        *puc = (ucs4_t )65533;
#line 140
        return (-2);
      }
    }
  }
#line 285
  *puc = (ucs4_t )65533;
#line 286
  return (-1);
}
}
#line 1 "u8-uctomb.o"
#pragma merger(0,"/tmp/cil-bFKmN8Ow.i","-g,-O2")
#line 1 "u8-uctomb-aux.o"
#pragma merger(0,"/tmp/cil-udMJcUwR.i","-g,-O2")
#line 25 "unistr/u8-uctomb-aux.c"
int u8_uctomb_aux(uint8_t *s , ucs4_t uc , int n ) 
{ int count ;

  {
#line 30
  if (uc < 128U) {
#line 32
    return (-2);
  } else
#line 33
  if (uc < 2048U) {
#line 34
    count = 2;
  } else
#line 35
  if (uc < 65536U) {
#line 37
    if (uc < 55296U) {
#line 38
      count = 3;
    } else
#line 37
    if (uc >= 57344U) {
#line 38
      count = 3;
    } else {
#line 40
      return (-1);
    }
  } else
#line 50
  if (uc < 1114112U) {
#line 51
    count = 4;
  } else {
#line 54
    return (-1);
  }
#line 56
  if (n < count) {
#line 57
    return (-2);
  }
#line 59
  switch (count) {
  case 4: 
#line 65
  *(s + 3) = (uint8_t )(128U | (uc & 63U));
#line 65
  uc >>= 6;
#line 65
  uc |= 65536U;
  case 3: 
#line 66
  *(s + 2) = (uint8_t )(128U | (uc & 63U));
#line 66
  uc >>= 6;
#line 66
  uc |= 2048U;
  case 2: 
#line 67
  *(s + 1) = (uint8_t )(128U | (uc & 63U));
#line 67
  uc >>= 6;
#line 67
  uc |= 192U;
#line 68
  *(s + 0) = (uint8_t )uc;
  }
#line 70
  return (count);
}
}
#line 1 "width.o"
#pragma merger(0,"/tmp/cil-jSfps0FA.i","-g,-O2")
#line 43 "./uniwidth.h"
int uc_width(ucs4_t uc , char const   *encoding ) ;
#line 36 "./streq.h"
__inline static int streq9(char const   *s1 , char const   *s2 ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 39
  if (0) {
#line 39
    __s1_len = __builtin_strlen(s1 + 9);
#line 39
    __s2_len = __builtin_strlen(s2 + 9);
#line 39
    if (! ((size_t )((void const   *)((s1 + 9) + 1)) - (size_t )((void const   *)(s1 + 9)) == 1UL)) {
#line 39
      goto _L___0;
    } else
#line 39
    if (__s1_len >= 4UL) {
      _L___0: 
#line 39
      if (! ((size_t )((void const   *)((s2 + 9) + 1)) - (size_t )((void const   *)(s2 + 9)) == 1UL)) {
#line 39
        tmp___5 = 1;
      } else
#line 39
      if (__s2_len >= 4UL) {
#line 39
        tmp___5 = 1;
      } else {
#line 39
        tmp___5 = 0;
      }
    } else {
#line 39
      tmp___5 = 0;
    }
#line 39
    if (tmp___5) {
#line 39
      tmp___0 = __builtin_strcmp(s1 + 9, s2 + 9);
#line 39
      tmp___4 = tmp___0;
    } else {
#line 39
      tmp___3 = __builtin_strcmp(s1 + 9, s2 + 9);
#line 39
      tmp___4 = tmp___3;
    }
  } else {
#line 39
    tmp___3 = __builtin_strcmp(s1 + 9, s2 + 9);
#line 39
    tmp___4 = tmp___3;
  }
#line 39
  return (tmp___4 == 0);
}
}
#line 42 "./streq.h"
__inline static int streq8(char const   *s1 , char const   *s2 , char s28 ) 
{ int tmp ;

  {
#line 45
  if ((int const   )*(s1 + 8) == (int const   )s28) {
#line 47
    if ((int )s28 == 0) {
#line 48
      return (1);
    } else {
#line 50
      tmp = streq9(s1, s2);
#line 50
      return (tmp);
    }
  } else {
#line 53
    return (0);
  }
}
}
#line 56 "./streq.h"
__inline static int streq7(char const   *s1 , char const   *s2 , char s27 , char s28 ) 
{ int tmp ;

  {
#line 59
  if ((int const   )*(s1 + 7) == (int const   )s27) {
#line 61
    if ((int )s27 == 0) {
#line 62
      return (1);
    } else {
#line 64
      tmp = streq8(s1, s2, s28);
#line 64
      return (tmp);
    }
  } else {
#line 67
    return (0);
  }
}
}
#line 70 "./streq.h"
__inline static int streq6(char const   *s1 , char const   *s2 , char s26 , char s27 ,
                           char s28 ) 
{ int tmp ;

  {
#line 73
  if ((int const   )*(s1 + 6) == (int const   )s26) {
#line 75
    if ((int )s26 == 0) {
#line 76
      return (1);
    } else {
#line 78
      tmp = streq7(s1, s2, s27, s28);
#line 78
      return (tmp);
    }
  } else {
#line 81
    return (0);
  }
}
}
#line 84 "./streq.h"
__inline static int streq5(char const   *s1 , char const   *s2 , char s25 , char s26 ,
                           char s27 , char s28 ) 
{ int tmp ;

  {
#line 87
  if ((int const   )*(s1 + 5) == (int const   )s25) {
#line 89
    if ((int )s25 == 0) {
#line 90
      return (1);
    } else {
#line 92
      tmp = streq6(s1, s2, s26, s27, s28);
#line 92
      return (tmp);
    }
  } else {
#line 95
    return (0);
  }
}
}
#line 98 "./streq.h"
__inline static int streq4(char const   *s1 , char const   *s2 , char s24 , char s25 ,
                           char s26 , char s27 , char s28 ) 
{ int tmp ;

  {
#line 101
  if ((int const   )*(s1 + 4) == (int const   )s24) {
#line 103
    if ((int )s24 == 0) {
#line 104
      return (1);
    } else {
#line 106
      tmp = streq5(s1, s2, s25, s26, s27, s28);
#line 106
      return (tmp);
    }
  } else {
#line 109
    return (0);
  }
}
}
#line 112 "./streq.h"
__inline static int streq3(char const   *s1 , char const   *s2 , char s23 , char s24 ,
                           char s25 , char s26 , char s27 , char s28 ) 
{ int tmp ;

  {
#line 115
  if ((int const   )*(s1 + 3) == (int const   )s23) {
#line 117
    if ((int )s23 == 0) {
#line 118
      return (1);
    } else {
#line 120
      tmp = streq4(s1, s2, s24, s25, s26, s27, s28);
#line 120
      return (tmp);
    }
  } else {
#line 123
    return (0);
  }
}
}
#line 126 "./streq.h"
__inline static int streq2(char const   *s1 , char const   *s2 , char s22 , char s23 ,
                           char s24 , char s25 , char s26 , char s27 , char s28 ) 
{ int tmp ;

  {
#line 129
  if ((int const   )*(s1 + 2) == (int const   )s22) {
#line 131
    if ((int )s22 == 0) {
#line 132
      return (1);
    } else {
#line 134
      tmp = streq3(s1, s2, s23, s24, s25, s26, s27, s28);
#line 134
      return (tmp);
    }
  } else {
#line 137
    return (0);
  }
}
}
#line 140 "./streq.h"
__inline static int streq1(char const   *s1 , char const   *s2 , char s21 , char s22 ,
                           char s23 , char s24 , char s25 , char s26 , char s27 ,
                           char s28 ) 
{ int tmp ;

  {
#line 143
  if ((int const   )*(s1 + 1) == (int const   )s21) {
#line 145
    if ((int )s21 == 0) {
#line 146
      return (1);
    } else {
#line 148
      tmp = streq2(s1, s2, s22, s23, s24, s25, s26, s27, s28);
#line 148
      return (tmp);
    }
  } else {
#line 151
    return (0);
  }
}
}
#line 154 "./streq.h"
__inline static int streq0(char const   *s1 , char const   *s2 , char s20 , char s21 ,
                           char s22 , char s23 , char s24 , char s25 , char s26 ,
                           char s27 , char s28 ) 
{ int tmp ;

  {
#line 157
  if ((int const   )*(s1 + 0) == (int const   )s20) {
#line 159
    if ((int )s20 == 0) {
#line 160
      return (1);
    } else {
#line 162
      tmp = streq1(s1, s2, s21, s22, s23, s24, s25, s26, s27, s28);
#line 162
      return (tmp);
    }
  } else {
#line 165
    return (0);
  }
}
}
#line 22 "uniwidth/cjk.h"
static int is_cjk_encoding(char const   *encoding ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 25
  tmp = streq0(encoding, "EUC-JP", (char )'E', (char )'U', (char )'C', (char )'-',
               (char )'J', (char )'P', (char)0, (char)0, (char)0);
#line 25
  if (tmp) {
#line 37
    return (1);
  } else {
#line 25
    tmp___0 = streq0(encoding, "GB2312", (char )'G', (char )'B', (char )'2', (char )'3',
                     (char )'1', (char )'2', (char)0, (char)0, (char)0);
#line 25
    if (tmp___0) {
#line 37
      return (1);
    } else {
#line 25
      tmp___1 = streq0(encoding, "GBK", (char )'G', (char )'B', (char )'K', (char)0,
                       (char)0, (char)0, (char)0, (char)0, (char)0);
#line 25
      if (tmp___1) {
#line 37
        return (1);
      } else {
#line 25
        tmp___2 = streq0(encoding, "EUC-TW", (char )'E', (char )'U', (char )'C', (char )'-',
                         (char )'T', (char )'W', (char)0, (char)0, (char)0);
#line 25
        if (tmp___2) {
#line 37
          return (1);
        } else {
#line 25
          tmp___3 = streq0(encoding, "BIG5", (char )'B', (char )'I', (char )'G', (char )'5',
                           (char)0, (char)0, (char)0, (char)0, (char)0);
#line 25
          if (tmp___3) {
#line 37
            return (1);
          } else {
#line 25
            tmp___4 = streq0(encoding, "EUC-KR", (char )'E', (char )'U', (char )'C',
                             (char )'-', (char )'K', (char )'R', (char)0, (char)0,
                             (char)0);
#line 25
            if (tmp___4) {
#line 37
              return (1);
            } else {
#line 25
              tmp___5 = streq0(encoding, "CP949", (char )'C', (char )'P', (char )'9',
                               (char )'4', (char )'9', (char)0, (char)0, (char)0,
                               (char)0);
#line 25
              if (tmp___5) {
#line 37
                return (1);
              } else {
#line 25
                tmp___6 = streq0(encoding, "JOHAB", (char )'J', (char )'O', (char )'H',
                                 (char )'A', (char )'B', (char)0, (char)0, (char)0,
                                 (char)0);
#line 25
                if (tmp___6) {
#line 37
                  return (1);
                }
              }
            }
          }
        }
      }
    }
  }
#line 38
  return (0);
}
}
#line 37 "uniwidth/width.c"
static unsigned char const   nonspacing_table_data[1728]  = 
#line 37 "uniwidth/width.c"
  {      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )248,      (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )254,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )191, 
        (unsigned char const   )182,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )7, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192,      (unsigned char const   )191, 
        (unsigned char const   )159,      (unsigned char const   )61,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )2,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )192,      (unsigned char const   )255,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )15,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192,      (unsigned char const   )251, 
        (unsigned char const   )239,      (unsigned char const   )62,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )14, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )20, 
        (unsigned char const   )254,      (unsigned char const   )33,      (unsigned char const   )254,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )30,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )6,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )134,      (unsigned char const   )57,      (unsigned char const   )2,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )35,      (unsigned char const   )0, 
        (unsigned char const   )6,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )190,      (unsigned char const   )33,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )144, 
        (unsigned char const   )30,      (unsigned char const   )32,      (unsigned char const   )64,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )1,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192, 
        (unsigned char const   )193,      (unsigned char const   )61,      (unsigned char const   )96,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )0,      (unsigned char const   )48,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )30,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )4,      (unsigned char const   )92,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )242,      (unsigned char const   )7, 
        (unsigned char const   )128,      (unsigned char const   )127,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )242,      (unsigned char const   )27, 
        (unsigned char const   )0,      (unsigned char const   )63,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )3, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )160,      (unsigned char const   )2, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )254,      (unsigned char const   )127, 
        (unsigned char const   )223,      (unsigned char const   )224,      (unsigned char const   )255,      (unsigned char const   )254, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )31, 
        (unsigned char const   )64,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )224,      (unsigned char const   )253,      (unsigned char const   )102, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )195, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )30,      (unsigned char const   )0, 
        (unsigned char const   )100,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )32, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )224, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )28,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )28,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )12,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )12,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )176,      (unsigned char const   )63, 
        (unsigned char const   )64,      (unsigned char const   )254,      (unsigned char const   )15,      (unsigned char const   )32, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )56,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )135,      (unsigned char const   )1,      (unsigned char const   )4,      (unsigned char const   )14, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )1, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )64,      (unsigned char const   )127, 
        (unsigned char const   )229,      (unsigned char const   )31,      (unsigned char const   )248,      (unsigned char const   )159, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )208,      (unsigned char const   )23, 
        (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )15,      (unsigned char const   )0, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )60,      (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )64,      (unsigned char const   )163,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )240,      (unsigned char const   )207,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )247,      (unsigned char const   )255, 
        (unsigned char const   )253,      (unsigned char const   )33,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )127,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )240, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )124,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )31,      (unsigned char const   )252,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )252,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )6, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )7,      (unsigned char const   )48, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )68,      (unsigned char const   )8,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )96,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )16,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )192,      (unsigned char const   )63,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )128,      (unsigned char const   )255,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )200,      (unsigned char const   )19, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )126,      (unsigned char const   )102,      (unsigned char const   )0, 
        (unsigned char const   )8,      (unsigned char const   )16,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )157,      (unsigned char const   )193, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )32,      (unsigned char const   )33,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )64, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )127,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )14, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )32, 
        (unsigned char const   )110,      (unsigned char const   )240,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )135, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255, 
        (unsigned char const   )127,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )120,      (unsigned char const   )38, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )128,      (unsigned char const   )3,      (unsigned char const   )248,      (unsigned char const   )255, 
        (unsigned char const   )231,      (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )60,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )28,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0};
#line 282 "uniwidth/width.c"
static signed char const   nonspacing_table_ind[240]  = 
#line 282
  {      (signed char const   )0,      (signed char const   )1,      (signed char const   )2,      (signed char const   )3, 
        (signed char const   )4,      (signed char const   )5,      (signed char const   )6,      (signed char const   )7, 
        (signed char const   )8,      (signed char const   )9,      (signed char const   )-1,      (signed char const   )10, 
        (signed char const   )11,      (signed char const   )12,      (signed char const   )13,      (signed char const   )-1, 
        (signed char const   )14,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )15,      (signed char const   )-1, 
        (signed char const   )16,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )17, 
        (signed char const   )18,      (signed char const   )19,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )20,      (signed char const   )-1,      (signed char const   )21, 
        (signed char const   )22,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )23,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )24,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )25,      (signed char const   )26,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1};
#line 316 "uniwidth/width.c"
int uc_width(ucs4_t uc , char const   *encoding ) 
{ int ind___0 ;
  int tmp ;
  int tmp___0 ;

  {
#line 320
  if (uc >> 9 < 240U) {
#line 322
    ind___0 = (int )nonspacing_table_ind[uc >> 9];
#line 323
    if (ind___0 >= 0) {
#line 324
      if (((int const   )nonspacing_table_data[(unsigned int )(64 * ind___0) + ((uc >> 3) & 63U)] >> (uc & 7U)) & 1) {
#line 326
        if (uc > 0U) {
#line 326
          if (uc < 160U) {
#line 327
            return (-1);
          } else {
#line 329
            return (0);
          }
        } else {
#line 329
          return (0);
        }
      }
    }
  } else
#line 332
  if (uc >> 9 == (ucs4_t )(917504 >> 9)) {
#line 334
    if (uc >= 917760U) {
#line 336
      if (uc <= 917999U) {
#line 337
        return (0);
      }
    } else {
#line 341
      if (uc >= 917536U) {
#line 341
        tmp = uc <= 917631U;
      } else {
#line 341
        tmp = uc == 917505U;
      }
#line 341
      if (tmp) {
#line 342
        return (0);
      }
    }
  }
#line 349
  if (uc >= 4352U) {
#line 349
    if (uc < 4448U) {
#line 363
      return (2);
    } else
#line 349
    if (uc >= 9001U) {
#line 349
      if (uc < 9003U) {
#line 363
        return (2);
      } else {
#line 349
        goto _L___9;
      }
    } else
    _L___9: 
#line 349
    if (uc >= 11904U) {
#line 349
      if (uc < 42192U) {
#line 349
        if (! (uc == 12351U)) {
#line 349
          if (uc >= 19904U) {
#line 349
            if (uc < 19968U) {
#line 349
              goto _L___8;
            } else {
#line 363
              return (2);
            }
          } else {
#line 363
            return (2);
          }
        } else {
#line 349
          goto _L___8;
        }
      } else {
#line 349
        goto _L___8;
      }
    } else
    _L___8: 
#line 349
    if (uc >= 44032U) {
#line 349
      if (uc < 55204U) {
#line 363
        return (2);
      } else {
#line 349
        goto _L___5;
      }
    } else
    _L___5: 
#line 349
    if (uc >= 63744U) {
#line 349
      if (uc < 64256U) {
#line 363
        return (2);
      } else {
#line 349
        goto _L___4;
      }
    } else
    _L___4: 
#line 349
    if (uc >= 65040U) {
#line 349
      if (uc < 65056U) {
#line 363
        return (2);
      } else {
#line 349
        goto _L___3;
      }
    } else
    _L___3: 
#line 349
    if (uc >= 65072U) {
#line 349
      if (uc < 65136U) {
#line 363
        return (2);
      } else {
#line 349
        goto _L___2;
      }
    } else
    _L___2: 
#line 349
    if (uc >= 65280U) {
#line 349
      if (uc < 65377U) {
#line 363
        return (2);
      } else {
#line 349
        goto _L___1;
      }
    } else
    _L___1: 
#line 349
    if (uc >= 65504U) {
#line 349
      if (uc < 65511U) {
#line 363
        return (2);
      } else {
#line 349
        goto _L___0;
      }
    } else
    _L___0: 
#line 349
    if (uc >= 131072U) {
#line 349
      if (uc <= 196607U) {
#line 363
        return (2);
      } else {
#line 349
        goto _L;
      }
    } else
    _L: 
#line 349
    if (uc >= 196608U) {
#line 349
      if (uc <= 262143U) {
#line 363
        return (2);
      }
    }
  }
#line 366
  if (uc >= 161U) {
#line 366
    if (uc < 65377U) {
#line 366
      if (uc != 8361U) {
#line 366
        tmp___0 = is_cjk_encoding(encoding);
#line 366
        if (tmp___0) {
#line 368
          return (2);
        }
      }
    }
  }
#line 369
  return (1);
}
}
#line 1 "userspec.o"
#pragma merger(0,"/tmp/cil-UapQNMTJ.i","-g,-O2")
#line 6 "userspec.h"
char const   *parse_user_spec(char const   *spec , uid_t *uid , gid_t *gid , char **username ,
                              char **groupname ) ;
#line 79 "/usr/include/pwd.h"
extern void endpwent(void) ;
#line 45 "xstrtol.h"
strtol_error xstrtoul(char const   *s , char **ptr , int strtol_base , unsigned long *val ,
                      char const   *valid_suffixes ) ;
#line 106 "userspec.c"
static char const   *parse_with_separator(char const   *spec , char const   *separator ,
                                          uid_t *uid , gid_t *gid , char **username ,
                                          char **groupname ) ;
#line 106 "userspec.c"
static char const   *E_invalid_user  =    "invalid user";
#line 107 "userspec.c"
static char const   *E_invalid_group  =    "invalid group";
#line 108 "userspec.c"
static char const   *E_bad_spec  =    "invalid spec";
#line 101 "userspec.c"
static char const   *parse_with_separator(char const   *spec , char const   *separator ,
                                          uid_t *uid , gid_t *gid , char **username ,
                                          char **groupname ) 
{ char const   *error_msg ;
  struct passwd *pwd ;
  struct group *grp ;
  char *u ;
  char const   *g ;
  char *gname ;
  uid_t unum ;
  gid_t gnum ;
  char *tmp ;
  size_t ulen ;
  void *tmp___0 ;
  struct passwd *tmp___1 ;
  _Bool use_login_group ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  strtol_error tmp___4 ;
  char buf___1[((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL] ;
  char *tmp___5 ;
  char *tmp___6 ;
  struct group *tmp___7 ;
  unsigned long tmp___8 ;
  strtol_error tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;

  {
#line 115
  gname = (char *)((void *)0);
#line 116
  unum = *uid;
#line 117
  gnum = *gid;
#line 119
  error_msg = (char const   *)((void *)0);
#line 120
  tmp = (char *)((void *)0);
#line 120
  *groupname = tmp;
#line 120
  *username = tmp;
#line 126
  u = (char *)((void *)0);
#line 127
  if ((unsigned long )separator == (unsigned long )((void *)0)) {
#line 129
    if (*spec) {
#line 130
      u = xstrdup(spec);
    }
  } else {
#line 134
    ulen = (size_t )(separator - spec);
#line 135
    if (ulen != 0UL) {
#line 137
      tmp___0 = xmemdup((void const   *)spec, ulen + 1UL);
#line 137
      u = (char *)tmp___0;
#line 138
      *(u + ulen) = (char )'\000';
    }
  }
#line 142
  if ((unsigned long )separator == (unsigned long )((void *)0)) {
#line 142
    g = (char const   *)((void *)0);
  } else
#line 142
  if ((int const   )*(separator + 1) == 0) {
#line 142
    g = (char const   *)((void *)0);
  } else {
#line 142
    g = separator + 1;
  }
#line 155
  if ((unsigned long )u != (unsigned long )((void *)0)) {
#line 158
    if ((int )*u == 43) {
#line 158
      pwd = (struct passwd *)((void *)0);
    } else {
#line 158
      tmp___1 = getpwnam((char const   *)u);
#line 158
      pwd = tmp___1;
    }
#line 159
    if ((unsigned long )pwd == (unsigned long )((void *)0)) {
#line 161
      if ((unsigned long )separator != (unsigned long )((void *)0)) {
#line 161
        if ((unsigned long )g == (unsigned long )((void *)0)) {
#line 161
          tmp___2 = 1;
        } else {
#line 161
          tmp___2 = 0;
        }
      } else {
#line 161
        tmp___2 = 0;
      }
#line 161
      use_login_group = (_Bool )tmp___2;
#line 162
      if (use_login_group) {
#line 166
        error_msg = E_bad_spec;
      } else {
#line 171
        tmp___4 = xstrtoul((char const   *)u, (char **)((void *)0), 10, & tmp___3,
                           "");
#line 171
        if ((unsigned int )tmp___4 == 0U) {
#line 171
          if (tmp___3 <= 4294967295UL) {
#line 171
            if ((uid_t )tmp___3 != 4294967295U) {
#line 173
              unum = (uid_t )tmp___3;
            } else {
#line 175
              error_msg = E_invalid_user;
            }
          } else {
#line 175
            error_msg = E_invalid_user;
          }
        } else {
#line 175
          error_msg = E_invalid_user;
        }
      }
    } else {
#line 180
      unum = pwd->pw_uid;
#line 181
      if ((unsigned long )g == (unsigned long )((void *)0)) {
#line 181
        if ((unsigned long )separator != (unsigned long )((void *)0)) {
#line 186
          gnum = pwd->pw_gid;
#line 187
          grp = getgrgid(gnum);
#line 188
          if (grp) {
#line 188
            tmp___6 = grp->gr_name;
          } else {
#line 188
            tmp___11 = (char *)umaxtostr((uintmax_t )gnum, buf___1);
#line 188
            tmp___5 = tmp___11;
#line 188
            tmp___6 = tmp___5;
          }
#line 188
          gname = xstrdup((char const   *)tmp___6);
#line 189
          endgrent();
        }
      }
    }
#line 192
    endpwent();
  }
#line 195
  if ((unsigned long )g != (unsigned long )((void *)0)) {
#line 195
    if ((unsigned long )error_msg == (unsigned long )((void *)0)) {
#line 199
      if ((int const   )*g == 43) {
#line 199
        grp = (struct group *)((void *)0);
      } else {
#line 199
        tmp___7 = getgrnam(g);
#line 199
        grp = tmp___7;
      }
#line 200
      if ((unsigned long )grp == (unsigned long )((void *)0)) {
#line 203
        tmp___9 = xstrtoul(g, (char **)((void *)0), 10, & tmp___8, "");
#line 203
        if ((unsigned int )tmp___9 == 0U) {
#line 203
          if (tmp___8 <= 4294967295UL) {
#line 203
            if ((gid_t )tmp___8 != 4294967295U) {
#line 205
              gnum = (gid_t )tmp___8;
            } else {
#line 207
              error_msg = E_invalid_group;
            }
          } else {
#line 207
            error_msg = E_invalid_group;
          }
        } else {
#line 207
          error_msg = E_invalid_group;
        }
      } else {
#line 210
        gnum = grp->gr_gid;
      }
#line 211
      endgrent();
#line 212
      gname = xstrdup(g);
    }
  }
#line 215
  if ((unsigned long )error_msg == (unsigned long )((void *)0)) {
#line 217
    *uid = unum;
#line 218
    *gid = gnum;
#line 219
    *username = u;
#line 220
    *groupname = gname;
#line 221
    u = (char *)((void *)0);
  } else {
#line 224
    free((void *)gname);
  }
#line 226
  free((void *)u);
#line 227
  tmp___10 = dcgettext((char const   *)((void *)0), error_msg, 5);
#line 227
  return ((char const   *)tmp___10);
}
}
#line 246 "userspec.c"
char const   *parse_user_spec(char const   *spec , uid_t *uid , gid_t *gid , char **username ,
                              char **groupname ) 
{ char const   *colon ;
  char *tmp___0 ;
  char const   *error_msg ;
  char const   *tmp___1 ;
  char const   *dot ;
  char *tmp___3 ;
  char const   *tmp___4 ;

  {
#line 250
  tmp___0 = __builtin_strchr((char *)spec, ':');
#line 250
  colon = (char const   *)tmp___0;
#line 251
  tmp___1 = parse_with_separator(spec, colon, uid, gid, username, groupname);
#line 251
  error_msg = tmp___1;
#line 254
  if (! colon) {
#line 254
    if (error_msg) {
#line 262
      tmp___3 = __builtin_strchr((char *)spec, '.');
#line 262
      dot = (char const   *)tmp___3;
#line 263
      if (dot) {
#line 263
        tmp___4 = parse_with_separator(spec, dot, uid, gid, username, groupname);
#line 263
        if (! tmp___4) {
#line 265
          error_msg = (char const   *)((void *)0);
        }
      }
    }
  }
#line 268
  return (error_msg);
}
}
#line 1 "utimecmp.o"
#pragma merger(0,"/tmp/cil-OAYRSfav.i","-g,-O2")
#line 35 "utimecmp.h"
int utimecmp(char const   *dst_name , struct stat  const  *dst_stat , struct stat  const  *src_stat ,
             int options ) ;
#line 49 "stat-time.h"
__inline static long get_stat_atime_ns(struct stat  const  *st ) 
{ 

  {
#line 53
  return ((long )st->st_atim.tv_nsec);
}
}
#line 62 "stat-time.h"
__inline static long get_stat_ctime_ns(struct stat  const  *st ) 
{ 

  {
#line 66
  return ((long )st->st_ctim.tv_nsec);
}
}
#line 75 "stat-time.h"
__inline static long get_stat_mtime_ns(struct stat  const  *st ) 
{ 

  {
#line 79
  return ((long )st->st_mtim.tv_nsec);
}
}
#line 3 "utimens.h"
int utimens(char const   *file , struct timespec  const  *timespec ) ;
#line 4
int lutimens(char const   *file , struct timespec  const  *timespec ) ;
#line 78 "utimecmp.c"
static size_t dev_info_hash(void const   *x , size_t table_size ) 
{ struct fs_res  const  *p ;

  {
#line 81
  p = (struct fs_res  const  *)x;
#line 90
  return ((size_t )(p->dev % (unsigned long const   )table_size));
}
}
#line 94 "utimecmp.c"
static _Bool dev_info_compare(void const   *x , void const   *y ) 
{ struct fs_res  const  *a ;
  struct fs_res  const  *b ;

  {
#line 97
  a = (struct fs_res  const  *)x;
#line 98
  b = (struct fs_res  const  *)y;
#line 99
  return ((_Bool )(a->dev == b->dev));
}
}
#line 148 "utimecmp.c"
static Hash_table *ht  ;
#line 151 "utimecmp.c"
static struct fs_res *new_dst_res  ;
#line 115 "utimecmp.c"
int utimecmp(char const   *dst_name , struct stat  const  *dst_stat , struct stat  const  *src_stat ,
             int options ) 
{ time_t dst_s ;
  time_t src_s ;
  int dst_ns ;
  long tmp ;
  int src_ns ;
  long tmp___0 ;
  struct fs_res *dst_res ;
  struct fs_res tmp_dst_res ;
  int res ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  time_t dst_a_s ;
  time_t dst_c_s ;
  time_t dst_m_s ;
  int dst_a_ns ;
  long tmp___4 ;
  int dst_c_ns ;
  long tmp___5 ;
  int dst_m_ns ;
  _Bool odd_second ;
  int a ;
  int c ;
  int m ;
  int SR10 ;
  struct timespec timespec[2] ;
  struct stat dst_status ;
  time_t s ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int stat_result ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  long tmp___12 ;
  int old_res ;
  int a___0 ;
  long tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
#line 138
  dst_s = (time_t )dst_stat->st_mtim.tv_sec;
#line 139
  src_s = (time_t )src_stat->st_mtim.tv_sec;
#line 140
  tmp = get_stat_mtime_ns(dst_stat);
#line 140
  dst_ns = (int )tmp;
#line 141
  tmp___0 = get_stat_mtime_ns(src_stat);
#line 141
  src_ns = (int )tmp___0;
#line 143
  if (options & 1) {
#line 152
    dst_res = (struct fs_res *)((void *)0);
#line 161
    if (dst_s == src_s) {
#line 161
      if (dst_ns == src_ns) {
#line 162
        return (0);
      }
    }
#line 163
    if (dst_s <= src_s - 2L) {
#line 164
      return (-1);
    }
#line 165
    if (src_s <= dst_s - 2L) {
#line 166
      return (1);
    }
#line 170
    if (! ht) {
#line 171
      ht = hash_initialize((size_t )16, (Hash_tuning const   *)((void *)0), & dev_info_hash,
                           & dev_info_compare, & free);
    }
#line 172
    if (ht) {
#line 174
      if (! new_dst_res) {
#line 176
        tmp___1 = malloc(sizeof(*new_dst_res));
#line 176
        new_dst_res = (struct fs_res *)tmp___1;
#line 177
        if (! new_dst_res) {
#line 178
          goto low_memory;
        }
#line 179
        new_dst_res->resolution = 2000000000;
#line 180
        new_dst_res->exact = (_Bool)0;
      }
#line 182
      new_dst_res->dev = (dev_t )dst_stat->st_dev;
#line 183
      tmp___2 = hash_insert(ht, (void const   *)new_dst_res);
#line 183
      dst_res = (struct fs_res *)tmp___2;
#line 184
      if (! dst_res) {
#line 185
        goto low_memory;
      }
#line 187
      if ((unsigned long )dst_res == (unsigned long )new_dst_res) {
#line 191
        new_dst_res = (struct fs_res *)((void *)0);
      }
    } else {
      low_memory: 
#line 197
      if (ht) {
#line 199
        tmp_dst_res.dev = (dev_t )dst_stat->st_dev;
#line 200
        tmp___3 = hash_lookup((Hash_table const   *)ht, (void const   *)(& tmp_dst_res));
#line 200
        dst_res = (struct fs_res *)tmp___3;
      }
#line 202
      if (! dst_res) {
#line 204
        dst_res = & tmp_dst_res;
#line 205
        dst_res->resolution = 2000000000;
#line 206
        dst_res->exact = (_Bool)0;
      }
    }
#line 210
    res = dst_res->resolution;
#line 225
    if (! dst_res->exact) {
#line 230
      dst_a_s = (time_t )dst_stat->st_atim.tv_sec;
#line 231
      dst_c_s = (time_t )dst_stat->st_ctim.tv_sec;
#line 232
      dst_m_s = dst_s;
#line 233
      tmp___4 = get_stat_atime_ns(dst_stat);
#line 233
      dst_a_ns = (int )tmp___4;
#line 234
      tmp___5 = get_stat_ctime_ns(dst_stat);
#line 234
      dst_c_ns = (int )tmp___5;
#line 235
      dst_m_ns = dst_ns;
#line 244
      odd_second = (_Bool )(((dst_a_s | dst_c_s) | dst_m_s) & 1L);
#line 253
      a = dst_a_ns;
#line 254
      c = dst_c_ns;
#line 255
      m = dst_m_ns;
#line 259
      SR10 = 1;
#line 259
      SR10 *= 10;
#line 261
      if (((a % SR10 | c % SR10) | m % SR10) != 0) {
#line 262
        res = 1;
      } else {
#line 264
        res = SR10;
#line 264
        a /= SR10;
#line 264
        c /= SR10;
#line 264
        m /= SR10;
#line 264
        while (1) {
#line 264
          if (res < dst_res->resolution) {
#line 264
            if (! (((a % 10 | c % 10) | m % 10) == 0)) {
#line 264
              break;
            }
          } else {
#line 264
            break;
          }
#line 268
          if (res == 1000000000) {
#line 270
            if (! odd_second) {
#line 271
              res *= 2;
            }
#line 272
            break;
          }
#line 264
          res *= 10;
#line 264
          a /= 10;
#line 264
          c /= 10;
#line 264
          m /= 10;
        }
      }
#line 276
      dst_res->resolution = res;
#line 279
      if (1 < res) {
#line 286
        src_ns = src_ns;
#line 292
        s = src_s & (long )(~ (res == 2000000000));
#line 293
        if (src_s < dst_s) {
#line 294
          return (1);
        } else
#line 293
        if (src_s == dst_s) {
#line 293
          if (src_ns <= dst_ns) {
#line 294
            return (1);
          }
        }
#line 295
        if (dst_s < s) {
#line 297
          return (-1);
        } else
#line 295
        if (dst_s == s) {
#line 295
          if (dst_ns < src_ns - src_ns % res) {
#line 297
            return (-1);
          }
        }
#line 306
        timespec[0].tv_sec = dst_a_s;
#line 307
        timespec[0].tv_nsec = (long )dst_a_ns;
#line 308
        timespec[1].tv_sec = dst_m_s | (long )(res == 2000000000);
#line 309
        timespec[1].tv_nsec = (long )(dst_m_ns + res / 9);
#line 314
        if ((dst_stat->st_mode & 61440U) == 40960U) {
#line 314
          tmp___6 = lutimens(dst_name, (struct timespec  const  *)(timespec));
#line 314
          tmp___8 = tmp___6;
        } else {
#line 314
          tmp___7 = utimens(dst_name, (struct timespec  const  *)(timespec));
#line 314
          tmp___8 = tmp___7;
        }
#line 314
        if (tmp___8 != 0) {
#line 317
          return (-2);
        }
#line 321
        if ((dst_stat->st_mode & 61440U) == 40960U) {
#line 321
          tmp___9 = lstat((char const   * __restrict  )dst_name, (struct stat * __restrict  )(& dst_status));
#line 321
          tmp___11 = tmp___9;
        } else {
#line 321
          tmp___10 = stat((char const   * __restrict  )dst_name, (struct stat * __restrict  )(& dst_status));
#line 321
          tmp___11 = tmp___10;
        }
#line 321
        stat_result = tmp___11;
#line 325
        tmp___12 = get_stat_mtime_ns((struct stat  const  *)(& dst_status));
#line 325
        if (((long )stat_result | (dst_status.st_mtim.tv_sec ^ dst_m_s)) | (tmp___12 ^ (long )dst_m_ns)) {
#line 331
          timespec[1].tv_sec = dst_m_s;
#line 332
          timespec[1].tv_nsec = (long )dst_m_ns;
#line 333
          if ((dst_stat->st_mode & 61440U) == 40960U) {
#line 334
            lutimens(dst_name, (struct timespec  const  *)(timespec));
          } else {
#line 336
            utimens(dst_name, (struct timespec  const  *)(timespec));
          }
        }
#line 339
        if (stat_result != 0) {
#line 340
          return (-2);
        }
#line 346
        old_res = res;
#line 347
        tmp___13 = get_stat_mtime_ns((struct stat  const  *)(& dst_status));
#line 347
        a___0 = (int )(1000000000L * (dst_status.st_mtim.tv_sec & 1L) + tmp___13);
#line 350
        res = 1;
#line 352
        a___0 /= res;
#line 352
        while (a___0 % 10 == 0) {
#line 354
          if (res == 1000000000) {
#line 356
            res *= 2;
#line 357
            break;
          }
#line 359
          res *= 10;
#line 360
          if (res == old_res) {
#line 361
            break;
          }
#line 352
          a___0 /= 10;
        }
      }
#line 366
      dst_res->resolution = res;
#line 367
      dst_res->exact = (_Bool)1;
    }
#line 371
    src_s &= (long )(~ (res == 2000000000));
#line 372
    src_ns -= src_ns % res;
  }
#line 376
  if (dst_s < src_s) {
#line 376
    tmp___16 = -1;
  } else {
#line 376
    if (dst_s > src_s) {
#line 376
      tmp___15 = 1;
    } else {
#line 376
      if (dst_ns < src_ns) {
#line 376
        tmp___14 = -1;
      } else {
#line 376
        tmp___14 = dst_ns > src_ns;
      }
#line 376
      tmp___15 = tmp___14;
    }
#line 376
    tmp___16 = tmp___15;
  }
#line 376
  return (tmp___16);
}
}
#line 1 "utimens.o"
#pragma merger(0,"/tmp/cil-bm7B46So.i","-g,-O2")
#line 2 "utimens.h"
int fdutimens(int fd , char const   *file , struct timespec  const  *timespec ) ;
#line 366 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int utimensat(int __fd , char const   *__path ,
                                                   struct timespec  const  *__times ,
                                                   int __flags )  __attribute__((__nonnull__(2))) ;
#line 374
extern  __attribute__((__nothrow__)) int futimens(int __fd , struct timespec  const  *__times ) ;
#line 140 "/usr/include/sys/time.h"
extern  __attribute__((__nothrow__)) int utimes(char const   *__file , struct timeval  const  *__tvp )  __attribute__((__nonnull__(1))) ;
#line 156
extern  __attribute__((__nothrow__)) int futimesat(int __fd , char const   *__file ,
                                                   struct timeval  const  *__tvp ) ;
#line 103 "stat-time.h"
__inline static struct timespec get_stat_atime(struct stat  const  *st ) 
{ 

  {
#line 107
  return ((struct timespec )st->st_atim);
}
}
#line 131 "stat-time.h"
__inline static struct timespec get_stat_mtime(struct stat  const  *st ) 
{ 

  {
#line 135
  return ((struct timespec )st->st_mtim);
}
}
#line 73 "utimens.c"
static int utimensat_works_really  ;
#line 74 "utimens.c"
static int lutimensat_works_really  ;
#line 84 "utimens.c"
static int validate_timespec(struct timespec *timespec ) 
{ int result ;
  int utime_omit_count ;
  int *tmp ;

  {
#line 87
  result = 0;
#line 88
  utime_omit_count = 0;
#line 89
  if (! timespec) {
#line 89
    __assert_fail("timespec", "utimens.c", 89U, "validate_timespec");
  }
#line 90
  if ((timespec + 0)->tv_nsec != (1L << 30) - 1L) {
#line 90
    if ((timespec + 0)->tv_nsec != (1L << 30) - 2L) {
#line 90
      if ((timespec + 0)->tv_nsec < 0L) {
#line 97
        tmp = __errno_location();
#line 97
        *tmp = 22;
#line 98
        return (-1);
      } else
#line 90
      if (1000000000L <= (timespec + 0)->tv_nsec) {
#line 97
        tmp = __errno_location();
#line 97
        *tmp = 22;
#line 98
        return (-1);
      } else {
#line 90
        goto _L___0;
      }
    } else {
#line 90
      goto _L___0;
    }
  } else
  _L___0: 
#line 90
  if ((timespec + 1)->tv_nsec != (1L << 30) - 1L) {
#line 90
    if ((timespec + 1)->tv_nsec != (1L << 30) - 2L) {
#line 90
      if ((timespec + 1)->tv_nsec < 0L) {
#line 97
        tmp = __errno_location();
#line 97
        *tmp = 22;
#line 98
        return (-1);
      } else
#line 90
      if (1000000000L <= (timespec + 1)->tv_nsec) {
#line 97
        tmp = __errno_location();
#line 97
        *tmp = 22;
#line 98
        return (-1);
      }
    }
  }
#line 104
  if ((timespec + 0)->tv_nsec == (1L << 30) - 1L) {
#line 104
    goto _L___1;
  } else
#line 104
  if ((timespec + 0)->tv_nsec == (1L << 30) - 2L) {
    _L___1: 
#line 107
    (timespec + 0)->tv_sec = (__time_t )0;
#line 108
    result = 1;
#line 109
    if ((timespec + 0)->tv_nsec == (1L << 30) - 2L) {
#line 110
      utime_omit_count ++;
    }
  }
#line 112
  if ((timespec + 1)->tv_nsec == (1L << 30) - 1L) {
#line 112
    goto _L___2;
  } else
#line 112
  if ((timespec + 1)->tv_nsec == (1L << 30) - 2L) {
    _L___2: 
#line 115
    (timespec + 1)->tv_sec = (__time_t )0;
#line 116
    result = 1;
#line 117
    if ((timespec + 1)->tv_nsec == (1L << 30) - 2L) {
#line 118
      utime_omit_count ++;
    }
  }
#line 120
  return (result + (utime_omit_count == 1));
}
}
#line 129 "utimens.c"
static _Bool update_timespec(struct stat  const  *statbuf , struct timespec **ts ) 
{ struct timespec *timespec ;

  {
#line 132
  timespec = *ts;
#line 133
  if ((timespec + 0)->tv_nsec == (1L << 30) - 2L) {
#line 133
    if ((timespec + 1)->tv_nsec == (1L << 30) - 2L) {
#line 135
      return ((_Bool)1);
    }
  }
#line 136
  if ((timespec + 0)->tv_nsec == (1L << 30) - 1L) {
#line 136
    if ((timespec + 1)->tv_nsec == (1L << 30) - 1L) {
#line 139
      *ts = (struct timespec *)((void *)0);
#line 140
      return ((_Bool)0);
    }
  }
#line 143
  if ((timespec + 0)->tv_nsec == (1L << 30) - 2L) {
#line 144
    *(timespec + 0) = get_stat_atime(statbuf);
  } else
#line 145
  if ((timespec + 0)->tv_nsec == (1L << 30) - 1L) {
#line 146
    gettime(timespec + 0);
  }
#line 148
  if ((timespec + 1)->tv_nsec == (1L << 30) - 2L) {
#line 149
    *(timespec + 1) = get_stat_mtime(statbuf);
  } else
#line 150
  if ((timespec + 1)->tv_nsec == (1L << 30) - 1L) {
#line 151
    gettime(timespec + 1);
  }
#line 153
  return ((_Bool)0);
}
}
#line 166 "utimens.c"
int fdutimens(int fd , char const   *file , struct timespec  const  *timespec ) 
{ struct timespec adjusted_timespec[2] ;
  struct timespec *ts ;
  struct timespec *tmp ;
  int adjustment_needed ;
  struct stat st ;
  int *tmp___0 ;
  int result ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  _Bool tmp___11 ;
  struct timeval timeval[2] ;
  struct timeval *t ;
  int tmp___12 ;
  _Bool abig ;
  _Bool mbig ;
  time_t adiff ;
  time_t mdiff ;
  struct timeval *tt ;
  struct timeval truncated_timeval[2] ;
  long tmp___13 ;
  long tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
#line 170
  if (timespec) {
#line 170
    tmp = adjusted_timespec;
  } else {
#line 170
    tmp = (struct timespec *)((void *)0);
  }
#line 170
  ts = tmp;
#line 171
  adjustment_needed = 0;
#line 174
  if (ts) {
#line 176
    adjusted_timespec[0] = (struct timespec )*(timespec + 0);
#line 177
    adjusted_timespec[1] = (struct timespec )*(timespec + 1);
#line 178
    adjustment_needed = validate_timespec(ts);
  }
#line 180
  if (adjustment_needed < 0) {
#line 181
    return (-1);
  }
#line 186
  if (fd < 0) {
#line 186
    if (! file) {
#line 188
      tmp___0 = __errno_location();
#line 188
      *tmp___0 = 9;
#line 189
      return (-1);
    }
  }
#line 215
  if (0 <= utimensat_works_really) {
#line 227
    if (adjustment_needed == 2) {
#line 229
      if (fd < 0) {
#line 229
        tmp___1 = stat((char const   * __restrict  )file, (struct stat * __restrict  )(& st));
#line 229
        tmp___3 = tmp___1;
      } else {
#line 229
        tmp___2 = fstat(fd, & st);
#line 229
        tmp___3 = tmp___2;
      }
#line 229
      if (tmp___3) {
#line 230
        return (-1);
      }
#line 231
      if ((ts + 0)->tv_nsec == (1L << 30) - 2L) {
#line 232
        *(ts + 0) = get_stat_atime((struct stat  const  *)(& st));
      } else
#line 233
      if ((ts + 1)->tv_nsec == (1L << 30) - 2L) {
#line 234
        *(ts + 1) = get_stat_mtime((struct stat  const  *)(& st));
      }
#line 236
      adjustment_needed ++;
    }
#line 240
    if (fd < 0) {
#line 242
      result = utimensat(-100, file, (struct timespec  const  *)ts, 0);
#line 251
      if (0 < result) {
#line 252
        tmp___4 = __errno_location();
#line 252
        *tmp___4 = 38;
      }
#line 254
      if (result == 0) {
#line 256
        utimensat_works_really = 1;
#line 257
        return (result);
      } else {
#line 254
        tmp___5 = __errno_location();
#line 254
        if (*tmp___5 != 38) {
#line 256
          utimensat_works_really = 1;
#line 257
          return (result);
        }
      }
    }
#line 262
    if (0 <= fd) {
#line 264
      result = futimens(fd, (struct timespec  const  *)ts);
#line 267
      if (0 < result) {
#line 268
        tmp___6 = __errno_location();
#line 268
        *tmp___6 = 38;
      }
#line 270
      if (result == 0) {
#line 272
        utimensat_works_really = 1;
#line 273
        return (result);
      } else {
#line 270
        tmp___7 = __errno_location();
#line 270
        if (*tmp___7 != 38) {
#line 272
          utimensat_works_really = 1;
#line 273
          return (result);
        }
      }
    }
  }
#line 278
  utimensat_works_really = -1;
#line 279
  lutimensat_works_really = -1;
#line 286
  if (adjustment_needed) {
#line 286
    goto _L;
  } else
#line 286
  if (0) {
    _L: 
#line 288
    if (adjustment_needed != 3) {
#line 288
      if (fd < 0) {
#line 288
        tmp___8 = stat((char const   * __restrict  )file, (struct stat * __restrict  )(& st));
#line 288
        tmp___10 = tmp___8;
      } else {
#line 288
        tmp___9 = fstat(fd, & st);
#line 288
        tmp___10 = tmp___9;
      }
#line 288
      if (tmp___10) {
#line 290
        return (-1);
      }
    }
#line 291
    if (ts) {
#line 291
      tmp___11 = update_timespec((struct stat  const  *)(& st), & ts);
#line 291
      if (tmp___11) {
#line 292
        return (0);
      }
    }
  }
#line 299
  if (ts) {
#line 301
    timeval[0].tv_sec = (ts + 0)->tv_sec;
#line 302
    timeval[0].tv_usec = (ts + 0)->tv_nsec / 1000L;
#line 303
    timeval[1].tv_sec = (ts + 1)->tv_sec;
#line 304
    timeval[1].tv_usec = (ts + 1)->tv_nsec / 1000L;
#line 305
    t = timeval;
  } else {
#line 308
    t = (struct timeval *)((void *)0);
  }
#line 310
  if (fd < 0) {
#line 313
    tmp___12 = futimesat(-100, file, (struct timeval  const  *)t);
#line 313
    return (tmp___12);
  } else {
#line 334
    tmp___16 = futimesat(fd, (char const   *)((void *)0), (struct timeval  const  *)t);
#line 334
    if (tmp___16 == 0) {
#line 342
      if (t) {
#line 344
        abig = (_Bool )(500000L <= (t + 0)->tv_usec);
#line 345
        mbig = (_Bool )(500000L <= (t + 1)->tv_usec);
#line 346
        if ((int )abig | (int )mbig) {
#line 346
          tmp___15 = fstat(fd, & st);
#line 346
          if (tmp___15 == 0) {
#line 350
            adiff = st.st_atim.tv_sec - (t + 0)->tv_sec;
#line 351
            mdiff = st.st_mtim.tv_sec - (t + 1)->tv_sec;
#line 353
            tt = (struct timeval *)((void *)0);
#line 355
            truncated_timeval[0] = *(t + 0);
#line 356
            truncated_timeval[1] = *(t + 1);
#line 357
            if (abig) {
#line 357
              if (adiff == 1L) {
#line 357
                tmp___13 = get_stat_atime_ns((struct stat  const  *)(& st));
#line 357
                if (tmp___13 == 0L) {
#line 359
                  tt = truncated_timeval;
#line 360
                  (tt + 0)->tv_usec = (__suseconds_t )0;
                }
              }
            }
#line 362
            if (mbig) {
#line 362
              if (mdiff == 1L) {
#line 362
                tmp___14 = get_stat_mtime_ns((struct stat  const  *)(& st));
#line 362
                if (tmp___14 == 0L) {
#line 364
                  tt = truncated_timeval;
#line 365
                  (tt + 1)->tv_usec = (__suseconds_t )0;
                }
              }
            }
#line 367
            if (tt) {
#line 368
              futimesat(fd, (char const   *)((void *)0), (struct timeval  const  *)tt);
            }
          }
        }
      }
#line 373
      return (0);
    }
  }
#line 379
  if (! file) {
#line 385
    return (-1);
  }
#line 389
  tmp___17 = utimes(file, (struct timeval  const  *)t);
#line 389
  return (tmp___17);
}
}
#line 411 "utimens.c"
int utimens(char const   *file , struct timespec  const  *timespec ) 
{ int tmp ;

  {
#line 414
  tmp = fdutimens(-1, file, timespec);
#line 414
  return (tmp);
}
}
#line 421 "utimens.c"
int lutimens(char const   *file , struct timespec  const  *timespec ) 
{ struct timespec adjusted_timespec[2] ;
  struct timespec *ts ;
  struct timespec *tmp ;
  int adjustment_needed ;
  struct stat st ;
  int result ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  _Bool tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;

  {
#line 425
  if (timespec) {
#line 425
    tmp = adjusted_timespec;
  } else {
#line 425
    tmp = (struct timespec *)((void *)0);
  }
#line 425
  ts = tmp;
#line 426
  adjustment_needed = 0;
#line 429
  if (ts) {
#line 431
    adjusted_timespec[0] = (struct timespec )*(timespec + 0);
#line 432
    adjusted_timespec[1] = (struct timespec )*(timespec + 1);
#line 433
    adjustment_needed = validate_timespec(ts);
  }
#line 435
  if (adjustment_needed < 0) {
#line 436
    return (-1);
  }
#line 444
  if (0 <= lutimensat_works_really) {
#line 456
    if (adjustment_needed == 2) {
#line 458
      tmp___0 = lstat((char const   * __restrict  )file, (struct stat * __restrict  )(& st));
#line 458
      if (tmp___0) {
#line 459
        return (-1);
      }
#line 460
      if ((ts + 0)->tv_nsec == (1L << 30) - 2L) {
#line 461
        *(ts + 0) = get_stat_atime((struct stat  const  *)(& st));
      } else
#line 462
      if ((ts + 1)->tv_nsec == (1L << 30) - 2L) {
#line 463
        *(ts + 1) = get_stat_mtime((struct stat  const  *)(& st));
      }
#line 465
      adjustment_needed ++;
    }
#line 468
    result = utimensat(-100, file, (struct timespec  const  *)ts, 256);
#line 477
    if (0 < result) {
#line 478
      tmp___1 = __errno_location();
#line 478
      *tmp___1 = 38;
    }
#line 480
    if (result == 0) {
#line 482
      utimensat_works_really = 1;
#line 483
      lutimensat_works_really = 1;
#line 484
      return (result);
    } else {
#line 480
      tmp___2 = __errno_location();
#line 480
      if (*tmp___2 != 38) {
#line 482
        utimensat_works_really = 1;
#line 483
        lutimensat_works_really = 1;
#line 484
        return (result);
      }
    }
  }
#line 487
  lutimensat_works_really = -1;
#line 494
  if (adjustment_needed) {
#line 494
    goto _L;
  } else
#line 494
  if (0) {
    _L: 
#line 496
    if (adjustment_needed != 3) {
#line 496
      tmp___3 = lstat((char const   * __restrict  )file, (struct stat * __restrict  )(& st));
#line 496
      if (tmp___3) {
#line 497
        return (-1);
      }
    }
#line 498
    if (ts) {
#line 498
      tmp___4 = update_timespec((struct stat  const  *)(& st), & ts);
#line 498
      if (tmp___4) {
#line 499
        return (0);
      }
    }
  }
#line 527
  if (! adjustment_needed) {
#line 527
    tmp___5 = lstat((char const   * __restrict  )file, (struct stat * __restrict  )(& st));
#line 527
    if (tmp___5) {
#line 528
      return (-1);
    }
  }
#line 529
  if (! ((st.st_mode & 61440U) == 40960U)) {
#line 530
    tmp___6 = fdutimens(-1, file, (struct timespec  const  *)ts);
#line 530
    return (tmp___6);
  }
#line 531
  tmp___7 = __errno_location();
#line 531
  *tmp___7 = 38;
#line 532
  return (-1);
}
}
#line 1 "verror.o"
#pragma merger(0,"/tmp/cil-OdPuDETE.i","-g,-O2")
#line 45 "error.h"
extern void error_at_line(int __status , int __errnum , char const   *__fname , unsigned int __lineno ,
                          char const   *__format  , ...) ;
#line 34 "verror.h"
void verror(int status , int errnum , char const   *format , va_list args ) ;
#line 45
void verror_at_line(int status , int errnum , char const   *file , unsigned int line_number ,
                    char const   *format , va_list args ) ;
#line 48 "xvasprintf.h"
char *xvasprintf(char const   *format , va_list args ) ;
#line 42 "verror.c"
void verror(int status , int errnum , char const   *format , va_list args ) 
{ 

  {
#line 45
  verror_at_line(status, errnum, (char const   *)((void *)0), 0U, format, args);
#line 46
  return;
}
}
#line 54 "verror.c"
void verror_at_line(int status , int errnum , char const   *file , unsigned int line_number ,
                    char const   *format , va_list args ) 
{ char *message ;
  char *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;

  {
#line 58
  tmp = xvasprintf(format, args);
#line 58
  message = tmp;
#line 59
  if (message) {
#line 64
    if (file) {
#line 65
      error_at_line(status, errnum, file, line_number, "%s", message);
    } else {
#line 67
      error(status, errnum, "%s", message);
    }
  } else {
#line 73
    tmp___0 = dcgettext((char const   *)((void *)0), "unable to display error message",
                        5);
#line 73
    tmp___1 = __errno_location();
#line 73
    error(0, *tmp___1, (char const   *)tmp___0);
#line 74
    abort();
  }
#line 76
  free((void *)message);
#line 77
  return;
}
}
#line 1 "version-etc.o"
#pragma merger(0,"/tmp/cil-dW3x2AAy.i","-g,-O2")
#line 719 "/usr/include/stdio.h"
extern int fputs_unlocked(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 34 "version-etc.h"
char const   version_etc_copyright[47] ;
#line 52
void version_etc_arn(FILE *stream , char const   *command_name , char const   *package ,
                     char const   *version , char const   * const  *authors , size_t n_authors ) ;
#line 58
void version_etc_ar(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , char const   * const  *authors ) ;
#line 69
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version  , ...)  __attribute__((__sentinel__)) ;
#line 76
void emit_bug_reporting_address(void) ;
#line 61 "version-etc.c"
void version_etc_arn(FILE *stream , char const   *command_name , char const   *package ,
                     char const   *version , char const   * const  *authors , size_t n_authors ) 
{ char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
#line 67
  if (command_name) {
#line 68
    fprintf((FILE * __restrict  )stream, (char const   * __restrict  )"%s (%s) %s\n",
            command_name, package, version);
  } else {
#line 70
    fprintf((FILE * __restrict  )stream, (char const   * __restrict  )"%s %s\n", package,
            version);
  }
#line 84
  tmp = dcgettext((char const   *)((void *)0), "(C)", 5);
#line 84
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )(version_etc_copyright),
          tmp, 2011);
#line 86
  tmp___0 = dcgettext((char const   *)((void *)0), "\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n\n",
                      5);
#line 86
  fputs_unlocked((char const   * __restrict  )tmp___0, (FILE * __restrict  )stream);
#line 95
  switch ((int )n_authors) {
  case 0: 
#line 99
  abort();
  case 1: 
#line 102
  tmp___1 = dcgettext((char const   *)((void *)0), "Written by %s.\n", 5);
#line 102
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )tmp___1, *(authors + 0));
#line 103
  break;
  case 2: 
#line 106
  tmp___2 = dcgettext((char const   *)((void *)0), "Written by %s and %s.\n", 5);
#line 106
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )tmp___2, *(authors + 0),
          *(authors + 1));
#line 107
  break;
  case 3: 
#line 110
  tmp___3 = dcgettext((char const   *)((void *)0), "Written by %s, %s, and %s.\n",
                      5);
#line 110
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )tmp___3, *(authors + 0),
          *(authors + 1), *(authors + 2));
#line 112
  break;
  case 4: 
#line 117
  tmp___4 = dcgettext((char const   *)((void *)0), "Written by %s, %s, %s,\nand %s.\n",
                      5);
#line 117
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )tmp___4, *(authors + 0),
          *(authors + 1), *(authors + 2), *(authors + 3));
#line 119
  break;
  case 5: 
#line 124
  tmp___5 = dcgettext((char const   *)((void *)0), "Written by %s, %s, %s,\n%s, and %s.\n",
                      5);
#line 124
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )tmp___5, *(authors + 0),
          *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4));
#line 126
  break;
  case 6: 
#line 131
  tmp___6 = dcgettext((char const   *)((void *)0), "Written by %s, %s, %s,\n%s, %s, and %s.\n",
                      5);
#line 131
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )tmp___6, *(authors + 0),
          *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4), *(authors + 5));
#line 134
  break;
  case 7: 
#line 139
  tmp___7 = dcgettext((char const   *)((void *)0), "Written by %s, %s, %s,\n%s, %s, %s, and %s.\n",
                      5);
#line 139
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )tmp___7, *(authors + 0),
          *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4), *(authors + 5),
          *(authors + 6));
#line 142
  break;
  case 8: 
#line 147
  tmp___8 = dcgettext((char const   *)((void *)0), "Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n",
                      5);
#line 147
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )tmp___8, *(authors + 0),
          *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4), *(authors + 5),
          *(authors + 6), *(authors + 7));
#line 151
  break;
  case 9: 
#line 156
  tmp___9 = dcgettext((char const   *)((void *)0), "Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n",
                      5);
#line 156
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )tmp___9, *(authors + 0),
          *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4), *(authors + 5),
          *(authors + 6), *(authors + 7), *(authors + 8));
#line 160
  break;
  default: 
#line 167
  tmp___10 = dcgettext((char const   *)((void *)0), "Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n",
                       5);
#line 167
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )tmp___10, *(authors + 0),
          *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4), *(authors + 5),
          *(authors + 6), *(authors + 7), *(authors + 8));
#line 171
  break;
  }
#line 173
  return;
}
}
#line 179 "version-etc.c"
void version_etc_ar(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , char const   * const  *authors ) 
{ size_t n_authors ;

  {
#line 186
  n_authors = (size_t )0;
#line 186
  while (*(authors + n_authors)) {
#line 186
    n_authors ++;
  }
#line 188
  version_etc_arn(stream, command_name, package, version, authors, n_authors);
#line 189
  return;
}
}
#line 195 "version-etc.c"
void version_etc_va(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , va_list authors ) 
{ size_t n_authors ;
  char const   *authtab[10] ;
  char const   *tmp ;

  {
#line 203
  n_authors = (size_t )0;
#line 203
  while (1) {
#line 203
    if (n_authors < 10UL) {
#line 203
      tmp = __builtin_va_arg(authors, char const   *);
#line 203
      authtab[n_authors] = tmp;
#line 203
      if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 203
        break;
      }
    } else {
#line 203
      break;
    }
#line 203
    n_authors ++;
  }
#line 208
  version_etc_arn(stream, command_name, package, version, (char const   * const  *)(authtab),
                  n_authors);
#line 210
  return;
}
}
#line 226
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version  , ...)  __attribute__((__sentinel__)) ;
#line 226 "version-etc.c"
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version  , ...) 
{ va_list authors ;

  {
#line 233
  __builtin_va_start(authors, version);
#line 234
  version_etc_va(stream, command_name, package, version, authors);
#line 235
  __builtin_va_end(authors);
#line 236
  return;
}
}
#line 238 "version-etc.c"
void emit_bug_reporting_address(void) 
{ char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 245
  tmp = dcgettext((char const   *)((void *)0), "\nReport bugs to: %s\n", 5);
#line 245
  printf((char const   * __restrict  )tmp, "bug-coreutils@gnu.org");
#line 251
  tmp___0 = dcgettext((char const   *)((void *)0), "%s home page: <%s>\n", 5);
#line 251
  printf((char const   * __restrict  )tmp___0, "GNU coreutils", "http://www.gnu.org/software/coreutils/");
#line 256
  tmp___1 = dcgettext((char const   *)((void *)0), "General help using GNU software: <http://www.gnu.org/gethelp/>\n",
                      5);
#line 256
  fputs_unlocked((char const   * __restrict  )tmp___1, (FILE * __restrict  )stdout);
#line 258
  return;
}
}
#line 1 "version-etc-fsf.o"
#pragma merger(0,"/tmp/cil-Si8yWYvD.i","-g,-O2")
#line 26 "version-etc-fsf.c"
char const   version_etc_copyright[47]  = 
#line 26 "version-etc-fsf.c"
  {      (char const   )'C',      (char const   )'o',      (char const   )'p',      (char const   )'y', 
        (char const   )'r',      (char const   )'i',      (char const   )'g',      (char const   )'h', 
        (char const   )'t',      (char const   )' ',      (char const   )'%',      (char const   )'s', 
        (char const   )' ',      (char const   )'%',      (char const   )'d',      (char const   )' ', 
        (char const   )'F',      (char const   )'r',      (char const   )'e',      (char const   )'e', 
        (char const   )' ',      (char const   )'S',      (char const   )'o',      (char const   )'f', 
        (char const   )'t',      (char const   )'w',      (char const   )'a',      (char const   )'r', 
        (char const   )'e',      (char const   )' ',      (char const   )'F',      (char const   )'o', 
        (char const   )'u',      (char const   )'n',      (char const   )'d',      (char const   )'a', 
        (char const   )'t',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )',',      (char const   )' ',      (char const   )'I',      (char const   )'n', 
        (char const   )'c',      (char const   )'.',      (char const   )'\000'};
#line 1 "write-any-file.o"
#pragma merger(0,"/tmp/cil-Cj3v0GQE.i","-g,-O2")
#line 2 "write-any-file.h"
_Bool can_write_any_file(void) ;
#line 697 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 33 "write-any-file.c"
static _Bool initialized___0  ;
#line 34 "write-any-file.c"
static _Bool can_write  ;
#line 30 "write-any-file.c"
_Bool can_write_any_file(void) 
{ _Bool can ;
  __uid_t tmp ;

  {
#line 36
  if (! initialized___0) {
#line 38
    can = (_Bool)0;
#line 43
    tmp = geteuid();
#line 43
    can = (_Bool )(tmp == 0U);
#line 45
    can_write = can;
#line 46
    initialized___0 = (_Bool)1;
  }
#line 49
  return (can_write);
}
}
#line 1 "xmalloc.o"
#pragma merger(0,"/tmp/cil-iOGAL1B7.i","-g,-O2")
#line 53 "xalloc.h"
void *xcalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 40 "xmalloc.c"
void *xmalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 40 "xmalloc.c"
void *xmalloc(size_t n ) 
{ void *p ;
  void *tmp ;

  {
#line 43
  tmp = malloc(n);
#line 43
  p = tmp;
#line 44
  if (! p) {
#line 44
    if (n != 0UL) {
#line 45
      xalloc_die();
    }
  }
#line 46
  return (p);
}
}
#line 52
void *xrealloc(void *p , size_t n )  __attribute__((__alloc_size__(2))) ;
#line 52 "xmalloc.c"
void *xrealloc(void *p , size_t n ) 
{ 

  {
#line 55
  if (! n) {
#line 55
    if (p) {
#line 59
      free(p);
#line 60
      return ((void *)0);
    }
  }
#line 63
  p = realloc(p, n);
#line 64
  if (! p) {
#line 64
    if (n) {
#line 65
      xalloc_die();
    }
  }
#line 66
  return (p);
}
}
#line 75 "xmalloc.c"
void *x2realloc(void *p , size_t *pn ) 
{ void *tmp ;

  {
#line 78
  tmp = x2nrealloc(p, pn, (size_t )1);
#line 78
  return (tmp);
}
}
#line 85
void *xzalloc(size_t s )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 85 "xmalloc.c"
void *xzalloc(size_t s ) 
{ void *tmp ;
  void __attribute__((__artificial__))  *tmp___0 ;

  {
#line 88
  tmp = xmalloc(s);
#line 88
  tmp___0 = memset(tmp, 0, s);
#line 88
  return ((void *)tmp___0);
}
}
#line 94
void *xcalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 94 "xmalloc.c"
void *xcalloc(size_t n , size_t s ) 
{ void *p ;

  {
#line 102
  p = calloc(n, s);
#line 102
  if (! p) {
#line 104
    xalloc_die();
  }
#line 105
  return (p);
}
}
#line 112
void *xmemdup(void const   *p , size_t s )  __attribute__((__malloc__, __alloc_size__(2))) ;
#line 112 "xmalloc.c"
void *xmemdup(void const   *p , size_t s ) 
{ void *tmp ;
  void __attribute__((__artificial__))  *tmp___0 ;

  {
#line 115
  tmp = xmalloc(s);
#line 115
  tmp___0 = memcpy((void * __restrict  )tmp, (void const   * __restrict  )p, s);
#line 115
  return ((void *)tmp___0);
}
}
#line 120
char *xstrdup(char const   *string )  __attribute__((__malloc__)) ;
#line 120 "xmalloc.c"
char *xstrdup(char const   *string ) 
{ size_t tmp ;
  void *tmp___0 ;

  {
#line 123
  tmp = strlen(string);
#line 123
  tmp___0 = xmemdup((void const   *)string, tmp + 1UL);
#line 123
  return ((char *)tmp___0);
}
}
#line 1 "xalloc-die.o"
#pragma merger(0,"/tmp/cil-X6OZ7pH6.i","-g,-O2")
#line 31 "xalloc-die.c"
 __attribute__((__noreturn__)) void xalloc_die(void) ;
#line 31 "xalloc-die.c"
void xalloc_die(void) 
{ char *tmp ;

  {
#line 34
  tmp = dcgettext((char const   *)((void *)0), "memory exhausted", 5);
#line 34
  error((int )exit_failure, 0, "%s", tmp);
#line 40
  abort();
}
}
#line 1 "xfreopen.o"
#pragma merger(0,"/tmp/cil-mmNHua13.i","-g,-O2")
#line 2 "xfreopen.h"
void xfreopen(char const   *filename , char const   *mode , FILE *fp ) ;
#line 29 "xfreopen.c"
void xfreopen(char const   *filename , char const   *mode , FILE *fp ) 
{ char const   *f ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  FILE *tmp___11 ;

  {
#line 32
  tmp___11 = freopen_safer(filename, mode, fp);
#line 32
  if (! tmp___11) {
#line 34
    if (filename) {
#line 34
      tmp___6 = filename;
    } else {
#line 34
      if ((unsigned long )fp == (unsigned long )stdin) {
#line 34
        tmp = dcgettext((char const   *)((void *)0), "stdin", 5);
#line 34
        tmp___5 = tmp;
      } else {
#line 34
        if ((unsigned long )fp == (unsigned long )stdout) {
#line 34
          tmp___0 = dcgettext((char const   *)((void *)0), "stdout", 5);
#line 34
          tmp___4 = tmp___0;
        } else {
#line 34
          if ((unsigned long )fp == (unsigned long )stderr) {
#line 34
            tmp___1 = dcgettext((char const   *)((void *)0), "stderr", 5);
#line 34
            tmp___3 = tmp___1;
          } else {
#line 34
            tmp___2 = dcgettext((char const   *)((void *)0), "unknown stream", 5);
#line 34
            tmp___3 = tmp___2;
          }
#line 34
          tmp___4 = tmp___3;
        }
#line 34
        tmp___5 = tmp___4;
      }
#line 34
      tmp___6 = (char const   *)tmp___5;
    }
#line 34
    f = tmp___6;
#line 39
    tmp___7 = quote_n(1, mode);
#line 39
    tmp___8 = quote_n(0, f);
#line 39
    tmp___9 = dcgettext((char const   *)((void *)0), "failed to reopen %s with mode %s",
                        5);
#line 39
    tmp___10 = __errno_location();
#line 39
    error((int )exit_failure, *tmp___10, (char const   *)tmp___9, tmp___8, tmp___7);
  }
#line 42
  return;
}
}
#line 1 "xgetcwd.o"
#pragma merger(0,"/tmp/cil-wqz3SSph.i","-g,-O2")
#line 34 "xgetcwd.c"
char *xgetcwd(void) 
{ char *cwd ;
  char *tmp ;
  int *tmp___0 ;

  {
#line 37
  tmp = rpl_getcwd((char *)((void *)0), (size_t )0);
#line 37
  cwd = tmp;
#line 38
  if (! cwd) {
#line 38
    tmp___0 = __errno_location();
#line 38
    if (*tmp___0 == 12) {
#line 39
      xalloc_die();
    }
  }
#line 40
  return (cwd);
}
}
#line 1 "xgetgroups.o"
#pragma merger(0,"/tmp/cil-JtQqgaHC.i","-g,-O2")
#line 21 "mgetgroups.h"
int xgetgroups(char const   *username , gid_t gid , gid_t **groups ) ;
#line 30 "xgetgroups.c"
int xgetgroups(char const   *username , gid_t gid , gid_t **groups ) 
{ int result ;
  int tmp ;
  int *tmp___0 ;

  {
#line 33
  tmp = mgetgroups(username, gid, groups);
#line 33
  result = tmp;
#line 34
  if (result == -1) {
#line 34
    tmp___0 = __errno_location();
#line 34
    if (*tmp___0 == 12) {
#line 35
      xalloc_die();
    }
  }
#line 36
  return (result);
}
}
#line 1 "xgethostname.o"
#pragma merger(0,"/tmp/cil-WUyzMmoR.i","-g,-O2")
#line 1 "xgethostname.h"
char *xgethostname(void) ;
#line 39 "xgethostname.c"
char *xgethostname(void) 
{ char *hostname ;
  size_t size ;
  size_t size_1 ;
  void *tmp ;
  int *tmp___0 ;
  int saved_errno ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int __attribute__((__artificial__))  tmp___7 ;

  {
#line 42
  hostname = (char *)((void *)0);
#line 43
  size = (size_t )34;
#line 45
  while (1) {
#line 52
    tmp = x2realloc((void *)hostname, & size);
#line 52
    hostname = (char *)tmp;
#line 53
    size_1 = size - 1UL;
#line 54
    *(hostname + (size_1 - 1UL)) = (char )'\000';
#line 55
    tmp___0 = __errno_location();
#line 55
    *tmp___0 = 0;
#line 57
    tmp___7 = gethostname(hostname, size_1);
#line 57
    if (tmp___7 == (int __attribute__((__artificial__))  )0) {
#line 59
      if (! *(hostname + (size_1 - 1UL))) {
#line 60
        break;
      }
    } else {
#line 62
      tmp___3 = __errno_location();
#line 62
      if (*tmp___3 != 0) {
#line 62
        tmp___4 = __errno_location();
#line 62
        if (*tmp___4 != 36) {
#line 62
          tmp___5 = __errno_location();
#line 62
          if (*tmp___5 != 22) {
#line 62
            tmp___6 = __errno_location();
#line 62
            if (*tmp___6 != 12) {
#line 66
              tmp___1 = __errno_location();
#line 66
              saved_errno = *tmp___1;
#line 67
              free((void *)hostname);
#line 68
              tmp___2 = __errno_location();
#line 68
              *tmp___2 = saved_errno;
#line 69
              return ((char *)((void *)0));
            }
          }
        }
      }
    }
  }
#line 73
  return (hostname);
}
}
#line 1 "xmemcoll.o"
#pragma merger(0,"/tmp/cil-EHuAxUz6.i","-g,-O2")
#line 2 "xmemcoll.h"
int xmemcoll(char *s1 , size_t s1len , char *s2 , size_t s2len ) ;
#line 3
int xmemcoll0(char const   *s1 , size_t s1size , char const   *s2 , size_t s2size ) ;
#line 34 "xmemcoll.c"
static void collate_error(int collation_errno , char const   *s1 , size_t s1len ,
                          char const   *s2 , size_t s2len ) 
{ char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 39
  tmp = dcgettext((char const   *)((void *)0), "string comparison failed", 5);
#line 39
  error(0, collation_errno, (char const   *)tmp);
#line 40
  tmp___0 = dcgettext((char const   *)((void *)0), "Set LC_ALL=\'C\' to work around the problem.",
                      5);
#line 40
  error(0, 0, (char const   *)tmp___0);
#line 41
  tmp___1 = quotearg_n_style_mem(1, (enum quoting_style )6, s2, s2len);
#line 41
  tmp___2 = quotearg_n_style_mem(0, (enum quoting_style )6, s1, s1len);
#line 41
  tmp___3 = dcgettext((char const   *)((void *)0), "The strings compared were %s and %s.",
                      5);
#line 41
  error((int )exit_failure, 0, (char const   *)tmp___3, tmp___2, tmp___1);
#line 45
  return;
}
}
#line 53 "xmemcoll.c"
int xmemcoll(char *s1 , size_t s1len , char *s2 , size_t s2len ) 
{ int diff ;
  int tmp ;
  int collation_errno ;
  int *tmp___0 ;

  {
#line 56
  tmp = memcoll(s1, s1len, s2, s2len);
#line 56
  diff = tmp;
#line 57
  tmp___0 = __errno_location();
#line 57
  collation_errno = *tmp___0;
#line 58
  if (collation_errno) {
#line 59
    collate_error(collation_errno, (char const   *)s1, s1len, (char const   *)s2,
                  s2len);
  }
#line 60
  return (diff);
}
}
#line 68 "xmemcoll.c"
int xmemcoll0(char const   *s1 , size_t s1size , char const   *s2 , size_t s2size ) 
{ int diff ;
  int tmp ;
  int collation_errno ;
  int *tmp___0 ;

  {
#line 71
  tmp = memcoll0(s1, s1size, s2, s2size);
#line 71
  diff = tmp;
#line 72
  tmp___0 = __errno_location();
#line 72
  collation_errno = *tmp___0;
#line 73
  if (collation_errno) {
#line 74
    collate_error(collation_errno, s1, s1size - 1UL, s2, s2size - 1UL);
  }
#line 75
  return (diff);
}
}
#line 1 "xnanosleep.o"
#pragma merger(0,"/tmp/cil-X04jO2dK.i","-g,-O2")
#line 1 "xnanosleep.h"
int xnanosleep(double seconds ) ;
#line 424 "./time.h"
int rpl_nanosleep(struct timespec  const  *requested_delay , struct timespec *remaining_delay )  __attribute__((__nonnull__(1))) ;
#line 37 "xnanosleep.c"
int xnanosleep(double seconds ) 
{ struct timespec ts_sleep ;
  struct timespec tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
#line 40
  tmp = dtotimespec(seconds);
#line 40
  ts_sleep = tmp;
#line 42
  while (1) {
#line 50
    tmp___0 = __errno_location();
#line 50
    *tmp___0 = 0;
#line 51
    tmp___1 = rpl_nanosleep((struct timespec  const  *)(& ts_sleep), (struct timespec *)((void *)0));
#line 51
    if (tmp___1 == 0) {
#line 52
      break;
    }
#line 53
    tmp___2 = __errno_location();
#line 53
    if (*tmp___2 != 4) {
#line 53
      tmp___3 = __errno_location();
#line 53
      if (*tmp___3 != 0) {
#line 54
        return (-1);
      }
    }
  }
#line 57
  return (0);
}
}
#line 1 "xprintf.o"
#pragma merger(0,"/tmp/cil-F5OJFFqX.i","-g,-O2")
#line 1486 "./stdio.h"
int rpl_vfprintf(FILE *fp , char const   *format , va_list args )  __attribute__((__nonnull__(1,2))) ;
#line 1541
int rpl_vprintf(char const   *format , va_list args )  __attribute__((__nonnull__(1))) ;
#line 35 "xprintf.h"
int xprintf(char const   * __restrict  format  , ...) ;
#line 37
int xvprintf(char const   * __restrict  format , va_list args ) ;
#line 39
int xfprintf(FILE * __restrict  stream , char const   * __restrict  format  , ...) ;
#line 41
int xvfprintf(FILE * __restrict  stream , char const   * __restrict  format , va_list args ) ;
#line 31 "xprintf.c"
int xprintf(char const   * __restrict  format  , ...) 
{ va_list args ;
  int retval ;

  {
#line 36
  __builtin_va_start(args, format);
#line 37
  retval = xvprintf(format, args);
#line 38
  __builtin_va_end(args);
#line 40
  return (retval);
}
}
#line 45 "xprintf.c"
int xvprintf(char const   * __restrict  format , va_list args ) 
{ int retval ;
  int tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
#line 48
  tmp = rpl_vprintf((char const   *)format, args);
#line 48
  retval = tmp;
#line 49
  if (retval < 0) {
#line 49
    tmp___2 = ferror(stdout);
#line 49
    if (! tmp___2) {
#line 50
      tmp___0 = dcgettext((char const   *)((void *)0), "cannot perform formatted output",
                          5);
#line 50
      tmp___1 = __errno_location();
#line 50
      error((int )exit_failure, *tmp___1, (char const   *)tmp___0);
    }
  }
#line 52
  return (retval);
}
}
#line 57 "xprintf.c"
int xfprintf(FILE * __restrict  stream , char const   * __restrict  format  , ...) 
{ va_list args ;
  int retval ;

  {
#line 62
  __builtin_va_start(args, format);
#line 63
  retval = xvfprintf(stream, format, args);
#line 64
  __builtin_va_end(args);
#line 66
  return (retval);
}
}
#line 71 "xprintf.c"
int xvfprintf(FILE * __restrict  stream , char const   * __restrict  format , va_list args ) 
{ int retval ;
  int tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
#line 74
  tmp = rpl_vfprintf((FILE *)stream, (char const   *)format, args);
#line 74
  retval = tmp;
#line 75
  if (retval < 0) {
#line 75
    tmp___2 = ferror((FILE *)stream);
#line 75
    if (! tmp___2) {
#line 76
      tmp___0 = dcgettext((char const   *)((void *)0), "cannot perform formatted output",
                          5);
#line 76
      tmp___1 = __errno_location();
#line 76
      error((int )exit_failure, *tmp___1, (char const   *)tmp___0);
    }
  }
#line 78
  return (retval);
}
}
#line 1 "xreadlink.o"
#pragma merger(0,"/tmp/cil-rFGD0xvs.i","-g,-O2")
#line 21 "xreadlink.h"
char *xreadlink(char const   *filename ) ;
#line 37 "xreadlink.c"
char *xreadlink(char const   *filename ) 
{ char *result ;
  char *tmp ;
  int *tmp___0 ;

  {
#line 40
  tmp = areadlink(filename);
#line 40
  result = tmp;
#line 41
  if ((unsigned long )result == (unsigned long )((void *)0)) {
#line 41
    tmp___0 = __errno_location();
#line 41
    if (*tmp___0 == 12) {
#line 42
      xalloc_die();
    }
  }
#line 43
  return (result);
}
}
#line 1 "xstriconv.o"
#pragma merger(0,"/tmp/cil-fwBLKTOG.i","-g,-O2")
#line 45 "xstriconv.h"
int xmem_cd_iconv(char const   *src , size_t srclen , iconv_t cd , char **resultp ,
                  size_t *lengthp ) ;
#line 57
char *xstr_cd_iconv(char const   *src , iconv_t cd ) ;
#line 31 "xstriconv.c"
int xmem_cd_iconv(char const   *src , size_t srclen , iconv_t cd , char **resultp ,
                  size_t *lengthp ) 
{ int retval ;
  int tmp ;
  int *tmp___0 ;

  {
#line 35
  tmp = mem_cd_iconv(src, srclen, cd, resultp, lengthp);
#line 35
  retval = tmp;
#line 37
  if (retval < 0) {
#line 37
    tmp___0 = __errno_location();
#line 37
    if (*tmp___0 == 12) {
#line 38
      xalloc_die();
    }
  }
#line 39
  return (retval);
}
}
#line 42 "xstriconv.c"
char *xstr_cd_iconv(char const   *src , iconv_t cd ) 
{ char *result ;
  char *tmp ;
  int *tmp___0 ;

  {
#line 45
  tmp = str_cd_iconv(src, cd);
#line 45
  result = tmp;
#line 47
  if ((unsigned long )result == (unsigned long )((void *)0)) {
#line 47
    tmp___0 = __errno_location();
#line 47
    if (*tmp___0 == 12) {
#line 48
      xalloc_die();
    }
  }
#line 49
  return (result);
}
}
#line 54 "xstriconv.c"
char *xstr_iconv(char const   *src , char const   *from_codeset , char const   *to_codeset ) 
{ char *result ;
  char *tmp ;
  int *tmp___0 ;

  {
#line 57
  tmp = str_iconv(src, from_codeset, to_codeset);
#line 57
  result = tmp;
#line 59
  if ((unsigned long )result == (unsigned long )((void *)0)) {
#line 59
    tmp___0 = __errno_location();
#line 59
    if (*tmp___0 == 12) {
#line 60
      xalloc_die();
    }
  }
#line 61
  return (result);
}
}
#line 1 "xstrndup.o"
#pragma merger(0,"/tmp/cil-QswfcA0o.i","-g,-O2")
#line 1322 "/usr/include/bits/string2.h"
extern  __attribute__((__nothrow__)) char *__strndup(char const   *__string , size_t __n )  __attribute__((__malloc__)) ;
#line 29 "xstrndup.c"
char *xstrndup(char const   *string , size_t n ) 
{ char *s ;
  char *tmp___4 ;

  {
#line 32
  tmp___4 = __strndup(string, n);
#line 32
  s = tmp___4;
#line 33
  if (! s) {
#line 34
    xalloc_die();
  }
#line 35
  return (s);
}
}
#line 1 "xstrtod.o"
#pragma merger(0,"/tmp/cil-sQ7lJPYn.i","-g,-O2")
#line 26 "xstrtod.h"
_Bool xstrtod(char const   *str , char const   **ptr , double *result , double (*convert)(char const   * ,
                                                                                          char ** ) ) ;
#line 44 "xstrtod.c"
_Bool xstrtod(char const   *str , char const   **ptr , double *result , double (*convert)(char const   * ,
                                                                                          char ** ) ) 
{ double val ;
  char *terminator ;
  _Bool ok ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 50
  ok = (_Bool)1;
#line 52
  tmp = __errno_location();
#line 52
  *tmp = 0;
#line 53
  val = (*convert)(str, & terminator);
#line 56
  if ((unsigned long )terminator == (unsigned long )str) {
#line 57
    ok = (_Bool)0;
  } else
#line 56
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 56
    if ((int )*terminator != 0) {
#line 57
      ok = (_Bool)0;
    } else {
#line 56
      goto _L;
    }
  } else
  _L: 
#line 62
  if (val != (double )0) {
#line 62
    tmp___0 = __errno_location();
#line 62
    if (*tmp___0 == 34) {
#line 63
      ok = (_Bool)0;
    }
  }
#line 66
  if ((unsigned long )ptr != (unsigned long )((void *)0)) {
#line 67
    *ptr = (char const   *)terminator;
  }
#line 69
  *result = val;
#line 70
  return (ok);
}
}
#line 1 "xstrtoimax.o"
#pragma merger(0,"/tmp/cil-y8pE2OpK.i","-g,-O2")
#line 46 "xstrtol.h"
strtol_error xstrtoimax(char const   *s , char **ptr , int strtol_base , intmax_t *val ,
                        char const   *valid_suffixes ) ;
#line 46 "xstrtol.c"
static strtol_error bkm_scale(intmax_t *x , int scale_factor ) 
{ 

  {
#line 49
  if (*x < (-0x7FFFFFFFFFFFFFFF-1) / (long )scale_factor) {
#line 51
    *x = (-0x7FFFFFFFFFFFFFFF-1);
#line 52
    return ((strtol_error )1);
  }
#line 54
  if (9223372036854775807L / (long )scale_factor < *x) {
#line 56
    *x = 9223372036854775807L;
#line 57
    return ((strtol_error )1);
  }
#line 59
  *x *= (intmax_t )scale_factor;
#line 60
  return ((strtol_error )0);
}
}
#line 63 "xstrtol.c"
static strtol_error bkm_scale_by_power(intmax_t *x , int base , int power ) 
{ strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;

  {
#line 66
  err = (strtol_error )0;
#line 67
  while (1) {
#line 67
    tmp___0 = power;
#line 67
    power --;
#line 67
    if (! tmp___0) {
#line 67
      break;
    }
#line 68
    tmp = bkm_scale(x, base);
#line 68
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
  }
#line 69
  return (err);
}
}
#line 74 "xstrtol.c"
strtol_error xstrtoimax(char const   *s , char **ptr , int strtol_base , intmax_t *val ,
                        char const   *valid_suffixes ) 
{ char *t_ptr ;
  char **p ;
  intmax_t tmp ;
  strtol_error err ;
  int *tmp___1 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int base ;
  int suffixes ;
  strtol_error overflow ;
  char *tmp___7 ;
  char *tmp___9 ;

  {
#line 81
  err = (strtol_error )0;
#line 83
  if (0 <= strtol_base) {
#line 83
    if (! (strtol_base <= 36)) {
#line 83
      __assert_fail("0 <= strtol_base && strtol_base <= 36", "xstrtol.c", 83U, "xstrtoimax");
    }
  } else {
#line 83
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "xstrtol.c", 83U, "xstrtoimax");
  }
#line 85
  if (ptr) {
#line 85
    p = ptr;
  } else {
#line 85
    p = & t_ptr;
  }
#line 97
  tmp___1 = __errno_location();
#line 97
  *tmp___1 = 0;
#line 98
  tmp = strtoimax((char const   * __restrict  )s, (char ** __restrict  )p, strtol_base);
#line 100
  if ((unsigned long )*p == (unsigned long )s) {
#line 104
    if (valid_suffixes) {
#line 104
      if (*(*p)) {
#line 104
        tmp___3 = __builtin_strchr((char *)valid_suffixes, (int )*(*p));
#line 104
        if (tmp___3) {
#line 105
          tmp = (intmax_t )1;
        } else {
#line 107
          return ((strtol_error )4);
        }
      } else {
#line 107
        return ((strtol_error )4);
      }
    } else {
#line 107
      return ((strtol_error )4);
    }
  } else {
#line 109
    tmp___5 = __errno_location();
#line 109
    if (*tmp___5 != 0) {
#line 111
      tmp___4 = __errno_location();
#line 111
      if (*tmp___4 != 34) {
#line 112
        return ((strtol_error )4);
      }
#line 113
      err = (strtol_error )1;
    }
  }
#line 119
  if (! valid_suffixes) {
#line 121
    *val = tmp;
#line 122
    return (err);
  }
#line 125
  if ((int )*(*p) != 0) {
#line 127
    base = 1024;
#line 128
    suffixes = 1;
#line 131
    tmp___7 = __builtin_strchr((char *)valid_suffixes, (int )*(*p));
#line 131
    if (! tmp___7) {
#line 133
      *val = tmp;
#line 134
      return ((strtol_error )((unsigned int )err | 2U));
    }
#line 137
    tmp___9 = __builtin_strchr((char *)valid_suffixes, '0');
#line 137
    if (tmp___9) {
#line 146
      switch ((int )*(*(p + 0) + 1)) {
      case 105: 
#line 149
      if ((int )*(*(p + 0) + 2) == 66) {
#line 150
        suffixes += 2;
      }
#line 151
      break;
      case 66: 
      case 68: 
#line 155
      base = 1000;
#line 156
      suffixes ++;
#line 157
      break;
      }
    }
#line 161
    switch ((int )*(*p)) {
    case 98: 
#line 164
    overflow = bkm_scale(& tmp, 512);
#line 165
    break;
    case 66: 
#line 168
    overflow = bkm_scale(& tmp, 1024);
#line 169
    break;
    case 99: 
#line 172
    overflow = (strtol_error )0;
#line 173
    break;
    case 69: 
#line 176
    overflow = bkm_scale_by_power(& tmp, base, 6);
#line 177
    break;
    case 71: 
    case 103: 
#line 181
    overflow = bkm_scale_by_power(& tmp, base, 3);
#line 182
    break;
    case 107: 
    case 75: 
#line 186
    overflow = bkm_scale_by_power(& tmp, base, 1);
#line 187
    break;
    case 77: 
    case 109: 
#line 191
    overflow = bkm_scale_by_power(& tmp, base, 2);
#line 192
    break;
    case 80: 
#line 195
    overflow = bkm_scale_by_power(& tmp, base, 5);
#line 196
    break;
    case 84: 
    case 116: 
#line 200
    overflow = bkm_scale_by_power(& tmp, base, 4);
#line 201
    break;
    case 119: 
#line 204
    overflow = bkm_scale(& tmp, 2);
#line 205
    break;
    case 89: 
#line 208
    overflow = bkm_scale_by_power(& tmp, base, 8);
#line 209
    break;
    case 90: 
#line 212
    overflow = bkm_scale_by_power(& tmp, base, 7);
#line 213
    break;
    default: 
#line 216
    *val = tmp;
#line 217
    return ((strtol_error )((unsigned int )err | 2U));
    }
#line 220
    err = (strtol_error )((unsigned int )err | (unsigned int )overflow);
#line 221
    *p += suffixes;
#line 222
    if (*(*p)) {
#line 223
      err = (strtol_error )((unsigned int )err | 2U);
    }
  }
#line 226
  *val = tmp;
#line 227
  return (err);
}
}
#line 1 "xstrtol.o"
#pragma merger(0,"/tmp/cil-5YJROW3B.i","-g,-O2")
#line 44 "xstrtol.h"
strtol_error xstrtol(char const   *s , char **ptr , int strtol_base , long *val ,
                     char const   *valid_suffixes ) ;
#line 46 "xstrtol.c"
static strtol_error bkm_scale___0(long *x , int scale_factor ) 
{ 

  {
#line 49
  if (*x < (-0x7FFFFFFFFFFFFFFF-1) / (long )scale_factor) {
#line 51
    *x = (-0x7FFFFFFFFFFFFFFF-1);
#line 52
    return ((strtol_error )1);
  }
#line 54
  if (9223372036854775807L / (long )scale_factor < *x) {
#line 56
    *x = 9223372036854775807L;
#line 57
    return ((strtol_error )1);
  }
#line 59
  *x *= (long )scale_factor;
#line 60
  return ((strtol_error )0);
}
}
#line 63 "xstrtol.c"
static strtol_error bkm_scale_by_power___0(long *x , int base , int power ) 
{ strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;

  {
#line 66
  err = (strtol_error )0;
#line 67
  while (1) {
#line 67
    tmp___0 = power;
#line 67
    power --;
#line 67
    if (! tmp___0) {
#line 67
      break;
    }
#line 68
    tmp = bkm_scale___0(x, base);
#line 68
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
  }
#line 69
  return (err);
}
}
#line 74 "xstrtol.c"
strtol_error xstrtol(char const   *s , char **ptr , int strtol_base , long *val ,
                     char const   *valid_suffixes ) 
{ char *t_ptr ;
  char **p ;
  long tmp ;
  strtol_error err ;
  int *tmp___1 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int base ;
  int suffixes ;
  strtol_error overflow ;
  char *tmp___7 ;
  char *tmp___9 ;

  {
#line 81
  err = (strtol_error )0;
#line 83
  if (0 <= strtol_base) {
#line 83
    if (! (strtol_base <= 36)) {
#line 83
      __assert_fail("0 <= strtol_base && strtol_base <= 36", "xstrtol.c", 83U, "xstrtol");
    }
  } else {
#line 83
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "xstrtol.c", 83U, "xstrtol");
  }
#line 85
  if (ptr) {
#line 85
    p = ptr;
  } else {
#line 85
    p = & t_ptr;
  }
#line 97
  tmp___1 = __errno_location();
#line 97
  *tmp___1 = 0;
#line 98
  tmp = strtol((char const   * __restrict  )s, (char ** __restrict  )p, strtol_base);
#line 100
  if ((unsigned long )*p == (unsigned long )s) {
#line 104
    if (valid_suffixes) {
#line 104
      if (*(*p)) {
#line 104
        tmp___3 = __builtin_strchr((char *)valid_suffixes, (int )*(*p));
#line 104
        if (tmp___3) {
#line 105
          tmp = 1L;
        } else {
#line 107
          return ((strtol_error )4);
        }
      } else {
#line 107
        return ((strtol_error )4);
      }
    } else {
#line 107
      return ((strtol_error )4);
    }
  } else {
#line 109
    tmp___5 = __errno_location();
#line 109
    if (*tmp___5 != 0) {
#line 111
      tmp___4 = __errno_location();
#line 111
      if (*tmp___4 != 34) {
#line 112
        return ((strtol_error )4);
      }
#line 113
      err = (strtol_error )1;
    }
  }
#line 119
  if (! valid_suffixes) {
#line 121
    *val = tmp;
#line 122
    return (err);
  }
#line 125
  if ((int )*(*p) != 0) {
#line 127
    base = 1024;
#line 128
    suffixes = 1;
#line 131
    tmp___7 = __builtin_strchr((char *)valid_suffixes, (int )*(*p));
#line 131
    if (! tmp___7) {
#line 133
      *val = tmp;
#line 134
      return ((strtol_error )((unsigned int )err | 2U));
    }
#line 137
    tmp___9 = __builtin_strchr((char *)valid_suffixes, '0');
#line 137
    if (tmp___9) {
#line 146
      switch ((int )*(*(p + 0) + 1)) {
      case 105: 
#line 149
      if ((int )*(*(p + 0) + 2) == 66) {
#line 150
        suffixes += 2;
      }
#line 151
      break;
      case 66: 
      case 68: 
#line 155
      base = 1000;
#line 156
      suffixes ++;
#line 157
      break;
      }
    }
#line 161
    switch ((int )*(*p)) {
    case 98: 
#line 164
    overflow = bkm_scale___0(& tmp, 512);
#line 165
    break;
    case 66: 
#line 168
    overflow = bkm_scale___0(& tmp, 1024);
#line 169
    break;
    case 99: 
#line 172
    overflow = (strtol_error )0;
#line 173
    break;
    case 69: 
#line 176
    overflow = bkm_scale_by_power___0(& tmp, base, 6);
#line 177
    break;
    case 71: 
    case 103: 
#line 181
    overflow = bkm_scale_by_power___0(& tmp, base, 3);
#line 182
    break;
    case 107: 
    case 75: 
#line 186
    overflow = bkm_scale_by_power___0(& tmp, base, 1);
#line 187
    break;
    case 77: 
    case 109: 
#line 191
    overflow = bkm_scale_by_power___0(& tmp, base, 2);
#line 192
    break;
    case 80: 
#line 195
    overflow = bkm_scale_by_power___0(& tmp, base, 5);
#line 196
    break;
    case 84: 
    case 116: 
#line 200
    overflow = bkm_scale_by_power___0(& tmp, base, 4);
#line 201
    break;
    case 119: 
#line 204
    overflow = bkm_scale___0(& tmp, 2);
#line 205
    break;
    case 89: 
#line 208
    overflow = bkm_scale_by_power___0(& tmp, base, 8);
#line 209
    break;
    case 90: 
#line 212
    overflow = bkm_scale_by_power___0(& tmp, base, 7);
#line 213
    break;
    default: 
#line 216
    *val = tmp;
#line 217
    return ((strtol_error )((unsigned int )err | 2U));
    }
#line 220
    err = (strtol_error )((unsigned int )err | (unsigned int )overflow);
#line 221
    *p += suffixes;
#line 222
    if (*(*p)) {
#line 223
      err = (strtol_error )((unsigned int )err | 2U);
    }
  }
#line 226
  *val = tmp;
#line 227
  return (err);
}
}
#line 1 "xstrtoul.o"
#pragma merger(0,"/tmp/cil-kNCugwxZ.i","-g,-O2")
#line 46 "xstrtol.c"
static strtol_error bkm_scale___1(unsigned long *x , int scale_factor ) 
{ 

  {
#line 54
  if (0xffffffffffffffffUL / (unsigned long )scale_factor < *x) {
#line 56
    *x = 0xffffffffffffffffUL;
#line 57
    return ((strtol_error )1);
  }
#line 59
  *x *= (unsigned long )scale_factor;
#line 60
  return ((strtol_error )0);
}
}
#line 63 "xstrtol.c"
static strtol_error bkm_scale_by_power___1(unsigned long *x , int base , int power ) 
{ strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;

  {
#line 66
  err = (strtol_error )0;
#line 67
  while (1) {
#line 67
    tmp___0 = power;
#line 67
    power --;
#line 67
    if (! tmp___0) {
#line 67
      break;
    }
#line 68
    tmp = bkm_scale___1(x, base);
#line 68
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
  }
#line 69
  return (err);
}
}
#line 74 "xstrtol.c"
strtol_error xstrtoul(char const   *s , char **ptr , int strtol_base , unsigned long *val ,
                      char const   *valid_suffixes ) 
{ char *t_ptr ;
  char **p ;
  unsigned long tmp ;
  strtol_error err ;
  char const   *q ;
  unsigned char ch ;
  unsigned short const   **tmp___0 ;
  int *tmp___1 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int base ;
  int suffixes ;
  strtol_error overflow ;
  char *tmp___7 ;
  char *tmp___9 ;

  {
#line 81
  err = (strtol_error )0;
#line 83
  if (0 <= strtol_base) {
#line 83
    if (! (strtol_base <= 36)) {
#line 83
      __assert_fail("0 <= strtol_base && strtol_base <= 36", "xstrtol.c", 83U, "xstrtoul");
    }
  } else {
#line 83
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "xstrtol.c", 83U, "xstrtoul");
  }
#line 85
  if (ptr) {
#line 85
    p = ptr;
  } else {
#line 85
    p = & t_ptr;
  }
#line 89
  q = s;
#line 90
  ch = (unsigned char )*q;
#line 91
  while (1) {
#line 91
    tmp___0 = __ctype_b_loc();
#line 91
    if (! ((int const   )*(*tmp___0 + (int )ch) & 8192)) {
#line 91
      break;
    }
#line 92
    q ++;
#line 92
    ch = (unsigned char )*q;
  }
#line 93
  if ((int )ch == 45) {
#line 94
    return ((strtol_error )4);
  }
#line 97
  tmp___1 = __errno_location();
#line 97
  *tmp___1 = 0;
#line 98
  tmp = strtoul((char const   * __restrict  )s, (char ** __restrict  )p, strtol_base);
#line 100
  if ((unsigned long )*p == (unsigned long )s) {
#line 104
    if (valid_suffixes) {
#line 104
      if (*(*p)) {
#line 104
        tmp___3 = __builtin_strchr((char *)valid_suffixes, (int )*(*p));
#line 104
        if (tmp___3) {
#line 105
          tmp = 1UL;
        } else {
#line 107
          return ((strtol_error )4);
        }
      } else {
#line 107
        return ((strtol_error )4);
      }
    } else {
#line 107
      return ((strtol_error )4);
    }
  } else {
#line 109
    tmp___5 = __errno_location();
#line 109
    if (*tmp___5 != 0) {
#line 111
      tmp___4 = __errno_location();
#line 111
      if (*tmp___4 != 34) {
#line 112
        return ((strtol_error )4);
      }
#line 113
      err = (strtol_error )1;
    }
  }
#line 119
  if (! valid_suffixes) {
#line 121
    *val = tmp;
#line 122
    return (err);
  }
#line 125
  if ((int )*(*p) != 0) {
#line 127
    base = 1024;
#line 128
    suffixes = 1;
#line 131
    tmp___7 = __builtin_strchr((char *)valid_suffixes, (int )*(*p));
#line 131
    if (! tmp___7) {
#line 133
      *val = tmp;
#line 134
      return ((strtol_error )((unsigned int )err | 2U));
    }
#line 137
    tmp___9 = __builtin_strchr((char *)valid_suffixes, '0');
#line 137
    if (tmp___9) {
#line 146
      switch ((int )*(*(p + 0) + 1)) {
      case 105: 
#line 149
      if ((int )*(*(p + 0) + 2) == 66) {
#line 150
        suffixes += 2;
      }
#line 151
      break;
      case 66: 
      case 68: 
#line 155
      base = 1000;
#line 156
      suffixes ++;
#line 157
      break;
      }
    }
#line 161
    switch ((int )*(*p)) {
    case 98: 
#line 164
    overflow = bkm_scale___1(& tmp, 512);
#line 165
    break;
    case 66: 
#line 168
    overflow = bkm_scale___1(& tmp, 1024);
#line 169
    break;
    case 99: 
#line 172
    overflow = (strtol_error )0;
#line 173
    break;
    case 69: 
#line 176
    overflow = bkm_scale_by_power___1(& tmp, base, 6);
#line 177
    break;
    case 71: 
    case 103: 
#line 181
    overflow = bkm_scale_by_power___1(& tmp, base, 3);
#line 182
    break;
    case 107: 
    case 75: 
#line 186
    overflow = bkm_scale_by_power___1(& tmp, base, 1);
#line 187
    break;
    case 77: 
    case 109: 
#line 191
    overflow = bkm_scale_by_power___1(& tmp, base, 2);
#line 192
    break;
    case 80: 
#line 195
    overflow = bkm_scale_by_power___1(& tmp, base, 5);
#line 196
    break;
    case 84: 
    case 116: 
#line 200
    overflow = bkm_scale_by_power___1(& tmp, base, 4);
#line 201
    break;
    case 119: 
#line 204
    overflow = bkm_scale___1(& tmp, 2);
#line 205
    break;
    case 89: 
#line 208
    overflow = bkm_scale_by_power___1(& tmp, base, 8);
#line 209
    break;
    case 90: 
#line 212
    overflow = bkm_scale_by_power___1(& tmp, base, 7);
#line 213
    break;
    default: 
#line 216
    *val = tmp;
#line 217
    return ((strtol_error )((unsigned int )err | 2U));
    }
#line 220
    err = (strtol_error )((unsigned int )err | (unsigned int )overflow);
#line 221
    *p += suffixes;
#line 222
    if (*(*p)) {
#line 223
      err = (strtol_error )((unsigned int )err | 2U);
    }
  }
#line 226
  *val = tmp;
#line 227
  return (err);
}
}
#line 1 "xstrtol-error.o"
#pragma merger(0,"/tmp/cil-cK_l5WOB.i","-g,-O2")
#line 69 "xstrtol.h"
 __attribute__((__noreturn__)) void xstrtol_fatal(enum strtol_error err , int opt_idx ,
                                                  char c , struct rpl_option  const  *long_options___1 ,
                                                  char const   *arg ) ;
#line 46 "xstrtol-error.c"
static void xstrtol_error(enum strtol_error err , int opt_idx , char c , struct rpl_option  const  *long_options___1 ,
                          char const   *arg , int exit_status ) 
{ char const   *hyphens ;
  char const   *msgid ;
  char const   *rpl_option ;
  char option_buffer[2] ;
  char *tmp ;

  {
#line 52
  hyphens = "--";
#line 57
  switch ((int )err) {
  default: 
#line 60
  abort();
  case 4: 
#line 63
  msgid = "invalid %s%s argument `%s\'";
#line 64
  break;
  case 2: 
  case 3: 
#line 68
  msgid = "invalid suffix in %s%s argument `%s\'";
#line 69
  break;
  case 1: 
#line 72
  msgid = "%s%s argument `%s\' too large";
#line 73
  break;
  }
#line 76
  if (opt_idx < 0) {
#line 78
    hyphens -= opt_idx;
#line 79
    option_buffer[0] = c;
#line 80
    option_buffer[1] = (char )'\000';
#line 81
    rpl_option = (char const   *)(option_buffer);
  } else {
#line 84
    rpl_option = (char const   *)(long_options___1 + opt_idx)->name;
  }
#line 86
  tmp = dcgettext((char const   *)((void *)0), msgid, 5);
#line 86
  error(exit_status, 0, (char const   *)tmp, hyphens, rpl_option, arg);
#line 87
  return;
}
}
#line 91
 __attribute__((__noreturn__)) void xstrtol_fatal(enum strtol_error err , int opt_idx ,
                                                  char c , struct rpl_option  const  *long_options___1 ,
                                                  char const   *arg ) ;
#line 91 "xstrtol-error.c"
void xstrtol_fatal(enum strtol_error err , int opt_idx , char c , struct rpl_option  const  *long_options___1 ,
                   char const   *arg ) 
{ 

  {
#line 96
  xstrtol_error(err, opt_idx, c, long_options___1, arg, (int )exit_failure);
#line 97
  abort();
}
}
#line 1 "xstrtold.o"
#pragma merger(0,"/tmp/cil-SvEwqpk5.i","-g,-O2")
#line 28 "xstrtod.h"
_Bool xstrtold(char const   *str , char const   **ptr , long double *result , long double (*convert)(char const   * ,
                                                                                                     char ** ) ) ;
#line 44 "xstrtod.c"
_Bool xstrtold(char const   *str , char const   **ptr , long double *result , long double (*convert)(char const   * ,
                                                                                                     char ** ) ) 
{ long double val ;
  char *terminator ;
  _Bool ok ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 50
  ok = (_Bool)1;
#line 52
  tmp = __errno_location();
#line 52
  *tmp = 0;
#line 53
  val = (*convert)(str, & terminator);
#line 56
  if ((unsigned long )terminator == (unsigned long )str) {
#line 57
    ok = (_Bool)0;
  } else
#line 56
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 56
    if ((int )*terminator != 0) {
#line 57
      ok = (_Bool)0;
    } else {
#line 56
      goto _L;
    }
  } else
  _L: 
#line 62
  if (val != (long double )0) {
#line 62
    tmp___0 = __errno_location();
#line 62
    if (*tmp___0 == 34) {
#line 63
      ok = (_Bool)0;
    }
  }
#line 66
  if ((unsigned long )ptr != (unsigned long )((void *)0)) {
#line 67
    *ptr = (char const   *)terminator;
  }
#line 69
  *result = val;
#line 70
  return (ok);
}
}
#line 1 "xstrtoumax.o"
#pragma merger(0,"/tmp/cil-qOoIKJIK.i","-g,-O2")
#line 46 "xstrtol.c"
static strtol_error bkm_scale___2(uintmax_t *x , int scale_factor ) 
{ 

  {
#line 54
  if (0xffffffffffffffffUL / (unsigned long )scale_factor < *x) {
#line 56
    *x = 0xffffffffffffffffUL;
#line 57
    return ((strtol_error )1);
  }
#line 59
  *x *= (uintmax_t )scale_factor;
#line 60
  return ((strtol_error )0);
}
}
#line 63 "xstrtol.c"
static strtol_error bkm_scale_by_power___2(uintmax_t *x , int base , int power ) 
{ strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;

  {
#line 66
  err = (strtol_error )0;
#line 67
  while (1) {
#line 67
    tmp___0 = power;
#line 67
    power --;
#line 67
    if (! tmp___0) {
#line 67
      break;
    }
#line 68
    tmp = bkm_scale___2(x, base);
#line 68
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
  }
#line 69
  return (err);
}
}
#line 74 "xstrtol.c"
strtol_error xstrtoumax(char const   *s , char **ptr , int strtol_base , uintmax_t *val ,
                        char const   *valid_suffixes ) 
{ char *t_ptr ;
  char **p ;
  uintmax_t tmp ;
  strtol_error err ;
  char const   *q ;
  unsigned char ch ;
  unsigned short const   **tmp___0 ;
  int *tmp___1 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int base ;
  int suffixes ;
  strtol_error overflow ;
  char *tmp___7 ;
  char *tmp___9 ;

  {
#line 81
  err = (strtol_error )0;
#line 83
  if (0 <= strtol_base) {
#line 83
    if (! (strtol_base <= 36)) {
#line 83
      __assert_fail("0 <= strtol_base && strtol_base <= 36", "xstrtol.c", 83U, "xstrtoumax");
    }
  } else {
#line 83
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "xstrtol.c", 83U, "xstrtoumax");
  }
#line 85
  if (ptr) {
#line 85
    p = ptr;
  } else {
#line 85
    p = & t_ptr;
  }
#line 89
  q = s;
#line 90
  ch = (unsigned char )*q;
#line 91
  while (1) {
#line 91
    tmp___0 = __ctype_b_loc();
#line 91
    if (! ((int const   )*(*tmp___0 + (int )ch) & 8192)) {
#line 91
      break;
    }
#line 92
    q ++;
#line 92
    ch = (unsigned char )*q;
  }
#line 93
  if ((int )ch == 45) {
#line 94
    return ((strtol_error )4);
  }
#line 97
  tmp___1 = __errno_location();
#line 97
  *tmp___1 = 0;
#line 98
  tmp = strtoumax((char const   * __restrict  )s, (char ** __restrict  )p, strtol_base);
#line 100
  if ((unsigned long )*p == (unsigned long )s) {
#line 104
    if (valid_suffixes) {
#line 104
      if (*(*p)) {
#line 104
        tmp___3 = __builtin_strchr((char *)valid_suffixes, (int )*(*p));
#line 104
        if (tmp___3) {
#line 105
          tmp = (uintmax_t )1;
        } else {
#line 107
          return ((strtol_error )4);
        }
      } else {
#line 107
        return ((strtol_error )4);
      }
    } else {
#line 107
      return ((strtol_error )4);
    }
  } else {
#line 109
    tmp___5 = __errno_location();
#line 109
    if (*tmp___5 != 0) {
#line 111
      tmp___4 = __errno_location();
#line 111
      if (*tmp___4 != 34) {
#line 112
        return ((strtol_error )4);
      }
#line 113
      err = (strtol_error )1;
    }
  }
#line 119
  if (! valid_suffixes) {
#line 121
    *val = tmp;
#line 122
    return (err);
  }
#line 125
  if ((int )*(*p) != 0) {
#line 127
    base = 1024;
#line 128
    suffixes = 1;
#line 131
    tmp___7 = __builtin_strchr((char *)valid_suffixes, (int )*(*p));
#line 131
    if (! tmp___7) {
#line 133
      *val = tmp;
#line 134
      return ((strtol_error )((unsigned int )err | 2U));
    }
#line 137
    tmp___9 = __builtin_strchr((char *)valid_suffixes, '0');
#line 137
    if (tmp___9) {
#line 146
      switch ((int )*(*(p + 0) + 1)) {
      case 105: 
#line 149
      if ((int )*(*(p + 0) + 2) == 66) {
#line 150
        suffixes += 2;
      }
#line 151
      break;
      case 66: 
      case 68: 
#line 155
      base = 1000;
#line 156
      suffixes ++;
#line 157
      break;
      }
    }
#line 161
    switch ((int )*(*p)) {
    case 98: 
#line 164
    overflow = bkm_scale___2(& tmp, 512);
#line 165
    break;
    case 66: 
#line 168
    overflow = bkm_scale___2(& tmp, 1024);
#line 169
    break;
    case 99: 
#line 172
    overflow = (strtol_error )0;
#line 173
    break;
    case 69: 
#line 176
    overflow = bkm_scale_by_power___2(& tmp, base, 6);
#line 177
    break;
    case 71: 
    case 103: 
#line 181
    overflow = bkm_scale_by_power___2(& tmp, base, 3);
#line 182
    break;
    case 107: 
    case 75: 
#line 186
    overflow = bkm_scale_by_power___2(& tmp, base, 1);
#line 187
    break;
    case 77: 
    case 109: 
#line 191
    overflow = bkm_scale_by_power___2(& tmp, base, 2);
#line 192
    break;
    case 80: 
#line 195
    overflow = bkm_scale_by_power___2(& tmp, base, 5);
#line 196
    break;
    case 84: 
    case 116: 
#line 200
    overflow = bkm_scale_by_power___2(& tmp, base, 4);
#line 201
    break;
    case 119: 
#line 204
    overflow = bkm_scale___2(& tmp, 2);
#line 205
    break;
    case 89: 
#line 208
    overflow = bkm_scale_by_power___2(& tmp, base, 8);
#line 209
    break;
    case 90: 
#line 212
    overflow = bkm_scale_by_power___2(& tmp, base, 7);
#line 213
    break;
    default: 
#line 216
    *val = tmp;
#line 217
    return ((strtol_error )((unsigned int )err | 2U));
    }
#line 220
    err = (strtol_error )((unsigned int )err | (unsigned int )overflow);
#line 221
    *p += suffixes;
#line 222
    if (*(*p)) {
#line 223
      err = (strtol_error )((unsigned int )err | 2U);
    }
  }
#line 226
  *val = tmp;
#line 227
  return (err);
}
}
#line 1 "xvasprintf.o"
#pragma merger(0,"/tmp/cil-i7V0Sdfw.i","-g,-O2")
#line 1430 "./stdio.h"
int rpl_vasprintf(char **resultp , char const   *format , va_list args )  __attribute__((__nonnull__(1,2))) ;
#line 54 "xsize.h"
__inline static size_t __attribute__((__pure__))  xsum(size_t size1 , size_t size2 ) 
{ size_t sum ;
  size_t tmp ;

  {
#line 60
  sum = size1 + size2;
#line 61
  if (sum >= size1) {
#line 61
    tmp = sum;
  } else {
#line 61
    tmp = 0xffffffffffffffffUL;
  }
#line 61
  return ((size_t __attribute__((__pure__))  )tmp);
}
}
#line 32 "xvasprintf.c"
__inline static char *xstrcat(size_t argcount , va_list args ) 
{ char *result ;
  va_list ap ;
  size_t totalsize ;
  size_t i ;
  char *p ;
  char const   *next ;
  char const   *tmp ;
  size_t tmp___0 ;
  size_t __attribute__((__pure__))  tmp___1 ;
  int *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  char const   *next___0 ;
  char const   *tmp___6 ;
  size_t len ;
  size_t tmp___7 ;

  {
#line 42
  totalsize = (size_t )0;
#line 43
  __builtin_va_copy(ap, args);
#line 44
  i = argcount;
#line 44
  while (i > 0UL) {
#line 46
    tmp = __builtin_va_arg(ap, char const   *);
#line 46
    next = tmp;
#line 47
    tmp___0 = strlen(next);
#line 47
    tmp___1 = xsum(totalsize, tmp___0);
#line 47
    totalsize = (size_t )tmp___1;
#line 44
    i --;
  }
#line 49
  __builtin_va_end(ap);
#line 54
  if (totalsize == 0xffffffffffffffffUL) {
#line 56
    tmp___2 = __errno_location();
#line 56
    *tmp___2 = 75;
#line 57
    return ((char *)((void *)0));
  } else
#line 54
  if (totalsize > 2147483647UL) {
#line 56
    tmp___2 = __errno_location();
#line 56
    *tmp___2 = 75;
#line 57
    return ((char *)((void *)0));
  }
#line 61
  if (sizeof(char ) == 1UL) {
#line 61
    tmp___3 = xmalloc(totalsize + 1UL);
#line 61
    tmp___5 = tmp___3;
  } else {
#line 61
    tmp___4 = xnmalloc(totalsize + 1UL, sizeof(char ));
#line 61
    tmp___5 = tmp___4;
  }
#line 61
  result = (char *)tmp___5;
#line 62
  p = result;
#line 63
  i = argcount;
#line 63
  while (i > 0UL) {
#line 65
    tmp___6 = __builtin_va_arg(args, char const   *);
#line 65
    next___0 = tmp___6;
#line 66
    tmp___7 = strlen(next___0);
#line 66
    len = tmp___7;
#line 67
    memcpy((void * __restrict  )p, (void const   * __restrict  )next___0, len);
#line 68
    p += len;
#line 63
    i --;
  }
#line 70
  *p = (char )'\000';
#line 72
  return (result);
}
}
#line 75 "xvasprintf.c"
char *xvasprintf(char const   *format , va_list args ) 
{ char *result ;
  size_t argcount ;
  char const   *f ;
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
#line 84
  argcount = (size_t )0;
#line 87
  f = format;
#line 87
  while (1) {
#line 89
    if ((int const   )*f == 0) {
#line 91
      tmp = xstrcat(argcount, args);
#line 91
      return (tmp);
    }
#line 92
    if ((int const   )*f != 37) {
#line 93
      break;
    }
#line 94
    f ++;
#line 95
    if ((int const   )*f != 115) {
#line 96
      break;
    }
#line 97
    f ++;
#line 98
    argcount ++;
  }
#line 102
  tmp___1 = rpl_vasprintf(& result, format, args);
#line 102
  if (tmp___1 < 0) {
#line 104
    tmp___0 = __errno_location();
#line 104
    if (*tmp___0 == 12) {
#line 105
      xalloc_die();
    }
#line 106
    return ((char *)((void *)0));
  }
#line 109
  return (result);
}
}
#line 1 "xasprintf.o"
#pragma merger(0,"/tmp/cil-zlGEj8wz.i","-g,-O2")
#line 46 "xvasprintf.h"
char *xasprintf(char const   *format  , ...) ;
#line 23 "xasprintf.c"
char *xasprintf(char const   *format  , ...) 
{ va_list args ;
  char *result ;

  {
#line 29
  __builtin_va_start(args, format);
#line 30
  result = xvasprintf(format, args);
#line 31
  __builtin_va_end(args);
#line 33
  return (result);
}
}
#line 1 "yesno.o"
#pragma merger(0,"/tmp/cil-h9IEoMLy.i","-g,-O2")
#line 22 "yesno.h"
_Bool yesno(void) ;
#line 885 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int rpmatch(char const   *__response )  __attribute__((__warn_unused_result__,
__nonnull__(1))) ;
#line 31 "yesno.c"
_Bool yesno(void) 
{ _Bool yes ;
  char *response ;
  size_t response_size ;
  ssize_t response_len ;
  __ssize_t tmp ;
  int tmp___0 ;

  {
#line 37
  response = (char *)((void *)0);
#line 38
  response_size = (size_t )0;
#line 39
  tmp = getline((char ** __restrict  )(& response), (size_t * __restrict  )(& response_size),
                (FILE * __restrict  )stdin);
#line 39
  response_len = tmp;
#line 41
  if (response_len <= 0L) {
#line 42
    yes = (_Bool)0;
  } else {
#line 45
    *(response + (response_len - 1L)) = (char )'\000';
#line 46
    tmp___0 = rpmatch((char const   *)response);
#line 46
    yes = (_Bool )(0 < tmp___0);
  }
#line 49
  free((void *)response);
#line 59
  return (yes);
}
}
#line 1 "buffer-lcm.o"
#pragma merger(0,"/tmp/cil-pdMn5QIa.i","-g,-O2")
#line 2 "buffer-lcm.h"
size_t buffer_lcm(size_t a , size_t b , size_t lcm_max )  __attribute__((__const__)) ;
#line 27 "buffer-lcm.c"
size_t buffer_lcm(size_t a , size_t b , size_t lcm_max )  __attribute__((__const__)) ;
#line 27 "buffer-lcm.c"
size_t buffer_lcm(size_t a , size_t b , size_t lcm_max ) 
{ size_t size ;
  size_t lcm___0 ;
  size_t m ;
  size_t n ;
  size_t q ;
  size_t r ;
  size_t tmp ;

  {
#line 33
  if (! a) {
#line 34
    if (b) {
#line 34
      size = b;
    } else {
#line 34
      size = (size_t )8192;
    }
  } else {
#line 37
    if (b) {
#line 45
      m = a;
#line 45
      n = b;
#line 45
      while (1) {
#line 45
        r = m % n;
#line 45
        if (! (r != 0UL)) {
#line 45
          break;
        }
#line 46
        goto __Cont;
        __Cont: 
#line 45
        m = n;
#line 45
        n = r;
      }
#line 49
      q = a / n;
#line 50
      lcm___0 = q * b;
#line 51
      if (lcm___0 <= lcm_max) {
#line 51
        if (lcm___0 / b == q) {
#line 52
          return (lcm___0);
        }
      }
    }
#line 55
    size = a;
  }
#line 58
  if (size <= lcm_max) {
#line 58
    tmp = size;
  } else {
#line 58
    tmp = lcm_max;
  }
#line 58
  return (tmp);
}
}
#line 1 "asnprintf.o"
#pragma merger(0,"/tmp/cil-S3A2UTWN.i","-g,-O2")
#line 73 "vasnprintf.h"
char *asnprintf(char *resultbuf , size_t *lengthp , char const   *format  , ...) ;
#line 75
char *vasnprintf(char *resultbuf , size_t *lengthp , char const   *format , va_list args ) ;
#line 27 "asnprintf.c"
char *asnprintf(char *resultbuf , size_t *lengthp , char const   *format  , ...) 
{ va_list args ;
  char *result ;

  {
#line 33
  __builtin_va_start(args, format);
#line 34
  result = vasnprintf(resultbuf, lengthp, format, args);
#line 35
  __builtin_va_end(args);
#line 36
  return (result);
}
}
#line 1 "asprintf.o"
#pragma merger(0,"/tmp/cil-xMV2BVsw.i","-g,-O2")
#line 1409 "./stdio.h"
int rpl_asprintf(char **resultp , char const   *format  , ...)  __attribute__((__nonnull__(1,2))) ;
#line 32 "asprintf.c"
int rpl_asprintf(char **resultp , char const   *format  , ...)  __attribute__((__nonnull__(1,2))) ;
#line 32 "asprintf.c"
int rpl_asprintf(char **resultp , char const   *format  , ...) 
{ va_list args ;
  int result ;

  {
#line 38
  __builtin_va_start(args, format);
#line 39
  result = rpl_vasprintf(resultp, format, args);
#line 40
  __builtin_va_end(args);
#line 41
  return (result);
}
}
#line 1 "chdir-long.o"
#pragma merger(0,"/tmp/cil-5pB0uhfb.i","-g,-O2")
#line 120 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memrchr(void const   *__s , int __c , size_t __n )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 45 "chdir-long.c"
__inline static void cdb_init(struct cd_buf *cdb ) 
{ 

  {
#line 48
  cdb->fd = -100;
#line 49
  return;
}
}
#line 51 "chdir-long.c"
__inline static int cdb_fchdir(struct cd_buf  const  *cdb ) 
{ int tmp ;

  {
#line 54
  tmp = fchdir((int )cdb->fd);
#line 54
  return (tmp);
}
}
#line 57 "chdir-long.c"
__inline static void cdb_free(struct cd_buf  const  *cdb ) 
{ _Bool close_fail ;
  int tmp ;

  {
#line 60
  if (0 <= (int )cdb->fd) {
#line 62
    tmp = close((int )cdb->fd);
#line 62
    close_fail = (_Bool )tmp;
#line 63
    if (! (! close_fail)) {
#line 63
      __assert_fail("! close_fail", "chdir-long.c", 63U, "cdb_free");
    }
  }
#line 65
  return;
}
}
#line 71 "chdir-long.c"
static int cdb_advance_fd(struct cd_buf *cdb , char const   *dir ) 
{ int new_fd ;
  int __attribute__((__artificial__))  tmp ;

  {
#line 74
  tmp = openat(cdb->fd, dir, 67840);
#line 74
  new_fd = (int )tmp;
#line 76
  if (new_fd < 0) {
#line 77
    return (-1);
  }
#line 79
  cdb_free((struct cd_buf  const  *)cdb);
#line 80
  cdb->fd = new_fd;
#line 82
  return (0);
}
}
#line 86 "chdir-long.c"
__inline static char *find_non_slash(char const   *s ) 
{ size_t n_slash ;
  unsigned long tmp___8 ;

  {
#line 89
  tmp___8 = __builtin_strspn(s, "/");
#line 89
  n_slash = tmp___8;
#line 90
  return ((char *)s + n_slash);
}
}
#line 108 "chdir-long.c"
int chdir_long(char *dir ) 
{ int e ;
  int tmp ;
  int *tmp___0 ;
  size_t len ;
  size_t tmp___1 ;
  char *dir_end ;
  struct cd_buf cdb ;
  size_t n_leading_slash ;
  unsigned long tmp___11 ;
  int err ;
  char *slash ;
  void *tmp___12 ;
  int *tmp___13 ;
  int tmp___14 ;
  int err___0 ;
  char *slash___0 ;
  void *tmp___15 ;
  int *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int saved_errno ;
  int *tmp___19 ;
  int *tmp___20 ;

  {
#line 111
  tmp = chdir((char const   *)dir);
#line 111
  e = tmp;
#line 112
  if (e == 0) {
#line 113
    return (e);
  } else {
#line 112
    tmp___0 = __errno_location();
#line 112
    if (*tmp___0 != 36) {
#line 113
      return (e);
    }
  }
#line 116
  tmp___1 = strlen((char const   *)dir);
#line 116
  len = tmp___1;
#line 117
  dir_end = dir + len;
#line 121
  cdb_init(& cdb);
#line 125
  if (! (0UL < len)) {
#line 125
    __assert_fail("0 < len", "chdir-long.c", 125U, "chdir_long");
  }
#line 126
  if (! (4096UL <= len)) {
#line 126
    __assert_fail("4096 <= len", "chdir-long.c", 126U, "chdir_long");
  }
#line 129
  tmp___11 = __builtin_strspn((char const   *)dir, "/");
#line 129
  n_leading_slash = tmp___11;
#line 136
  if (n_leading_slash == 2UL) {
#line 141
    tmp___12 = memchr((void const   *)(dir + 3), '/', (size_t )(dir_end - (dir + 3)));
#line 141
    slash = (char *)tmp___12;
#line 142
    if ((unsigned long )slash == (unsigned long )((void *)0)) {
#line 144
      tmp___13 = __errno_location();
#line 144
      *tmp___13 = 36;
#line 145
      return (-1);
    }
#line 147
    *slash = (char )'\000';
#line 148
    err = cdb_advance_fd(& cdb, (char const   *)dir);
#line 149
    *slash = (char )'/';
#line 150
    if (err != 0) {
#line 151
      goto Fail;
    }
#line 152
    dir = find_non_slash((char const   *)(slash + 1));
  } else
#line 154
  if (n_leading_slash) {
#line 156
    tmp___14 = cdb_advance_fd(& cdb, "/");
#line 156
    if (tmp___14 != 0) {
#line 157
      goto Fail;
    }
#line 158
    dir += n_leading_slash;
  }
#line 161
  if (! ((int )*dir != 47)) {
#line 161
    __assert_fail("*dir != \'/\'", "chdir-long.c", 161U, "chdir_long");
  }
#line 162
  if (! ((unsigned long )dir <= (unsigned long )dir_end)) {
#line 162
    __assert_fail("dir <= dir_end", "chdir-long.c", 162U, "chdir_long");
  }
#line 164
  while (4096 <= dir_end - dir) {
#line 170
    tmp___15 = memrchr((void const   *)dir, '/', (size_t )4096);
#line 170
    slash___0 = (char *)tmp___15;
#line 171
    if ((unsigned long )slash___0 == (unsigned long )((void *)0)) {
#line 173
      tmp___16 = __errno_location();
#line 173
      *tmp___16 = 36;
#line 174
      return (-1);
    }
#line 177
    *slash___0 = (char )'\000';
#line 178
    if (! (slash___0 - dir < 4096)) {
#line 178
      __assert_fail("slash - dir < 4096", "chdir-long.c", 178U, "chdir_long");
    }
#line 179
    err___0 = cdb_advance_fd(& cdb, (char const   *)dir);
#line 180
    *slash___0 = (char )'/';
#line 181
    if (err___0 != 0) {
#line 182
      goto Fail;
    }
#line 184
    dir = find_non_slash((char const   *)(slash___0 + 1));
  }
#line 187
  if ((unsigned long )dir < (unsigned long )dir_end) {
#line 189
    tmp___17 = cdb_advance_fd(& cdb, (char const   *)dir);
#line 189
    if (tmp___17 != 0) {
#line 190
      goto Fail;
    }
  }
#line 193
  tmp___18 = cdb_fchdir((struct cd_buf  const  *)(& cdb));
#line 193
  if (tmp___18 != 0) {
#line 194
    goto Fail;
  }
#line 196
  cdb_free((struct cd_buf  const  *)(& cdb));
#line 197
  return (0);
  Fail: 
#line 201
  tmp___19 = __errno_location();
#line 201
  saved_errno = *tmp___19;
#line 202
  cdb_free((struct cd_buf  const  *)(& cdb));
#line 203
  tmp___20 = __errno_location();
#line 203
  *tmp___20 = saved_errno;
#line 204
  return (-1);
}
}
#line 1 "fclose.o"
#pragma merger(0,"/tmp/cil-qZKcFIMj.i","-g,-O2")
#line 234 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 52 "/usr/include/stdio_ext.h"
extern  __attribute__((__nothrow__)) int __freading(FILE *__fp ) ;
#line 29 "fclose.c"
int rpl_fclose(FILE *fp )  __attribute__((__nonnull__(1))) ;
#line 29 "fclose.c"
int rpl_fclose(FILE *fp ) 
{ int saved_errno ;
  int fd ;
  int result ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  __off_t tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;

  {
#line 33
  saved_errno = 0;
#line 35
  result = 0;
#line 38
  fd = fileno(fp);
#line 39
  if (fd < 0) {
#line 40
    tmp = fclose(fp);
#line 40
    return (tmp);
  }
#line 45
  tmp___1 = __freading(fp);
#line 45
  if (tmp___1 != 0) {
#line 45
    tmp___2 = fileno(fp);
#line 45
    tmp___3 = lseek(tmp___2, (__off_t )0, 1);
#line 45
    if (tmp___3 != -1L) {
      _L: 
#line 45
      tmp___4 = rpl_fflush(fp);
#line 45
      if (tmp___4) {
#line 47
        tmp___0 = __errno_location();
#line 47
        saved_errno = *tmp___0;
      }
    }
  } else {
#line 45
    goto _L;
  }
#line 72
  result = fclose(fp);
#line 77
  if (saved_errno != 0) {
#line 79
    tmp___5 = __errno_location();
#line 79
    *tmp___5 = saved_errno;
#line 80
    result = -1;
  }
#line 83
  return (result);
}
}
#line 1 "fcntl.o"
#pragma merger(0,"/tmp/cil-gGG66C9w.i","-g,-O2")
#line 110 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 229 "fcntl.c"
static int have_dupfd_cloexec  =    0;
#line 165 "fcntl.c"
int rpl_fcntl(int fd , int action  , ...) 
{ va_list arg ;
  int result ;
  int target ;
  int tmp ;
  int *tmp___0 ;
  int flags ;
  int tmp___1 ;
  int saved_errno ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  void *p ;
  void *tmp___5 ;

  {
#line 169
  result = -1;
#line 170
  __builtin_va_start(arg, action);
#line 171
  switch (action) {
  case 1030: 
#line 216
  tmp = __builtin_va_arg(arg, int );
#line 216
  target = tmp;
#line 230
  if (0 <= have_dupfd_cloexec) {
#line 232
    result = fcntl(fd, action, target);
#line 233
    if (0 <= result) {
#line 235
      have_dupfd_cloexec = 1;
    } else {
#line 233
      tmp___0 = __errno_location();
#line 233
      if (*tmp___0 != 22) {
#line 235
        have_dupfd_cloexec = 1;
      } else {
#line 243
        result = rpl_fcntl(fd, 0, target);
#line 244
        if (result < 0) {
#line 245
          break;
        }
#line 246
        have_dupfd_cloexec = -1;
      }
    }
  } else {
#line 250
    result = rpl_fcntl(fd, 0, target);
  }
#line 251
  if (0 <= result) {
#line 251
    if (have_dupfd_cloexec == -1) {
#line 253
      tmp___1 = fcntl(result, 1);
#line 253
      flags = tmp___1;
#line 254
      if (flags < 0) {
#line 254
        goto _L;
      } else {
#line 254
        tmp___4 = fcntl(result, 2, flags | 1);
#line 254
        if (tmp___4 == -1) {
          _L: 
#line 256
          tmp___2 = __errno_location();
#line 256
          saved_errno = *tmp___2;
#line 257
          close(result);
#line 258
          tmp___3 = __errno_location();
#line 258
          *tmp___3 = saved_errno;
#line 259
          result = -1;
        }
      }
    }
  }
#line 262
  break;
  default: 
#line 298
  tmp___5 = __builtin_va_arg(arg, void *);
#line 298
  p = tmp___5;
#line 299
  result = fcntl(fd, action, p);
#line 303
  break;
  }
#line 306
  __builtin_va_end(arg);
#line 307
  return (result);
}
}
#line 1 "fflush.o"
#pragma merger(0,"/tmp/cil-qS5ThY6d.i","-g,-O2")
#line 239 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 37 "fflush.c"
__inline static void clear_ungetc_buffer_preserving_position(FILE *fp ) 
{ 

  {
#line 40
  if (fp->_flags & 256) {
#line 42
    rpl_fseeko(fp, (off_t )0, 1);
  }
#line 43
  return;
}
}
#line 116 "fflush.c"
int rpl_fflush(FILE *stream ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 138
  if ((unsigned long )stream == (unsigned long )((void *)0)) {
#line 139
    tmp = fflush(stream);
#line 139
    return (tmp);
  } else {
#line 138
    tmp___0 = __freading(stream);
#line 138
    if (! (tmp___0 != 0)) {
#line 139
      tmp = fflush(stream);
#line 139
      return (tmp);
    }
  }
#line 143
  clear_ungetc_buffer_preserving_position(stream);
#line 145
  tmp___1 = fflush(stream);
#line 145
  return (tmp___1);
}
}
#line 1 "fpurge.o"
#pragma merger(0,"/tmp/cil-ViNOjNKf.i","-g,-O2")
#line 607 "./stdio.h"
int fpurge(FILE *fp )  __attribute__((__nonnull__(1))) ;
#line 73 "/usr/include/stdio_ext.h"
extern  __attribute__((__nothrow__)) void __fpurge(FILE *__fp ) ;
#line 29 "fpurge.c"
int fpurge(FILE *fp )  __attribute__((__nonnull__(1))) ;
#line 29 "fpurge.c"
int fpurge(FILE *fp ) 
{ 

  {
#line 34
  __fpurge(fp);
#line 36
  return (0);
}
}
#line 1 "fseek.o"
#pragma merger(0,"/tmp/cil-9oWuAZ2F.i","-g,-O2")
#line 746 "./stdio.h"
int rpl_fseek(FILE *fp , long offset , int whence )  __attribute__((__nonnull__(1))) ;
#line 25 "fseek.c"
int rpl_fseek(FILE *fp , long offset , int whence )  __attribute__((__nonnull__(1))) ;
#line 25 "fseek.c"
int rpl_fseek(FILE *fp , long offset , int whence ) 
{ int tmp ;

  {
#line 29
  tmp = rpl_fseeko(fp, offset, whence);
#line 29
  return (tmp);
}
}
#line 1 "fseeko.o"
#pragma merger(0,"/tmp/cil-HrPkKFM6.i","-g,-O2")
#line 766 "/usr/include/stdio.h"
extern int fseeko(FILE *__stream , __off_t __off , int __whence ) ;
#line 30 "fseeko.c"
int rpl_fseeko(FILE *fp , off_t offset , int whence )  __attribute__((__nonnull__(1))) ;
#line 30 "fseeko.c"
int rpl_fseeko(FILE *fp , off_t offset , int whence ) 
{ off_t pos ;
  int tmp ;
  __off_t tmp___0 ;
  int tmp___1 ;

  {
#line 46
  if ((unsigned long )fp->_IO_read_end == (unsigned long )fp->_IO_read_ptr) {
#line 46
    if ((unsigned long )fp->_IO_write_ptr == (unsigned long )fp->_IO_write_base) {
#line 46
      if ((unsigned long )fp->_IO_save_base == (unsigned long )((void *)0)) {
#line 101
        tmp = fileno(fp);
#line 101
        tmp___0 = lseek(tmp, offset, whence);
#line 101
        pos = tmp___0;
#line 102
        if (pos == -1L) {
#line 107
          return (-1);
        }
#line 111
        fp->_flags &= -17;
#line 112
        fp->_offset = pos;
#line 142
        return (0);
      }
    }
  }
#line 144
  tmp___1 = fseeko(fp, offset, whence);
#line 144
  return (tmp___1);
}
}
#line 1 "fsusage.o"
#pragma merger(0,"/tmp/cil-R1ze4WPc.i","-g,-O2")
#line 38 "fsusage.h"
int get_fs_usage(char const   *file , char const   *disk , struct fs_usage *fsp ) ;
#line 32 "/usr/include/sys/statfs.h"
extern  __attribute__((__nothrow__)) int statfs(char const   *__file , struct statfs *__buf )  __attribute__((__nonnull__(1,2))) ;
#line 94 "fsusage.c"
int get_fs_usage(char const   *file , char const   *disk , struct fs_usage *fsp ) 
{ struct statfs fsd ;
  int tmp ;
  int tmp___1 ;
  int tmp___3 ;
  int tmp___5 ;
  int tmp___7 ;
  int tmp___9 ;

  {
#line 186
  tmp = statfs(file, & fsd);
#line 186
  if (tmp < 0) {
#line 187
    return (-1);
  }
#line 189
  if (sizeof(fsd.f_bsize) < sizeof(uintmax_t )) {
#line 189
    if (sizeof(fsd.f_bsize) < sizeof(int )) {
#line 189
      tmp___1 = - (1 << sizeof(fsd.f_bsize) * 8UL);
    } else {
#line 189
      tmp___1 = 0;
    }
#line 189
    if (~ fsd.f_bsize == (long )tmp___1) {
#line 189
      fsp->fsu_blocksize = 0xffffffffffffffffUL;
    } else {
#line 189
      fsp->fsu_blocksize = (uintmax_t )fsd.f_bsize;
    }
  } else {
#line 189
    fsp->fsu_blocksize = (uintmax_t )fsd.f_bsize;
  }
#line 241
  if (sizeof(fsd.f_blocks) < sizeof(uintmax_t )) {
#line 241
    if (sizeof(fsd.f_blocks) < sizeof(int )) {
#line 241
      tmp___3 = - (1 << sizeof(fsd.f_blocks) * 8UL);
    } else {
#line 241
      tmp___3 = 0;
    }
#line 241
    if (~ fsd.f_blocks == (__fsblkcnt_t )tmp___3) {
#line 241
      fsp->fsu_blocks = 0xffffffffffffffffUL;
    } else {
#line 241
      fsp->fsu_blocks = fsd.f_blocks;
    }
  } else {
#line 241
    fsp->fsu_blocks = fsd.f_blocks;
  }
#line 242
  if (sizeof(fsd.f_bfree) < sizeof(uintmax_t )) {
#line 242
    if (sizeof(fsd.f_bfree) < sizeof(int )) {
#line 242
      tmp___5 = - (1 << sizeof(fsd.f_bfree) * 8UL);
    } else {
#line 242
      tmp___5 = 0;
    }
#line 242
    if (~ fsd.f_bfree == (__fsblkcnt_t )tmp___5) {
#line 242
      fsp->fsu_bfree = 0xffffffffffffffffUL;
    } else {
#line 242
      fsp->fsu_bfree = fsd.f_bfree;
    }
  } else {
#line 242
    fsp->fsu_bfree = fsd.f_bfree;
  }
#line 243
  fsp->fsu_bavail = fsd.f_bavail | ~ ((fsd.f_bavail & (1UL << (sizeof(fsd.f_bavail) * 8UL - 1UL))) - 1UL);
#line 244
  fsp->fsu_bavail_top_bit_set = (_Bool )((fsd.f_bavail & (1UL << (sizeof(fsd.f_bavail) * 8UL - 1UL))) != 0UL);
#line 245
  if (sizeof(fsd.f_files) < sizeof(uintmax_t )) {
#line 245
    if (sizeof(fsd.f_files) < sizeof(int )) {
#line 245
      tmp___7 = - (1 << sizeof(fsd.f_files) * 8UL);
    } else {
#line 245
      tmp___7 = 0;
    }
#line 245
    if (~ fsd.f_files == (__fsfilcnt_t )tmp___7) {
#line 245
      fsp->fsu_files = 0xffffffffffffffffUL;
    } else {
#line 245
      fsp->fsu_files = fsd.f_files;
    }
  } else {
#line 245
    fsp->fsu_files = fsd.f_files;
  }
#line 246
  if (sizeof(fsd.f_ffree) < sizeof(uintmax_t )) {
#line 246
    if (sizeof(fsd.f_ffree) < sizeof(int )) {
#line 246
      tmp___9 = - (1 << sizeof(fsd.f_ffree) * 8UL);
    } else {
#line 246
      tmp___9 = 0;
    }
#line 246
    if (~ fsd.f_ffree == (__fsfilcnt_t )tmp___9) {
#line 246
      fsp->fsu_ffree = 0xffffffffffffffffUL;
    } else {
#line 246
      fsp->fsu_ffree = fsd.f_ffree;
    }
  } else {
#line 246
    fsp->fsu_ffree = fsd.f_ffree;
  }
#line 251
  return (0);
}
}
#line 1 "fts.o"
#pragma merger(0,"/tmp/cil-sLvGW6en.i","-g,-O2")
#line 263 "fts_.h"
 __attribute__((__nothrow__)) FTSENT *fts_children(FTS *sp , int instr )  __attribute__((__warn_unused_result__)) ;
#line 264
 __attribute__((__nothrow__)) int fts_close(FTS *sp )  __attribute__((__warn_unused_result__)) ;
#line 265
 __attribute__((__nothrow__)) FTS *fts_open(char * const  *argv , int options , int (*compar)(FTSENT const   ** ,
                                                                                              FTSENT const   ** ) )  __attribute__((__warn_unused_result__)) ;
#line 268
 __attribute__((__nothrow__)) FTSENT *fts_read(FTS *sp )  __attribute__((__warn_unused_result__)) ;
#line 269
 __attribute__((__nothrow__)) int fts_set(FTS *sp  __attribute__((__unused__)) , FTSENT *p ,
                                          int instr ) ;
#line 761 "/usr/include/stdlib.h"
extern void qsort(void *__base , size_t __nmemb , size_t __size , int (*__compar)(void const   * ,
                                                                                  void const   * ) )  __attribute__((__nonnull__(1,4))) ;
#line 203 "fts.c"
static FTSENT *fts_alloc(FTS *sp , char const   *name , size_t namelen ) ;
#line 204
static FTSENT *fts_build(FTS *sp , int type ) ;
#line 205
static void fts_lfree(FTSENT *head ) ;
#line 206
static void fts_load(FTS *sp , FTSENT *p ) ;
#line 207
static size_t fts_maxarglen(char * const  *argv ) ;
#line 208
static void fts_padjust(FTS *sp , FTSENT *head ) ;
#line 209
static _Bool fts_palloc(FTS *sp , size_t more ) ;
#line 210
static FTSENT *fts_sort(FTS *sp , FTSENT *head , size_t nitems ) ;
#line 211
static unsigned short fts_stat(FTS *sp , FTSENT *p , _Bool follow ) ;
#line 212
static int fts_safe_changedir(FTS *sp , FTSENT *p , int fd , char const   *dir ) ;
#line 31 "fts-cycle.c"
static _Bool AD_compare(void const   *x , void const   *y ) 
{ struct Active_dir  const  *ax ;
  struct Active_dir  const  *ay ;
  int tmp ;

  {
#line 34
  ax = (struct Active_dir  const  *)x;
#line 35
  ay = (struct Active_dir  const  *)y;
#line 36
  if (ax->ino == ay->ino) {
#line 36
    if (ax->dev == ay->dev) {
#line 36
      tmp = 1;
    } else {
#line 36
      tmp = 0;
    }
  } else {
#line 36
    tmp = 0;
  }
#line 36
  return ((_Bool )tmp);
}
}
#line 40 "fts-cycle.c"
static size_t AD_hash(void const   *x , size_t table_size ) 
{ struct Active_dir  const  *ax ;

  {
#line 43
  ax = (struct Active_dir  const  *)x;
#line 44
  return ((uintmax_t )ax->ino % table_size);
}
}
#line 49 "fts-cycle.c"
static _Bool setup_dir(FTS *fts ) 
{ void *tmp ;

  {
#line 52
  if (fts->fts_options & 258) {
#line 55
    fts->fts_cycle.ht = hash_initialize((size_t )31, (Hash_tuning const   *)((void *)0),
                                        & AD_hash, & AD_compare, & free);
#line 57
    if (! fts->fts_cycle.ht) {
#line 58
      return ((_Bool)0);
    }
  } else {
#line 62
    tmp = malloc(sizeof(*(fts->fts_cycle.state)));
#line 62
    fts->fts_cycle.state = (struct cycle_check_state *)tmp;
#line 63
    if (! fts->fts_cycle.state) {
#line 64
      return ((_Bool)0);
    }
#line 65
    cycle_check_init(fts->fts_cycle.state);
  }
#line 68
  return ((_Bool)1);
}
}
#line 73 "fts-cycle.c"
static _Bool enter_dir(FTS *fts , FTSENT *ent ) 
{ struct stat  const  *st ;
  struct Active_dir *ad ;
  void *tmp ;
  struct Active_dir *ad_from_table ;
  void *tmp___0 ;
  _Bool tmp___1 ;

  {
#line 76
  if (fts->fts_options & 258) {
#line 78
    st = (struct stat  const  *)(ent->fts_statp);
#line 79
    tmp = malloc(sizeof(*ad));
#line 79
    ad = (struct Active_dir *)tmp;
#line 82
    if (! ad) {
#line 83
      return ((_Bool)0);
    }
#line 85
    ad->dev = (dev_t )st->st_dev;
#line 86
    ad->ino = (ino_t )st->st_ino;
#line 87
    ad->fts_ent = ent;
#line 92
    tmp___0 = hash_insert(fts->fts_cycle.ht, (void const   *)ad);
#line 92
    ad_from_table = (struct Active_dir *)tmp___0;
#line 94
    if ((unsigned long )ad_from_table != (unsigned long )ad) {
#line 96
      free((void *)ad);
#line 97
      if (! ad_from_table) {
#line 98
        return ((_Bool)0);
      }
#line 102
      ent->fts_cycle = ad_from_table->fts_ent;
#line 103
      ent->fts_info = (unsigned short)2;
    }
  } else {
#line 108
    tmp___1 = cycle_check(fts->fts_cycle.state, (struct stat  const  *)(ent->fts_statp));
#line 108
    if (tmp___1) {
#line 114
      ent->fts_cycle = ent;
#line 115
      ent->fts_info = (unsigned short)2;
    }
  }
#line 119
  return ((_Bool)1);
}
}
#line 124 "fts-cycle.c"
static void leave_dir(FTS *fts , FTSENT *ent ) 
{ struct stat  const  *st ;
  struct Active_dir obj ;
  void *found ;
  FTSENT *parent ;

  {
#line 127
  st = (struct stat  const  *)(ent->fts_statp);
#line 128
  if (fts->fts_options & 258) {
#line 132
    obj.dev = (dev_t )st->st_dev;
#line 133
    obj.ino = (ino_t )st->st_ino;
#line 134
    found = hash_delete(fts->fts_cycle.ht, (void const   *)(& obj));
#line 135
    if (! found) {
#line 136
      abort();
    }
#line 137
    free(found);
  } else {
#line 141
    parent = ent->fts_parent;
#line 142
    if ((unsigned long )parent != (unsigned long )((void *)0)) {
#line 142
      if (0L <= parent->fts_level) {
#line 143
        while (1) {
#line 143
          if ((fts->fts_cycle.state)->chdir_counter == 0UL) {
#line 143
            abort();
          }
#line 143
          if ((fts->fts_cycle.state)->dev_ino.st_ino == (ino_t )st->st_ino) {
#line 143
            if ((fts->fts_cycle.state)->dev_ino.st_dev == (dev_t )st->st_dev) {
#line 143
              (fts->fts_cycle.state)->dev_ino.st_dev = parent->fts_statp[0].st_dev;
#line 143
              (fts->fts_cycle.state)->dev_ino.st_ino = parent->fts_statp[0].st_ino;
            }
          }
#line 143
          break;
        }
      }
    }
  }
#line 146
  return;
}
}
#line 150 "fts-cycle.c"
static void free_dir(FTS *sp ) 
{ 

  {
#line 153
  if (sp->fts_options & 258) {
#line 155
    if (sp->fts_cycle.ht) {
#line 156
      hash_free(sp->fts_cycle.ht);
    }
  } else {
#line 159
    free((void *)sp->fts_cycle.state);
  }
#line 160
  return;
}
}
#line 273 "fts.c"
static void fd_ring_clear(I_ring *fd_ring ) 
{ int fd ;
  int tmp ;
  _Bool tmp___0 ;

  {
#line 276
  while (1) {
#line 276
    tmp___0 = i_ring_empty((I_ring const   *)fd_ring);
#line 276
    if (tmp___0) {
#line 276
      break;
    }
#line 278
    tmp = i_ring_pop(fd_ring);
#line 278
    fd = tmp;
#line 279
    if (0 <= fd) {
#line 280
      close(fd);
    }
  }
#line 282
  return;
}
}
#line 287 "fts.c"
static void fts_set_stat_required(FTSENT *p , _Bool required ) 
{ 

  {
#line 290
  while (1) {
#line 290
    if (! ((int )p->fts_info == 11)) {
#line 290
      abort();
    }
#line 290
    break;
  }
#line 291
  if (required) {
#line 291
    p->fts_statp[0].st_size = (__off_t )2;
  } else {
#line 291
    p->fts_statp[0].st_size = (__off_t )1;
  }
#line 294
  return;
}
}
#line 298 "fts.c"
__inline static DIR *opendirat(int fd , char const   *dir , int extra_flags , int *pdir_fd ) 
{ int new_fd ;
  int tmp ;
  DIR *dirp ;
  int saved_errno ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 302
  tmp = openat_safer(fd, dir, 67840 | extra_flags);
#line 302
  new_fd = tmp;
#line 307
  if (new_fd < 0) {
#line 308
    return ((DIR *)((void *)0));
  }
#line 309
  set_cloexec_flag(new_fd, (_Bool)1);
#line 310
  dirp = fdopendir(new_fd);
#line 311
  if (dirp) {
#line 312
    *pdir_fd = new_fd;
  } else {
#line 315
    tmp___0 = __errno_location();
#line 315
    saved_errno = *tmp___0;
#line 316
    close(new_fd);
#line 317
    tmp___1 = __errno_location();
#line 317
    *tmp___1 = saved_errno;
  }
#line 319
  return (dirp);
}
}
#line 327 "fts.c"
static void cwd_advance_fd(FTS *sp , int fd , _Bool chdir_down_one ) 
{ int old ;
  int prev_fd_in_slot ;
  int tmp ;

  {
#line 331
  old = sp->fts_cwd_fd;
#line 332
  while (1) {
#line 332
    if (! (old != fd)) {
#line 332
      if (! (old == -100)) {
#line 332
        abort();
      }
    }
#line 332
    break;
  }
#line 334
  if (chdir_down_one) {
#line 338
    tmp = i_ring_push(& sp->fts_fd_ring, old);
#line 338
    prev_fd_in_slot = tmp;
#line 340
    if (0 <= prev_fd_in_slot) {
#line 341
      close(prev_fd_in_slot);
    }
  } else
#line 343
  if (! (sp->fts_options & 4)) {
#line 345
    if (0 <= old) {
#line 346
      close(old);
    }
  }
#line 349
  sp->fts_cwd_fd = fd;
#line 350
  return;
}
}
#line 356 "fts.c"
__inline static int diropen(FTS const   *sp , char const   *dir ) 
{ int open_flags ;
  int tmp ;
  int tmp___0 ;
  int fd ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 360
  if (sp->fts_options & 16) {
#line 360
    tmp = 131072;
  } else {
#line 360
    tmp = 0;
  }
#line 360
  if (sp->fts_options & 2048) {
#line 360
    tmp___0 = 262144;
  } else {
#line 360
    tmp___0 = 0;
  }
#line 360
  open_flags = (67840 | tmp) | tmp___0;
#line 364
  if (sp->fts_options & 512) {
#line 364
    tmp___1 = openat_safer((int )sp->fts_cwd_fd, dir, open_flags);
#line 364
    tmp___3 = tmp___1;
  } else {
#line 364
    tmp___2 = open_safer(dir, open_flags);
#line 364
    tmp___3 = tmp___2;
  }
#line 364
  fd = tmp___3;
#line 367
  if (0 <= fd) {
#line 368
    set_cloexec_flag(fd, (_Bool)1);
  }
#line 369
  return (fd);
}
}
#line 372
 __attribute__((__nothrow__)) FTS *fts_open(char * const  *argv , int options , int (*compar)(FTSENT const   ** ,
                                                                                              FTSENT const   ** ) )  __attribute__((__warn_unused_result__)) ;
#line 372 "fts.c"
FTS *fts_open(char * const  *argv , int options , int (*compar)(FTSENT const   ** ,
                                                                FTSENT const   ** ) ) 
{ register FTS *sp ;
  register FTSENT *p ;
  register FTSENT *root ;
  register size_t nitems ;
  FTSENT *parent ;
  FTSENT *tmp ;
  _Bool defer_stat ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  void *tmp___3 ;
  size_t maxarglen ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  _Bool tmp___8 ;
  int tmp___9 ;
  size_t len ;
  size_t tmp___10 ;
  struct _ftsent *tmp___11 ;
  _Bool tmp___12 ;
  int tmp___13 ;

  {
#line 380
  parent = (FTSENT *)((void *)0);
#line 381
  tmp = (FTSENT *)((void *)0);
#line 385
  if (options & -4096) {
#line 386
    tmp___0 = __errno_location();
#line 386
    *tmp___0 = 22;
#line 387
    return ((FTS *)((void *)0));
  }
#line 389
  if (options & 4) {
#line 389
    if (options & 512) {
#line 390
      tmp___1 = __errno_location();
#line 390
      *tmp___1 = 22;
#line 391
      return ((FTS *)((void *)0));
    }
  }
#line 393
  if (! (options & 18)) {
#line 394
    tmp___2 = __errno_location();
#line 394
    *tmp___2 = 22;
#line 395
    return ((FTS *)((void *)0));
  }
#line 399
  tmp___3 = malloc(sizeof(FTS ));
#line 399
  sp = (FTS *)tmp___3;
#line 399
  if ((unsigned long )sp == (unsigned long )((void *)0)) {
#line 400
    return ((FTS *)((void *)0));
  }
#line 401
  memset((void *)sp, 0, sizeof(FTS ));
#line 402
  sp->fts_compar = compar;
#line 403
  sp->fts_options = options;
#line 406
  if (sp->fts_options & 2) {
#line 407
    sp->fts_options |= 4;
#line 408
    sp->fts_options &= -513;
  }
#line 412
  sp->fts_cwd_fd = -100;
#line 454
  tmp___6 = fts_maxarglen(argv);
#line 454
  maxarglen = tmp___6;
#line 455
  if (maxarglen > 4096UL) {
#line 455
    tmp___7 = maxarglen;
  } else {
#line 455
    tmp___7 = (size_t )4096;
  }
#line 455
  tmp___8 = fts_palloc(sp, tmp___7);
#line 455
  if (! tmp___8) {
#line 456
    goto mem1;
  }
#line 460
  if ((unsigned long )*argv != (unsigned long )((void *)0)) {
#line 461
    parent = fts_alloc(sp, "", (size_t )0);
#line 461
    if ((unsigned long )parent == (unsigned long )((void *)0)) {
#line 462
      goto mem2;
    }
#line 463
    parent->fts_level = (ptrdiff_t )-1;
  }
#line 477
  if ((unsigned long )compar == (unsigned long )((void *)0)) {
#line 477
    tmp___9 = 1;
  } else
#line 477
  if (sp->fts_options & 1024) {
#line 477
    tmp___9 = 1;
  } else {
#line 477
    tmp___9 = 0;
  }
#line 477
  defer_stat = (_Bool )tmp___9;
#line 480
  root = (FTSENT *)((void *)0);
#line 480
  nitems = (size_t )0;
#line 480
  while ((unsigned long )*argv != (unsigned long )((void *)0)) {
#line 482
    tmp___10 = strlen((char const   *)*argv);
#line 482
    len = tmp___10;
#line 483
    p = fts_alloc(sp, (char const   *)*argv, len);
#line 483
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 484
      goto mem3;
    }
#line 485
    p->fts_level = (ptrdiff_t )0;
#line 486
    p->fts_parent = parent;
#line 487
    p->fts_accpath = p->fts_name;
#line 491
    if (defer_stat) {
#line 491
      if ((unsigned long )root != (unsigned long )((void *)0)) {
#line 492
        p->fts_info = (unsigned short)11;
#line 493
        fts_set_stat_required(p, (_Bool)1);
      } else {
#line 495
        p->fts_info = fts_stat(sp, p, (_Bool)0);
      }
    } else {
#line 495
      p->fts_info = fts_stat(sp, p, (_Bool)0);
    }
#line 502
    if (compar) {
#line 503
      p->fts_link = root;
#line 504
      root = p;
    } else {
#line 506
      p->fts_link = (struct _ftsent *)((void *)0);
#line 507
      if ((unsigned long )root == (unsigned long )((void *)0)) {
#line 508
        root = p;
#line 508
        tmp = root;
      } else {
#line 510
        tmp->fts_link = p;
#line 511
        tmp = p;
      }
    }
#line 480
    argv ++;
#line 480
    nitems ++;
  }
#line 515
  if (compar) {
#line 515
    if (nitems > 1UL) {
#line 516
      root = fts_sort(sp, root, nitems);
    }
  }
#line 523
  tmp___11 = fts_alloc(sp, "", (size_t )0);
#line 523
  sp->fts_cur = tmp___11;
#line 523
  if ((unsigned long )tmp___11 == (unsigned long )((void *)0)) {
#line 524
    goto mem3;
  }
#line 525
  (sp->fts_cur)->fts_link = root;
#line 526
  (sp->fts_cur)->fts_info = (unsigned short)9;
#line 527
  tmp___12 = setup_dir(sp);
#line 527
  if (! tmp___12) {
#line 528
    goto mem3;
  }
#line 537
  if (! (sp->fts_options & 4)) {
#line 537
    if (! (sp->fts_options & 512)) {
#line 537
      tmp___13 = diropen((FTS const   *)sp, ".");
#line 537
      sp->fts_rfd = tmp___13;
#line 537
      if (tmp___13 < 0) {
#line 539
        sp->fts_options |= 4;
      }
    }
  }
#line 541
  i_ring_init(& sp->fts_fd_ring, -1);
#line 542
  return (sp);
  mem3: 
#line 544
  fts_lfree(root);
#line 545
  free((void *)parent);
  mem2: 
#line 546
  free((void *)sp->fts_path);
  mem1: 
#line 547
  free((void *)sp);
#line 548
  return ((FTS *)((void *)0));
}
}
#line 551 "fts.c"
static void fts_load(FTS *sp , FTSENT *p ) 
{ register size_t len ;
  register char *cp ;
  size_t tmp ;
  char *tmp___0 ;

  {
#line 565
  tmp = p->fts_namelen;
#line 565
  p->fts_pathlen = tmp;
#line 565
  len = tmp;
#line 566
  memmove((void *)sp->fts_path, (void const   *)(p->fts_name), len + 1UL);
#line 567
  cp = strrchr((char const   *)(p->fts_name), '/');
#line 567
  if (cp) {
#line 567
    if ((unsigned long )cp != (unsigned long )(p->fts_name)) {
#line 568
      cp ++;
#line 568
      len = strlen((char const   *)cp);
#line 569
      memmove((void *)(p->fts_name), (void const   *)cp, len + 1UL);
#line 570
      p->fts_namelen = len;
    } else
#line 567
    if (*(cp + 1)) {
#line 568
      cp ++;
#line 568
      len = strlen((char const   *)cp);
#line 569
      memmove((void *)(p->fts_name), (void const   *)cp, len + 1UL);
#line 570
      p->fts_namelen = len;
    }
  }
#line 572
  tmp___0 = sp->fts_path;
#line 572
  p->fts_path = tmp___0;
#line 572
  p->fts_accpath = tmp___0;
#line 573
  return;
}
}
#line 575
 __attribute__((__nothrow__)) int fts_close(FTS *sp )  __attribute__((__warn_unused_result__)) ;
#line 575 "fts.c"
int fts_close(FTS *sp ) 
{ register FTSENT *freep ;
  register FTSENT *p ;
  int saved_errno ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;

  {
#line 579
  saved_errno = 0;
#line 586
  if (sp->fts_cur) {
#line 587
    p = sp->fts_cur;
#line 587
    while (p->fts_level >= 0L) {
#line 588
      freep = p;
#line 589
      if ((unsigned long )p->fts_link != (unsigned long )((void *)0)) {
#line 589
        p = p->fts_link;
      } else {
#line 589
        p = p->fts_parent;
      }
#line 590
      free((void *)freep);
    }
#line 592
    free((void *)p);
  }
#line 596
  if (sp->fts_child) {
#line 597
    fts_lfree(sp->fts_child);
  }
#line 598
  free((void *)sp->fts_array);
#line 599
  free((void *)sp->fts_path);
#line 601
  if (sp->fts_options & 512) {
#line 603
    if (0 <= sp->fts_cwd_fd) {
#line 604
      tmp___0 = close(sp->fts_cwd_fd);
#line 604
      if (tmp___0) {
#line 605
        tmp = __errno_location();
#line 605
        saved_errno = *tmp;
      }
    }
  } else
#line 607
  if (! (sp->fts_options & 4)) {
#line 610
    tmp___2 = fchdir(sp->fts_rfd);
#line 610
    if (tmp___2) {
#line 611
      tmp___1 = __errno_location();
#line 611
      saved_errno = *tmp___1;
    }
#line 615
    tmp___4 = close(sp->fts_rfd);
#line 615
    if (tmp___4) {
#line 616
      if (saved_errno == 0) {
#line 617
        tmp___3 = __errno_location();
#line 617
        saved_errno = *tmp___3;
      }
    }
  }
#line 620
  fd_ring_clear(& sp->fts_fd_ring);
#line 622
  if (sp->fts_leaf_optimization_works_ht) {
#line 623
    hash_free(sp->fts_leaf_optimization_works_ht);
  }
#line 625
  free_dir(sp);
#line 628
  free((void *)sp);
#line 631
  if (saved_errno) {
#line 632
    tmp___5 = __errno_location();
#line 632
    *tmp___5 = saved_errno;
#line 633
    return (-1);
  }
#line 636
  return (0);
}
}
#line 51 "/usr/include/sys/statfs.h"
extern  __attribute__((__nothrow__)) int fstatfs(int __fildes , struct statfs *__buf )  __attribute__((__nonnull__(2))) ;
#line 654 "fts.c"
static _Bool dirent_inode_sort_may_be_useful(int dir_fd ) 
{ struct statfs fs_buf ;
  int tmp ;

  {
#line 665
  tmp = fstatfs(dir_fd, & fs_buf);
#line 665
  if (tmp != 0) {
#line 666
    return ((_Bool)1);
  }
#line 670
  switch ((int )fs_buf.f_type) {
  case 16914836: 
  case 26985: 
#line 676
  return ((_Bool)0);
  default: 
#line 679
  return ((_Bool)1);
  }
}
}
#line 686 "fts.c"
static _Bool leaf_optimization_applies(int dir_fd ) 
{ struct statfs fs_buf ;
  int tmp ;

  {
#line 692
  tmp = fstatfs(dir_fd, & fs_buf);
#line 692
  if (tmp != 0) {
#line 693
    return ((_Bool)0);
  }
#line 698
  switch ((int )fs_buf.f_type) {
  case 1382369651: 
#line 703
  return ((_Bool)1);
  default: 
#line 712
  return ((_Bool)0);
  }
}
}
#line 736 "fts.c"
static size_t LCO_hash(void const   *x , size_t table_size ) 
{ struct LCO_ent  const  *ax ;

  {
#line 739
  ax = (struct LCO_ent  const  *)x;
#line 740
  return ((uintmax_t )ax->st_dev % table_size);
}
}
#line 743 "fts.c"
static _Bool LCO_compare(void const   *x , void const   *y ) 
{ struct LCO_ent  const  *ax ;
  struct LCO_ent  const  *ay ;

  {
#line 746
  ax = (struct LCO_ent  const  *)x;
#line 747
  ay = (struct LCO_ent  const  *)y;
#line 748
  return ((_Bool )(ax->st_dev == ay->st_dev));
}
}
#line 754 "fts.c"
static _Bool link_count_optimize_ok(FTSENT const   *p ) 
{ FTS *sp ;
  Hash_table *h ;
  struct LCO_ent tmp ;
  struct LCO_ent *ent ;
  _Bool opt_ok ;
  struct LCO_ent *t2 ;
  struct hash_table *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 757
  sp = (FTS *)p->fts_fts;
#line 758
  h = sp->fts_leaf_optimization_works_ht;
#line 766
  if (! (sp->fts_options & 512)) {
#line 767
    return ((_Bool)0);
  }
#line 770
  if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 772
    tmp___0 = hash_initialize((size_t )13, (Hash_tuning const   *)((void *)0), & LCO_hash,
                              & LCO_compare, & free);
#line 772
    sp->fts_leaf_optimization_works_ht = tmp___0;
#line 772
    h = tmp___0;
#line 775
    if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 776
      return ((_Bool)0);
    }
  }
#line 778
  tmp.st_dev = (dev_t )p->fts_statp[0].st_dev;
#line 779
  tmp___1 = hash_lookup((Hash_table const   *)h, (void const   *)(& tmp));
#line 779
  ent = (struct LCO_ent *)tmp___1;
#line 780
  if (ent) {
#line 781
    return (ent->opt_ok);
  }
#line 784
  tmp___2 = malloc(sizeof(*t2));
#line 784
  t2 = (struct LCO_ent *)tmp___2;
#line 785
  if ((unsigned long )t2 == (unsigned long )((void *)0)) {
#line 786
    return ((_Bool)0);
  }
#line 789
  opt_ok = leaf_optimization_applies(sp->fts_cwd_fd);
#line 790
  t2->opt_ok = opt_ok;
#line 791
  t2->st_dev = (dev_t )p->fts_statp[0].st_dev;
#line 793
  tmp___3 = hash_insert(h, (void const   *)t2);
#line 793
  ent = (struct LCO_ent *)tmp___3;
#line 794
  if ((unsigned long )ent == (unsigned long )((void *)0)) {
#line 797
    free((void *)t2);
#line 798
    return ((_Bool)0);
  }
#line 800
  while (1) {
#line 800
    if (! ((unsigned long )ent == (unsigned long )t2)) {
#line 800
      abort();
    }
#line 800
    break;
  }
#line 802
  return (opt_ok);
}
}
#line 813
 __attribute__((__nothrow__)) FTSENT *fts_read(FTS *sp )  __attribute__((__warn_unused_result__)) ;
#line 813 "fts.c"
FTSENT *fts_read(FTS *sp ) 
{ register FTSENT *p ;
  register FTSENT *tmp ;
  register unsigned short instr ;
  register char *t ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  struct _ftsent *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  char *tmp___13 ;
  FTSENT *parent ;
  _Bool tmp___14 ;
  int *tmp___15 ;
  _Bool tmp___16 ;
  int *tmp___17 ;
  struct _ftsent *tmp___18 ;
  int *tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int saved_errno ;
  int *tmp___25 ;
  int *tmp___26 ;
  int *tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int *tmp___30 ;
  int tmp___31 ;
  FTSENT *tmp___32 ;

  {
#line 821
  if ((unsigned long )sp->fts_cur == (unsigned long )((void *)0)) {
#line 822
    return ((FTSENT *)((void *)0));
  } else
#line 821
  if (sp->fts_options & 8192) {
#line 822
    return ((FTSENT *)((void *)0));
  }
#line 825
  p = sp->fts_cur;
#line 828
  instr = p->fts_instr;
#line 829
  p->fts_instr = (unsigned short)3;
#line 832
  if ((int )instr == 1) {
#line 833
    p->fts_info = fts_stat(sp, p, (_Bool)0);
#line 834
    return (p);
  }
#line 845
  if ((int )instr == 2) {
#line 845
    if ((int )p->fts_info == 12) {
#line 845
      goto _L;
    } else
#line 845
    if ((int )p->fts_info == 13) {
      _L: 
#line 847
      p->fts_info = fts_stat(sp, p, (_Bool)1);
#line 848
      if ((int )p->fts_info == 1) {
#line 848
        if (! (sp->fts_options & 4)) {
#line 849
          tmp___1 = diropen((FTS const   *)sp, ".");
#line 849
          p->fts_symfd = tmp___1;
#line 849
          if (tmp___1 < 0) {
#line 850
            tmp___0 = __errno_location();
#line 850
            p->fts_errno = *tmp___0;
#line 851
            p->fts_info = (unsigned short)7;
          } else {
#line 853
            p->fts_flags = (unsigned short )((int )p->fts_flags | 2);
          }
        }
      }
#line 855
      goto check_for_dir;
    }
  }
#line 859
  if ((int )p->fts_info == 1) {
#line 861
    if ((int )instr == 4) {
#line 861
      goto _L___0;
    } else
#line 861
    if (sp->fts_options & 64) {
#line 861
      if (p->fts_statp[0].st_dev != sp->fts_dev) {
        _L___0: 
#line 863
        if ((int )p->fts_flags & 2) {
#line 864
          close(p->fts_symfd);
        }
#line 865
        if (sp->fts_child) {
#line 866
          fts_lfree(sp->fts_child);
#line 867
          sp->fts_child = (struct _ftsent *)((void *)0);
        }
#line 869
        p->fts_info = (unsigned short)6;
#line 870
        while (1) {
#line 870
          leave_dir(sp, p);
#line 870
          break;
        }
#line 871
        return (p);
      }
    }
#line 875
    if ((unsigned long )sp->fts_child != (unsigned long )((void *)0)) {
#line 875
      if (sp->fts_options & 4096) {
#line 876
        sp->fts_options &= -4097;
#line 877
        fts_lfree(sp->fts_child);
#line 878
        sp->fts_child = (struct _ftsent *)((void *)0);
      }
    }
#line 893
    if ((unsigned long )sp->fts_child != (unsigned long )((void *)0)) {
#line 894
      tmp___3 = fts_safe_changedir(sp, p, -1, (char const   *)p->fts_accpath);
#line 894
      if (tmp___3) {
#line 895
        tmp___2 = __errno_location();
#line 895
        p->fts_errno = *tmp___2;
#line 896
        p->fts_flags = (unsigned short )((int )p->fts_flags | 1);
#line 897
        p = sp->fts_child;
#line 897
        while ((unsigned long )p != (unsigned long )((void *)0)) {
#line 899
          p->fts_accpath = (p->fts_parent)->fts_accpath;
#line 897
          p = p->fts_link;
        }
      }
    } else {
#line 902
      tmp___4 = fts_build(sp, 3);
#line 902
      sp->fts_child = tmp___4;
#line 902
      if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
#line 903
        if (sp->fts_options & 8192) {
#line 904
          return ((FTSENT *)((void *)0));
        }
#line 908
        if (p->fts_errno) {
#line 908
          if ((int )p->fts_info != 4) {
#line 909
            p->fts_info = (unsigned short)7;
          }
        }
#line 910
        while (1) {
#line 910
          leave_dir(sp, p);
#line 910
          break;
        }
#line 911
        return (p);
      }
    }
#line 913
    p = sp->fts_child;
#line 914
    sp->fts_child = (struct _ftsent *)((void *)0);
#line 915
    goto name;
  }
  next: 
#line 919
  tmp = p;
#line 924
  if ((unsigned long )p->fts_link == (unsigned long )((void *)0)) {
#line 924
    if ((p->fts_parent)->fts_dirp) {
#line 926
      p = tmp->fts_parent;
#line 927
      sp->fts_cur = p;
#line 928
      *(sp->fts_path + p->fts_pathlen) = (char )'\000';
#line 930
      p = fts_build(sp, 3);
#line 930
      if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 932
        if (sp->fts_options & 8192) {
#line 933
          return ((FTSENT *)((void *)0));
        }
#line 934
        goto cd_dot_dot;
      }
#line 937
      free((void *)tmp);
#line 938
      goto name;
    }
  }
#line 941
  p = p->fts_link;
#line 941
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 942
    sp->fts_cur = p;
#line 943
    free((void *)tmp);
#line 950
    if (p->fts_level == 0L) {
#line 951
      fd_ring_clear(& sp->fts_fd_ring);
#line 951
      if (! (sp->fts_options & 4)) {
#line 951
        if (sp->fts_options & 512) {
#line 951
          if (sp->fts_options & 512) {
#line 951
            tmp___5 = -100;
          } else {
#line 951
            tmp___5 = sp->fts_rfd;
          }
#line 951
          cwd_advance_fd(sp, tmp___5, (_Bool)1);
#line 951
          tmp___8 = 0;
        } else {
#line 951
          if (sp->fts_options & 512) {
#line 951
            tmp___6 = -100;
          } else {
#line 951
            tmp___6 = sp->fts_rfd;
          }
#line 951
          tmp___7 = fchdir(tmp___6);
#line 951
          tmp___8 = tmp___7;
        }
#line 951
        if (tmp___8) {
#line 951
          tmp___9 = 1;
        } else {
#line 951
          tmp___9 = 0;
        }
      } else {
#line 951
        tmp___9 = 0;
      }
#line 951
      if (tmp___9) {
#line 952
        sp->fts_options |= 8192;
#line 953
        return ((FTSENT *)((void *)0));
      }
#line 955
      free_dir(sp);
#line 956
      fts_load(sp, p);
#line 957
      setup_dir(sp);
#line 958
      goto check_for_dir;
    }
#line 966
    if ((int )p->fts_instr == 4) {
#line 967
      goto next;
    }
#line 968
    if ((int )p->fts_instr == 2) {
#line 969
      p->fts_info = fts_stat(sp, p, (_Bool)1);
#line 970
      if ((int )p->fts_info == 1) {
#line 970
        if (! (sp->fts_options & 4)) {
#line 971
          tmp___11 = diropen((FTS const   *)sp, ".");
#line 971
          p->fts_symfd = tmp___11;
#line 971
          if (tmp___11 < 0) {
#line 972
            tmp___10 = __errno_location();
#line 972
            p->fts_errno = *tmp___10;
#line 973
            p->fts_info = (unsigned short)7;
          } else {
#line 975
            p->fts_flags = (unsigned short )((int )p->fts_flags | 2);
          }
        }
      }
#line 977
      p->fts_instr = (unsigned short)3;
    }
    name: 
#line 980
    if ((int )*((p->fts_parent)->fts_path + ((p->fts_parent)->fts_pathlen - 1UL)) == 47) {
#line 980
      tmp___12 = (p->fts_parent)->fts_pathlen - 1UL;
    } else {
#line 980
      tmp___12 = (p->fts_parent)->fts_pathlen;
    }
#line 980
    t = sp->fts_path + tmp___12;
#line 981
    tmp___13 = t;
#line 981
    t ++;
#line 981
    *tmp___13 = (char )'/';
#line 982
    memmove((void *)t, (void const   *)(p->fts_name), p->fts_namelen + 1UL);
    check_for_dir: 
#line 984
    sp->fts_cur = p;
#line 985
    if ((int )p->fts_info == 11) {
#line 987
      if (p->fts_statp[0].st_size == 2L) {
#line 989
        parent = p->fts_parent;
#line 990
        if (0L < p->fts_level) {
#line 990
          if (parent->fts_n_dirs_remaining == 0UL) {
#line 990
            if (sp->fts_options & 8) {
#line 990
              if (sp->fts_options & 16) {
#line 990
                tmp___14 = link_count_optimize_ok((FTSENT const   *)parent);
#line 990
                if (! tmp___14) {
#line 990
                  goto _L___4;
                }
              } else {
#line 990
                goto _L___4;
              }
            } else {
#line 990
              goto _L___4;
            }
          } else {
#line 990
            goto _L___4;
          }
        } else {
          _L___4: 
#line 1002
          p->fts_info = fts_stat(sp, p, (_Bool)0);
#line 1003
          if ((p->fts_statp[0].st_mode & 61440U) == 16384U) {
#line 1003
            if (p->fts_level != 0L) {
#line 1003
              if (parent->fts_n_dirs_remaining) {
#line 1006
                (parent->fts_n_dirs_remaining) --;
              }
            }
          }
        }
      } else {
#line 1010
        while (1) {
#line 1010
          if (! (p->fts_statp[0].st_size == 1L)) {
#line 1010
            abort();
          }
#line 1010
          break;
        }
      }
    }
#line 1013
    if ((int )p->fts_info == 1) {
#line 1018
      if (p->fts_level == 0L) {
#line 1019
        sp->fts_dev = p->fts_statp[0].st_dev;
      }
#line 1021
      tmp___16 = enter_dir(sp, p);
#line 1021
      if (! tmp___16) {
#line 1023
        tmp___15 = __errno_location();
#line 1023
        *tmp___15 = 12;
#line 1024
        return ((FTSENT *)((void *)0));
      }
    }
#line 1027
    return (p);
  }
  cd_dot_dot: 
#line 1032
  p = tmp->fts_parent;
#line 1033
  sp->fts_cur = p;
#line 1034
  free((void *)tmp);
#line 1036
  if (p->fts_level == -1L) {
#line 1041
    free((void *)p);
#line 1042
    tmp___17 = __errno_location();
#line 1042
    *tmp___17 = 0;
#line 1043
    tmp___18 = (struct _ftsent *)((void *)0);
#line 1043
    sp->fts_cur = tmp___18;
#line 1043
    return (tmp___18);
  }
#line 1046
  while (1) {
#line 1046
    if (! ((int )p->fts_info != 11)) {
#line 1046
      abort();
    }
#line 1046
    break;
  }
#line 1049
  *(sp->fts_path + p->fts_pathlen) = (char )'\000';
#line 1057
  if (p->fts_level == 0L) {
#line 1058
    fd_ring_clear(& sp->fts_fd_ring);
#line 1058
    if (! (sp->fts_options & 4)) {
#line 1058
      if (sp->fts_options & 512) {
#line 1058
        if (sp->fts_options & 512) {
#line 1058
          tmp___20 = -100;
        } else {
#line 1058
          tmp___20 = sp->fts_rfd;
        }
#line 1058
        cwd_advance_fd(sp, tmp___20, (_Bool)1);
#line 1058
        tmp___23 = 0;
      } else {
#line 1058
        if (sp->fts_options & 512) {
#line 1058
          tmp___21 = -100;
        } else {
#line 1058
          tmp___21 = sp->fts_rfd;
        }
#line 1058
        tmp___22 = fchdir(tmp___21);
#line 1058
        tmp___23 = tmp___22;
      }
#line 1058
      if (tmp___23) {
#line 1058
        tmp___24 = 1;
      } else {
#line 1058
        tmp___24 = 0;
      }
    } else {
#line 1058
      tmp___24 = 0;
    }
#line 1058
    if (tmp___24) {
#line 1059
      tmp___19 = __errno_location();
#line 1059
      p->fts_errno = *tmp___19;
#line 1060
      sp->fts_options |= 8192;
    }
  } else
#line 1062
  if ((int )p->fts_flags & 2) {
#line 1063
    if (! (sp->fts_options & 4)) {
#line 1063
      if (sp->fts_options & 512) {
#line 1063
        cwd_advance_fd(sp, p->fts_symfd, (_Bool)1);
#line 1063
        tmp___29 = 0;
      } else {
#line 1063
        tmp___28 = fchdir(p->fts_symfd);
#line 1063
        tmp___29 = tmp___28;
      }
#line 1063
      if (tmp___29) {
#line 1064
        tmp___25 = __errno_location();
#line 1064
        saved_errno = *tmp___25;
#line 1065
        close(p->fts_symfd);
#line 1066
        tmp___26 = __errno_location();
#line 1066
        *tmp___26 = saved_errno;
#line 1067
        tmp___27 = __errno_location();
#line 1067
        p->fts_errno = *tmp___27;
#line 1068
        sp->fts_options |= 8192;
      }
    }
#line 1070
    close(p->fts_symfd);
  } else
#line 1071
  if (! ((int )p->fts_flags & 1)) {
#line 1071
    tmp___31 = fts_safe_changedir(sp, p->fts_parent, -1, "..");
#line 1071
    if (tmp___31) {
#line 1073
      tmp___30 = __errno_location();
#line 1073
      p->fts_errno = *tmp___30;
#line 1074
      sp->fts_options |= 8192;
    }
  }
#line 1076
  if (p->fts_errno) {
#line 1076
    p->fts_info = (unsigned short)7;
  } else {
#line 1076
    p->fts_info = (unsigned short)6;
  }
#line 1077
  if (p->fts_errno == 0) {
#line 1078
    while (1) {
#line 1078
      leave_dir(sp, p);
#line 1078
      break;
    }
  }
#line 1079
  if (sp->fts_options & 8192) {
#line 1079
    tmp___32 = (FTSENT *)((void *)0);
  } else {
#line 1079
    tmp___32 = p;
  }
#line 1079
  return (tmp___32);
}
}
#line 1089
 __attribute__((__nothrow__)) int fts_set(FTS *sp  __attribute__((__unused__)) , FTSENT *p ,
                                          int instr ) ;
#line 1089 "fts.c"
int fts_set(FTS *sp  __attribute__((__unused__)) , FTSENT *p , int instr ) 
{ int *tmp ;

  {
#line 1092
  if (instr != 0) {
#line 1092
    if (instr != 1) {
#line 1092
      if (instr != 2) {
#line 1092
        if (instr != 3) {
#line 1092
          if (instr != 4) {
#line 1094
            tmp = __errno_location();
#line 1094
            *tmp = 22;
#line 1095
            return (1);
          }
        }
      }
    }
  }
#line 1097
  p->fts_instr = (unsigned short )instr;
#line 1098
  return (0);
}
}
#line 1101
 __attribute__((__nothrow__)) FTSENT *fts_children(FTS *sp , int instr )  __attribute__((__warn_unused_result__)) ;
#line 1101 "fts.c"
FTSENT *fts_children(FTS *sp , int instr ) 
{ register FTSENT *p ;
  int fd ;
  int *tmp ;
  int *tmp___0 ;
  struct _ftsent *tmp___1 ;
  struct _ftsent *tmp___2 ;
  int saved_errno ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
#line 1107
  if (instr != 0) {
#line 1107
    if (instr != 4096) {
#line 1108
      tmp = __errno_location();
#line 1108
      *tmp = 22;
#line 1109
      return ((FTSENT *)((void *)0));
    }
  }
#line 1113
  p = sp->fts_cur;
#line 1119
  tmp___0 = __errno_location();
#line 1119
  *tmp___0 = 0;
#line 1122
  if (sp->fts_options & 8192) {
#line 1123
    return ((FTSENT *)((void *)0));
  }
#line 1126
  if ((int )p->fts_info == 9) {
#line 1127
    return (p->fts_link);
  }
#line 1134
  if ((int )p->fts_info != 1) {
#line 1135
    return ((FTSENT *)((void *)0));
  }
#line 1138
  if ((unsigned long )sp->fts_child != (unsigned long )((void *)0)) {
#line 1139
    fts_lfree(sp->fts_child);
  }
#line 1141
  if (instr == 4096) {
#line 1142
    sp->fts_options |= 4096;
#line 1143
    instr = 2;
  } else {
#line 1145
    instr = 1;
  }
#line 1154
  if (p->fts_level != 0L) {
#line 1156
    tmp___1 = fts_build(sp, instr);
#line 1156
    sp->fts_child = tmp___1;
#line 1156
    return (tmp___1);
  } else
#line 1154
  if ((int )*(p->fts_accpath + 0) == 47) {
#line 1156
    tmp___1 = fts_build(sp, instr);
#line 1156
    sp->fts_child = tmp___1;
#line 1156
    return (tmp___1);
  } else
#line 1154
  if (sp->fts_options & 4) {
#line 1156
    tmp___1 = fts_build(sp, instr);
#line 1156
    sp->fts_child = tmp___1;
#line 1156
    return (tmp___1);
  }
#line 1158
  fd = diropen((FTS const   *)sp, ".");
#line 1158
  if (fd < 0) {
#line 1159
    tmp___2 = (struct _ftsent *)((void *)0);
#line 1159
    sp->fts_child = tmp___2;
#line 1159
    return (tmp___2);
  }
#line 1160
  sp->fts_child = fts_build(sp, instr);
#line 1161
  if (sp->fts_options & 512) {
#line 1163
    cwd_advance_fd(sp, fd, (_Bool)1);
  } else {
#line 1167
    tmp___5 = fchdir(fd);
#line 1167
    if (tmp___5) {
#line 1169
      tmp___3 = __errno_location();
#line 1169
      saved_errno = *tmp___3;
#line 1170
      close(fd);
#line 1171
      tmp___4 = __errno_location();
#line 1171
      *tmp___4 = saved_errno;
#line 1172
      return ((FTSENT *)((void *)0));
    }
#line 1174
    close(fd);
  }
#line 1176
  return (sp->fts_child);
}
}
#line 1184 "fts.c"
static int fts_compare_ino(struct _ftsent  const  **a , struct _ftsent  const  **b ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 1187
  if ((*(a + 0))->fts_statp[0].st_ino < (*(b + 0))->fts_statp[0].st_ino) {
#line 1187
    tmp___0 = -1;
  } else {
#line 1187
    if ((*(b + 0))->fts_statp[0].st_ino < (*(a + 0))->fts_statp[0].st_ino) {
#line 1187
      tmp = 1;
    } else {
#line 1187
      tmp = 0;
    }
#line 1187
    tmp___0 = tmp;
  }
#line 1187
  return (tmp___0);
}
}
#line 1193 "fts.c"
static void set_stat_type(struct stat *st , unsigned int dtype ) 
{ mode_t type ;

  {
#line 1197
  switch ((int )dtype) {
  case 6: 
#line 1200
  type = (mode_t )24576;
#line 1201
  break;
  case 2: 
#line 1203
  type = (mode_t )8192;
#line 1204
  break;
  case 4: 
#line 1206
  type = (mode_t )16384;
#line 1207
  break;
  case 1: 
#line 1209
  type = (mode_t )4096;
#line 1210
  break;
  case 10: 
#line 1212
  type = (mode_t )40960;
#line 1213
  break;
  case 8: 
#line 1215
  type = (mode_t )32768;
#line 1216
  break;
  case 12: 
#line 1218
  type = (mode_t )49152;
#line 1219
  break;
  default: 
#line 1221
  type = (mode_t )0;
  }
#line 1223
  st->st_mode = type;
#line 1224
  return;
}
}
#line 1259 "fts.c"
static FTSENT *fts_build(FTS *sp , int type ) 
{ register FTSENT *p ;
  register FTSENT *head ;
  register size_t nitems ;
  FTSENT *tail ;
  void *oldaddr ;
  int saved_errno ;
  _Bool descend ;
  _Bool doadjust ;
  ptrdiff_t level ;
  nlink_t nlinks ;
  _Bool nostat ;
  size_t len ;
  size_t maxlen ;
  size_t new_len ;
  char *cp ;
  int dir_fd ;
  FTSENT *cur ;
  _Bool continue_readdir ;
  DIR *dp ;
  int *tmp ;
  int *tmp___0 ;
  DIR *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  _Bool tmp___6 ;
  size_t max_entries ;
  unsigned long tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  _Bool is_dir ;
  struct dirent *dp___0 ;
  struct dirent *tmp___12 ;
  size_t tmp___13 ;
  int *tmp___14 ;
  int *tmp___15 ;
  size_t tmp___16 ;
  _Bool tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  int *tmp___20 ;
  _Bool skip_stat ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  _Bool tmp___31 ;

  {
#line 1276
  cur = sp->fts_cur;
#line 1277
  continue_readdir = (_Bool )(! (! cur->fts_dirp));
#line 1282
  if (continue_readdir) {
#line 1284
    dp = cur->fts_dirp;
#line 1285
    dir_fd = dirfd(dp);
#line 1286
    if (dir_fd < 0) {
#line 1288
      while (1) {
#line 1288
        closedir(cur->fts_dirp);
#line 1288
        cur->fts_dirp = (DIR *)((void *)0);
#line 1288
        break;
      }
#line 1289
      if (type == 3) {
#line 1291
        cur->fts_info = (unsigned short)4;
#line 1292
        tmp = __errno_location();
#line 1292
        cur->fts_errno = *tmp;
      }
#line 1294
      return ((FTSENT *)((void *)0));
    }
  } else {
#line 1301
    if (sp->fts_options & 16) {
#line 1301
      if (sp->fts_options & 1) {
#line 1301
        if (cur->fts_level == 0L) {
#line 1301
          tmp___2 = 0;
        } else {
#line 1301
          tmp___2 = 131072;
        }
      } else {
#line 1301
        tmp___2 = 131072;
      }
    } else {
#line 1301
      tmp___2 = 0;
    }
#line 1301
    if (sp->fts_options & 2048) {
#line 1301
      tmp___3 = 262144;
    } else {
#line 1301
      tmp___3 = 0;
    }
#line 1301
    if (! (sp->fts_options & 4)) {
#line 1301
      if (sp->fts_options & 512) {
#line 1301
        tmp___4 = sp->fts_cwd_fd;
      } else {
#line 1301
        tmp___4 = -100;
      }
    } else {
#line 1301
      tmp___4 = -100;
    }
#line 1301
    tmp___1 = opendirat(tmp___4, (char const   *)cur->fts_accpath, tmp___2 | tmp___3,
                        & dir_fd);
#line 1301
    cur->fts_dirp = tmp___1;
#line 1301
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 1303
      if (type == 3) {
#line 1305
        cur->fts_info = (unsigned short)4;
#line 1306
        tmp___0 = __errno_location();
#line 1306
        cur->fts_errno = *tmp___0;
      }
#line 1308
      return ((FTSENT *)((void *)0));
    }
#line 1313
    if ((int )cur->fts_info == 11) {
#line 1314
      cur->fts_info = fts_stat(sp, cur, (_Bool)0);
    } else
#line 1315
    if (sp->fts_options & 256) {
#line 1322
      while (1) {
#line 1322
        leave_dir(sp, cur);
#line 1322
        break;
      }
#line 1323
      fts_stat(sp, cur, (_Bool)0);
#line 1324
      tmp___6 = enter_dir(sp, cur);
#line 1324
      if (! tmp___6) {
#line 1326
        tmp___5 = __errno_location();
#line 1326
        *tmp___5 = 12;
#line 1327
        return ((FTSENT *)((void *)0));
      }
    }
  }
#line 1339
  if ((unsigned long )sp->fts_compar == (unsigned long )((void *)0)) {
#line 1339
    tmp___7 = 100000UL;
  } else {
#line 1339
    tmp___7 = 0xffffffffffffffffUL;
  }
#line 1339
  max_entries = tmp___7;
#line 1347
  if (type == 2) {
#line 1348
    nlinks = (nlink_t )0;
#line 1350
    nostat = (_Bool)0;
  } else
#line 1351
  if (sp->fts_options & 8) {
#line 1351
    if (sp->fts_options & 16) {
#line 1352
      if (sp->fts_options & 32) {
#line 1352
        tmp___8 = 0;
      } else {
#line 1352
        tmp___8 = 2;
      }
#line 1352
      nlinks = cur->fts_statp[0].st_nlink - (__nlink_t )tmp___8;
#line 1354
      nostat = (_Bool)1;
    } else {
#line 1356
      nlinks = (nlink_t )-1;
#line 1357
      nostat = (_Bool)0;
    }
  } else {
#line 1356
    nlinks = (nlink_t )-1;
#line 1357
    nostat = (_Bool)0;
  }
#line 1375
  if (continue_readdir) {
#line 1379
    descend = (_Bool)1;
  } else
#line 1381
  if (nlinks) {
#line 1381
    goto _L___0;
  } else
#line 1381
  if (type == 3) {
    _L___0: 
#line 1382
    if (sp->fts_options & 512) {
#line 1384
      dir_fd = dup_safer(dir_fd);
#line 1385
      if (0 <= dir_fd) {
#line 1386
        set_cloexec_flag(dir_fd, (_Bool)1);
      }
    }
#line 1388
    if (dir_fd < 0) {
#line 1388
      goto _L;
    } else {
#line 1388
      tmp___10 = fts_safe_changedir(sp, cur, dir_fd, (char const   *)((void *)0));
#line 1388
      if (tmp___10) {
        _L: 
#line 1389
        if (nlinks) {
#line 1389
          if (type == 3) {
#line 1390
            tmp___9 = __errno_location();
#line 1390
            cur->fts_errno = *tmp___9;
          }
        }
#line 1391
        cur->fts_flags = (unsigned short )((int )cur->fts_flags | 1);
#line 1392
        descend = (_Bool)0;
#line 1393
        while (1) {
#line 1393
          closedir(cur->fts_dirp);
#line 1393
          cur->fts_dirp = (DIR *)((void *)0);
#line 1393
          break;
        }
#line 1394
        if (sp->fts_options & 512) {
#line 1394
          if (0 <= dir_fd) {
#line 1395
            close(dir_fd);
          }
        }
#line 1396
        cur->fts_dirp = (DIR *)((void *)0);
      } else {
#line 1398
        descend = (_Bool)1;
      }
    }
  } else {
#line 1400
    descend = (_Bool)0;
  }
#line 1412
  if ((int )*(cur->fts_path + (cur->fts_pathlen - 1UL)) == 47) {
#line 1412
    len = cur->fts_pathlen - 1UL;
  } else {
#line 1412
    len = cur->fts_pathlen;
  }
#line 1413
  if (sp->fts_options & 4) {
#line 1414
    cp = sp->fts_path + len;
#line 1415
    tmp___11 = cp;
#line 1415
    cp ++;
#line 1415
    *tmp___11 = (char )'/';
  } else {
#line 1418
    cp = (char *)((void *)0);
  }
#line 1420
  len ++;
#line 1421
  maxlen = sp->fts_pathlen - len;
#line 1423
  level = cur->fts_level + 1L;
#line 1426
  doadjust = (_Bool)0;
#line 1427
  head = (FTSENT *)((void *)0);
#line 1428
  tail = (FTSENT *)((void *)0);
#line 1429
  nitems = (size_t )0;
#line 1430
  while (cur->fts_dirp) {
#line 1432
    tmp___12 = readdir(cur->fts_dirp);
#line 1432
    dp___0 = tmp___12;
#line 1433
    if ((unsigned long )dp___0 == (unsigned long )((void *)0)) {
#line 1434
      break;
    }
#line 1435
    if (! (sp->fts_options & 32)) {
#line 1435
      if ((int )dp___0->d_name[0] == 46) {
#line 1435
        if (! dp___0->d_name[1]) {
#line 1436
          continue;
        } else
#line 1435
        if ((int )dp___0->d_name[1] == 46) {
#line 1435
          if (! dp___0->d_name[2]) {
#line 1436
            continue;
          }
        }
      }
    }
#line 1438
    tmp___13 = strlen((char const   *)(dp___0->d_name));
#line 1438
    p = fts_alloc(sp, (char const   *)(dp___0->d_name), tmp___13);
#line 1438
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1440
      goto mem1;
    }
#line 1441
    tmp___18 = strlen((char const   *)(dp___0->d_name));
#line 1441
    if (tmp___18 >= maxlen) {
#line 1443
      oldaddr = (void *)sp->fts_path;
#line 1444
      tmp___16 = strlen((char const   *)(dp___0->d_name));
#line 1444
      tmp___17 = fts_palloc(sp, (tmp___16 + len) + 1UL);
#line 1444
      if (! tmp___17) {
        mem1: 
#line 1450
        tmp___14 = __errno_location();
#line 1450
        saved_errno = *tmp___14;
#line 1451
        free((void *)p);
#line 1452
        fts_lfree(head);
#line 1453
        while (1) {
#line 1453
          closedir(cur->fts_dirp);
#line 1453
          cur->fts_dirp = (DIR *)((void *)0);
#line 1453
          break;
        }
#line 1454
        cur->fts_info = (unsigned short)7;
#line 1455
        sp->fts_options |= 8192;
#line 1456
        tmp___15 = __errno_location();
#line 1456
        *tmp___15 = saved_errno;
#line 1457
        return ((FTSENT *)((void *)0));
      }
#line 1460
      if ((unsigned long )oldaddr != (unsigned long )sp->fts_path) {
#line 1461
        doadjust = (_Bool)1;
#line 1462
        if (sp->fts_options & 4) {
#line 1463
          cp = sp->fts_path + len;
        }
      }
#line 1465
      maxlen = sp->fts_pathlen - len;
    }
#line 1468
    tmp___19 = strlen((char const   *)(dp___0->d_name));
#line 1468
    new_len = len + tmp___19;
#line 1469
    if (new_len < len) {
#line 1476
      free((void *)p);
#line 1477
      fts_lfree(head);
#line 1478
      while (1) {
#line 1478
        closedir(cur->fts_dirp);
#line 1478
        cur->fts_dirp = (DIR *)((void *)0);
#line 1478
        break;
      }
#line 1479
      cur->fts_info = (unsigned short)7;
#line 1480
      sp->fts_options |= 8192;
#line 1481
      tmp___20 = __errno_location();
#line 1481
      *tmp___20 = 36;
#line 1482
      return ((FTSENT *)((void *)0));
    }
#line 1484
    p->fts_level = level;
#line 1485
    p->fts_parent = sp->fts_cur;
#line 1486
    p->fts_pathlen = new_len;
#line 1490
    p->fts_statp[0].st_ino = dp___0->d_ino;
#line 1493
    if (sp->fts_options & 4) {
#line 1494
      p->fts_accpath = p->fts_path;
#line 1495
      memmove((void *)cp, (void const   *)(p->fts_name), p->fts_namelen + 1UL);
    } else {
#line 1497
      p->fts_accpath = p->fts_name;
    }
#line 1499
    if ((unsigned long )sp->fts_compar == (unsigned long )((void *)0)) {
#line 1499
      goto _L___1;
    } else
#line 1499
    if (sp->fts_options & 1024) {
      _L___1: 
#line 1512
      if (sp->fts_options & 16) {
#line 1512
        if (sp->fts_options & 8) {
#line 1512
          if ((int )dp___0->d_type != 0) {
#line 1512
            if (! ((int )dp___0->d_type == 4)) {
#line 1512
              tmp___21 = 1;
            } else {
#line 1512
              tmp___21 = 0;
            }
          } else {
#line 1512
            tmp___21 = 0;
          }
        } else {
#line 1512
          tmp___21 = 0;
        }
      } else {
#line 1512
        tmp___21 = 0;
      }
#line 1512
      skip_stat = (_Bool )tmp___21;
#line 1516
      p->fts_info = (unsigned short)11;
#line 1519
      set_stat_type(p->fts_statp, (unsigned int )dp___0->d_type);
#line 1520
      fts_set_stat_required(p, (_Bool )(! skip_stat));
#line 1521
      if (sp->fts_options & 16) {
#line 1521
        if ((int )dp___0->d_type == 4) {
#line 1521
          tmp___22 = 1;
        } else {
#line 1521
          tmp___22 = 0;
        }
      } else {
#line 1521
        tmp___22 = 0;
      }
#line 1521
      is_dir = (_Bool )tmp___22;
    } else {
#line 1524
      p->fts_info = fts_stat(sp, p, (_Bool)0);
#line 1525
      if ((int )p->fts_info == 1) {
#line 1525
        tmp___23 = 1;
      } else
#line 1525
      if ((int )p->fts_info == 2) {
#line 1525
        tmp___23 = 1;
      } else
#line 1525
      if ((int )p->fts_info == 5) {
#line 1525
        tmp___23 = 1;
      } else {
#line 1525
        tmp___23 = 0;
      }
#line 1525
      is_dir = (_Bool )tmp___23;
    }
#line 1531
    if (nlinks > 0UL) {
#line 1531
      if (is_dir) {
#line 1532
        nlinks -= (nlink_t )nostat;
      }
    }
#line 1535
    p->fts_link = (struct _ftsent *)((void *)0);
#line 1536
    if ((unsigned long )head == (unsigned long )((void *)0)) {
#line 1537
      tail = p;
#line 1537
      head = tail;
    } else {
#line 1539
      tail->fts_link = p;
#line 1540
      tail = p;
    }
#line 1542
    nitems ++;
#line 1543
    if (max_entries <= nitems) {
#line 1547
      goto break_without_closedir;
    }
  }
#line 1551
  if (cur->fts_dirp) {
#line 1552
    while (1) {
#line 1552
      closedir(cur->fts_dirp);
#line 1552
      cur->fts_dirp = (DIR *)((void *)0);
#line 1552
      break;
    }
  }
  break_without_closedir: 
#line 1560
  if (doadjust) {
#line 1561
    fts_padjust(sp, head);
  }
#line 1567
  if (sp->fts_options & 4) {
#line 1568
    if (len == sp->fts_pathlen) {
#line 1569
      cp --;
    } else
#line 1568
    if (nitems == 0UL) {
#line 1569
      cp --;
    }
#line 1570
    *cp = (char )'\000';
  }
#line 1580
  if (! continue_readdir) {
#line 1580
    if (descend) {
#line 1580
      if (type == 1) {
#line 1580
        goto _L___2;
      } else
#line 1580
      if (! nitems) {
        _L___2: 
#line 1580
        if (cur->fts_level == 0L) {
#line 1580
          fd_ring_clear(& sp->fts_fd_ring);
#line 1580
          if (! (sp->fts_options & 4)) {
#line 1580
            if (sp->fts_options & 512) {
#line 1580
              if (sp->fts_options & 512) {
#line 1580
                tmp___24 = -100;
              } else {
#line 1580
                tmp___24 = sp->fts_rfd;
              }
#line 1580
              cwd_advance_fd(sp, tmp___24, (_Bool)1);
#line 1580
              tmp___27 = 0;
            } else {
#line 1580
              if (sp->fts_options & 512) {
#line 1580
                tmp___25 = -100;
              } else {
#line 1580
                tmp___25 = sp->fts_rfd;
              }
#line 1580
              tmp___26 = fchdir(tmp___25);
#line 1580
              tmp___27 = tmp___26;
            }
#line 1580
            if (tmp___27) {
#line 1580
              tmp___28 = 1;
            } else {
#line 1580
              tmp___28 = 0;
            }
          } else {
#line 1580
            tmp___28 = 0;
          }
#line 1580
          tmp___30 = tmp___28;
        } else {
#line 1580
          tmp___29 = fts_safe_changedir(sp, cur->fts_parent, -1, "..");
#line 1580
          tmp___30 = tmp___29;
        }
#line 1580
        if (tmp___30) {
#line 1584
          cur->fts_info = (unsigned short)7;
#line 1585
          sp->fts_options |= 8192;
#line 1586
          fts_lfree(head);
#line 1587
          return ((FTSENT *)((void *)0));
        }
      }
    }
  }
#line 1591
  if (! nitems) {
#line 1592
    if (type == 3) {
#line 1593
      cur->fts_info = (unsigned short)6;
    }
#line 1594
    fts_lfree(head);
#line 1595
    return ((FTSENT *)((void *)0));
  }
#line 1602
  if (nitems > 10000UL) {
#line 1602
    if (! sp->fts_compar) {
#line 1602
      if (sp->fts_options & 512) {
#line 1602
        tmp___31 = dirent_inode_sort_may_be_useful(sp->fts_cwd_fd);
#line 1602
        if (tmp___31) {
#line 1606
          sp->fts_compar = & fts_compare_ino;
#line 1607
          head = fts_sort(sp, head, nitems);
#line 1608
          sp->fts_compar = (int (*)(struct _ftsent  const  ** , struct _ftsent  const  ** ))((void *)0);
        }
      }
    }
  }
#line 1612
  if (sp->fts_compar) {
#line 1612
    if (nitems > 1UL) {
#line 1613
      head = fts_sort(sp, head, nitems);
    }
  }
#line 1614
  return (head);
}
}
#line 1761 "fts.c"
static unsigned short fts_stat(FTS *sp , FTSENT *p , _Bool follow ) 
{ struct stat *sbp ;
  int saved_errno ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 1765
  sbp = p->fts_statp;
#line 1768
  if (p->fts_level == 0L) {
#line 1768
    if (sp->fts_options & 1) {
#line 1769
      follow = (_Bool)1;
    }
  }
#line 1776
  if (sp->fts_options & 2) {
#line 1776
    goto _L;
  } else
#line 1776
  if (follow) {
    _L: 
#line 1777
    tmp___3 = stat((char const   * __restrict  )p->fts_accpath, (struct stat * __restrict  )sbp);
#line 1777
    if (tmp___3) {
#line 1778
      tmp = __errno_location();
#line 1778
      saved_errno = *tmp;
#line 1779
      tmp___1 = __errno_location();
#line 1779
      if (*tmp___1 == 2) {
#line 1779
        tmp___2 = lstat((char const   * __restrict  )p->fts_accpath, (struct stat * __restrict  )sbp);
#line 1779
        if (tmp___2 == 0) {
#line 1781
          tmp___0 = __errno_location();
#line 1781
          *tmp___0 = 0;
#line 1782
          return ((unsigned short)13);
        }
      }
#line 1784
      p->fts_errno = saved_errno;
#line 1785
      goto err;
    }
  } else {
#line 1787
    tmp___5 = fstatat(sp->fts_cwd_fd, (char const   * __restrict  )p->fts_accpath,
                      (struct stat * __restrict  )sbp, 256);
#line 1787
    if (tmp___5) {
#line 1789
      tmp___4 = __errno_location();
#line 1789
      p->fts_errno = *tmp___4;
      err: 
#line 1790
      memset((void *)sbp, 0, sizeof(struct stat ));
#line 1791
      return ((unsigned short)10);
    }
  }
#line 1794
  if ((sbp->st_mode & 61440U) == 16384U) {
#line 1795
    if (sp->fts_options & 32) {
#line 1795
      tmp___6 = 0;
    } else {
#line 1795
      tmp___6 = 2;
    }
#line 1795
    p->fts_n_dirs_remaining = sbp->st_nlink - (__nlink_t )tmp___6;
#line 1797
    if ((int )p->fts_name[0] == 46) {
#line 1797
      if (! p->fts_name[1]) {
#line 1797
        goto _L___0;
      } else
#line 1797
      if ((int )p->fts_name[1] == 46) {
#line 1797
        if (! p->fts_name[2]) {
          _L___0: 
#line 1799
          if (p->fts_level == 0L) {
#line 1799
            tmp___7 = 1;
          } else {
#line 1799
            tmp___7 = 5;
          }
#line 1799
          return ((unsigned short )tmp___7);
        }
      }
    }
#line 1802
    return ((unsigned short)1);
  }
#line 1804
  if ((sbp->st_mode & 61440U) == 40960U) {
#line 1805
    return ((unsigned short)12);
  }
#line 1806
  if ((sbp->st_mode & 61440U) == 32768U) {
#line 1807
    return ((unsigned short)8);
  }
#line 1808
  return ((unsigned short)3);
}
}
#line 1811 "fts.c"
static int fts_compar(void const   *a , void const   *b ) 
{ FTSENT const   **pa ;
  FTSENT const   **pb ;
  int tmp ;

  {
#line 1819
  pa = (FTSENT const   **)a;
#line 1820
  pb = (FTSENT const   **)b;
#line 1821
  tmp = (*(((*(pa + 0))->fts_fts)->fts_compar))(pa, pb);
#line 1821
  return (tmp);
}
}
#line 1824 "fts.c"
static FTSENT *fts_sort(FTS *sp , FTSENT *head , size_t nitems ) 
{ register FTSENT **ap ;
  register FTSENT *p ;
  FTSENT *dummy ;
  int (*compare)(void const   * , void const   * ) ;
  int (*tmp)(void const   * , void const   * ) ;
  FTSENT **a ;
  void *tmp___0 ;
  FTSENT **tmp___1 ;

  {
#line 1838
  if (sizeof(& dummy) == sizeof(void *)) {
#line 1838
    if ((long )(& dummy) == (long )((void *)(& dummy))) {
#line 1838
      tmp = (int (*)(void const   * , void const   * ))sp->fts_compar;
    } else {
#line 1838
      tmp = & fts_compar;
    }
  } else {
#line 1838
    tmp = & fts_compar;
  }
#line 1838
  compare = tmp;
#line 1851
  if (nitems > sp->fts_nitems) {
#line 1854
    sp->fts_nitems = nitems + 40UL;
#line 1855
    if (0xffffffffffffffffUL / sizeof(*a) < sp->fts_nitems) {
#line 1858
      free((void *)sp->fts_array);
#line 1859
      sp->fts_array = (struct _ftsent **)((void *)0);
#line 1860
      sp->fts_nitems = (size_t )0;
#line 1861
      return (head);
    } else {
#line 1855
      tmp___0 = realloc((void *)sp->fts_array, sp->fts_nitems * sizeof(*a));
#line 1855
      a = (FTSENT **)tmp___0;
#line 1855
      if (! a) {
#line 1858
        free((void *)sp->fts_array);
#line 1859
        sp->fts_array = (struct _ftsent **)((void *)0);
#line 1860
        sp->fts_nitems = (size_t )0;
#line 1861
        return (head);
      }
    }
#line 1863
    sp->fts_array = a;
  }
#line 1865
  ap = sp->fts_array;
#line 1865
  p = head;
#line 1865
  while (p) {
#line 1866
    tmp___1 = ap;
#line 1866
    ap ++;
#line 1866
    *tmp___1 = p;
#line 1865
    p = p->fts_link;
  }
#line 1867
  qsort((void *)sp->fts_array, nitems, sizeof(FTSENT *), compare);
#line 1868
  ap = sp->fts_array;
#line 1868
  head = *ap;
#line 1868
  while (1) {
#line 1868
    nitems --;
#line 1868
    if (! nitems) {
#line 1868
      break;
    }
#line 1869
    (*(ap + 0))->fts_link = *(ap + 1);
#line 1868
    ap ++;
  }
#line 1870
  (*(ap + 0))->fts_link = (struct _ftsent *)((void *)0);
#line 1871
  return (head);
}
}
#line 1874 "fts.c"
static FTSENT *fts_alloc(FTS *sp , char const   *name , size_t namelen ) 
{ register FTSENT *p ;
  size_t len ;
  void *tmp ;

  {
#line 1885
  len = sizeof(FTSENT ) + namelen;
#line 1886
  tmp = malloc(len);
#line 1886
  p = (FTSENT *)tmp;
#line 1886
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1887
    return ((FTSENT *)((void *)0));
  }
#line 1890
  memmove((void *)(p->fts_name), (void const   *)name, namelen);
#line 1891
  p->fts_name[namelen] = (char )'\000';
#line 1893
  p->fts_namelen = namelen;
#line 1894
  p->fts_fts = sp;
#line 1895
  p->fts_path = sp->fts_path;
#line 1896
  p->fts_errno = 0;
#line 1897
  p->fts_dirp = (DIR *)((void *)0);
#line 1898
  p->fts_flags = (unsigned short)0;
#line 1899
  p->fts_instr = (unsigned short)3;
#line 1900
  p->fts_number = 0L;
#line 1901
  p->fts_pointer = (void *)0;
#line 1902
  return (p);
}
}
#line 1905 "fts.c"
static void fts_lfree(FTSENT *head ) 
{ register FTSENT *p ;

  {
#line 1912
  while (1) {
#line 1912
    p = head;
#line 1912
    if (! p) {
#line 1912
      break;
    }
#line 1913
    head = head->fts_link;
#line 1914
    if (p->fts_dirp) {
#line 1915
      closedir(p->fts_dirp);
    }
#line 1916
    free((void *)p);
  }
#line 1918
  return;
}
}
#line 1927 "fts.c"
static _Bool fts_palloc(FTS *sp , size_t more ) 
{ char *p ;
  size_t new_len ;
  int *tmp ;
  void *tmp___0 ;

  {
#line 1932
  new_len = (sp->fts_pathlen + more) + 256UL;
#line 1937
  if (new_len < sp->fts_pathlen) {
#line 1938
    free((void *)sp->fts_path);
#line 1939
    sp->fts_path = (char *)((void *)0);
#line 1940
    tmp = __errno_location();
#line 1940
    *tmp = 36;
#line 1941
    return ((_Bool)0);
  }
#line 1943
  sp->fts_pathlen = new_len;
#line 1944
  tmp___0 = realloc((void *)sp->fts_path, sp->fts_pathlen);
#line 1944
  p = (char *)tmp___0;
#line 1945
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1946
    free((void *)sp->fts_path);
#line 1947
    sp->fts_path = (char *)((void *)0);
#line 1948
    return ((_Bool)0);
  }
#line 1950
  sp->fts_path = p;
#line 1951
  return ((_Bool)1);
}
}
#line 1958 "fts.c"
static void fts_padjust(FTS *sp , FTSENT *head ) 
{ FTSENT *p ;
  char *addr ;

  {
#line 1963
  addr = sp->fts_path;
#line 1973
  p = sp->fts_child;
#line 1973
  while (p) {
#line 1974
    while (1) {
#line 1974
      if ((unsigned long )p->fts_accpath != (unsigned long )(p->fts_name)) {
#line 1974
        p->fts_accpath = addr + (p->fts_accpath - p->fts_path);
      }
#line 1974
      p->fts_path = addr;
#line 1974
      break;
    }
#line 1973
    p = p->fts_link;
  }
#line 1977
  p = head;
#line 1977
  while (p->fts_level >= 0L) {
#line 1978
    while (1) {
#line 1978
      if ((unsigned long )p->fts_accpath != (unsigned long )(p->fts_name)) {
#line 1978
        p->fts_accpath = addr + (p->fts_accpath - p->fts_path);
      }
#line 1978
      p->fts_path = addr;
#line 1978
      break;
    }
#line 1979
    if (p->fts_link) {
#line 1979
      p = p->fts_link;
    } else {
#line 1979
      p = p->fts_parent;
    }
  }
#line 1981
  return;
}
}
#line 1983 "fts.c"
static size_t fts_maxarglen(char * const  *argv ) 
{ size_t len ;
  size_t max ;

  {
#line 1989
  max = (size_t )0;
#line 1989
  while (*argv) {
#line 1990
    len = strlen((char const   *)*argv);
#line 1990
    if (len > max) {
#line 1991
      max = len;
    }
#line 1989
    argv ++;
  }
#line 1992
  return (max + 1UL);
}
}
#line 2004 "fts.c"
static int fts_safe_changedir(FTS *sp , FTSENT *p , int fd , char const   *dir ) 
{ int ret ;
  _Bool is_dotdot ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int newfd ;
  int parent_fd ;
  _Bool tmp___7 ;
  struct stat sb ;
  int tmp___8 ;
  int *tmp___9 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___11 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int oerrno ;
  int *tmp___17 ;
  int *tmp___18 ;

  {
#line 2009
  if (dir) {
#line 2009
    if (0) {
#line 2009
      __s1_len = __builtin_strlen(dir);
#line 2009
      __s2_len = __builtin_strlen("..");
#line 2009
      if (! ((size_t )((void const   *)(dir + 1)) - (size_t )((void const   *)dir) == 1UL)) {
#line 2009
        goto _L___0;
      } else
#line 2009
      if (__s1_len >= 4UL) {
        _L___0: 
#line 2009
        if (! ((size_t )((void const   *)(".." + 1)) - (size_t )((void const   *)"..") == 1UL)) {
#line 2009
          tmp___5 = 1;
        } else
#line 2009
        if (__s2_len >= 4UL) {
#line 2009
          tmp___5 = 1;
        } else {
#line 2009
          tmp___5 = 0;
        }
      } else {
#line 2009
        tmp___5 = 0;
      }
#line 2009
      if (tmp___5) {
#line 2009
        tmp___0 = __builtin_strcmp(dir, "..");
#line 2009
        tmp___4 = tmp___0;
      } else {
#line 2009
        tmp___3 = __builtin_strcmp(dir, "..");
#line 2009
        tmp___4 = tmp___3;
      }
    } else {
#line 2009
      tmp___3 = __builtin_strcmp(dir, "..");
#line 2009
      tmp___4 = tmp___3;
    }
#line 2009
    if (tmp___4 == 0) {
#line 2009
      tmp___6 = 1;
    } else {
#line 2009
      tmp___6 = 0;
    }
  } else {
#line 2009
    tmp___6 = 0;
  }
#line 2009
  is_dotdot = (_Bool )tmp___6;
#line 2016
  if (sp->fts_options & 4) {
#line 2018
    if (sp->fts_options & 512) {
#line 2018
      if (0 <= fd) {
#line 2019
        close(fd);
      }
    }
#line 2020
    return (0);
  }
#line 2023
  if (fd < 0) {
#line 2023
    if (is_dotdot) {
#line 2023
      if (sp->fts_options & 512) {
#line 2030
        tmp___7 = i_ring_empty((I_ring const   *)(& sp->fts_fd_ring));
#line 2030
        if (! tmp___7) {
#line 2034
          parent_fd = i_ring_pop(& sp->fts_fd_ring);
#line 2035
          is_dotdot = (_Bool)1;
#line 2036
          if (0 <= parent_fd) {
#line 2038
            fd = parent_fd;
#line 2039
            dir = (char const   *)((void *)0);
          }
        }
      }
    }
  }
#line 2044
  newfd = fd;
#line 2045
  if (fd < 0) {
#line 2045
    newfd = diropen((FTS const   *)sp, dir);
#line 2045
    if (newfd < 0) {
#line 2046
      return (-1);
    }
  }
#line 2056
  if (sp->fts_options & 2) {
#line 2056
    goto _L___3;
  } else
#line 2056
  if (dir) {
#line 2056
    if (0) {
#line 2056
      __s1_len___0 = __builtin_strlen(dir);
#line 2056
      __s2_len___0 = __builtin_strlen("..");
#line 2056
      if (! ((size_t )((void const   *)(dir + 1)) - (size_t )((void const   *)dir) == 1UL)) {
#line 2056
        goto _L___2;
      } else
#line 2056
      if (__s1_len___0 >= 4UL) {
        _L___2: 
#line 2056
        if (! ((size_t )((void const   *)(".." + 1)) - (size_t )((void const   *)"..") == 1UL)) {
#line 2056
          tmp___16 = 1;
        } else
#line 2056
        if (__s2_len___0 >= 4UL) {
#line 2056
          tmp___16 = 1;
        } else {
#line 2056
          tmp___16 = 0;
        }
      } else {
#line 2056
        tmp___16 = 0;
      }
#line 2056
      if (tmp___16) {
#line 2056
        tmp___11 = __builtin_strcmp(dir, "..");
#line 2056
        tmp___15 = tmp___11;
      } else {
#line 2056
        tmp___14 = __builtin_strcmp(dir, "..");
#line 2056
        tmp___15 = tmp___14;
      }
    } else {
#line 2056
      tmp___14 = __builtin_strcmp(dir, "..");
#line 2056
      tmp___15 = tmp___14;
    }
#line 2056
    if (tmp___15 == 0) {
      _L___3: 
#line 2059
      tmp___8 = fstat(newfd, & sb);
#line 2059
      if (tmp___8) {
#line 2061
        ret = -1;
#line 2062
        goto bail;
      }
#line 2064
      if (p->fts_statp[0].st_dev != sb.st_dev) {
#line 2067
        tmp___9 = __errno_location();
#line 2067
        *tmp___9 = 2;
#line 2068
        ret = -1;
#line 2069
        goto bail;
      } else
#line 2064
      if (p->fts_statp[0].st_ino != sb.st_ino) {
#line 2067
        tmp___9 = __errno_location();
#line 2067
        *tmp___9 = 2;
#line 2068
        ret = -1;
#line 2069
        goto bail;
      }
    }
  }
#line 2073
  if (sp->fts_options & 512) {
#line 2075
    cwd_advance_fd(sp, newfd, (_Bool )(! is_dotdot));
#line 2076
    return (0);
  }
#line 2079
  ret = fchdir(newfd);
  bail: 
#line 2081
  if (fd < 0) {
#line 2083
    tmp___17 = __errno_location();
#line 2083
    oerrno = *tmp___17;
#line 2084
    close(newfd);
#line 2085
    tmp___18 = __errno_location();
#line 2085
    *tmp___18 = oerrno;
  }
#line 2087
  return (ret);
}
}
#line 1 "futimens.o"
#pragma merger(0,"/tmp/cil-1UFLmVhO.i","-g,-O2")
#line 30 "futimens.c"
int rpl_futimens(int fd , struct timespec  const  *times ) 
{ int tmp ;

  {
#line 36
  tmp = fdutimens(fd, (char const   *)((void *)0), times);
#line 36
  return (tmp);
}
}
#line 1 "getcwd.o"
#pragma merger(0,"/tmp/cil-w5X3H3hU.i","-g,-O2")
#line 209 "/usr/include/dirent.h"
extern  __attribute__((__nothrow__)) void rewinddir(DIR *__dirp )  __attribute__((__nonnull__(1))) ;
#line 105 "getcwd.c"
char *rpl_getcwd(char *buf___1 , size_t size ) 
{ int fd ;
  _Bool fd_needs_closing ;
  DIR *dirstream ;
  dev_t rootdev ;
  dev_t thisdev ;
  ino_t rootino ;
  ino_t thisino ;
  char *dir ;
  register char *dirp ;
  struct stat st ;
  size_t allocated ;
  size_t used ;
  char __attribute__((__warn_unused_result__, __artificial__))  *tmp ;
  int *tmp___0 ;
  char big_buffer[4096] ;
  char __attribute__((__warn_unused_result__, __artificial__))  *tmp___1 ;
  char *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  void *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  struct dirent *d ;
  dev_t dotdev ;
  ino_t dotino ;
  _Bool mount_point ;
  int parent_status ;
  size_t dirroom ;
  size_t namlen ;
  _Bool use_d_ino ;
  int __attribute__((__artificial__))  tmp___16 ;
  int tmp___17 ;
  int *tmp___18 ;
  int *tmp___19 ;
  int *tmp___20 ;
  int *tmp___21 ;
  _Bool match ;
  int tmp___22 ;
  int entry_status ;
  int *tmp___23 ;
  char *tmp___24 ;
  size_t oldsize ;
  size_t tmp___25 ;
  void *tmp___26 ;
  void __attribute__((__artificial__))  *tmp___27 ;
  int tmp___28 ;
  void *tmp___29 ;
  int *tmp___30 ;
  int save ;
  int *tmp___31 ;
  int *tmp___32 ;

  {
#line 121
  fd = -100;
#line 122
  fd_needs_closing = (_Bool)0;
#line 129
  dirstream = (DIR *)((void *)0);
#line 135
  allocated = size;
#line 149
  tmp = getcwd(buf___1, size);
#line 149
  dir = (char *)tmp;
#line 150
  if (dir) {
#line 151
    return (dir);
  } else
#line 150
  if (size) {
#line 150
    tmp___0 = __errno_location();
#line 150
    if (*tmp___0 == 34) {
#line 151
      return (dir);
    }
  }
#line 157
  tmp___8 = __errno_location();
#line 157
  if (*tmp___8 == 22) {
#line 157
    if ((unsigned long )buf___1 == (unsigned long )((void *)0)) {
#line 157
      if (size == 0UL) {
#line 160
        tmp___1 = getcwd(big_buffer, sizeof(big_buffer));
#line 160
        dir = (char *)tmp___1;
#line 161
        if (dir) {
#line 162
          tmp___7 = __strdup((char const   *)dir);
#line 162
          return (tmp___7);
        }
      }
    }
  }
#line 168
  tmp___9 = __errno_location();
#line 168
  if (*tmp___9 != 34) {
#line 168
    tmp___10 = __errno_location();
#line 168
    if (*tmp___10 != 36) {
#line 168
      tmp___11 = __errno_location();
#line 168
      if (*tmp___11 != 2) {
#line 169
        return ((char *)((void *)0));
      }
    }
  }
#line 173
  if (size == 0UL) {
#line 175
    if ((unsigned long )buf___1 != (unsigned long )((void *)0)) {
#line 177
      tmp___12 = __errno_location();
#line 177
      *tmp___12 = 22;
#line 178
      return ((char *)((void *)0));
    }
#line 181
    allocated = (size_t )4096;
  }
#line 184
  if ((unsigned long )buf___1 == (unsigned long )((void *)0)) {
#line 186
    tmp___13 = malloc(allocated);
#line 186
    dir = (char *)tmp___13;
#line 187
    if ((unsigned long )dir == (unsigned long )((void *)0)) {
#line 188
      return ((char *)((void *)0));
    }
  } else {
#line 191
    dir = buf___1;
  }
#line 193
  dirp = dir + allocated;
#line 194
  dirp --;
#line 194
  *dirp = (char )'\000';
#line 196
  tmp___14 = lstat((char const   * __restrict  )".", (struct stat * __restrict  )(& st));
#line 196
  if (tmp___14 < 0) {
#line 197
    goto lose;
  }
#line 198
  thisdev = st.st_dev;
#line 199
  thisino = st.st_ino;
#line 201
  tmp___15 = lstat((char const   * __restrict  )"/", (struct stat * __restrict  )(& st));
#line 201
  if (tmp___15 < 0) {
#line 202
    goto lose;
  }
#line 203
  rootdev = st.st_dev;
#line 204
  rootino = st.st_ino;
#line 206
  while (1) {
#line 206
    if (thisdev == rootdev) {
#line 206
      if (thisino == rootino) {
#line 206
        break;
      }
    }
#line 215
    use_d_ino = (_Bool)1;
#line 219
    tmp___16 = openat(fd, "..", 0);
#line 219
    fd = (int )tmp___16;
#line 220
    if (fd < 0) {
#line 221
      goto lose;
    }
#line 222
    fd_needs_closing = (_Bool)1;
#line 223
    parent_status = fstat(fd, & st);
#line 230
    if (parent_status != 0) {
#line 231
      goto lose;
    }
#line 233
    if (dirstream) {
#line 233
      tmp___17 = closedir(dirstream);
#line 233
      if (tmp___17 != 0) {
#line 235
        dirstream = (DIR *)((void *)0);
#line 236
        goto lose;
      }
    }
#line 240
    dotdev = st.st_dev;
#line 241
    dotino = st.st_ino;
#line 242
    mount_point = (_Bool )(dotdev != thisdev);
#line 246
    dirstream = fdopendir(fd);
#line 247
    if ((unsigned long )dirstream == (unsigned long )((void *)0)) {
#line 248
      goto lose;
    }
#line 249
    fd_needs_closing = (_Bool)0;
#line 256
    while (1) {
#line 260
      tmp___18 = __errno_location();
#line 260
      *tmp___18 = 0;
#line 261
      d = readdir(dirstream);
#line 270
      if ((unsigned long )d == (unsigned long )((void *)0)) {
#line 270
        tmp___19 = __errno_location();
#line 270
        if (*tmp___19 == 0) {
#line 270
          if (use_d_ino) {
#line 272
            use_d_ino = (_Bool)0;
#line 273
            rewinddir(dirstream);
#line 274
            d = readdir(dirstream);
          }
        }
      }
#line 277
      if ((unsigned long )d == (unsigned long )((void *)0)) {
#line 279
        tmp___21 = __errno_location();
#line 279
        if (*tmp___21 == 0) {
#line 282
          tmp___20 = __errno_location();
#line 282
          *tmp___20 = 2;
        }
#line 283
        goto lose;
      }
#line 285
      if ((int )d->d_name[0] == 46) {
#line 285
        if ((int )d->d_name[1] == 0) {
#line 288
          goto __Cont;
        } else
#line 285
        if ((int )d->d_name[1] == 46) {
#line 285
          if ((int )d->d_name[2] == 0) {
#line 288
            goto __Cont;
          }
        }
      }
#line 290
      if (use_d_ino) {
#line 292
        if (d->d_ino == thisino) {
#line 292
          tmp___22 = 1;
        } else
#line 292
        if (mount_point) {
#line 292
          tmp___22 = 1;
        } else {
#line 292
          tmp___22 = 0;
        }
#line 292
        match = (_Bool )tmp___22;
#line 293
        if (! match) {
#line 294
          goto __Cont;
        }
      }
#line 300
      entry_status = fstatat(fd, (char const   * __restrict  )(d->d_name), (struct stat * __restrict  )(& st),
                             256);
#line 344
      if (entry_status == 0) {
#line 344
        if ((st.st_mode & 61440U) == 16384U) {
#line 344
          if (st.st_dev == thisdev) {
#line 344
            if (st.st_ino == thisino) {
#line 346
              break;
            }
          }
        }
      }
      __Cont: ;
    }
#line 350
    dirroom = (size_t )(dirp - dir);
#line 351
    namlen = strlen((char const   *)(d->d_name));
#line 353
    if (dirroom <= namlen) {
#line 355
      if (size != 0UL) {
#line 357
        tmp___23 = __errno_location();
#line 357
        *tmp___23 = 34;
#line 358
        goto lose;
      } else {
#line 363
        oldsize = allocated;
#line 365
        if (allocated < namlen) {
#line 365
          tmp___25 = namlen;
        } else {
#line 365
          tmp___25 = allocated;
        }
#line 365
        allocated += tmp___25;
#line 366
        if (allocated < oldsize) {
#line 368
          goto memory_exhausted;
        } else {
#line 366
          tmp___26 = realloc((void *)dir, allocated);
#line 366
          tmp___24 = (char *)tmp___26;
#line 366
          if (! tmp___24) {
#line 368
            goto memory_exhausted;
          }
        }
#line 372
        tmp___27 = memcpy((void * __restrict  )((tmp___24 + allocated) - (oldsize - dirroom)),
                          (void const   * __restrict  )(tmp___24 + dirroom), oldsize - dirroom);
#line 372
        dirp = (char *)tmp___27;
#line 375
        dir = tmp___24;
      }
    }
#line 378
    dirp -= namlen;
#line 379
    memcpy((void * __restrict  )dirp, (void const   * __restrict  )(d->d_name), namlen);
#line 380
    dirp --;
#line 380
    *dirp = (char )'/';
#line 382
    thisdev = dotdev;
#line 383
    thisino = dotino;
  }
#line 386
  if (dirstream) {
#line 386
    tmp___28 = closedir(dirstream);
#line 386
    if (tmp___28 != 0) {
#line 388
      dirstream = (DIR *)((void *)0);
#line 389
      goto lose;
    }
  }
#line 392
  if ((unsigned long )dirp == (unsigned long )(dir + (allocated - 1UL))) {
#line 393
    dirp --;
#line 393
    *dirp = (char )'/';
  }
#line 400
  used = (size_t )((dir + allocated) - dirp);
#line 401
  memmove((void *)dir, (void const   *)dirp, used);
#line 403
  if (size == 0UL) {
#line 405
    tmp___29 = realloc((void *)dir, used);
#line 405
    buf___1 = (char *)tmp___29;
  }
#line 407
  if ((unsigned long )buf___1 == (unsigned long )((void *)0)) {
#line 410
    buf___1 = dir;
  }
#line 412
  return (buf___1);
  memory_exhausted: 
#line 415
  tmp___30 = __errno_location();
#line 415
  *tmp___30 = 12;
  lose: 
#line 418
  tmp___31 = __errno_location();
#line 418
  save = *tmp___31;
#line 419
  if (dirstream) {
#line 420
    closedir(dirstream);
  }
#line 422
  if (fd_needs_closing) {
#line 423
    close(fd);
  }
#line 428
  if ((unsigned long )buf___1 == (unsigned long )((void *)0)) {
#line 429
    free((void *)dir);
  }
#line 430
  tmp___32 = __errno_location();
#line 430
  *tmp___32 = save;
#line 432
  return ((char *)((void *)0));
}
}
#line 1 "getcwd-lgpl.o"
#pragma merger(0,"/tmp/cil-HFYXRuPi.i","-g,-O2")
#line 1 "gethrxtime.o"
#pragma merger(0,"/tmp/cil-UhKv4HE3.i","-g,-O2")
#line 42 "xtime.h"
__inline static xtime_t xtime_make(xtime_t s , long ns ) 
{ 

  {
#line 48
  return (1000000000LL * s + (xtime_t )ns);
}
}
#line 34 "gethrxtime.h"
xtime_t gethrxtime(void) ;
#line 32 "gethrxtime.c"
xtime_t gethrxtime(void) 
{ struct timespec ts ;
  xtime_t tmp ;
  int tmp___0 ;
  struct timespec ts___0 ;
  xtime_t tmp___1 ;

  {
#line 46
  tmp___0 = clock_gettime(1, & ts);
#line 46
  if (tmp___0 == 0) {
#line 47
    tmp = xtime_make((xtime_t )ts.tv_sec, ts.tv_nsec);
#line 47
    return (tmp);
  }
#line 63
  gettime(& ts___0);
#line 64
  tmp___1 = xtime_make((xtime_t )ts___0.tv_sec, ts___0.tv_nsec);
#line 64
  return (tmp___1);
}
}
#line 1 "getopt.o"
#pragma merger(0,"/tmp/cil-mxQrEjpX.i","-g,-O2")
#line 148 "./getopt.h"
char *rpl_optarg  ;
#line 171
int rpl_optopt ;
#line 241
 __attribute__((__nothrow__)) int rpl_getopt(int argc , char * const  *argv , char const   *optstring )  __attribute__((__nonnull__(2,3))) ;
#line 24 "getopt_int.h"
int rpl_getopt_internal(int argc , char **argv , char const   *optstring , struct rpl_option  const  *longopts ,
                        int *longind , int long_only , int posixly_correct ) ;
#line 118
int _getopt_internal_r(int argc , char **argv , char const   *optstring , struct rpl_option  const  *longopts ,
                       int *longind , int long_only , struct _getopt_data *d , int posixly_correct ) ;
#line 82 "getopt.c"
int rpl_optind  =    1;
#line 87 "getopt.c"
int rpl_opterr  =    1;
#line 93 "getopt.c"
int rpl_optopt  =    '?';
#line 97 "getopt.c"
static struct _getopt_data getopt_data  ;
#line 143 "getopt.c"
static void exchange(char **argv , struct _getopt_data *d ) 
{ int bottom ;
  int middle ;
  int top ;
  char *tem ;
  int len ;
  register int i ;
  int len___0 ;
  register int i___0 ;

  {
#line 146
  bottom = d->__first_nonopt;
#line 147
  middle = d->__last_nonopt;
#line 148
  top = d->rpl_optind;
#line 178
  while (1) {
#line 178
    if (top > middle) {
#line 178
      if (! (middle > bottom)) {
#line 178
        break;
      }
    } else {
#line 178
      break;
    }
#line 180
    if (top - middle > middle - bottom) {
#line 183
      len = middle - bottom;
#line 187
      i = 0;
#line 187
      while (i < len) {
#line 189
        tem = *(argv + (bottom + i));
#line 190
        *(argv + (bottom + i)) = *(argv + ((top - (middle - bottom)) + i));
#line 191
        *(argv + ((top - (middle - bottom)) + i)) = tem;
#line 187
        i ++;
      }
#line 195
      top -= len;
    } else {
#line 200
      len___0 = top - middle;
#line 204
      i___0 = 0;
#line 204
      while (i___0 < len___0) {
#line 206
        tem = *(argv + (bottom + i___0));
#line 207
        *(argv + (bottom + i___0)) = *(argv + (middle + i___0));
#line 208
        *(argv + (middle + i___0)) = tem;
#line 204
        i___0 ++;
      }
#line 212
      bottom += len___0;
    }
  }
#line 218
  d->__first_nonopt += d->rpl_optind - d->__last_nonopt;
#line 219
  d->__last_nonopt = d->rpl_optind;
#line 220
  return;
}
}
#line 224 "getopt.c"
static char const   *_getopt_initialize(int argc  __attribute__((__unused__)) , char **argv  __attribute__((__unused__)) ,
                                        char const   *optstring , struct _getopt_data *d ,
                                        int posixly_correct ) 
{ int tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 233
  tmp = d->rpl_optind;
#line 233
  d->__last_nonopt = tmp;
#line 233
  d->__first_nonopt = tmp;
#line 235
  d->__nextchar = (char *)((void *)0);
#line 237
  if (posixly_correct) {
#line 237
    tmp___1 = 1;
  } else {
#line 237
    tmp___0 = getenv("POSIXLY_CORRECT");
#line 237
    if (tmp___0) {
#line 237
      tmp___1 = 1;
    } else {
#line 237
      tmp___1 = 0;
    }
  }
#line 237
  d->__posixly_correct = tmp___1;
#line 241
  if ((int const   )*(optstring + 0) == 45) {
#line 243
    d->__ordering = (enum __ord )2;
#line 244
    optstring ++;
  } else
#line 246
  if ((int const   )*(optstring + 0) == 43) {
#line 248
    d->__ordering = (enum __ord )0;
#line 249
    optstring ++;
  } else
#line 251
  if (d->__posixly_correct) {
#line 252
    d->__ordering = (enum __ord )0;
  } else {
#line 254
    d->__ordering = (enum __ord )1;
  }
#line 286
  return (optstring);
}
}
#line 345 "getopt.c"
int _getopt_internal_r(int argc , char **argv , char const   *optstring , struct rpl_option  const  *longopts ,
                       int *longind , int long_only , struct _getopt_data *d , int posixly_correct ) 
{ int print_errors ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *nameend ;
  unsigned int namelen ;
  struct rpl_option  const  *p ;
  struct rpl_option  const  *pfound ;
  struct option_list *ambig_list ;
  int exact ;
  int indfound ;
  int option_index ;
  struct option_list *newp ;
  void *tmp___8 ;
  size_t tmp___9 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___13 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  struct option_list first ;
  char *tmp___23 ;
  size_t tmp___24 ;
  struct option_list *pn ;
  char *tmp___25 ;
  char *tmp___26 ;
  size_t tmp___27 ;
  int tmp___28 ;
  char *tmp___29 ;
  size_t tmp___30 ;
  int tmp___31 ;
  size_t tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___36 ;
  char *tmp___38 ;
  char c ;
  char *tmp___39 ;
  char const   *temp ;
  char *tmp___41 ;
  char *tmp___42 ;
  char *nameend___0 ;
  struct rpl_option  const  *p___0 ;
  struct rpl_option  const  *pfound___0 ;
  int exact___0 ;
  int ambig ;
  int indfound___0 ;
  int option_index___0 ;
  char *tmp___43 ;
  int tmp___44 ;
  size_t tmp___45 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___49 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  char *tmp___59 ;
  size_t tmp___60 ;
  char *tmp___61 ;
  size_t tmp___62 ;
  int tmp___63 ;
  char *tmp___64 ;
  size_t tmp___65 ;
  int tmp___66 ;
  size_t tmp___67 ;
  char *tmp___68 ;
  int tmp___69 ;

  {
#line 350
  print_errors = d->rpl_opterr;
#line 352
  if (argc < 1) {
#line 353
    return (-1);
  }
#line 355
  d->rpl_optarg = (char *)((void *)0);
#line 357
  if (d->rpl_optind == 0) {
#line 357
    goto _L;
  } else
#line 357
  if (! d->__initialized) {
    _L: 
#line 359
    if (d->rpl_optind == 0) {
#line 360
      d->rpl_optind = 1;
    }
#line 361
    optstring = _getopt_initialize(argc, argv, optstring, d, posixly_correct);
#line 363
    d->__initialized = 1;
  } else
#line 365
  if ((int const   )*(optstring + 0) == 45) {
#line 366
    optstring ++;
  } else
#line 365
  if ((int const   )*(optstring + 0) == 43) {
#line 366
    optstring ++;
  }
#line 367
  if ((int const   )*(optstring + 0) == 58) {
#line 368
    print_errors = 0;
  }
#line 382
  if ((unsigned long )d->__nextchar == (unsigned long )((void *)0)) {
#line 382
    goto _L___5;
  } else
#line 382
  if ((int )*(d->__nextchar) == 0) {
    _L___5: 
#line 388
    if (d->__last_nonopt > d->rpl_optind) {
#line 389
      d->__last_nonopt = d->rpl_optind;
    }
#line 390
    if (d->__first_nonopt > d->rpl_optind) {
#line 391
      d->__first_nonopt = d->rpl_optind;
    }
#line 393
    if ((unsigned int )d->__ordering == 1U) {
#line 398
      if (d->__first_nonopt != d->__last_nonopt) {
#line 398
        if (d->__last_nonopt != d->rpl_optind) {
#line 400
          exchange(argv, d);
        } else {
#line 398
          goto _L___0;
        }
      } else
      _L___0: 
#line 401
      if (d->__last_nonopt != d->rpl_optind) {
#line 402
        d->__first_nonopt = d->rpl_optind;
      }
#line 407
      while (1) {
#line 407
        if (d->rpl_optind < argc) {
#line 407
          if (! ((int )*(*(argv + d->rpl_optind) + 0) != 45)) {
#line 407
            if (! ((int )*(*(argv + d->rpl_optind) + 1) == 0)) {
#line 407
              break;
            }
          }
        } else {
#line 407
          break;
        }
#line 408
        (d->rpl_optind) ++;
      }
#line 409
      d->__last_nonopt = d->rpl_optind;
    }
#line 417
    if (d->rpl_optind != argc) {
#line 417
      if (0) {
#line 417
        __s1_len = __builtin_strlen((char const   *)*(argv + d->rpl_optind));
#line 417
        __s2_len = __builtin_strlen("--");
#line 417
        if (! ((size_t )((void const   *)(*(argv + d->rpl_optind) + 1)) - (size_t )((void const   *)*(argv + d->rpl_optind)) == 1UL)) {
#line 417
          goto _L___3;
        } else
#line 417
        if (__s1_len >= 4UL) {
          _L___3: 
#line 417
          if (! ((size_t )((void const   *)("--" + 1)) - (size_t )((void const   *)"--") == 1UL)) {
#line 417
            tmp___5 = 1;
          } else
#line 417
          if (__s2_len >= 4UL) {
#line 417
            tmp___5 = 1;
          } else {
#line 417
            tmp___5 = 0;
          }
        } else {
#line 417
          tmp___5 = 0;
        }
#line 417
        if (tmp___5) {
#line 417
          tmp___0 = __builtin_strcmp((char const   *)*(argv + d->rpl_optind), "--");
#line 417
          tmp___4 = tmp___0;
        } else {
#line 417
          tmp___3 = __builtin_strcmp((char const   *)*(argv + d->rpl_optind), "--");
#line 417
          tmp___4 = tmp___3;
        }
      } else {
#line 417
        tmp___3 = __builtin_strcmp((char const   *)*(argv + d->rpl_optind), "--");
#line 417
        tmp___4 = tmp___3;
      }
#line 417
      if (! tmp___4) {
#line 419
        (d->rpl_optind) ++;
#line 421
        if (d->__first_nonopt != d->__last_nonopt) {
#line 421
          if (d->__last_nonopt != d->rpl_optind) {
#line 423
            exchange(argv, d);
          } else {
#line 421
            goto _L___1;
          }
        } else
        _L___1: 
#line 424
        if (d->__first_nonopt == d->__last_nonopt) {
#line 425
          d->__first_nonopt = d->rpl_optind;
        }
#line 426
        d->__last_nonopt = argc;
#line 428
        d->rpl_optind = argc;
      }
    }
#line 434
    if (d->rpl_optind == argc) {
#line 438
      if (d->__first_nonopt != d->__last_nonopt) {
#line 439
        d->rpl_optind = d->__first_nonopt;
      }
#line 440
      return (-1);
    }
#line 446
    if ((int )*(*(argv + d->rpl_optind) + 0) != 45) {
#line 446
      goto _L___4;
    } else
#line 446
    if ((int )*(*(argv + d->rpl_optind) + 1) == 0) {
      _L___4: 
#line 448
      if ((unsigned int )d->__ordering == 0U) {
#line 449
        return (-1);
      }
#line 450
      tmp___6 = d->rpl_optind;
#line 450
      (d->rpl_optind) ++;
#line 450
      d->rpl_optarg = *(argv + tmp___6);
#line 451
      return (1);
    }
#line 457
    if ((unsigned long )longopts != (unsigned long )((void *)0)) {
#line 457
      if ((int )*(*(argv + d->rpl_optind) + 1) == 45) {
#line 457
        tmp___7 = 1;
      } else {
#line 457
        tmp___7 = 0;
      }
    } else {
#line 457
      tmp___7 = 0;
    }
#line 457
    d->__nextchar = (*(argv + d->rpl_optind) + 1) + tmp___7;
  }
#line 476
  if ((unsigned long )longopts != (unsigned long )((void *)0)) {
#line 476
    if ((int )*(*(argv + d->rpl_optind) + 1) == 45) {
#line 476
      goto _L___10;
    } else
#line 476
    if (long_only) {
#line 476
      if (*(*(argv + d->rpl_optind) + 2)) {
#line 476
        goto _L___10;
      } else {
#line 476
        tmp___38 = __builtin_strchr((char *)optstring, (int )*(*(argv + d->rpl_optind) + 1));
#line 476
        if (! tmp___38) {
          _L___10: 
#line 484
          pfound = (struct rpl_option  const  *)((void *)0);
#line 485
          ambig_list = (struct option_list *)((void *)0);
#line 490
          exact = 0;
#line 491
          indfound = -1;
#line 494
          nameend = d->__nextchar;
#line 494
          while (1) {
#line 494
            if (*nameend) {
#line 494
              if (! ((int )*nameend != 61)) {
#line 494
                break;
              }
            } else {
#line 494
              break;
            }
#line 494
            nameend ++;
          }
#line 496
          namelen = (unsigned int )(nameend - d->__nextchar);
#line 500
          p = longopts;
#line 500
          option_index = 0;
#line 500
          while (p->name) {
#line 501
            if (0) {
#line 501
              if (0) {
#line 501
                __s1_len___0 = __builtin_strlen((char const   *)p->name);
#line 501
                __s2_len___0 = __builtin_strlen((char const   *)d->__nextchar);
#line 501
                if (! ((size_t )((void const   *)(p->name + 1)) - (size_t )((void const   *)p->name) == 1UL)) {
#line 501
                  goto _L___7;
                } else
#line 501
                if (__s1_len___0 >= 4UL) {
                  _L___7: 
#line 501
                  if (! ((size_t )((void const   *)(d->__nextchar + 1)) - (size_t )((void const   *)d->__nextchar) == 1UL)) {
#line 501
                    tmp___18 = 1;
                  } else
#line 501
                  if (__s2_len___0 >= 4UL) {
#line 501
                    tmp___18 = 1;
                  } else {
#line 501
                    tmp___18 = 0;
                  }
                } else {
#line 501
                  tmp___18 = 0;
                }
#line 501
                if (tmp___18) {
#line 501
                  tmp___13 = __builtin_strcmp((char const   *)p->name, (char const   *)d->__nextchar);
#line 501
                  tmp___17 = tmp___13;
                } else {
#line 501
                  tmp___16 = __builtin_strcmp((char const   *)p->name, (char const   *)d->__nextchar);
#line 501
                  tmp___17 = tmp___16;
                }
              } else {
#line 501
                tmp___16 = __builtin_strcmp((char const   *)p->name, (char const   *)d->__nextchar);
#line 501
                tmp___17 = tmp___16;
              }
#line 501
              tmp___20 = tmp___17;
            } else {
#line 501
              tmp___19 = strncmp((char const   *)p->name, (char const   *)d->__nextchar,
                                 (size_t )namelen);
#line 501
              tmp___20 = tmp___19;
            }
#line 501
            if (! tmp___20) {
#line 503
              tmp___9 = strlen((char const   *)p->name);
#line 503
              if (namelen == (unsigned int )tmp___9) {
#line 506
                pfound = p;
#line 507
                indfound = option_index;
#line 508
                exact = 1;
#line 509
                break;
              } else
#line 511
              if ((unsigned long )pfound == (unsigned long )((void *)0)) {
#line 514
                pfound = p;
#line 515
                indfound = option_index;
              } else
#line 517
              if (long_only) {
#line 523
                tmp___8 = malloc(sizeof(*newp));
#line 523
                newp = (struct option_list *)tmp___8;
#line 524
                newp->p = p;
#line 525
                newp->next = ambig_list;
#line 526
                ambig_list = newp;
              } else
#line 517
              if (pfound->has_arg != p->has_arg) {
#line 523
                tmp___8 = malloc(sizeof(*newp));
#line 523
                newp = (struct option_list *)tmp___8;
#line 524
                newp->p = p;
#line 525
                newp->next = ambig_list;
#line 526
                ambig_list = newp;
              } else
#line 517
              if ((unsigned long )pfound->flag != (unsigned long )p->flag) {
#line 523
                tmp___8 = malloc(sizeof(*newp));
#line 523
                newp = (struct option_list *)tmp___8;
#line 524
                newp->p = p;
#line 525
                newp->next = ambig_list;
#line 526
                ambig_list = newp;
              } else
#line 517
              if (pfound->val != p->val) {
#line 523
                tmp___8 = malloc(sizeof(*newp));
#line 523
                newp = (struct option_list *)tmp___8;
#line 524
                newp->p = p;
#line 525
                newp->next = ambig_list;
#line 526
                ambig_list = newp;
              }
            }
#line 500
            p ++;
#line 500
            option_index ++;
          }
#line 530
          if ((unsigned long )ambig_list != (unsigned long )((void *)0)) {
#line 530
            if (! exact) {
#line 532
              if (print_errors) {
#line 535
                first.p = pfound;
#line 536
                first.next = ambig_list;
#line 537
                ambig_list = & first;
#line 575
                tmp___23 = dcgettext((char const   *)((void *)0), "%s: option \'%s\' is ambiguous; possibilities:",
                                     5);
#line 575
                fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___23,
                        *(argv + 0), *(argv + d->rpl_optind));
#line 578
                while (1) {
#line 580
                  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" \'--%s\'",
                          (ambig_list->p)->name);
#line 581
                  ambig_list = ambig_list->next;
#line 578
                  if (! ((unsigned long )ambig_list != (unsigned long )((void *)0))) {
#line 578
                    break;
                  }
                }
#line 585
                fputc('\n', stderr);
              }
#line 588
              tmp___24 = strlen((char const   *)d->__nextchar);
#line 588
              d->__nextchar += tmp___24;
#line 589
              (d->rpl_optind) ++;
#line 590
              d->rpl_optopt = 0;
#line 591
              return ('?');
            }
          }
#line 594
          while ((unsigned long )ambig_list != (unsigned long )((void *)0)) {
#line 596
            pn = ambig_list->next;
#line 597
            free((void *)ambig_list);
#line 598
            ambig_list = pn;
          }
#line 601
          if ((unsigned long )pfound != (unsigned long )((void *)0)) {
#line 603
            option_index = indfound;
#line 604
            (d->rpl_optind) ++;
#line 605
            if (*nameend) {
#line 609
              if (pfound->has_arg) {
#line 610
                d->rpl_optarg = nameend + 1;
              } else {
#line 613
                if (print_errors) {
#line 620
                  if ((int )*(*(argv + (d->rpl_optind - 1)) + 1) == 45) {
#line 628
                    tmp___25 = dcgettext((char const   *)((void *)0), "%s: option \'--%s\' doesn\'t allow an argument\n",
                                         5);
#line 628
                    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___25,
                            *(argv + 0), pfound->name);
                  } else {
#line 642
                    tmp___26 = dcgettext((char const   *)((void *)0), "%s: option \'%c%s\' doesn\'t allow an argument\n",
                                         5);
#line 642
                    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___26,
                            *(argv + 0), (int )*(*(argv + (d->rpl_optind - 1)) + 0),
                            pfound->name);
                  }
                }
#line 668
                tmp___27 = strlen((char const   *)d->__nextchar);
#line 668
                d->__nextchar += tmp___27;
#line 670
                d->rpl_optopt = (int )pfound->val;
#line 671
                return ('?');
              }
            } else
#line 674
            if (pfound->has_arg == 1) {
#line 676
              if (d->rpl_optind < argc) {
#line 677
                tmp___28 = d->rpl_optind;
#line 677
                (d->rpl_optind) ++;
#line 677
                d->rpl_optarg = *(argv + tmp___28);
              } else {
#line 680
                if (print_errors) {
#line 703
                  tmp___29 = dcgettext((char const   *)((void *)0), "%s: option \'--%s\' requires an argument\n",
                                       5);
#line 703
                  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___29,
                          *(argv + 0), pfound->name);
                }
#line 708
                tmp___30 = strlen((char const   *)d->__nextchar);
#line 708
                d->__nextchar += tmp___30;
#line 709
                d->rpl_optopt = (int )pfound->val;
#line 710
                if ((int const   )*(optstring + 0) == 58) {
#line 710
                  tmp___31 = ':';
                } else {
#line 710
                  tmp___31 = '?';
                }
#line 710
                return (tmp___31);
              }
            }
#line 713
            tmp___32 = strlen((char const   *)d->__nextchar);
#line 713
            d->__nextchar += tmp___32;
#line 714
            if ((unsigned long )longind != (unsigned long )((void *)0)) {
#line 715
              *longind = option_index;
            }
#line 716
            if (pfound->flag) {
#line 718
              *(pfound->flag) = (int )pfound->val;
#line 719
              return (0);
            }
#line 721
            return ((int )pfound->val);
          }
#line 728
          if (! long_only) {
#line 728
            goto _L___8;
          } else
#line 728
          if ((int )*(*(argv + d->rpl_optind) + 1) == 45) {
#line 728
            goto _L___8;
          } else {
#line 728
            tmp___36 = __builtin_strchr((char *)optstring, (int )*(d->__nextchar));
#line 728
            if ((unsigned long )tmp___36 == (unsigned long )((void *)0)) {
              _L___8: 
#line 731
              if (print_errors) {
#line 738
                if ((int )*(*(argv + d->rpl_optind) + 1) == 45) {
#line 745
                  tmp___33 = dcgettext((char const   *)((void *)0), "%s: unrecognized option \'--%s\'\n",
                                       5);
#line 745
                  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___33,
                          *(argv + 0), d->__nextchar);
                } else {
#line 756
                  tmp___34 = dcgettext((char const   *)((void *)0), "%s: unrecognized option \'%c%s\'\n",
                                       5);
#line 756
                  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___34,
                          *(argv + 0), (int )*(*(argv + d->rpl_optind) + 0), d->__nextchar);
                }
              }
#line 778
              d->__nextchar = (char *)"";
#line 779
              (d->rpl_optind) ++;
#line 780
              d->rpl_optopt = 0;
#line 781
              return ('?');
            }
          }
        }
      }
    }
  }
#line 788
  tmp___39 = d->__nextchar;
#line 788
  (d->__nextchar) ++;
#line 788
  c = *tmp___39;
#line 789
  tmp___41 = __builtin_strchr((char *)optstring, (int )c);
#line 789
  temp = (char const   *)tmp___41;
#line 792
  if ((int )*(d->__nextchar) == 0) {
#line 793
    (d->rpl_optind) ++;
  }
#line 795
  if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 795
    goto _L___11;
  } else
#line 795
  if ((int )c == 58) {
#line 795
    goto _L___11;
  } else
#line 795
  if ((int )c == 59) {
    _L___11: 
#line 797
    if (print_errors) {
#line 808
      tmp___42 = dcgettext((char const   *)((void *)0), "%s: invalid option -- \'%c\'\n",
                           5);
#line 808
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___42,
              *(argv + 0), (int )c);
    }
#line 828
    d->rpl_optopt = (int )c;
#line 829
    return ('?');
  }
#line 832
  if ((int const   )*(temp + 0) == 87) {
#line 832
    if ((int const   )*(temp + 1) == 59) {
#line 836
      pfound___0 = (struct rpl_option  const  *)((void *)0);
#line 837
      exact___0 = 0;
#line 838
      ambig = 0;
#line 839
      indfound___0 = 0;
#line 842
      if ((unsigned long )longopts == (unsigned long )((void *)0)) {
#line 843
        goto no_longs;
      }
#line 846
      if ((int )*(d->__nextchar) != 0) {
#line 848
        d->rpl_optarg = d->__nextchar;
#line 851
        (d->rpl_optind) ++;
      } else
#line 853
      if (d->rpl_optind == argc) {
#line 855
        if (print_errors) {
#line 877
          tmp___43 = dcgettext((char const   *)((void *)0), "%s: option requires an argument -- \'%c\'\n",
                               5);
#line 877
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___43,
                  *(argv + 0), (int )c);
        }
#line 882
        d->rpl_optopt = (int )c;
#line 883
        if ((int const   )*(optstring + 0) == 58) {
#line 884
          c = (char )':';
        } else {
#line 886
          c = (char )'?';
        }
#line 887
        return ((int )c);
      } else {
#line 892
        tmp___44 = d->rpl_optind;
#line 892
        (d->rpl_optind) ++;
#line 892
        d->rpl_optarg = *(argv + tmp___44);
      }
#line 897
      nameend___0 = d->rpl_optarg;
#line 897
      d->__nextchar = nameend___0;
#line 897
      while (1) {
#line 897
        if (*nameend___0) {
#line 897
          if (! ((int )*nameend___0 != 61)) {
#line 897
            break;
          }
        } else {
#line 897
          break;
        }
#line 897
        nameend___0 ++;
      }
#line 903
      p___0 = longopts;
#line 903
      option_index___0 = 0;
#line 903
      while (p___0->name) {
#line 904
        if (0) {
#line 904
          if (0) {
#line 904
            __s1_len___1 = __builtin_strlen((char const   *)p___0->name);
#line 904
            __s2_len___1 = __builtin_strlen((char const   *)d->__nextchar);
#line 904
            if (! ((size_t )((void const   *)(p___0->name + 1)) - (size_t )((void const   *)p___0->name) == 1UL)) {
#line 904
              goto _L___13;
            } else
#line 904
            if (__s1_len___1 >= 4UL) {
              _L___13: 
#line 904
              if (! ((size_t )((void const   *)(d->__nextchar + 1)) - (size_t )((void const   *)d->__nextchar) == 1UL)) {
#line 904
                tmp___54 = 1;
              } else
#line 904
              if (__s2_len___1 >= 4UL) {
#line 904
                tmp___54 = 1;
              } else {
#line 904
                tmp___54 = 0;
              }
            } else {
#line 904
              tmp___54 = 0;
            }
#line 904
            if (tmp___54) {
#line 904
              tmp___49 = __builtin_strcmp((char const   *)p___0->name, (char const   *)d->__nextchar);
#line 904
              tmp___53 = tmp___49;
            } else {
#line 904
              tmp___52 = __builtin_strcmp((char const   *)p___0->name, (char const   *)d->__nextchar);
#line 904
              tmp___53 = tmp___52;
            }
          } else {
#line 904
            tmp___52 = __builtin_strcmp((char const   *)p___0->name, (char const   *)d->__nextchar);
#line 904
            tmp___53 = tmp___52;
          }
#line 904
          tmp___56 = tmp___53;
        } else {
#line 904
          tmp___55 = strncmp((char const   *)p___0->name, (char const   *)d->__nextchar,
                             (size_t )(nameend___0 - d->__nextchar));
#line 904
          tmp___56 = tmp___55;
        }
#line 904
        if (! tmp___56) {
#line 906
          tmp___45 = strlen((char const   *)p___0->name);
#line 906
          if ((size_t )((unsigned int )(nameend___0 - d->__nextchar)) == tmp___45) {
#line 909
            pfound___0 = p___0;
#line 910
            indfound___0 = option_index___0;
#line 911
            exact___0 = 1;
#line 912
            break;
          } else
#line 914
          if ((unsigned long )pfound___0 == (unsigned long )((void *)0)) {
#line 917
            pfound___0 = p___0;
#line 918
            indfound___0 = option_index___0;
          } else
#line 920
          if (long_only) {
#line 925
            ambig = 1;
          } else
#line 920
          if (pfound___0->has_arg != p___0->has_arg) {
#line 925
            ambig = 1;
          } else
#line 920
          if ((unsigned long )pfound___0->flag != (unsigned long )p___0->flag) {
#line 925
            ambig = 1;
          } else
#line 920
          if (pfound___0->val != p___0->val) {
#line 925
            ambig = 1;
          }
        }
#line 903
        p___0 ++;
#line 903
        option_index___0 ++;
      }
#line 927
      if (ambig) {
#line 927
        if (! exact___0) {
#line 929
          if (print_errors) {
#line 950
            tmp___59 = dcgettext((char const   *)((void *)0), "%s: option \'-W %s\' is ambiguous\n",
                                 5);
#line 950
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___59,
                    *(argv + 0), d->rpl_optarg);
          }
#line 954
          tmp___60 = strlen((char const   *)d->__nextchar);
#line 954
          d->__nextchar += tmp___60;
#line 955
          (d->rpl_optind) ++;
#line 956
          return ('?');
        }
      }
#line 958
      if ((unsigned long )pfound___0 != (unsigned long )((void *)0)) {
#line 960
        option_index___0 = indfound___0;
#line 961
        if (*nameend___0) {
#line 965
          if (pfound___0->has_arg) {
#line 966
            d->rpl_optarg = nameend___0 + 1;
          } else {
#line 969
            if (print_errors) {
#line 992
              tmp___61 = dcgettext((char const   *)((void *)0), "%s: option \'-W %s\' doesn\'t allow an argument\n",
                                   5);
#line 992
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___61,
                      *(argv + 0), pfound___0->name);
            }
#line 998
            tmp___62 = strlen((char const   *)d->__nextchar);
#line 998
            d->__nextchar += tmp___62;
#line 999
            return ('?');
          }
        } else
#line 1002
        if (pfound___0->has_arg == 1) {
#line 1004
          if (d->rpl_optind < argc) {
#line 1005
            tmp___63 = d->rpl_optind;
#line 1005
            (d->rpl_optind) ++;
#line 1005
            d->rpl_optarg = *(argv + tmp___63);
          } else {
#line 1008
            if (print_errors) {
#line 1031
              tmp___64 = dcgettext((char const   *)((void *)0), "%s: option \'-W %s\' requires an argument\n",
                                   5);
#line 1031
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___64,
                      *(argv + 0), pfound___0->name);
            }
#line 1036
            tmp___65 = strlen((char const   *)d->__nextchar);
#line 1036
            d->__nextchar += tmp___65;
#line 1037
            if ((int const   )*(optstring + 0) == 58) {
#line 1037
              tmp___66 = ':';
            } else {
#line 1037
              tmp___66 = '?';
            }
#line 1037
            return (tmp___66);
          }
        } else {
#line 1041
          d->rpl_optarg = (char *)((void *)0);
        }
#line 1042
        tmp___67 = strlen((char const   *)d->__nextchar);
#line 1042
        d->__nextchar += tmp___67;
#line 1043
        if ((unsigned long )longind != (unsigned long )((void *)0)) {
#line 1044
          *longind = option_index___0;
        }
#line 1045
        if (pfound___0->flag) {
#line 1047
          *(pfound___0->flag) = (int )pfound___0->val;
#line 1048
          return (0);
        }
#line 1050
        return ((int )pfound___0->val);
      }
      no_longs: 
#line 1054
      d->__nextchar = (char *)((void *)0);
#line 1055
      return ('W');
    }
  }
#line 1057
  if ((int const   )*(temp + 1) == 58) {
#line 1059
    if ((int const   )*(temp + 2) == 58) {
#line 1062
      if ((int )*(d->__nextchar) != 0) {
#line 1064
        d->rpl_optarg = d->__nextchar;
#line 1065
        (d->rpl_optind) ++;
      } else {
#line 1068
        d->rpl_optarg = (char *)((void *)0);
      }
#line 1069
      d->__nextchar = (char *)((void *)0);
    } else {
#line 1074
      if ((int )*(d->__nextchar) != 0) {
#line 1076
        d->rpl_optarg = d->__nextchar;
#line 1079
        (d->rpl_optind) ++;
      } else
#line 1081
      if (d->rpl_optind == argc) {
#line 1083
        if (print_errors) {
#line 1105
          tmp___68 = dcgettext((char const   *)((void *)0), "%s: option requires an argument -- \'%c\'\n",
                               5);
#line 1105
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___68,
                  *(argv + 0), (int )c);
        }
#line 1110
        d->rpl_optopt = (int )c;
#line 1111
        if ((int const   )*(optstring + 0) == 58) {
#line 1112
          c = (char )':';
        } else {
#line 1114
          c = (char )'?';
        }
      } else {
#line 1119
        tmp___69 = d->rpl_optind;
#line 1119
        (d->rpl_optind) ++;
#line 1119
        d->rpl_optarg = *(argv + tmp___69);
      }
#line 1120
      d->__nextchar = (char *)((void *)0);
    }
  }
#line 1123
  return ((int )c);
}
}
#line 1127 "getopt.c"
int rpl_getopt_internal(int argc , char **argv , char const   *optstring , struct rpl_option  const  *longopts ,
                        int *longind , int long_only , int posixly_correct ) 
{ int result ;

  {
#line 1134
  getopt_data.rpl_optind = rpl_optind;
#line 1135
  getopt_data.rpl_opterr = rpl_opterr;
#line 1137
  result = _getopt_internal_r(argc, argv, optstring, longopts, longind, long_only,
                              & getopt_data, posixly_correct);
#line 1141
  rpl_optind = getopt_data.rpl_optind;
#line 1142
  rpl_optarg = getopt_data.rpl_optarg;
#line 1143
  rpl_optopt = getopt_data.rpl_optopt;
#line 1145
  return (result);
}
}
#line 1156
 __attribute__((__nothrow__)) int rpl_getopt(int argc , char * const  *argv , char const   *optstring )  __attribute__((__nonnull__(2,3))) ;
#line 1156 "getopt.c"
int rpl_getopt(int argc , char * const  *argv , char const   *optstring ) 
{ int tmp ;

  {
#line 1159
  tmp = rpl_getopt_internal(argc, (char **)argv, optstring, (struct rpl_option  const  *)0,
                            (int *)0, 0, 1);
#line 1159
  return (tmp);
}
}
#line 1 "getopt1.o"
#pragma merger(0,"/tmp/cil-mXp2FDNA.i","-g,-O2")
#line 249 "./getopt.h"
 __attribute__((__nothrow__)) int rpl_getopt_long_only(int argc , char **argv , char const   *options ,
                                                       struct rpl_option  const  *long_options___1 ,
                                                       int *opt_index )  __attribute__((__nonnull__(2,3))) ;
#line 124 "getopt_int.h"
int _getopt_long_r(int argc , char **argv , char const   *options , struct rpl_option  const  *long_options___1 ,
                   int *opt_index , struct _getopt_data *d ) ;
#line 129
int _getopt_long_only_r(int argc , char **argv , char const   *options , struct rpl_option  const  *long_options___1 ,
                        int *opt_index , struct _getopt_data *d ) ;
#line 39 "getopt1.c"
 __attribute__((__nothrow__)) int rpl_getopt_long(int argc , char **argv , char const   *options ,
                                                  struct rpl_option  const  *long_options___1 ,
                                                  int *opt_index )  __attribute__((__nonnull__(2,3))) ;
#line 39 "getopt1.c"
int rpl_getopt_long(int argc , char **argv , char const   *options , struct rpl_option  const  *long_options___1 ,
                    int *opt_index ) 
{ int tmp ;

  {
#line 43
  tmp = rpl_getopt_internal(argc, argv, options, long_options___1, opt_index, 0, 0);
#line 43
  return (tmp);
}
}
#line 47 "getopt1.c"
int _getopt_long_r(int argc , char **argv , char const   *options , struct rpl_option  const  *long_options___1 ,
                   int *opt_index , struct _getopt_data *d ) 
{ int tmp ;

  {
#line 52
  tmp = _getopt_internal_r(argc, argv, options, long_options___1, opt_index, 0, d,
                           0);
#line 52
  return (tmp);
}
}
#line 61
 __attribute__((__nothrow__)) int rpl_getopt_long_only(int argc , char **argv , char const   *options ,
                                                       struct rpl_option  const  *long_options___1 ,
                                                       int *opt_index )  __attribute__((__nonnull__(2,3))) ;
#line 61 "getopt1.c"
int rpl_getopt_long_only(int argc , char **argv , char const   *options , struct rpl_option  const  *long_options___1 ,
                         int *opt_index ) 
{ int tmp ;

  {
#line 66
  tmp = rpl_getopt_internal(argc, argv, options, long_options___1, opt_index, 1, 0);
#line 66
  return (tmp);
}
}
#line 70 "getopt1.c"
int _getopt_long_only_r(int argc , char **argv , char const   *options , struct rpl_option  const  *long_options___1 ,
                        int *opt_index , struct _getopt_data *d ) 
{ int tmp ;

  {
#line 75
  tmp = _getopt_internal_r(argc, argv, options, long_options___1, opt_index, 1, d,
                           0);
#line 75
  return (tmp);
}
}
#line 1 "getpass.o"
#pragma merger(0,"/tmp/cil-n1wIBX1O.i","-g,-O2")
#line 967 "/usr/include/unistd.h"
char *gnu_getpass(char const   *prompt___0 )  __attribute__((__nonnull__(1))) ;
#line 249 "/usr/include/stdio.h"
extern int fflush_unlocked(FILE *__stream ) ;
#line 83 "/usr/include/stdio_ext.h"
extern  __attribute__((__nothrow__)) int __fsetlocking(FILE *__fp , int __type ) ;
#line 67 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int tcgetattr(int __fd , struct termios *__termios_p ) ;
#line 71
extern  __attribute__((__nothrow__)) int tcsetattr(int __fd , int __optional_actions ,
                                                   struct termios  const  *__termios_p ) ;
#line 79 "getpass.c"
static void call_fclose(void *arg ) 
{ 

  {
#line 82
  if ((unsigned long )arg != (unsigned long )((void *)0)) {
#line 83
    rpl_fclose((FILE *)arg);
  }
#line 84
  return;
}
}
#line 93 "getpass.c"
static char *buf  ;
#line 94 "getpass.c"
static size_t bufsize  ;
#line 86
char *gnu_getpass(char const   *prompt___0 )  __attribute__((__nonnull__(1))) ;
#line 86 "getpass.c"
char *gnu_getpass(char const   *prompt___0 ) 
{ FILE *tty ;
  FILE *in ;
  FILE *out ;
  struct termios s ;
  struct termios t ;
  _Bool tty_changed ;
  ssize_t nread ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 92
  tty_changed = (_Bool)0;
#line 100
  tty = fopen((char const   * __restrict  )"/dev/tty", (char const   * __restrict  )"w+");
#line 101
  if ((unsigned long )tty == (unsigned long )((void *)0)) {
#line 103
    in = stdin;
#line 104
    out = stderr;
  } else {
#line 109
    __fsetlocking(tty, 2);
#line 111
    in = tty;
#line 111
    out = in;
  }
#line 118
  tmp___1 = fileno(in);
#line 118
  tmp___2 = tcgetattr(tmp___1, & t);
#line 118
  if (tmp___2 == 0) {
#line 121
    s = t;
#line 123
    t.c_lflag &= 4294967286U;
#line 124
    tmp = fileno(in);
#line 124
    tmp___0 = tcsetattr(tmp, 2, (struct termios  const  *)(& t));
#line 124
    tty_changed = (_Bool )(tmp___0 == 0);
  }
#line 129
  fputs_unlocked((char const   * __restrict  )prompt___0, (FILE * __restrict  )out);
#line 130
  fflush_unlocked(out);
#line 133
  nread = getline((char ** __restrict  )(& buf), (size_t * __restrict  )(& bufsize),
                  (FILE * __restrict  )in);
#line 144
  rpl_fseeko(out, (off_t )0, 1);
#line 146
  if ((unsigned long )buf != (unsigned long )((void *)0)) {
#line 148
    if (nread < 0L) {
#line 149
      *(buf + 0) = (char )'\000';
    } else
#line 150
    if ((int )*(buf + (nread - 1L)) == 10) {
#line 153
      *(buf + (nread - 1L)) = (char )'\000';
#line 154
      if (tty_changed) {
#line 157
        fputc_unlocked('\n', out);
      }
    }
  }
#line 164
  if (tty_changed) {
#line 165
    tmp___3 = fileno(in);
#line 165
    tcsetattr(tmp___3, 2, (struct termios  const  *)(& s));
  }
#line 170
  call_fclose((void *)tty);
#line 172
  return (buf);
}
}
#line 1 "isapipe.o"
#pragma merger(0,"/tmp/cil-dCG56FmA.i","-g,-O2")
#line 6 "isapipe.h"
int isapipe(int fd ) ;
#line 68 "isapipe.c"
int isapipe(int fd ) 
{ nlink_t pipe_link_count_max ;
  _Bool check_for_fifo ;
  struct stat st ;
  int fstat_result ;
  int tmp ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 71
  pipe_link_count_max = (nlink_t )1;
#line 72
  check_for_fifo = (_Bool)1;
#line 74
  tmp = fstat(fd, & st);
#line 74
  fstat_result = tmp;
#line 76
  if (fstat_result != 0) {
#line 77
    return (fstat_result);
  }
#line 114
  if (st.st_nlink <= pipe_link_count_max) {
#line 114
    if (check_for_fifo) {
#line 114
      tmp___4 = (st.st_mode & 61440U) == 4096U;
    } else {
#line 114
      tmp___4 = (st.st_mode & 61440U) == 49152U;
    }
#line 114
    if (tmp___4) {
#line 114
      tmp___5 = 1;
    } else {
#line 114
      tmp___5 = 0;
    }
  } else {
#line 114
    tmp___5 = 0;
  }
#line 114
  return (tmp___5);
}
}
#line 1 "isnanl.o"
#pragma merger(0,"/tmp/cil-5AaP4Yzr.i","-g,-O2")
#line 24 "isnan.c"
int rpl_isnanl(long double x ) ;
#line 82 "isnan.c"
int rpl_isnanl(long double x ) 
{ memory_double m ;
  unsigned int exponent ;

  {
#line 98
  m.value = x;
#line 99
  exponent = m.word[2] & 32767U;
#line 110
  if (exponent == 0U) {
#line 111
    return ((int )(m.word[1] >> 31));
  } else
#line 112
  if (exponent == 32767U) {
#line 113
    return (((m.word[1] ^ 2147483648U) | m.word[0]) != 0U);
  } else {
#line 115
    return ((int )((m.word[1] >> 31) ^ 1U));
  }
}
}
#line 1 "linkat.o"
#pragma merger(0,"/tmp/cil-yrlUrfXI.i","-g,-O2")
#line 815 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int linkat(int __fromfd , char const   *__from ,
                                                int __tofd , char const   *__to ,
                                                int __flags )  __attribute__((__warn_unused_result__,
__nonnull__(2,4))) ;
#line 1299 "./unistd.h"
int rpl_linkat(int fd1 , char const   *file1 , int fd2 , char const   *file2 , int flag )  __attribute__((__nonnull__(2,4))) ;
#line 225 "linkat.c"
static int linkat_follow(int fd1 , char const   *file1 , int fd2 , char const   *file2 ) 
{ char *name ;
  char *target ;
  int result ;
  int i ;
  char *dir ;
  char *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int saved_errno ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int saved_errno___0 ;
  int *tmp___7 ;
  int *tmp___8 ;

  {
#line 228
  name = (char *)file1;
#line 231
  i = 20;
#line 234
  while (1) {
#line 234
    tmp___2 = i;
#line 234
    i --;
#line 234
    if (tmp___2) {
#line 234
      target = areadlinkat(fd1, (char const   *)name);
#line 234
      if (! target) {
#line 234
        break;
      }
    } else {
#line 234
      break;
    }
#line 236
    if ((int )*(target + 0) == 47) {
#line 236
      goto _L;
    } else
#line 236
    if (0) {
      _L: 
#line 238
      if ((unsigned long )name != (unsigned long )file1) {
#line 239
        free((void *)name);
      }
#line 240
      name = target;
    } else {
#line 244
      tmp = mdir_name((char const   *)name);
#line 244
      dir = tmp;
#line 245
      if ((unsigned long )name != (unsigned long )file1) {
#line 246
        free((void *)name);
      }
#line 247
      if (! dir) {
#line 249
        free((void *)target);
#line 250
        tmp___0 = __errno_location();
#line 250
        *tmp___0 = 12;
#line 251
        return (-1);
      }
#line 253
      name = mfile_name_concat((char const   *)dir, (char const   *)target, (char **)((void *)0));
#line 254
      free((void *)dir);
#line 255
      free((void *)target);
#line 256
      if (! name) {
#line 258
        tmp___1 = __errno_location();
#line 258
        *tmp___1 = 12;
#line 259
        return (-1);
      }
    }
  }
#line 263
  if (i < 0) {
#line 265
    target = (char *)((void *)0);
#line 266
    tmp___3 = __errno_location();
#line 266
    *tmp___3 = 40;
  }
#line 268
  if (! target) {
#line 268
    tmp___6 = __errno_location();
#line 268
    if (*tmp___6 != 22) {
#line 270
      if ((unsigned long )name != (unsigned long )file1) {
#line 272
        tmp___4 = __errno_location();
#line 272
        saved_errno = *tmp___4;
#line 273
        free((void *)name);
#line 274
        tmp___5 = __errno_location();
#line 274
        *tmp___5 = saved_errno;
      }
#line 276
      return (-1);
    }
  }
#line 278
  result = linkat(fd1, (char const   *)name, fd2, file2, 0);
#line 279
  if ((unsigned long )name != (unsigned long )file1) {
#line 281
    tmp___7 = __errno_location();
#line 281
    saved_errno___0 = *tmp___7;
#line 282
    free((void *)name);
#line 283
    tmp___8 = __errno_location();
#line 283
    *tmp___8 = saved_errno___0;
  }
#line 285
  return (result);
}
}
#line 329 "linkat.c"
static int have_follow_really  ;
#line 292
int rpl_linkat(int fd1 , char const   *file1 , int fd2 , char const   *file2 , int flag )  __attribute__((__nonnull__(2,4))) ;
#line 292 "linkat.c"
int rpl_linkat(int fd1 , char const   *file1 , int fd2 , char const   *file2 , int flag ) 
{ int *tmp ;
  int tmp___0 ;
  int result ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
#line 295
  if (flag & -1025) {
#line 297
    tmp = __errno_location();
#line 297
    *tmp = 22;
#line 298
    return (-1);
  }
#line 324
  if (! flag) {
#line 325
    tmp___0 = linkat(fd1, file1, fd2, file2, flag);
#line 325
    return (tmp___0);
  }
#line 330
  if (0 <= have_follow_really) {
#line 332
    tmp___1 = linkat(fd1, file1, fd2, file2, flag);
#line 332
    result = tmp___1;
#line 333
    if (result == -1) {
#line 333
      tmp___2 = __errno_location();
#line 333
      if (! (*tmp___2 == 22)) {
#line 335
        have_follow_really = 1;
#line 336
        return (result);
      }
    } else {
#line 335
      have_follow_really = 1;
#line 336
      return (result);
    }
#line 338
    have_follow_really = -1;
  }
#line 341
  tmp___3 = linkat_follow(fd1, file1, fd2, file2);
#line 341
  return (tmp___3);
}
}
#line 1 "mountlist.o"
#pragma merger(0,"/tmp/cil-oc8GQ0MI.i","-g,-O2")
#line 38 "mountlist.h"
struct mount_entry *read_file_system_list(_Bool need_fs_type ) ;
#line 67 "/usr/include/mntent.h"
extern  __attribute__((__nothrow__)) FILE *setmntent(char const   *__file , char const   *__mode ) ;
#line 72
extern  __attribute__((__nothrow__)) struct mntent *getmntent(FILE *__stream ) ;
#line 88
extern  __attribute__((__nothrow__)) int endmntent(FILE *__stream ) ;
#line 329 "mountlist.c"
static dev_t dev_from_mount_options(char const   *mount_options ) 
{ 

  {
#line 356
  return ((dev_t )-1);
}
}
#line 366 "mountlist.c"
struct mount_entry *read_file_system_list(_Bool need_fs_type ) 
{ struct mount_entry *mount_list ;
  struct mount_entry *me ;
  struct mount_entry **mtail ;
  struct mntent *mnt ;
  char const   *table___0 ;
  FILE *fp ;
  void *tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___1 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___15 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___22 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___29 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___36 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  char *tmp___44 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  int tmp___46 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  size_t __s1_len___6 ;
  size_t __s2_len___6 ;
  int tmp___53 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int saved_errno ;
  int *tmp___61 ;
  int *tmp___62 ;

  {
#line 371
  mtail = & mount_list;
#line 408
  table___0 = "/etc/mtab";
#line 411
  fp = setmntent(table___0, "r");
#line 412
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 413
    return ((struct mount_entry *)((void *)0));
  }
#line 415
  while (1) {
#line 415
    mnt = getmntent(fp);
#line 415
    if (! mnt) {
#line 415
      break;
    }
#line 417
    tmp = xmalloc(sizeof(*me));
#line 417
    me = (struct mount_entry *)tmp;
#line 418
    me->me_devname = xstrdup((char const   *)mnt->mnt_fsname);
#line 419
    me->me_mountdir = xstrdup((char const   *)mnt->mnt_dir);
#line 420
    me->me_type = xstrdup((char const   *)mnt->mnt_type);
#line 421
    me->me_type_malloced = 1U;
#line 422
    if (0) {
#line 422
      __s1_len = __builtin_strlen((char const   *)me->me_type);
#line 422
      __s2_len = __builtin_strlen("autofs");
#line 422
      if (! ((size_t )((void const   *)(me->me_type + 1)) - (size_t )((void const   *)me->me_type) == 1UL)) {
#line 422
        goto _L___0;
      } else
#line 422
      if (__s1_len >= 4UL) {
        _L___0: 
#line 422
        if (! ((size_t )((void const   *)("autofs" + 1)) - (size_t )((void const   *)"autofs") == 1UL)) {
#line 422
          tmp___6 = 1;
        } else
#line 422
        if (__s2_len >= 4UL) {
#line 422
          tmp___6 = 1;
        } else {
#line 422
          tmp___6 = 0;
        }
      } else {
#line 422
        tmp___6 = 0;
      }
#line 422
      if (tmp___6) {
#line 422
        tmp___1 = __builtin_strcmp((char const   *)me->me_type, "autofs");
#line 422
        tmp___5 = tmp___1;
      } else {
#line 422
        tmp___4 = __builtin_strcmp((char const   *)me->me_type, "autofs");
#line 422
        tmp___5 = tmp___4;
      }
    } else {
#line 422
      tmp___4 = __builtin_strcmp((char const   *)me->me_type, "autofs");
#line 422
      tmp___5 = tmp___4;
    }
#line 422
    if (tmp___5 == 0) {
#line 422
      tmp___42 = 1;
    } else {
#line 422
      if (0) {
#line 422
        __s1_len___0 = __builtin_strlen((char const   *)me->me_type);
#line 422
        __s2_len___0 = __builtin_strlen("none");
#line 422
        if (! ((size_t )((void const   *)(me->me_type + 1)) - (size_t )((void const   *)me->me_type) == 1UL)) {
#line 422
          goto _L___2;
        } else
#line 422
        if (__s1_len___0 >= 4UL) {
          _L___2: 
#line 422
          if (! ((size_t )((void const   *)("none" + 1)) - (size_t )((void const   *)"none") == 1UL)) {
#line 422
            tmp___13 = 1;
          } else
#line 422
          if (__s2_len___0 >= 4UL) {
#line 422
            tmp___13 = 1;
          } else {
#line 422
            tmp___13 = 0;
          }
        } else {
#line 422
          tmp___13 = 0;
        }
#line 422
        if (tmp___13) {
#line 422
          tmp___8 = __builtin_strcmp((char const   *)me->me_type, "none");
#line 422
          tmp___12 = tmp___8;
        } else {
#line 422
          tmp___11 = __builtin_strcmp((char const   *)me->me_type, "none");
#line 422
          tmp___12 = tmp___11;
        }
      } else {
#line 422
        tmp___11 = __builtin_strcmp((char const   *)me->me_type, "none");
#line 422
        tmp___12 = tmp___11;
      }
#line 422
      if (tmp___12 == 0) {
#line 422
        tmp___42 = 1;
      } else {
#line 422
        if (0) {
#line 422
          __s1_len___1 = __builtin_strlen((char const   *)me->me_type);
#line 422
          __s2_len___1 = __builtin_strlen("proc");
#line 422
          if (! ((size_t )((void const   *)(me->me_type + 1)) - (size_t )((void const   *)me->me_type) == 1UL)) {
#line 422
            goto _L___4;
          } else
#line 422
          if (__s1_len___1 >= 4UL) {
            _L___4: 
#line 422
            if (! ((size_t )((void const   *)("proc" + 1)) - (size_t )((void const   *)"proc") == 1UL)) {
#line 422
              tmp___20 = 1;
            } else
#line 422
            if (__s2_len___1 >= 4UL) {
#line 422
              tmp___20 = 1;
            } else {
#line 422
              tmp___20 = 0;
            }
          } else {
#line 422
            tmp___20 = 0;
          }
#line 422
          if (tmp___20) {
#line 422
            tmp___15 = __builtin_strcmp((char const   *)me->me_type, "proc");
#line 422
            tmp___19 = tmp___15;
          } else {
#line 422
            tmp___18 = __builtin_strcmp((char const   *)me->me_type, "proc");
#line 422
            tmp___19 = tmp___18;
          }
        } else {
#line 422
          tmp___18 = __builtin_strcmp((char const   *)me->me_type, "proc");
#line 422
          tmp___19 = tmp___18;
        }
#line 422
        if (tmp___19 == 0) {
#line 422
          tmp___42 = 1;
        } else {
#line 422
          if (0) {
#line 422
            __s1_len___2 = __builtin_strlen((char const   *)me->me_type);
#line 422
            __s2_len___2 = __builtin_strlen("subfs");
#line 422
            if (! ((size_t )((void const   *)(me->me_type + 1)) - (size_t )((void const   *)me->me_type) == 1UL)) {
#line 422
              goto _L___6;
            } else
#line 422
            if (__s1_len___2 >= 4UL) {
              _L___6: 
#line 422
              if (! ((size_t )((void const   *)("subfs" + 1)) - (size_t )((void const   *)"subfs") == 1UL)) {
#line 422
                tmp___27 = 1;
              } else
#line 422
              if (__s2_len___2 >= 4UL) {
#line 422
                tmp___27 = 1;
              } else {
#line 422
                tmp___27 = 0;
              }
            } else {
#line 422
              tmp___27 = 0;
            }
#line 422
            if (tmp___27) {
#line 422
              tmp___22 = __builtin_strcmp((char const   *)me->me_type, "subfs");
#line 422
              tmp___26 = tmp___22;
            } else {
#line 422
              tmp___25 = __builtin_strcmp((char const   *)me->me_type, "subfs");
#line 422
              tmp___26 = tmp___25;
            }
          } else {
#line 422
            tmp___25 = __builtin_strcmp((char const   *)me->me_type, "subfs");
#line 422
            tmp___26 = tmp___25;
          }
#line 422
          if (tmp___26 == 0) {
#line 422
            tmp___42 = 1;
          } else {
#line 422
            if (0) {
#line 422
              __s1_len___3 = __builtin_strlen((char const   *)me->me_type);
#line 422
              __s2_len___3 = __builtin_strlen("kernfs");
#line 422
              if (! ((size_t )((void const   *)(me->me_type + 1)) - (size_t )((void const   *)me->me_type) == 1UL)) {
#line 422
                goto _L___8;
              } else
#line 422
              if (__s1_len___3 >= 4UL) {
                _L___8: 
#line 422
                if (! ((size_t )((void const   *)("kernfs" + 1)) - (size_t )((void const   *)"kernfs") == 1UL)) {
#line 422
                  tmp___34 = 1;
                } else
#line 422
                if (__s2_len___3 >= 4UL) {
#line 422
                  tmp___34 = 1;
                } else {
#line 422
                  tmp___34 = 0;
                }
              } else {
#line 422
                tmp___34 = 0;
              }
#line 422
              if (tmp___34) {
#line 422
                tmp___29 = __builtin_strcmp((char const   *)me->me_type, "kernfs");
#line 422
                tmp___33 = tmp___29;
              } else {
#line 422
                tmp___32 = __builtin_strcmp((char const   *)me->me_type, "kernfs");
#line 422
                tmp___33 = tmp___32;
              }
            } else {
#line 422
              tmp___32 = __builtin_strcmp((char const   *)me->me_type, "kernfs");
#line 422
              tmp___33 = tmp___32;
            }
#line 422
            if (tmp___33 == 0) {
#line 422
              tmp___42 = 1;
            } else {
#line 422
              if (0) {
#line 422
                __s1_len___4 = __builtin_strlen((char const   *)me->me_type);
#line 422
                __s2_len___4 = __builtin_strlen("ignore");
#line 422
                if (! ((size_t )((void const   *)(me->me_type + 1)) - (size_t )((void const   *)me->me_type) == 1UL)) {
#line 422
                  goto _L___10;
                } else
#line 422
                if (__s1_len___4 >= 4UL) {
                  _L___10: 
#line 422
                  if (! ((size_t )((void const   *)("ignore" + 1)) - (size_t )((void const   *)"ignore") == 1UL)) {
#line 422
                    tmp___41 = 1;
                  } else
#line 422
                  if (__s2_len___4 >= 4UL) {
#line 422
                    tmp___41 = 1;
                  } else {
#line 422
                    tmp___41 = 0;
                  }
                } else {
#line 422
                  tmp___41 = 0;
                }
#line 422
                if (tmp___41) {
#line 422
                  tmp___36 = __builtin_strcmp((char const   *)me->me_type, "ignore");
#line 422
                  tmp___40 = tmp___36;
                } else {
#line 422
                  tmp___39 = __builtin_strcmp((char const   *)me->me_type, "ignore");
#line 422
                  tmp___40 = tmp___39;
                }
              } else {
#line 422
                tmp___39 = __builtin_strcmp((char const   *)me->me_type, "ignore");
#line 422
                tmp___40 = tmp___39;
              }
#line 422
              if (tmp___40 == 0) {
#line 422
                tmp___42 = 1;
              } else {
#line 422
                tmp___42 = 0;
              }
            }
          }
        }
      }
    }
#line 422
    me->me_dummy = (unsigned int )tmp___42;
#line 423
    tmp___44 = __builtin_strchr(me->me_devname, ':');
#line 423
    if ((unsigned long )tmp___44 != (unsigned long )((void *)0)) {
#line 423
      tmp___59 = 1;
    } else
#line 423
    if ((int )*(me->me_devname + 0) == 47) {
#line 423
      if ((int )*(me->me_devname + 1) == 47) {
#line 423
        if (0) {
#line 423
          __s1_len___5 = __builtin_strlen((char const   *)me->me_type);
#line 423
          __s2_len___5 = __builtin_strlen("smbfs");
#line 423
          if (! ((size_t )((void const   *)(me->me_type + 1)) - (size_t )((void const   *)me->me_type) == 1UL)) {
#line 423
            goto _L___12;
          } else
#line 423
          if (__s1_len___5 >= 4UL) {
            _L___12: 
#line 423
            if (! ((size_t )((void const   *)("smbfs" + 1)) - (size_t )((void const   *)"smbfs") == 1UL)) {
#line 423
              tmp___51 = 1;
            } else
#line 423
            if (__s2_len___5 >= 4UL) {
#line 423
              tmp___51 = 1;
            } else {
#line 423
              tmp___51 = 0;
            }
          } else {
#line 423
            tmp___51 = 0;
          }
#line 423
          if (tmp___51) {
#line 423
            tmp___46 = __builtin_strcmp((char const   *)me->me_type, "smbfs");
#line 423
            tmp___50 = tmp___46;
          } else {
#line 423
            tmp___49 = __builtin_strcmp((char const   *)me->me_type, "smbfs");
#line 423
            tmp___50 = tmp___49;
          }
        } else {
#line 423
          tmp___49 = __builtin_strcmp((char const   *)me->me_type, "smbfs");
#line 423
          tmp___50 = tmp___49;
        }
#line 423
        if (tmp___50 == 0) {
#line 423
          tmp___59 = 1;
        } else {
#line 423
          if (0) {
#line 423
            __s1_len___6 = __builtin_strlen((char const   *)me->me_type);
#line 423
            __s2_len___6 = __builtin_strlen("cifs");
#line 423
            if (! ((size_t )((void const   *)(me->me_type + 1)) - (size_t )((void const   *)me->me_type) == 1UL)) {
#line 423
              goto _L___14;
            } else
#line 423
            if (__s1_len___6 >= 4UL) {
              _L___14: 
#line 423
              if (! ((size_t )((void const   *)("cifs" + 1)) - (size_t )((void const   *)"cifs") == 1UL)) {
#line 423
                tmp___58 = 1;
              } else
#line 423
              if (__s2_len___6 >= 4UL) {
#line 423
                tmp___58 = 1;
              } else {
#line 423
                tmp___58 = 0;
              }
            } else {
#line 423
              tmp___58 = 0;
            }
#line 423
            if (tmp___58) {
#line 423
              tmp___53 = __builtin_strcmp((char const   *)me->me_type, "cifs");
#line 423
              tmp___57 = tmp___53;
            } else {
#line 423
              tmp___56 = __builtin_strcmp((char const   *)me->me_type, "cifs");
#line 423
              tmp___57 = tmp___56;
            }
          } else {
#line 423
            tmp___56 = __builtin_strcmp((char const   *)me->me_type, "cifs");
#line 423
            tmp___57 = tmp___56;
          }
#line 423
          if (tmp___57 == 0) {
#line 423
            tmp___59 = 1;
          } else {
#line 423
            tmp___59 = 0;
          }
        }
      } else {
#line 423
        tmp___59 = 0;
      }
    } else {
#line 423
      tmp___59 = 0;
    }
#line 423
    me->me_remote = (unsigned int )tmp___59;
#line 424
    me->me_dev = dev_from_mount_options((char const   *)mnt->mnt_opts);
#line 427
    *mtail = me;
#line 428
    mtail = & me->me_next;
  }
#line 431
  tmp___60 = endmntent(fp);
#line 431
  if (tmp___60 == 0) {
#line 432
    goto free_then_fail;
  }
#line 928
  *mtail = (struct mount_entry *)((void *)0);
#line 929
  return (mount_list);
  free_then_fail: 
#line 934
  tmp___61 = __errno_location();
#line 934
  saved_errno = *tmp___61;
#line 935
  *mtail = (struct mount_entry *)((void *)0);
#line 937
  while (mount_list) {
#line 939
    me = mount_list->me_next;
#line 940
    free((void *)mount_list->me_devname);
#line 941
    free((void *)mount_list->me_mountdir);
#line 942
    if (mount_list->me_type_malloced) {
#line 943
      free((void *)mount_list->me_type);
    }
#line 944
    free((void *)mount_list);
#line 945
    mount_list = me;
  }
#line 948
  tmp___62 = __errno_location();
#line 948
  *tmp___62 = saved_errno;
#line 949
  return ((struct mount_entry *)((void *)0));
}
}
#line 1 "nanosleep.o"
#pragma merger(0,"/tmp/cil-YCXQinTL.i","-g,-O2")
#line 328 "/usr/include/time.h"
extern int nanosleep(struct timespec  const  *__requested_time , struct timespec *__remaining ) ;
#line 45 "nanosleep.c"
int rpl_nanosleep(struct timespec  const  *requested_delay , struct timespec *remaining_delay )  __attribute__((__nonnull__(1))) ;
#line 45 "nanosleep.c"
int rpl_nanosleep(struct timespec  const  *requested_delay , struct timespec *remaining_delay ) 
{ int *tmp ;
  time_t limit ;
  time_t seconds ;
  struct timespec intermediate ;
  int result ;
  int tmp___0 ;

  {
#line 56
  if (requested_delay->tv_nsec < 0L) {
#line 58
    tmp = __errno_location();
#line 58
    *tmp = 22;
#line 59
    return (-1);
  } else
#line 56
  if (1000000000L <= (long )requested_delay->tv_nsec) {
#line 58
    tmp = __errno_location();
#line 58
    *tmp = 22;
#line 59
    return (-1);
  }
#line 65
  limit = (time_t )2073600;
#line 66
  seconds = (time_t )requested_delay->tv_sec;
#line 68
  intermediate.tv_nsec = (long )requested_delay->tv_nsec;
#line 70
  while (limit < seconds) {
#line 73
    intermediate.tv_sec = limit;
#line 74
    result = nanosleep((struct timespec  const  *)(& intermediate), remaining_delay);
#line 75
    seconds -= limit;
#line 76
    if (result) {
#line 78
      if (remaining_delay) {
#line 79
        remaining_delay->tv_sec += seconds;
      }
#line 80
      return (result);
    }
#line 82
    intermediate.tv_nsec = 0L;
  }
#line 84
  intermediate.tv_sec = seconds;
#line 85
  tmp___0 = nanosleep((struct timespec  const  *)(& intermediate), remaining_delay);
#line 85
  return (tmp___0);
}
}
#line 1 "openat-proc.o"
#pragma merger(0,"/tmp/cil-ctOsNzcD.i","-g,-O2")
#line 47 "openat-priv.h"
char *openat_proc_name(char *buf___1 , int fd , char const   *file ) ;
#line 288 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int access(char const   *__name , int __type )  __attribute__((__nonnull__(1))) ;
#line 58 "openat-proc.c"
static int proc_status  =    0;
#line 55 "openat-proc.c"
char *openat_proc_name(char *buf___1 , int fd , char const   *file ) 
{ int proc_self_fd ;
  int __attribute__((__artificial__))  tmp ;
  char dotdot_buf[(((sizeof("/proc/self/fd/%d/%s") - sizeof("%d%s")) + (((sizeof(int ) * 8UL - 1UL) * 146UL + 484UL) / 485UL + 1UL)) + (sizeof("../fd") - 1UL)) + 1UL] ;
  int tmp___1 ;
  size_t bufsize___0 ;
  size_t tmp___2 ;
  char *result ;
  void *tmp___3 ;

  {
#line 61
  if (! *file) {
#line 63
    *(buf___1 + 0) = (char )'\000';
#line 64
    return (buf___1);
  }
#line 67
  if (! proc_status) {
#line 77
    tmp = open("/proc/self/fd", 67840);
#line 77
    proc_self_fd = (int )tmp;
#line 79
    if (proc_self_fd < 0) {
#line 80
      proc_status = -1;
    } else {
#line 89
      sprintf((char * __restrict  )(dotdot_buf), (char const   * __restrict  )"/proc/self/fd/%d/%s",
              proc_self_fd, "../fd");
#line 90
      tmp___1 = access((char const   *)(dotdot_buf), 0);
#line 90
      if (tmp___1) {
#line 90
        proc_status = -1;
      } else {
#line 90
        proc_status = 1;
      }
#line 91
      close(proc_self_fd);
    }
  }
#line 95
  if (proc_status < 0) {
#line 96
    return ((char *)((void *)0));
  } else {
#line 99
    tmp___2 = strlen(file);
#line 99
    bufsize___0 = (((sizeof("/proc/self/fd/%d/%s") - sizeof("%d%s")) + (((sizeof(int ) * 8UL - 1UL) * 146UL + 484UL) / 485UL + 1UL)) + tmp___2) + 1UL;
#line 100
    result = buf___1;
#line 101
    if (4032UL < bufsize___0) {
#line 103
      tmp___3 = malloc(bufsize___0);
#line 103
      result = (char *)tmp___3;
#line 104
      if (! result) {
#line 105
        return ((char *)((void *)0));
      }
    }
#line 107
    sprintf((char * __restrict  )result, (char const   * __restrict  )"/proc/self/fd/%d/%s",
            fd, file);
#line 108
    return (result);
  }
}
}
#line 1 "printf-args.o"
#pragma merger(0,"/tmp/cil-SJ6wN4Jk.i","-g,-O2")
#line 157 "printf-args.h"
int printf_fetchargs(va_list args , arguments *a ) ;
#line 115 "printf-args.c"
static wchar_t const   wide_null_string[7]  = {      (wchar_t const   )'(',      (wchar_t const   )'N',      (wchar_t const   )'U',      (wchar_t const   )'L', 
        (wchar_t const   )'L',      (wchar_t const   )')',      (wchar_t const   )0};
#line 38 "printf-args.c"
int printf_fetchargs(va_list args , arguments *a ) 
{ size_t i ;
  argument *ap ;
  int tmp ;
  wint_t tmp___0 ;

  {
#line 44
  i = (size_t )0;
#line 44
  ap = a->arg + 0;
#line 44
  while (i < a->count) {
#line 45
    switch ((int )ap->type) {
    case 1: 
#line 48
    ap->a.a_schar = __builtin_va_arg(args, int );
#line 49
    break;
    case 2: 
#line 51
    ap->a.a_uchar = __builtin_va_arg(args, int );
#line 52
    break;
    case 3: 
#line 54
    ap->a.a_short = __builtin_va_arg(args, int );
#line 55
    break;
    case 4: 
#line 57
    ap->a.a_ushort = __builtin_va_arg(args, int );
#line 58
    break;
    case 5: 
#line 60
    ap->a.a_int = __builtin_va_arg(args, int );
#line 61
    break;
    case 6: 
#line 63
    ap->a.a_uint = __builtin_va_arg(args, unsigned int );
#line 64
    break;
    case 7: 
#line 66
    ap->a.a_longint = __builtin_va_arg(args, long );
#line 67
    break;
    case 8: 
#line 69
    ap->a.a_ulongint = __builtin_va_arg(args, unsigned long );
#line 70
    break;
    case 9: 
#line 73
    ap->a.a_longlongint = __builtin_va_arg(args, long long );
#line 74
    break;
    case 10: 
#line 76
    ap->a.a_ulonglongint = __builtin_va_arg(args, unsigned long long );
#line 77
    break;
    case 11: 
#line 80
    ap->a.a_double = __builtin_va_arg(args, double );
#line 81
    break;
    case 12: 
#line 83
    ap->a.a_longdouble = __builtin_va_arg(args, long double );
#line 84
    break;
    case 13: 
#line 86
    ap->a.a_char = __builtin_va_arg(args, int );
#line 87
    break;
    case 14: 
#line 93
    if (sizeof(wint_t ) < sizeof(int )) {
#line 93
      tmp = __builtin_va_arg(args, int );
#line 93
      ap->a.a_wide_char = (wint_t )tmp;
    } else {
#line 93
      tmp___0 = __builtin_va_arg(args, wint_t );
#line 93
      ap->a.a_wide_char = tmp___0;
    }
#line 97
    break;
    case 15: 
#line 100
    ap->a.a_string = __builtin_va_arg(args, char const   *);
#line 104
    if ((unsigned long )ap->a.a_string == (unsigned long )((void *)0)) {
#line 105
      ap->a.a_string = "(NULL)";
    }
#line 106
    break;
    case 16: 
#line 109
    ap->a.a_wide_string = __builtin_va_arg(args, wchar_t const   *);
#line 113
    if ((unsigned long )ap->a.a_wide_string == (unsigned long )((void *)0)) {
#line 122
      ap->a.a_wide_string = wide_null_string;
    }
#line 124
    break;
    case 17: 
#line 127
    ap->a.a_pointer = __builtin_va_arg(args, void *);
#line 128
    break;
    case 18: 
#line 130
    ap->a.a_count_schar_pointer = __builtin_va_arg(args, signed char *);
#line 131
    break;
    case 19: 
#line 133
    ap->a.a_count_short_pointer = __builtin_va_arg(args, short *);
#line 134
    break;
    case 20: 
#line 136
    ap->a.a_count_int_pointer = __builtin_va_arg(args, int *);
#line 137
    break;
    case 21: 
#line 139
    ap->a.a_count_longint_pointer = __builtin_va_arg(args, long *);
#line 140
    break;
    case 22: 
#line 143
    ap->a.a_count_longlongint_pointer = __builtin_va_arg(args, long long *);
#line 144
    break;
    default: 
#line 187
    return (-1);
    }
#line 44
    i ++;
#line 44
    ap ++;
  }
#line 189
  return (0);
}
}
#line 1 "printf-parse.o"
#pragma merger(0,"/tmp/cil-RLvVxikX.i","-g,-O2")
#line 191 "printf-parse.h"
int printf_parse(char const   *format , char_directives *d , arguments *a ) ;
#line 85 "printf-parse.c"
int printf_parse(char const   *format , char_directives *d , arguments *a ) 
{ char const   *cp ;
  size_t arg_posn ;
  size_t d_allocated ;
  size_t a_allocated ;
  size_t max_width_length ;
  size_t max_precision_length ;
  char c ;
  char const   *tmp ;
  size_t arg_index ;
  char_directive *dp ;
  char const   *np ;
  size_t n ;
  size_t tmp___0 ;
  size_t __attribute__((__pure__))  tmp___1 ;
  char const   *np___0 ;
  size_t n___0 ;
  size_t tmp___2 ;
  size_t __attribute__((__pure__))  tmp___3 ;
  size_t tmp___4 ;
  size_t n___1 ;
  size_t memory_size ;
  argument *memory ;
  size_t __attribute__((__pure__))  tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  size_t tmp___9 ;
  size_t width_length ;
  char const   *np___1 ;
  size_t n___2 ;
  size_t tmp___10 ;
  size_t __attribute__((__pure__))  tmp___11 ;
  size_t tmp___12 ;
  size_t n___3 ;
  size_t memory_size___0 ;
  argument *memory___0 ;
  size_t __attribute__((__pure__))  tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  size_t tmp___17 ;
  size_t precision_length ;
  arg_type type ;
  int flags ;
  char const   *tmp___18 ;
  size_t tmp___19 ;
  size_t n___4 ;
  size_t memory_size___1 ;
  argument *memory___1 ;
  size_t __attribute__((__pure__))  tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;
  size_t tmp___24 ;
  size_t memory_size___2 ;
  char_directive *memory___2 ;
  void *tmp___25 ;
  void *tmp___26 ;
  void *tmp___27 ;
  int *tmp___28 ;
  int *tmp___29 ;

  {
#line 88
  cp = format;
#line 89
  arg_posn = (size_t )0;
#line 92
  max_width_length = (size_t )0;
#line 93
  max_precision_length = (size_t )0;
#line 95
  d->count = (size_t )0;
#line 96
  d_allocated = (size_t )7;
#line 97
  d->dir = d->direct_alloc_dir;
#line 99
  a->count = (size_t )0;
#line 100
  a_allocated = (size_t )7;
#line 101
  a->arg = a->direct_alloc_arg;
#line 137
  while ((int const   )*cp != 0) {
#line 139
    tmp = cp;
#line 139
    cp ++;
#line 139
    c = (char )*tmp;
#line 140
    if ((int )c == 37) {
#line 142
      arg_index = ~ ((size_t )0);
#line 143
      dp = d->dir + d->count;
#line 146
      dp->dir_start = cp - 1;
#line 147
      dp->flags = 0;
#line 148
      dp->width_start = (char const   *)((void *)0);
#line 149
      dp->width_end = (char const   *)((void *)0);
#line 150
      dp->width_arg_index = ~ ((size_t )0);
#line 151
      dp->precision_start = (char const   *)((void *)0);
#line 152
      dp->precision_end = (char const   *)((void *)0);
#line 153
      dp->precision_arg_index = ~ ((size_t )0);
#line 154
      dp->arg_index = ~ ((size_t )0);
#line 157
      if ((int const   )*cp >= 48) {
#line 157
        if ((int const   )*cp <= 57) {
#line 161
          np = cp;
#line 161
          while (1) {
#line 161
            if ((int const   )*np >= 48) {
#line 161
              if (! ((int const   )*np <= 57)) {
#line 161
                break;
              }
            } else {
#line 161
              break;
            }
#line 161
            np ++;
          }
#line 163
          if ((int const   )*np == 36) {
#line 165
            n = (size_t )0;
#line 167
            np = cp;
#line 167
            while (1) {
#line 167
              if ((int const   )*np >= 48) {
#line 167
                if (! ((int const   )*np <= 57)) {
#line 167
                  break;
                }
              } else {
#line 167
                break;
              }
#line 168
              if (n <= 1844674407370955161UL) {
#line 168
                tmp___0 = n * 10UL;
              } else {
#line 168
                tmp___0 = 0xffffffffffffffffUL;
              }
#line 168
              tmp___1 = xsum(tmp___0, (size_t )((int const   )*np - 48));
#line 168
              n = (size_t )tmp___1;
#line 167
              np ++;
            }
#line 169
            if (n == 0UL) {
#line 171
              goto error;
            }
#line 172
            if (n == 0xffffffffffffffffUL) {
#line 174
              goto error;
            }
#line 175
            arg_index = n - 1UL;
#line 176
            cp = np + 1;
          }
        }
      }
#line 181
      while (1) {
#line 183
        if ((int const   )*cp == 39) {
#line 185
          dp->flags |= 1;
#line 186
          cp ++;
        } else
#line 188
        if ((int const   )*cp == 45) {
#line 190
          dp->flags |= 2;
#line 191
          cp ++;
        } else
#line 193
        if ((int const   )*cp == 43) {
#line 195
          dp->flags |= 4;
#line 196
          cp ++;
        } else
#line 198
        if ((int const   )*cp == 32) {
#line 200
          dp->flags |= 8;
#line 201
          cp ++;
        } else
#line 203
        if ((int const   )*cp == 35) {
#line 205
          dp->flags |= 16;
#line 206
          cp ++;
        } else
#line 208
        if ((int const   )*cp == 48) {
#line 210
          dp->flags |= 32;
#line 211
          cp ++;
        } else
#line 214
        if ((int const   )*cp == 73) {
#line 216
          dp->flags |= 64;
#line 217
          cp ++;
        } else {
#line 221
          break;
        }
      }
#line 225
      if ((int const   )*cp == 42) {
#line 227
        dp->width_start = cp;
#line 228
        cp ++;
#line 229
        dp->width_end = cp;
#line 230
        if (max_width_length < 1UL) {
#line 231
          max_width_length = (size_t )1;
        }
#line 234
        if ((int const   )*cp >= 48) {
#line 234
          if ((int const   )*cp <= 57) {
#line 238
            np___0 = cp;
#line 238
            while (1) {
#line 238
              if ((int const   )*np___0 >= 48) {
#line 238
                if (! ((int const   )*np___0 <= 57)) {
#line 238
                  break;
                }
              } else {
#line 238
                break;
              }
#line 238
              np___0 ++;
            }
#line 240
            if ((int const   )*np___0 == 36) {
#line 242
              n___0 = (size_t )0;
#line 244
              np___0 = cp;
#line 244
              while (1) {
#line 244
                if ((int const   )*np___0 >= 48) {
#line 244
                  if (! ((int const   )*np___0 <= 57)) {
#line 244
                    break;
                  }
                } else {
#line 244
                  break;
                }
#line 245
                if (n___0 <= 1844674407370955161UL) {
#line 245
                  tmp___2 = n___0 * 10UL;
                } else {
#line 245
                  tmp___2 = 0xffffffffffffffffUL;
                }
#line 245
                tmp___3 = xsum(tmp___2, (size_t )((int const   )*np___0 - 48));
#line 245
                n___0 = (size_t )tmp___3;
#line 244
                np___0 ++;
              }
#line 246
              if (n___0 == 0UL) {
#line 248
                goto error;
              }
#line 249
              if (n___0 == 0xffffffffffffffffUL) {
#line 251
                goto error;
              }
#line 252
              dp->width_arg_index = n___0 - 1UL;
#line 253
              cp = np___0 + 1;
            }
          }
        }
#line 256
        if (dp->width_arg_index == 0xffffffffffffffffUL) {
#line 258
          tmp___4 = arg_posn;
#line 258
          arg_posn ++;
#line 258
          dp->width_arg_index = tmp___4;
#line 259
          if (dp->width_arg_index == 0xffffffffffffffffUL) {
#line 261
            goto error;
          }
        }
#line 263
        n___1 = dp->width_arg_index;
#line 263
        if (n___1 >= a_allocated) {
#line 263
          if (a_allocated <= 9223372036854775807UL) {
#line 263
            a_allocated *= 2UL;
          } else {
#line 263
            a_allocated = 0xffffffffffffffffUL;
          }
#line 263
          if (a_allocated <= n___1) {
#line 263
            tmp___5 = xsum(n___1, (size_t )1);
#line 263
            a_allocated = (size_t )tmp___5;
          }
#line 263
          if (a_allocated <= 0xffffffffffffffffUL / sizeof(argument )) {
#line 263
            memory_size = a_allocated * sizeof(argument );
          } else {
#line 263
            memory_size = 0xffffffffffffffffUL;
          }
#line 263
          if (memory_size == 0xffffffffffffffffUL) {
#line 263
            goto out_of_memory;
          }
#line 263
          if ((unsigned long )a->arg != (unsigned long )(a->direct_alloc_arg)) {
#line 263
            tmp___6 = realloc((void *)a->arg, memory_size);
#line 263
            tmp___8 = tmp___6;
          } else {
#line 263
            tmp___7 = malloc(memory_size);
#line 263
            tmp___8 = tmp___7;
          }
#line 263
          memory = (argument *)tmp___8;
#line 263
          if ((unsigned long )memory == (unsigned long )((void *)0)) {
#line 263
            goto out_of_memory;
          }
#line 263
          if ((unsigned long )a->arg == (unsigned long )(a->direct_alloc_arg)) {
#line 263
            memcpy((void * __restrict  )memory, (void const   * __restrict  )a->arg,
                   a->count * sizeof(argument ));
          }
#line 263
          a->arg = memory;
        }
#line 263
        while (a->count <= n___1) {
#line 263
          tmp___9 = a->count;
#line 263
          (a->count) ++;
#line 263
          (a->arg + tmp___9)->type = (arg_type )0;
        }
#line 263
        if ((unsigned int )(a->arg + n___1)->type == 0U) {
#line 263
          (a->arg + n___1)->type = (arg_type )5;
        } else
#line 263
        if ((unsigned int )(a->arg + n___1)->type != 5U) {
#line 263
          goto error;
        }
      } else
#line 265
      if ((int const   )*cp >= 48) {
#line 265
        if ((int const   )*cp <= 57) {
#line 269
          dp->width_start = cp;
#line 270
          while (1) {
#line 270
            if ((int const   )*cp >= 48) {
#line 270
              if (! ((int const   )*cp <= 57)) {
#line 270
                break;
              }
            } else {
#line 270
              break;
            }
#line 270
            cp ++;
          }
#line 272
          dp->width_end = cp;
#line 273
          width_length = (size_t )(dp->width_end - dp->width_start);
#line 274
          if (max_width_length < width_length) {
#line 275
            max_width_length = width_length;
          }
        }
      }
#line 279
      if ((int const   )*cp == 46) {
#line 281
        cp ++;
#line 282
        if ((int const   )*cp == 42) {
#line 284
          dp->precision_start = cp - 1;
#line 285
          cp ++;
#line 286
          dp->precision_end = cp;
#line 287
          if (max_precision_length < 2UL) {
#line 288
            max_precision_length = (size_t )2;
          }
#line 291
          if ((int const   )*cp >= 48) {
#line 291
            if ((int const   )*cp <= 57) {
#line 295
              np___1 = cp;
#line 295
              while (1) {
#line 295
                if ((int const   )*np___1 >= 48) {
#line 295
                  if (! ((int const   )*np___1 <= 57)) {
#line 295
                    break;
                  }
                } else {
#line 295
                  break;
                }
#line 295
                np___1 ++;
              }
#line 297
              if ((int const   )*np___1 == 36) {
#line 299
                n___2 = (size_t )0;
#line 301
                np___1 = cp;
#line 301
                while (1) {
#line 301
                  if ((int const   )*np___1 >= 48) {
#line 301
                    if (! ((int const   )*np___1 <= 57)) {
#line 301
                      break;
                    }
                  } else {
#line 301
                    break;
                  }
#line 302
                  if (n___2 <= 1844674407370955161UL) {
#line 302
                    tmp___10 = n___2 * 10UL;
                  } else {
#line 302
                    tmp___10 = 0xffffffffffffffffUL;
                  }
#line 302
                  tmp___11 = xsum(tmp___10, (size_t )((int const   )*np___1 - 48));
#line 302
                  n___2 = (size_t )tmp___11;
#line 301
                  np___1 ++;
                }
#line 303
                if (n___2 == 0UL) {
#line 305
                  goto error;
                }
#line 306
                if (n___2 == 0xffffffffffffffffUL) {
#line 309
                  goto error;
                }
#line 310
                dp->precision_arg_index = n___2 - 1UL;
#line 311
                cp = np___1 + 1;
              }
            }
          }
#line 314
          if (dp->precision_arg_index == 0xffffffffffffffffUL) {
#line 316
            tmp___12 = arg_posn;
#line 316
            arg_posn ++;
#line 316
            dp->precision_arg_index = tmp___12;
#line 317
            if (dp->precision_arg_index == 0xffffffffffffffffUL) {
#line 319
              goto error;
            }
          }
#line 321
          n___3 = dp->precision_arg_index;
#line 321
          if (n___3 >= a_allocated) {
#line 321
            if (a_allocated <= 9223372036854775807UL) {
#line 321
              a_allocated *= 2UL;
            } else {
#line 321
              a_allocated = 0xffffffffffffffffUL;
            }
#line 321
            if (a_allocated <= n___3) {
#line 321
              tmp___13 = xsum(n___3, (size_t )1);
#line 321
              a_allocated = (size_t )tmp___13;
            }
#line 321
            if (a_allocated <= 0xffffffffffffffffUL / sizeof(argument )) {
#line 321
              memory_size___0 = a_allocated * sizeof(argument );
            } else {
#line 321
              memory_size___0 = 0xffffffffffffffffUL;
            }
#line 321
            if (memory_size___0 == 0xffffffffffffffffUL) {
#line 321
              goto out_of_memory;
            }
#line 321
            if ((unsigned long )a->arg != (unsigned long )(a->direct_alloc_arg)) {
#line 321
              tmp___14 = realloc((void *)a->arg, memory_size___0);
#line 321
              tmp___16 = tmp___14;
            } else {
#line 321
              tmp___15 = malloc(memory_size___0);
#line 321
              tmp___16 = tmp___15;
            }
#line 321
            memory___0 = (argument *)tmp___16;
#line 321
            if ((unsigned long )memory___0 == (unsigned long )((void *)0)) {
#line 321
              goto out_of_memory;
            }
#line 321
            if ((unsigned long )a->arg == (unsigned long )(a->direct_alloc_arg)) {
#line 321
              memcpy((void * __restrict  )memory___0, (void const   * __restrict  )a->arg,
                     a->count * sizeof(argument ));
            }
#line 321
            a->arg = memory___0;
          }
#line 321
          while (a->count <= n___3) {
#line 321
            tmp___17 = a->count;
#line 321
            (a->count) ++;
#line 321
            (a->arg + tmp___17)->type = (arg_type )0;
          }
#line 321
          if ((unsigned int )(a->arg + n___3)->type == 0U) {
#line 321
            (a->arg + n___3)->type = (arg_type )5;
          } else
#line 321
          if ((unsigned int )(a->arg + n___3)->type != 5U) {
#line 321
            goto error;
          }
        } else {
#line 327
          dp->precision_start = cp - 1;
#line 328
          while (1) {
#line 328
            if ((int const   )*cp >= 48) {
#line 328
              if (! ((int const   )*cp <= 57)) {
#line 328
                break;
              }
            } else {
#line 328
              break;
            }
#line 328
            cp ++;
          }
#line 330
          dp->precision_end = cp;
#line 331
          precision_length = (size_t )(dp->precision_end - dp->precision_start);
#line 332
          if (max_precision_length < precision_length) {
#line 333
            max_precision_length = precision_length;
          }
        }
      }
#line 342
      flags = 0;
#line 344
      while (1) {
#line 346
        if ((int const   )*cp == 104) {
#line 348
          flags |= 1 << (flags & 1);
#line 349
          cp ++;
        } else
#line 351
        if ((int const   )*cp == 76) {
#line 353
          flags |= 4;
#line 354
          cp ++;
        } else
#line 356
        if ((int const   )*cp == 108) {
#line 358
          flags += 8;
#line 359
          cp ++;
        } else
#line 361
        if ((int const   )*cp == 106) {
#line 363
          if (sizeof(intmax_t ) > sizeof(long )) {
#line 366
            flags += 16;
          } else
#line 368
          if (sizeof(intmax_t ) > sizeof(int )) {
#line 371
            flags += 8;
          }
#line 373
          cp ++;
        } else
#line 375
        if ((int const   )*cp == 122) {
#line 375
          goto _L;
        } else
#line 375
        if ((int const   )*cp == 90) {
          _L: 
#line 380
          if (sizeof(size_t ) > sizeof(long )) {
#line 383
            flags += 16;
          } else
#line 385
          if (sizeof(size_t ) > sizeof(int )) {
#line 388
            flags += 8;
          }
#line 390
          cp ++;
        } else
#line 392
        if ((int const   )*cp == 116) {
#line 394
          if (sizeof(ptrdiff_t ) > sizeof(long )) {
#line 397
            flags += 16;
          } else
#line 399
          if (sizeof(ptrdiff_t ) > sizeof(int )) {
#line 402
            flags += 8;
          }
#line 404
          cp ++;
        } else {
#line 445
          break;
        }
      }
#line 449
      tmp___18 = cp;
#line 449
      cp ++;
#line 449
      c = (char )*tmp___18;
#line 450
      switch ((int )c) {
      case 100: 
      case 105: 
#line 455
      if (flags >= 16) {
#line 456
        type = (arg_type )9;
      } else
#line 455
      if (flags & 4) {
#line 456
        type = (arg_type )9;
      } else
#line 461
      if (flags >= 8) {
#line 462
        type = (arg_type )7;
      } else
#line 463
      if (flags & 2) {
#line 464
        type = (arg_type )1;
      } else
#line 465
      if (flags & 1) {
#line 466
        type = (arg_type )3;
      } else {
#line 468
        type = (arg_type )5;
      }
#line 469
      break;
      case 111: 
      case 117: 
      case 120: 
      case 88: 
#line 473
      if (flags >= 16) {
#line 474
        type = (arg_type )10;
      } else
#line 473
      if (flags & 4) {
#line 474
        type = (arg_type )10;
      } else
#line 479
      if (flags >= 8) {
#line 480
        type = (arg_type )8;
      } else
#line 481
      if (flags & 2) {
#line 482
        type = (arg_type )2;
      } else
#line 483
      if (flags & 1) {
#line 484
        type = (arg_type )4;
      } else {
#line 486
        type = (arg_type )6;
      }
#line 487
      break;
      case 102: 
      case 70: 
      case 101: 
      case 69: 
      case 103: 
      case 71: 
      case 97: 
      case 65: 
#line 490
      if (flags >= 16) {
#line 491
        type = (arg_type )12;
      } else
#line 490
      if (flags & 4) {
#line 491
        type = (arg_type )12;
      } else {
#line 493
        type = (arg_type )11;
      }
#line 494
      break;
      case 99: 
#line 496
      if (flags >= 8) {
#line 498
        type = (arg_type )14;
      } else {
#line 503
        type = (arg_type )13;
      }
#line 504
      break;
      case 67: 
#line 507
      type = (arg_type )14;
#line 508
      c = (char )'c';
#line 509
      break;
      case 115: 
#line 512
      if (flags >= 8) {
#line 514
        type = (arg_type )16;
      } else {
#line 519
        type = (arg_type )15;
      }
#line 520
      break;
      case 83: 
#line 523
      type = (arg_type )16;
#line 524
      c = (char )'s';
#line 525
      break;
      case 112: 
#line 528
      type = (arg_type )17;
#line 529
      break;
      case 110: 
#line 533
      if (flags >= 16) {
#line 534
        type = (arg_type )22;
      } else
#line 533
      if (flags & 4) {
#line 534
        type = (arg_type )22;
      } else
#line 539
      if (flags >= 8) {
#line 540
        type = (arg_type )21;
      } else
#line 541
      if (flags & 2) {
#line 542
        type = (arg_type )18;
      } else
#line 543
      if (flags & 1) {
#line 544
        type = (arg_type )19;
      } else {
#line 546
        type = (arg_type )20;
      }
#line 547
      break;
      case 37: 
#line 560
      type = (arg_type )0;
#line 561
      break;
      default: 
#line 564
      goto error;
      }
#line 568
      if ((unsigned int )type != 0U) {
#line 570
        dp->arg_index = arg_index;
#line 571
        if (dp->arg_index == 0xffffffffffffffffUL) {
#line 573
          tmp___19 = arg_posn;
#line 573
          arg_posn ++;
#line 573
          dp->arg_index = tmp___19;
#line 574
          if (dp->arg_index == 0xffffffffffffffffUL) {
#line 576
            goto error;
          }
        }
#line 578
        n___4 = dp->arg_index;
#line 578
        if (n___4 >= a_allocated) {
#line 578
          if (a_allocated <= 9223372036854775807UL) {
#line 578
            a_allocated *= 2UL;
          } else {
#line 578
            a_allocated = 0xffffffffffffffffUL;
          }
#line 578
          if (a_allocated <= n___4) {
#line 578
            tmp___20 = xsum(n___4, (size_t )1);
#line 578
            a_allocated = (size_t )tmp___20;
          }
#line 578
          if (a_allocated <= 0xffffffffffffffffUL / sizeof(argument )) {
#line 578
            memory_size___1 = a_allocated * sizeof(argument );
          } else {
#line 578
            memory_size___1 = 0xffffffffffffffffUL;
          }
#line 578
          if (memory_size___1 == 0xffffffffffffffffUL) {
#line 578
            goto out_of_memory;
          }
#line 578
          if ((unsigned long )a->arg != (unsigned long )(a->direct_alloc_arg)) {
#line 578
            tmp___21 = realloc((void *)a->arg, memory_size___1);
#line 578
            tmp___23 = tmp___21;
          } else {
#line 578
            tmp___22 = malloc(memory_size___1);
#line 578
            tmp___23 = tmp___22;
          }
#line 578
          memory___1 = (argument *)tmp___23;
#line 578
          if ((unsigned long )memory___1 == (unsigned long )((void *)0)) {
#line 578
            goto out_of_memory;
          }
#line 578
          if ((unsigned long )a->arg == (unsigned long )(a->direct_alloc_arg)) {
#line 578
            memcpy((void * __restrict  )memory___1, (void const   * __restrict  )a->arg,
                   a->count * sizeof(argument ));
          }
#line 578
          a->arg = memory___1;
        }
#line 578
        while (a->count <= n___4) {
#line 578
          tmp___24 = a->count;
#line 578
          (a->count) ++;
#line 578
          (a->arg + tmp___24)->type = (arg_type )0;
        }
#line 578
        if ((unsigned int )(a->arg + n___4)->type == 0U) {
#line 578
          (a->arg + n___4)->type = type;
        } else
#line 578
        if ((unsigned int )(a->arg + n___4)->type != (unsigned int )type) {
#line 578
          goto error;
        }
      }
#line 580
      dp->conversion = c;
#line 581
      dp->dir_end = cp;
#line 584
      (d->count) ++;
#line 585
      if (d->count >= d_allocated) {
#line 590
        if (d_allocated <= 9223372036854775807UL) {
#line 590
          d_allocated *= 2UL;
        } else {
#line 590
          d_allocated = 0xffffffffffffffffUL;
        }
#line 591
        if (d_allocated <= 0xffffffffffffffffUL / sizeof(char_directive )) {
#line 591
          memory_size___2 = d_allocated * sizeof(char_directive );
        } else {
#line 591
          memory_size___2 = 0xffffffffffffffffUL;
        }
#line 592
        if (memory_size___2 == 0xffffffffffffffffUL) {
#line 594
          goto out_of_memory;
        }
#line 595
        if ((unsigned long )d->dir != (unsigned long )(d->direct_alloc_dir)) {
#line 595
          tmp___25 = realloc((void *)d->dir, memory_size___2);
#line 595
          tmp___27 = tmp___25;
        } else {
#line 595
          tmp___26 = malloc(memory_size___2);
#line 595
          tmp___27 = tmp___26;
        }
#line 595
        memory___2 = (char_directive *)tmp___27;
#line 598
        if ((unsigned long )memory___2 == (unsigned long )((void *)0)) {
#line 600
          goto out_of_memory;
        }
#line 601
        if ((unsigned long )d->dir == (unsigned long )(d->direct_alloc_dir)) {
#line 602
          memcpy((void * __restrict  )memory___2, (void const   * __restrict  )d->dir,
                 d->count * sizeof(char_directive ));
        }
#line 603
        d->dir = memory___2;
      }
    }
  }
#line 614
  (d->dir + d->count)->dir_start = cp;
#line 616
  d->max_width_length = max_width_length;
#line 617
  d->max_precision_length = max_precision_length;
#line 618
  return (0);
  error: 
#line 621
  if ((unsigned long )a->arg != (unsigned long )(a->direct_alloc_arg)) {
#line 622
    free((void *)a->arg);
  }
#line 623
  if ((unsigned long )d->dir != (unsigned long )(d->direct_alloc_dir)) {
#line 624
    free((void *)d->dir);
  }
#line 625
  tmp___28 = __errno_location();
#line 625
  *tmp___28 = 22;
#line 626
  return (-1);
  out_of_memory: 
#line 629
  if ((unsigned long )a->arg != (unsigned long )(a->direct_alloc_arg)) {
#line 630
    free((void *)a->arg);
  }
#line 631
  if ((unsigned long )d->dir != (unsigned long )(d->direct_alloc_dir)) {
#line 632
    free((void *)d->dir);
  }
#line 633
  tmp___29 = __errno_location();
#line 633
  *tmp___29 = 12;
#line 634
  return (-1);
}
}
#line 1 "readutmp.o"
#pragma merger(0,"/tmp/cil-yaBcltoY.i","-g,-O2")
#line 54 "/usr/include/utmpx.h"
extern void setutxent(void) ;
#line 60
extern void endutxent(void) ;
#line 66
extern struct utmpx *getutxent(void) ;
#line 94
extern int utmpxname(char const   *__file ) ;
#line 212 "readutmp.h"
char *extract_trimmed_name(STRUCT_UTMP const   *ut ) ;
#line 213
int read_utmp(char const   *file , size_t *n_entries , STRUCT_UTMP **utmp_buf , int options ) ;
#line 126 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
#line 44 "readutmp.c"
char *extract_trimmed_name(STRUCT_UTMP const   *ut ) 
{ char *p ;
  char *trimmed_name ;
  void *tmp ;
  size_t tmp___0 ;

  {
#line 49
  tmp = xmalloc(sizeof(ut->ut_user) + 1UL);
#line 49
  trimmed_name = (char *)tmp;
#line 50
  strncpy((char * __restrict  )trimmed_name, (char const   * __restrict  )(ut->ut_user),
          sizeof(ut->ut_user));
#line 54
  *(trimmed_name + sizeof(ut->ut_user)) = (char )'\000';
#line 55
  tmp___0 = strlen((char const   *)trimmed_name);
#line 55
  p = trimmed_name + tmp___0;
#line 55
  while (1) {
#line 55
    if ((unsigned long )trimmed_name < (unsigned long )p) {
#line 55
      if (! ((int )*(p + -1) == 32)) {
#line 55
        break;
      }
    } else {
#line 55
      break;
    }
#line 58
    goto __Cont;
    __Cont: 
#line 55
    p --;
#line 55
    *p = (char )'\000';
  }
#line 59
  return (trimmed_name);
}
}
#line 64 "readutmp.c"
__inline static _Bool desirable_utmp_entry(STRUCT_UTMP const   *u , int options ) 
{ _Bool user_proc ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;

  {
#line 67
  if (u->ut_user[0]) {
#line 67
    if ((int const   )u->ut_type == 7) {
#line 67
      tmp = 1;
    } else {
#line 67
      tmp = 0;
    }
  } else {
#line 67
    tmp = 0;
  }
#line 67
  user_proc = (_Bool )tmp;
#line 68
  if (options & 2) {
#line 68
    if (! user_proc) {
#line 69
      return ((_Bool)0);
    }
  }
#line 70
  if (options & 1) {
#line 70
    if (user_proc) {
#line 70
      if (u->ut_pid <= 0) {
#line 74
        return ((_Bool)0);
      } else {
#line 70
        tmp___0 = kill((__pid_t )u->ut_pid, 0);
#line 70
        if (tmp___0 < 0) {
#line 70
          tmp___1 = __errno_location();
#line 70
          if (*tmp___1 == 3) {
#line 74
            return ((_Bool)0);
          }
        }
      }
    }
  }
#line 75
  return ((_Bool)1);
}
}
#line 87 "readutmp.c"
int read_utmp(char const   *file , size_t *n_entries , STRUCT_UTMP **utmp_buf , int options ) 
{ size_t n_read ;
  size_t n_alloc ;
  STRUCT_UTMP *utmp ;
  STRUCT_UTMP *u ;
  void *tmp ;
  size_t tmp___0 ;
  _Bool tmp___1 ;

  {
#line 91
  n_read = (size_t )0;
#line 92
  n_alloc = (size_t )0;
#line 93
  utmp = (STRUCT_UTMP *)((void *)0);
#line 100
  utmpxname(file);
#line 102
  setutxent();
#line 104
  while (1) {
#line 104
    u = getutxent();
#line 104
    if (! ((unsigned long )u != (unsigned long )((void *)0))) {
#line 104
      break;
    }
#line 105
    tmp___1 = desirable_utmp_entry((STRUCT_UTMP const   *)u, options);
#line 105
    if (tmp___1) {
#line 107
      if (n_read == n_alloc) {
#line 108
        tmp = x2nrealloc((void *)utmp, & n_alloc, sizeof(*utmp));
#line 108
        utmp = (STRUCT_UTMP *)tmp;
      }
#line 110
      tmp___0 = n_read;
#line 110
      n_read ++;
#line 110
      *(utmp + tmp___0) = *u;
    }
  }
#line 113
  endutxent();
#line 115
  *n_entries = n_read;
#line 116
  *utmp_buf = utmp;
#line 118
  return (0);
}
}
#line 1 "remove.o"
#pragma merger(0,"/tmp/cil-ildXE4Yg.i","-g,-O2")
#line 1225 "./stdio.h"
int rpl_remove(char const   *name )  __attribute__((__nonnull__(1))) ;
#line 845 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int unlink(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 854
extern  __attribute__((__nothrow__)) int rmdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 31 "remove.c"
int rpl_remove(char const   *name )  __attribute__((__nonnull__(1))) ;
#line 31 "remove.c"
int rpl_remove(char const   *name ) 
{ int result ;
  int tmp ;
  int *tmp___0 ;

  {
#line 39
  tmp = rmdir(name);
#line 39
  result = tmp;
#line 40
  if (result) {
#line 40
    tmp___0 = __errno_location();
#line 40
    if (*tmp___0 == 20) {
#line 41
      result = unlink(name);
    }
  }
#line 42
  return (result);
}
}
#line 1 "root-dev-ino.o"
#pragma merger(0,"/tmp/cil-ypOvCriv.i","-g,-O2")
#line 24 "root-dev-ino.h"
struct dev_ino *get_root_dev_ino(struct dev_ino *root_d_i ) ;
#line 28 "root-dev-ino.c"
struct dev_ino *get_root_dev_ino(struct dev_ino *root_d_i ) 
{ struct stat statbuf ;
  int tmp ;

  {
#line 32
  tmp = lstat((char const   * __restrict  )"/", (struct stat * __restrict  )(& statbuf));
#line 32
  if (tmp) {
#line 33
    return ((struct dev_ino *)((void *)0));
  }
#line 34
  root_d_i->st_ino = statbuf.st_ino;
#line 35
  root_d_i->st_dev = statbuf.st_dev;
#line 36
  return (root_d_i);
}
}
#line 1 "selinux-at.o"
#pragma merger(0,"/tmp/cil-RFDffaud.i","-g,-O2")
#line 76 "./selinux/selinux.h"
__inline static int getfilecon(char const   *file  __attribute__((__unused__)) , char **con  __attribute__((__unused__)) ) 
{ int *tmp ;

  {
#line 78
  tmp = __errno_location();
#line 78
  *tmp = 95;
#line 78
  return (-1);
}
}
#line 85 "./selinux/selinux.h"
__inline static int setfilecon(char const   *file  __attribute__((__unused__)) , char *con  __attribute__((__unused__)) ) 
{ int *tmp ;

  {
#line 87
  tmp = __errno_location();
#line 87
  *tmp = 95;
#line 87
  return (-1);
}
}
#line 34 "selinux-at.h"
int getfileconat(int fd , char const   *file , char **con ) ;
#line 39
int lgetfileconat(int fd , char const   *file , char **con ) ;
#line 45
int setfileconat(int fd , char const   *file , char *con ) ;
#line 52
int lsetfileconat(int fd , char const   *file , char *con ) ;
#line 61 "at-func.c"
int getfileconat(int fd , char const   *file , char **con ) 
{ struct saved_cwd saved_cwd ;
  int saved_errno ;
  int err ;
  int tmp ;
  char proc_buf[4032] ;
  char *proc_file ;
  char *tmp___0 ;
  int proc_result ;
  int tmp___1 ;
  int proc_errno ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;

  {
#line 72
  if (fd == -100) {
#line 73
    tmp = getfilecon(file, con);
#line 73
    return (tmp);
  } else
#line 72
  if ((int const   )*(file + 0) == 47) {
#line 73
    tmp = getfilecon(file, con);
#line 73
    return (tmp);
  }
#line 77
  tmp___0 = openat_proc_name(proc_buf, fd, file);
#line 77
  proc_file = tmp___0;
#line 78
  if (proc_file) {
#line 80
    tmp___1 = getfilecon((char const   *)proc_file, con);
#line 80
    proc_result = tmp___1;
#line 81
    tmp___2 = __errno_location();
#line 81
    proc_errno = *tmp___2;
#line 82
    if ((unsigned long )proc_file != (unsigned long )(proc_buf)) {
#line 83
      free((void *)proc_file);
    }
#line 87
    if (-1 != proc_result) {
#line 88
      return (proc_result);
    }
#line 89
    if (! (proc_errno == 20)) {
#line 89
      if (! (proc_errno == 2)) {
#line 89
        if (! (proc_errno == 1)) {
#line 89
          if (! (proc_errno == 13)) {
#line 89
            if (! (proc_errno == 38)) {
#line 89
              if (! (proc_errno == 95)) {
#line 91
                tmp___3 = __errno_location();
#line 91
                *tmp___3 = proc_errno;
#line 92
                return (proc_result);
              }
            }
          }
        }
      }
    }
  }
#line 97
  tmp___5 = save_cwd(& saved_cwd);
#line 97
  if (tmp___5 != 0) {
#line 98
    tmp___4 = __errno_location();
#line 98
    openat_save_fail(*tmp___4);
  }
#line 99
  if (0 <= fd) {
#line 99
    if (fd == saved_cwd.desc) {
#line 104
      free_cwd(& saved_cwd);
#line 105
      tmp___6 = __errno_location();
#line 105
      *tmp___6 = 9;
#line 106
      return (-1);
    }
  }
#line 109
  tmp___9 = fchdir(fd);
#line 109
  if (tmp___9 != 0) {
#line 111
    tmp___7 = __errno_location();
#line 111
    saved_errno = *tmp___7;
#line 112
    free_cwd(& saved_cwd);
#line 113
    tmp___8 = __errno_location();
#line 113
    *tmp___8 = saved_errno;
#line 114
    return (-1);
  }
#line 117
  err = getfilecon(file, con);
#line 118
  if (err == -1) {
#line 118
    tmp___10 = __errno_location();
#line 118
    saved_errno = *tmp___10;
  } else {
#line 118
    saved_errno = 0;
  }
#line 120
  tmp___12 = restore_cwd((struct saved_cwd  const  *)(& saved_cwd));
#line 120
  if (tmp___12 != 0) {
#line 121
    tmp___11 = __errno_location();
#line 121
    openat_restore_fail(*tmp___11);
  }
#line 123
  free_cwd(& saved_cwd);
#line 125
  if (saved_errno) {
#line 126
    tmp___13 = __errno_location();
#line 126
    *tmp___13 = saved_errno;
  }
#line 127
  return (err);
}
}
#line 61 "at-func.c"
int lgetfileconat(int fd , char const   *file , char **con ) 
{ struct saved_cwd saved_cwd ;
  int saved_errno ;
  int err ;
  int tmp ;
  char proc_buf[4032] ;
  char *proc_file ;
  char *tmp___0 ;
  int proc_result ;
  int tmp___1 ;
  int proc_errno ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;

  {
#line 72
  if (fd == -100) {
#line 73
    tmp = getfilecon(file, con);
#line 73
    return (tmp);
  } else
#line 72
  if ((int const   )*(file + 0) == 47) {
#line 73
    tmp = getfilecon(file, con);
#line 73
    return (tmp);
  }
#line 77
  tmp___0 = openat_proc_name(proc_buf, fd, file);
#line 77
  proc_file = tmp___0;
#line 78
  if (proc_file) {
#line 80
    tmp___1 = getfilecon((char const   *)proc_file, con);
#line 80
    proc_result = tmp___1;
#line 81
    tmp___2 = __errno_location();
#line 81
    proc_errno = *tmp___2;
#line 82
    if ((unsigned long )proc_file != (unsigned long )(proc_buf)) {
#line 83
      free((void *)proc_file);
    }
#line 87
    if (-1 != proc_result) {
#line 88
      return (proc_result);
    }
#line 89
    if (! (proc_errno == 20)) {
#line 89
      if (! (proc_errno == 2)) {
#line 89
        if (! (proc_errno == 1)) {
#line 89
          if (! (proc_errno == 13)) {
#line 89
            if (! (proc_errno == 38)) {
#line 89
              if (! (proc_errno == 95)) {
#line 91
                tmp___3 = __errno_location();
#line 91
                *tmp___3 = proc_errno;
#line 92
                return (proc_result);
              }
            }
          }
        }
      }
    }
  }
#line 97
  tmp___5 = save_cwd(& saved_cwd);
#line 97
  if (tmp___5 != 0) {
#line 98
    tmp___4 = __errno_location();
#line 98
    openat_save_fail(*tmp___4);
  }
#line 99
  if (0 <= fd) {
#line 99
    if (fd == saved_cwd.desc) {
#line 104
      free_cwd(& saved_cwd);
#line 105
      tmp___6 = __errno_location();
#line 105
      *tmp___6 = 9;
#line 106
      return (-1);
    }
  }
#line 109
  tmp___9 = fchdir(fd);
#line 109
  if (tmp___9 != 0) {
#line 111
    tmp___7 = __errno_location();
#line 111
    saved_errno = *tmp___7;
#line 112
    free_cwd(& saved_cwd);
#line 113
    tmp___8 = __errno_location();
#line 113
    *tmp___8 = saved_errno;
#line 114
    return (-1);
  }
#line 117
  err = getfilecon(file, con);
#line 118
  if (err == -1) {
#line 118
    tmp___10 = __errno_location();
#line 118
    saved_errno = *tmp___10;
  } else {
#line 118
    saved_errno = 0;
  }
#line 120
  tmp___12 = restore_cwd((struct saved_cwd  const  *)(& saved_cwd));
#line 120
  if (tmp___12 != 0) {
#line 121
    tmp___11 = __errno_location();
#line 121
    openat_restore_fail(*tmp___11);
  }
#line 123
  free_cwd(& saved_cwd);
#line 125
  if (saved_errno) {
#line 126
    tmp___13 = __errno_location();
#line 126
    *tmp___13 = saved_errno;
  }
#line 127
  return (err);
}
}
#line 61 "at-func.c"
int setfileconat(int fd , char const   *file , char *con ) 
{ struct saved_cwd saved_cwd ;
  int saved_errno ;
  int err ;
  int tmp ;
  char proc_buf[4032] ;
  char *proc_file ;
  char *tmp___0 ;
  int proc_result ;
  int tmp___1 ;
  int proc_errno ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;

  {
#line 72
  if (fd == -100) {
#line 73
    tmp = setfilecon(file, con);
#line 73
    return (tmp);
  } else
#line 72
  if ((int const   )*(file + 0) == 47) {
#line 73
    tmp = setfilecon(file, con);
#line 73
    return (tmp);
  }
#line 77
  tmp___0 = openat_proc_name(proc_buf, fd, file);
#line 77
  proc_file = tmp___0;
#line 78
  if (proc_file) {
#line 80
    tmp___1 = setfilecon((char const   *)proc_file, con);
#line 80
    proc_result = tmp___1;
#line 81
    tmp___2 = __errno_location();
#line 81
    proc_errno = *tmp___2;
#line 82
    if ((unsigned long )proc_file != (unsigned long )(proc_buf)) {
#line 83
      free((void *)proc_file);
    }
#line 87
    if (-1 != proc_result) {
#line 88
      return (proc_result);
    }
#line 89
    if (! (proc_errno == 20)) {
#line 89
      if (! (proc_errno == 2)) {
#line 89
        if (! (proc_errno == 1)) {
#line 89
          if (! (proc_errno == 13)) {
#line 89
            if (! (proc_errno == 38)) {
#line 89
              if (! (proc_errno == 95)) {
#line 91
                tmp___3 = __errno_location();
#line 91
                *tmp___3 = proc_errno;
#line 92
                return (proc_result);
              }
            }
          }
        }
      }
    }
  }
#line 97
  tmp___5 = save_cwd(& saved_cwd);
#line 97
  if (tmp___5 != 0) {
#line 98
    tmp___4 = __errno_location();
#line 98
    openat_save_fail(*tmp___4);
  }
#line 99
  if (0 <= fd) {
#line 99
    if (fd == saved_cwd.desc) {
#line 104
      free_cwd(& saved_cwd);
#line 105
      tmp___6 = __errno_location();
#line 105
      *tmp___6 = 9;
#line 106
      return (-1);
    }
  }
#line 109
  tmp___9 = fchdir(fd);
#line 109
  if (tmp___9 != 0) {
#line 111
    tmp___7 = __errno_location();
#line 111
    saved_errno = *tmp___7;
#line 112
    free_cwd(& saved_cwd);
#line 113
    tmp___8 = __errno_location();
#line 113
    *tmp___8 = saved_errno;
#line 114
    return (-1);
  }
#line 117
  err = setfilecon(file, con);
#line 118
  if (err == -1) {
#line 118
    tmp___10 = __errno_location();
#line 118
    saved_errno = *tmp___10;
  } else {
#line 118
    saved_errno = 0;
  }
#line 120
  tmp___12 = restore_cwd((struct saved_cwd  const  *)(& saved_cwd));
#line 120
  if (tmp___12 != 0) {
#line 121
    tmp___11 = __errno_location();
#line 121
    openat_restore_fail(*tmp___11);
  }
#line 123
  free_cwd(& saved_cwd);
#line 125
  if (saved_errno) {
#line 126
    tmp___13 = __errno_location();
#line 126
    *tmp___13 = saved_errno;
  }
#line 127
  return (err);
}
}
#line 61 "at-func.c"
int lsetfileconat(int fd , char const   *file , char *con ) 
{ struct saved_cwd saved_cwd ;
  int saved_errno ;
  int err ;
  int tmp ;
  char proc_buf[4032] ;
  char *proc_file ;
  char *tmp___0 ;
  int proc_result ;
  int tmp___1 ;
  int proc_errno ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;

  {
#line 72
  if (fd == -100) {
#line 73
    tmp = setfilecon(file, con);
#line 73
    return (tmp);
  } else
#line 72
  if ((int const   )*(file + 0) == 47) {
#line 73
    tmp = setfilecon(file, con);
#line 73
    return (tmp);
  }
#line 77
  tmp___0 = openat_proc_name(proc_buf, fd, file);
#line 77
  proc_file = tmp___0;
#line 78
  if (proc_file) {
#line 80
    tmp___1 = setfilecon((char const   *)proc_file, con);
#line 80
    proc_result = tmp___1;
#line 81
    tmp___2 = __errno_location();
#line 81
    proc_errno = *tmp___2;
#line 82
    if ((unsigned long )proc_file != (unsigned long )(proc_buf)) {
#line 83
      free((void *)proc_file);
    }
#line 87
    if (-1 != proc_result) {
#line 88
      return (proc_result);
    }
#line 89
    if (! (proc_errno == 20)) {
#line 89
      if (! (proc_errno == 2)) {
#line 89
        if (! (proc_errno == 1)) {
#line 89
          if (! (proc_errno == 13)) {
#line 89
            if (! (proc_errno == 38)) {
#line 89
              if (! (proc_errno == 95)) {
#line 91
                tmp___3 = __errno_location();
#line 91
                *tmp___3 = proc_errno;
#line 92
                return (proc_result);
              }
            }
          }
        }
      }
    }
  }
#line 97
  tmp___5 = save_cwd(& saved_cwd);
#line 97
  if (tmp___5 != 0) {
#line 98
    tmp___4 = __errno_location();
#line 98
    openat_save_fail(*tmp___4);
  }
#line 99
  if (0 <= fd) {
#line 99
    if (fd == saved_cwd.desc) {
#line 104
      free_cwd(& saved_cwd);
#line 105
      tmp___6 = __errno_location();
#line 105
      *tmp___6 = 9;
#line 106
      return (-1);
    }
  }
#line 109
  tmp___9 = fchdir(fd);
#line 109
  if (tmp___9 != 0) {
#line 111
    tmp___7 = __errno_location();
#line 111
    saved_errno = *tmp___7;
#line 112
    free_cwd(& saved_cwd);
#line 113
    tmp___8 = __errno_location();
#line 113
    *tmp___8 = saved_errno;
#line 114
    return (-1);
  }
#line 117
  err = setfilecon(file, con);
#line 118
  if (err == -1) {
#line 118
    tmp___10 = __errno_location();
#line 118
    saved_errno = *tmp___10;
  } else {
#line 118
    saved_errno = 0;
  }
#line 120
  tmp___12 = restore_cwd((struct saved_cwd  const  *)(& saved_cwd));
#line 120
  if (tmp___12 != 0) {
#line 121
    tmp___11 = __errno_location();
#line 121
    openat_restore_fail(*tmp___11);
  }
#line 123
  free_cwd(& saved_cwd);
#line 125
  if (saved_errno) {
#line 126
    tmp___13 = __errno_location();
#line 126
    *tmp___13 = saved_errno;
  }
#line 127
  return (err);
}
}
#line 1 "sig2str.o"
#pragma merger(0,"/tmp/cil-YFsqIx7V.i","-g,-O2")
#line 402 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int __libc_current_sigrtmin(void) ;
#line 404
extern  __attribute__((__nothrow__)) int __libc_current_sigrtmax(void) ;
#line 30 "sig2str.h"
int sig2str(int signum , char *signame ) ;
#line 31
int str2sig(char const   *signame , int *signum ) ;
#line 41 "sig2str.c"
static struct numname numname_table[35]  = 
#line 41 "sig2str.c"
  {      {1, {(char const   )'H', (char const   )'U', (char const   )'P', (char const   )'\000',
          (char const   )(char)0, (char const   )(char)0, (char const   )(char)0,
          (char const   )(char)0}}, 
        {2, {(char const   )'I', (char const   )'N', (char const   )'T', (char const   )'\000',
          (char const   )(char)0, (char const   )(char)0, (char const   )(char)0,
          (char const   )(char)0}}, 
        {3, {(char const   )'Q', (char const   )'U', (char const   )'I', (char const   )'T',
          (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {4,
      {(char const   )'I', (char const   )'L', (char const   )'L', (char const   )'\000',
       (char const   )(char)0, (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {5,
      {(char const   )'T', (char const   )'R', (char const   )'A', (char const   )'P',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {6,
      {(char const   )'A', (char const   )'B', (char const   )'R', (char const   )'T',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {8,
      {(char const   )'F', (char const   )'P', (char const   )'E', (char const   )'\000',
       (char const   )(char)0, (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {9,
      {(char const   )'K', (char const   )'I', (char const   )'L', (char const   )'L',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {11,
      {(char const   )'S', (char const   )'E', (char const   )'G', (char const   )'V',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {7,
      {(char const   )'B', (char const   )'U', (char const   )'S', (char const   )'\000',
       (char const   )(char)0, (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {13,
      {(char const   )'P', (char const   )'I', (char const   )'P', (char const   )'E',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {14,
      {(char const   )'A', (char const   )'L', (char const   )'R', (char const   )'M',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {15,
      {(char const   )'T', (char const   )'E', (char const   )'R', (char const   )'M',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {10,
      {(char const   )'U', (char const   )'S', (char const   )'R', (char const   )'1',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {12,
      {(char const   )'U', (char const   )'S', (char const   )'R', (char const   )'2',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {17,
      {(char const   )'C', (char const   )'H', (char const   )'L', (char const   )'D',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {23,
      {(char const   )'U', (char const   )'R', (char const   )'G', (char const   )'\000',
       (char const   )(char)0, (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {19,
      {(char const   )'S', (char const   )'T', (char const   )'O', (char const   )'P',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {20,
      {(char const   )'T', (char const   )'S', (char const   )'T', (char const   )'P',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {18,
      {(char const   )'C', (char const   )'O', (char const   )'N', (char const   )'T',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {21,
      {(char const   )'T', (char const   )'T', (char const   )'I', (char const   )'N',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {22,
      {(char const   )'T', (char const   )'T', (char const   )'O', (char const   )'U',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {31,
      {(char const   )'S', (char const   )'Y', (char const   )'S', (char const   )'\000',
       (char const   )(char)0, (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {29,
      {(char const   )'P', (char const   )'O', (char const   )'L', (char const   )'L',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {26,
      {(char const   )'V', (char const   )'T', (char const   )'A', (char const   )'L',
       (char const   )'R', (char const   )'M', (char const   )'\000', (char const   )(char)0}}, 
        {27,
      {(char const   )'P', (char const   )'R', (char const   )'O', (char const   )'F',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {24,
      {(char const   )'X', (char const   )'C', (char const   )'P', (char const   )'U',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {25,
      {(char const   )'X', (char const   )'F', (char const   )'S', (char const   )'Z',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {6,
      {(char const   )'I', (char const   )'O', (char const   )'T', (char const   )'\000',
       (char const   )(char)0, (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {17,
      {(char const   )'C', (char const   )'L', (char const   )'D', (char const   )'\000',
       (char const   )(char)0, (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {30,
      {(char const   )'P', (char const   )'W', (char const   )'R', (char const   )'\000',
       (char const   )(char)0, (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {28,
      {(char const   )'W', (char const   )'I', (char const   )'N', (char const   )'C',
       (char const   )'H', (char const   )'\000', (char const   )(char)0, (char const   )(char)0}}, 
        {29,
      {(char const   )'I', (char const   )'O', (char const   )'\000', (char const   )(char)0,
       (char const   )(char)0, (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {16,
      {(char const   )'S', (char const   )'T', (char const   )'K', (char const   )'F',
       (char const   )'L', (char const   )'T', (char const   )'\000', (char const   )(char)0}}, 
        {0,
      {(char const   )'E', (char const   )'X', (char const   )'I', (char const   )'T',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}};
#line 260 "sig2str.c"
static int str2signum(char const   *signame ) 
{ char *endp ;
  long n ;
  long tmp ;
  unsigned int i ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___1 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *endp___0 ;
  int rtmin ;
  int tmp___7 ;
  int rtmax ;
  int tmp___8 ;
  long n___0 ;
  long tmp___9 ;
  long n___1 ;
  long tmp___10 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___27 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;

  {
#line 263
  if ((unsigned int )*signame - 48U <= 9U) {
#line 266
    tmp = strtol((char const   * __restrict  )signame, (char ** __restrict  )(& endp),
                 10);
#line 266
    n = tmp;
#line 267
    if (! *endp) {
#line 267
      if (n <= 64L) {
#line 268
        return ((int )n);
      }
    }
  } else {
#line 273
    i = 0U;
#line 273
    while ((unsigned long )i < sizeof(numname_table) / sizeof(numname_table[0])) {
#line 274
      if (0) {
#line 274
        __s1_len = __builtin_strlen(numname_table[i].name);
#line 274
        __s2_len = __builtin_strlen(signame);
#line 274
        if (! ((size_t )((void const   *)(numname_table[i].name + 1)) - (size_t )((void const   *)(numname_table[i].name)) == 1UL)) {
#line 274
          goto _L___0;
        } else
#line 274
        if (__s1_len >= 4UL) {
          _L___0: 
#line 274
          if (! ((size_t )((void const   *)(signame + 1)) - (size_t )((void const   *)signame) == 1UL)) {
#line 274
            tmp___6 = 1;
          } else
#line 274
          if (__s2_len >= 4UL) {
#line 274
            tmp___6 = 1;
          } else {
#line 274
            tmp___6 = 0;
          }
        } else {
#line 274
          tmp___6 = 0;
        }
#line 274
        if (tmp___6) {
#line 274
          tmp___1 = __builtin_strcmp(numname_table[i].name, signame);
#line 274
          tmp___5 = tmp___1;
        } else {
#line 274
          tmp___4 = __builtin_strcmp(numname_table[i].name, signame);
#line 274
          tmp___5 = tmp___4;
        }
      } else {
#line 274
        tmp___4 = __builtin_strcmp(numname_table[i].name, signame);
#line 274
        tmp___5 = tmp___4;
      }
#line 274
      if (tmp___5 == 0) {
#line 275
        return (numname_table[i].num);
      }
#line 273
      i ++;
    }
#line 279
    tmp___7 = __libc_current_sigrtmin();
#line 279
    rtmin = tmp___7;
#line 280
    tmp___8 = __libc_current_sigrtmax();
#line 280
    rtmax = tmp___8;
#line 282
    if (0 < rtmin) {
#line 282
      if (0) {
#line 282
        if (0) {
#line 282
          __s1_len___1 = __builtin_strlen(signame);
#line 282
          __s2_len___1 = __builtin_strlen("RTMIN");
#line 282
          if (! ((size_t )((void const   *)(signame + 1)) - (size_t )((void const   *)signame) == 1UL)) {
#line 282
            goto _L___4;
          } else
#line 282
          if (__s1_len___1 >= 4UL) {
            _L___4: 
#line 282
            if (! ((size_t )((void const   *)("RTMIN" + 1)) - (size_t )((void const   *)"RTMIN") == 1UL)) {
#line 282
              tmp___32 = 1;
            } else
#line 282
            if (__s2_len___1 >= 4UL) {
#line 282
              tmp___32 = 1;
            } else {
#line 282
              tmp___32 = 0;
            }
          } else {
#line 282
            tmp___32 = 0;
          }
#line 282
          if (tmp___32) {
#line 282
            tmp___27 = __builtin_strcmp(signame, "RTMIN");
#line 282
            tmp___31 = tmp___27;
          } else {
#line 282
            tmp___30 = __builtin_strcmp(signame, "RTMIN");
#line 282
            tmp___31 = tmp___30;
          }
        } else {
#line 282
          tmp___30 = __builtin_strcmp(signame, "RTMIN");
#line 282
          tmp___31 = tmp___30;
        }
#line 282
        tmp___34 = tmp___31;
      } else {
#line 282
        tmp___33 = strncmp(signame, "RTMIN", (size_t )5);
#line 282
        tmp___34 = tmp___33;
      }
#line 282
      if (tmp___34 == 0) {
#line 284
        tmp___9 = strtol((char const   * __restrict  )(signame + 5), (char ** __restrict  )(& endp___0),
                         10);
#line 284
        n___0 = tmp___9;
#line 285
        if (! *endp___0) {
#line 285
          if (0L <= n___0) {
#line 285
            if (n___0 <= (long )(rtmax - rtmin)) {
#line 286
              return ((int )((long )rtmin + n___0));
            }
          }
        }
      } else {
#line 282
        goto _L___5;
      }
    } else
    _L___5: 
#line 288
    if (0 < rtmax) {
#line 288
      if (0) {
#line 288
        if (0) {
#line 288
          __s1_len___0 = __builtin_strlen(signame);
#line 288
          __s2_len___0 = __builtin_strlen("RTMAX");
#line 288
          if (! ((size_t )((void const   *)(signame + 1)) - (size_t )((void const   *)signame) == 1UL)) {
#line 288
            goto _L___2;
          } else
#line 288
          if (__s1_len___0 >= 4UL) {
            _L___2: 
#line 288
            if (! ((size_t )((void const   *)("RTMAX" + 1)) - (size_t )((void const   *)"RTMAX") == 1UL)) {
#line 288
              tmp___19 = 1;
            } else
#line 288
            if (__s2_len___0 >= 4UL) {
#line 288
              tmp___19 = 1;
            } else {
#line 288
              tmp___19 = 0;
            }
          } else {
#line 288
            tmp___19 = 0;
          }
#line 288
          if (tmp___19) {
#line 288
            tmp___14 = __builtin_strcmp(signame, "RTMAX");
#line 288
            tmp___18 = tmp___14;
          } else {
#line 288
            tmp___17 = __builtin_strcmp(signame, "RTMAX");
#line 288
            tmp___18 = tmp___17;
          }
        } else {
#line 288
          tmp___17 = __builtin_strcmp(signame, "RTMAX");
#line 288
          tmp___18 = tmp___17;
        }
#line 288
        tmp___21 = tmp___18;
      } else {
#line 288
        tmp___20 = strncmp(signame, "RTMAX", (size_t )5);
#line 288
        tmp___21 = tmp___20;
      }
#line 288
      if (tmp___21 == 0) {
#line 290
        tmp___10 = strtol((char const   * __restrict  )(signame + 5), (char ** __restrict  )(& endp___0),
                          10);
#line 290
        n___1 = tmp___10;
#line 291
        if (! *endp___0) {
#line 291
          if ((long )(rtmin - rtmax) <= n___1) {
#line 291
            if (n___1 <= 0L) {
#line 292
              return ((int )((long )rtmax + n___1));
            }
          }
        }
      }
    }
  }
#line 297
  return (-1);
}
}
#line 303 "sig2str.c"
int str2sig(char const   *signame , int *signum ) 
{ int tmp ;

  {
#line 306
  *signum = str2signum(signame);
#line 307
  if (*signum < 0) {
#line 307
    tmp = -1;
  } else {
#line 307
    tmp = 0;
  }
#line 307
  return (tmp);
}
}
#line 314 "sig2str.c"
int sig2str(int signum , char *signame ) 
{ unsigned int i ;
  int rtmin ;
  int tmp ;
  int rtmax ;
  int tmp___0 ;
  int delta ;
  char const   *tmp___1 ;
  int delta___0 ;
  char const   *tmp___2 ;

  {
#line 318
  i = 0U;
#line 318
  while ((unsigned long )i < sizeof(numname_table) / sizeof(numname_table[0])) {
#line 319
    if (numname_table[i].num == signum) {
#line 321
      strcpy((char * __restrict  )signame, (char const   * __restrict  )(numname_table[i].name));
#line 322
      return (0);
    }
#line 318
    i ++;
  }
#line 326
  tmp = __libc_current_sigrtmin();
#line 326
  rtmin = tmp;
#line 327
  tmp___0 = __libc_current_sigrtmax();
#line 327
  rtmax = tmp___0;
#line 329
  if (rtmin <= signum) {
#line 329
    if (! (signum <= rtmax)) {
#line 330
      return (-1);
    }
  } else {
#line 330
    return (-1);
  }
#line 332
  if (signum <= rtmin + (rtmax - rtmin) / 2) {
#line 334
    delta = signum - rtmin;
#line 335
    if (delta) {
#line 335
      tmp___1 = "RTMIN+%d";
    } else {
#line 335
      tmp___1 = "RTMIN";
    }
#line 335
    sprintf((char * __restrict  )signame, (char const   * __restrict  )tmp___1, delta);
  } else {
#line 339
    delta___0 = rtmax - signum;
#line 340
    if (delta___0) {
#line 340
      tmp___2 = "RTMAX-%d";
    } else {
#line 340
      tmp___2 = "RTMAX";
    }
#line 340
    sprintf((char * __restrict  )signame, (char const   * __restrict  )tmp___2, delta___0);
  }
#line 343
  return (0);
}
}
#line 1 "strerror.o"
#pragma merger(0,"/tmp/cil-caAyaIV4.i","-g,-O2")
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 1242 "./string.h"
char *rpl_strerror(int n ) ;
#line 39 "strerror.c"
static char buf___0[256]  ;
#line 57 "strerror.c"
static char const   fmt[17]  = 
#line 57
  {      (char const   )'U',      (char const   )'n',      (char const   )'k',      (char const   )'n', 
        (char const   )'o',      (char const   )'w',      (char const   )'n',      (char const   )' ', 
        (char const   )'e',      (char const   )'r',      (char const   )'r',      (char const   )'o', 
        (char const   )'r',      (char const   )' ',      (char const   )'%',      (char const   )'d', 
        (char const   )'\000'};
#line 35 "strerror.c"
char *rpl_strerror(int n ) 
{ size_t len ;
  char const   *msg ;
  char *tmp ;
  int *tmp___0 ;
  void __attribute__((__artificial__))  *tmp___1 ;

  {
#line 44
  msg = (char const   *)((void *)0);
#line 45
  if (msg) {
#line 46
    return ((char *)msg);
  }
#line 48
  tmp = strerror(n);
#line 48
  msg = (char const   *)tmp;
#line 55
  if (! msg) {
#line 59
    sprintf((char * __restrict  )(buf___0), (char const   * __restrict  )(fmt), n);
#line 60
    tmp___0 = __errno_location();
#line 60
    *tmp___0 = 22;
#line 61
    return (buf___0);
  } else
#line 55
  if (! *msg) {
#line 59
    sprintf((char * __restrict  )(buf___0), (char const   * __restrict  )(fmt), n);
#line 60
    tmp___0 = __errno_location();
#line 60
    *tmp___0 = 22;
#line 61
    return (buf___0);
  }
#line 65
  len = strlen(msg);
#line 66
  if (sizeof(buf___0) <= len) {
#line 67
    abort();
  }
#line 69
  tmp___1 = memcpy((void * __restrict  )(buf___0), (void const   * __restrict  )msg,
                   len + 1UL);
#line 69
  return ((char *)tmp___1);
}
}
#line 1 "utimensat.o"
#pragma merger(0,"/tmp/cil-JBMaZE8g.i","-g,-O2")
#line 42 "utimensat.c"
static int local_utimensat(int fd , char const   *file , struct timespec  const  *ts ,
                           int flag ) ;
#line 56 "utimensat.c"
static int utimensat_works_really___0  ;
#line 47
int rpl_utimensat(int fd , char const   *file , struct timespec  const  *times , int flag )  __attribute__((__nonnull__(2))) ;
#line 47 "utimensat.c"
int rpl_utimensat(int fd , char const   *file , struct timespec  const  *times , int flag ) 
{ struct timespec ts[2] ;
  int result ;
  struct stat st ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
#line 57
  if (0 <= utimensat_works_really___0) {
#line 70
    if (times) {
#line 70
      if ((times + 0)->tv_nsec == (long const   )((1L << 30) - 2L)) {
#line 70
        goto _L;
      } else
#line 70
      if ((times + 1)->tv_nsec == (long const   )((1L << 30) - 2L)) {
        _L: 
#line 73
        tmp = fstatat(fd, (char const   * __restrict  )file, (struct stat * __restrict  )(& st),
                      flag);
#line 73
        if (tmp) {
#line 74
          return (-1);
        }
#line 75
        if ((times + 0)->tv_nsec == (long const   )((1L << 30) - 2L)) {
#line 75
          if ((times + 1)->tv_nsec == (long const   )((1L << 30) - 2L)) {
#line 76
            return (0);
          }
        }
#line 77
        if ((times + 0)->tv_nsec == (long const   )((1L << 30) - 2L)) {
#line 78
          ts[0] = get_stat_atime((struct stat  const  *)(& st));
        } else {
#line 80
          ts[0] = (struct timespec )*(times + 0);
        }
#line 81
        if ((times + 1)->tv_nsec == (long const   )((1L << 30) - 2L)) {
#line 82
          ts[1] = get_stat_mtime((struct stat  const  *)(& st));
        } else {
#line 84
          ts[1] = (struct timespec )*(times + 1);
        }
#line 85
        times = (struct timespec  const  *)(ts);
      }
    }
#line 88
    result = utimensat(fd, file, times, flag);
#line 94
    if (result == -1) {
#line 94
      tmp___0 = __errno_location();
#line 94
      if (*tmp___0 == 22) {
#line 94
        if (flag & -257) {
#line 95
          return (result);
        }
      }
    }
#line 96
    if (result == 0) {
#line 98
      utimensat_works_really___0 = 1;
#line 99
      return (result);
    } else {
#line 96
      tmp___1 = __errno_location();
#line 96
      if (*tmp___1 != 38) {
#line 96
        tmp___2 = __errno_location();
#line 96
        if (*tmp___2 != 22) {
#line 98
          utimensat_works_really___0 = 1;
#line 99
          return (result);
        }
      }
    }
  }
#line 106
  if (0 <= utimensat_works_really___0) {
#line 106
    tmp___3 = __errno_location();
#line 106
    if (*tmp___3 == 38) {
#line 107
      utimensat_works_really___0 = -1;
    }
  }
#line 108
  tmp___4 = local_utimensat(fd, file, times, flag);
#line 108
  return (tmp___4);
}
}
#line 61 "at-func.c"
static int local_utimensat(int fd , char const   *file , struct timespec  const  *ts ,
                           int flag ) 
{ struct saved_cwd saved_cwd ;
  int saved_errno ;
  int err ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char proc_buf[4032] ;
  char *proc_file ;
  char *tmp___3 ;
  int proc_result ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int proc_errno ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  int *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int *tmp___17 ;
  int *tmp___18 ;
  int tmp___19 ;
  int *tmp___20 ;

  {
#line 70
  if (flag & -257) {
#line 70
    tmp = __errno_location();
#line 70
    *tmp = 22;
#line 70
    return (-1);
  }
#line 72
  if (fd == -100) {
#line 72
    goto _L___0;
  } else
#line 72
  if ((int const   )*(file + 0) == 47) {
#line 72
    goto _L___0;
  } else
#line 72
  if (0) {
    _L___0: 
#line 73
    if (flag == 256) {
#line 73
      tmp___0 = lutimens(file, ts);
#line 73
      tmp___2 = tmp___0;
    } else {
#line 73
      tmp___1 = utimens(file, ts);
#line 73
      tmp___2 = tmp___1;
    }
#line 73
    return (tmp___2);
  }
#line 77
  tmp___3 = openat_proc_name(proc_buf, fd, file);
#line 77
  proc_file = tmp___3;
#line 78
  if (proc_file) {
#line 80
    if (flag == 256) {
#line 80
      tmp___4 = lutimens((char const   *)proc_file, ts);
#line 80
      tmp___6 = tmp___4;
    } else {
#line 80
      tmp___5 = utimens((char const   *)proc_file, ts);
#line 80
      tmp___6 = tmp___5;
    }
#line 80
    proc_result = tmp___6;
#line 81
    tmp___7 = __errno_location();
#line 81
    proc_errno = *tmp___7;
#line 82
    if ((unsigned long )proc_file != (unsigned long )(proc_buf)) {
#line 83
      free((void *)proc_file);
    }
#line 87
    if (-1 != proc_result) {
#line 88
      return (proc_result);
    }
#line 89
    if (! (proc_errno == 20)) {
#line 89
      if (! (proc_errno == 2)) {
#line 89
        if (! (proc_errno == 1)) {
#line 89
          if (! (proc_errno == 13)) {
#line 89
            if (! (proc_errno == 38)) {
#line 89
              if (! (proc_errno == 95)) {
#line 91
                tmp___8 = __errno_location();
#line 91
                *tmp___8 = proc_errno;
#line 92
                return (proc_result);
              }
            }
          }
        }
      }
    }
  }
#line 97
  tmp___10 = save_cwd(& saved_cwd);
#line 97
  if (tmp___10 != 0) {
#line 98
    tmp___9 = __errno_location();
#line 98
    openat_save_fail(*tmp___9);
  }
#line 99
  if (0 <= fd) {
#line 99
    if (fd == saved_cwd.desc) {
#line 104
      free_cwd(& saved_cwd);
#line 105
      tmp___11 = __errno_location();
#line 105
      *tmp___11 = 9;
#line 106
      return (-1);
    }
  }
#line 109
  tmp___14 = fchdir(fd);
#line 109
  if (tmp___14 != 0) {
#line 111
    tmp___12 = __errno_location();
#line 111
    saved_errno = *tmp___12;
#line 112
    free_cwd(& saved_cwd);
#line 113
    tmp___13 = __errno_location();
#line 113
    *tmp___13 = saved_errno;
#line 114
    return (-1);
  }
#line 117
  if (flag == 256) {
#line 117
    tmp___15 = lutimens(file, ts);
#line 117
    err = tmp___15;
  } else {
#line 117
    tmp___16 = utimens(file, ts);
#line 117
    err = tmp___16;
  }
#line 118
  if (err == -1) {
#line 118
    tmp___17 = __errno_location();
#line 118
    saved_errno = *tmp___17;
  } else {
#line 118
    saved_errno = 0;
  }
#line 120
  tmp___19 = restore_cwd((struct saved_cwd  const  *)(& saved_cwd));
#line 120
  if (tmp___19 != 0) {
#line 121
    tmp___18 = __errno_location();
#line 121
    openat_restore_fail(*tmp___18);
  }
#line 123
  free_cwd(& saved_cwd);
#line 125
  if (saved_errno) {
#line 126
    tmp___20 = __errno_location();
#line 126
    *tmp___20 = saved_errno;
  }
#line 127
  return (err);
}
}
#line 1 "vasnprintf.o"
#pragma merger(0,"/tmp/cil-9ObY4hGe.i","-g,-O2")
#line 75 "xsize.h"
__inline static size_t __attribute__((__pure__))  xsum4(size_t size1 , size_t size2 ,
                                                        size_t size3 , size_t size4 ) 
{ size_t __attribute__((__pure__))  tmp ;
  size_t __attribute__((__pure__))  tmp___0 ;
  size_t __attribute__((__pure__))  tmp___1 ;

  {
#line 81
  tmp = xsum(size1, size2);
#line 81
  tmp___0 = xsum((size_t )tmp, size3);
#line 81
  tmp___1 = xsum((size_t )tmp___0, size4);
#line 81
  return (tmp___1);
}
}
#line 85 "xsize.h"
__inline static size_t __attribute__((__pure__))  xmax(size_t size1 , size_t size2 ) 
{ size_t tmp ;

  {
#line 93
  if (size1 >= size2) {
#line 93
    tmp = size1;
  } else {
#line 93
    tmp = size2;
  }
#line 93
  return ((size_t __attribute__((__pure__))  )tmp);
}
}
#line 61 "/usr/include/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int __signbitl(long double __x )  __attribute__((__const__)) ;
#line 61 "/usr/include/bits/mathinline.h"
__inline extern int __signbitl(long double __x ) 
{ union __anonunion___u_36 __u ;

  {
#line 64
  __u.__l = __x;
#line 65
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 276 "vasnprintf.c"
static char decimal_point_char(void) 
{ char const   *point ;
  char *tmp ;
  int tmp___0 ;

  {
#line 285
  tmp = nl_langinfo(65536);
#line 285
  point = (char const   *)tmp;
#line 294
  if ((int const   )*(point + 0) != 0) {
#line 294
    tmp___0 = (int )((int const   )*(point + 0));
  } else {
#line 294
    tmp___0 = (int )((int const   )'.');
  }
#line 294
  return ((char )tmp___0);
}
}
#line 313 "vasnprintf.c"
static int is_infinite_or_zerol(long double x ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 316
  tmp = rpl_isnanl(x);
#line 316
  if (tmp) {
#line 316
    tmp___0 = 1;
  } else
#line 316
  if (x + x == x) {
#line 316
    tmp___0 = 1;
  } else {
#line 316
    tmp___0 = 0;
  }
#line 316
  return (tmp___0);
}
}
#line 3600
extern int __builtin_signbitl() ;
#line 3600
extern int __builtin_signbit() ;
#line 3600
extern int __builtin_signbitf() ;
#line 1746 "vasnprintf.c"
char *vasnprintf(char *resultbuf , size_t *lengthp , char const   *format , va_list args ) 
{ char_directives d ;
  arguments a ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  size_t buf_neededlength ;
  char *buf___1 ;
  char *buf_malloced ;
  char const   *cp ;
  size_t i ;
  char_directive *dp ;
  char *result ;
  size_t allocated ;
  size_t length ;
  size_t __attribute__((__pure__))  tmp___2 ;
  void *tmp___3 ;
  size_t buf_memsize ;
  size_t tmp___4 ;
  void *tmp___5 ;
  size_t n ;
  size_t augmented_length ;
  size_t __attribute__((__pure__))  tmp___6 ;
  size_t memory_size ;
  char *memory ;
  size_t tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  char const   *tmp___11 ;
  size_t augmented_length___0 ;
  size_t __attribute__((__pure__))  tmp___12 ;
  size_t memory_size___0 ;
  char *memory___0 ;
  size_t tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  int flags ;
  int has_width ;
  size_t width ;
  int has_precision ;
  size_t precision ;
  size_t tmp_length ;
  char tmpbuf[700] ;
  char *tmp___16 ;
  char *pad_ptr ;
  char *p ;
  int arg ;
  char const   *digitp ;
  char const   *tmp___17 ;
  size_t tmp___18 ;
  size_t __attribute__((__pure__))  tmp___19 ;
  int arg___0 ;
  char const   *digitp___0 ;
  char const   *tmp___20 ;
  size_t tmp___21 ;
  size_t __attribute__((__pure__))  tmp___22 ;
  size_t __attribute__((__pure__))  tmp___23 ;
  size_t __attribute__((__pure__))  tmp___24 ;
  size_t tmp_memsize ;
  size_t tmp___25 ;
  void *tmp___26 ;
  long double arg___1 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  int sign ;
  fpucw_t oldcw ;
  fpucw_t _cw ;
  fpucw_t _ncw ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  char *tmp___44 ;
  char *tmp___45 ;
  char *tmp___46 ;
  char *tmp___47 ;
  char *tmp___48 ;
  char *tmp___49 ;
  char *tmp___50 ;
  char *tmp___51 ;
  char *tmp___52 ;
  char *tmp___53 ;
  char *tmp___54 ;
  char *tmp___55 ;
  char *tmp___56 ;
  char *tmp___57 ;
  size_t ndigits ;
  size_t tmp___58 ;
  char *tmp___59 ;
  char *tmp___60 ;
  char *tmp___61 ;
  char *tmp___62 ;
  char *tmp___63 ;
  char *tmp___64 ;
  char *tmp___65 ;
  char *tmp___66 ;
  char *tmp___67 ;
  char *tmp___68 ;
  fpucw_t _ncw___0 ;
  int tmp___69 ;
  size_t pad ;
  char *end ;
  char *tmp___70 ;
  char *q ;
  char *tmp___71 ;
  char *q___0 ;
  char *tmp___72 ;
  size_t count ;
  size_t n___0 ;
  size_t __attribute__((__pure__))  tmp___73 ;
  size_t memory_size___1 ;
  char *memory___1 ;
  size_t tmp___74 ;
  void *tmp___75 ;
  void *tmp___76 ;
  arg_type type ;
  int flags___0 ;
  char *fbp ;
  unsigned int prefix_count ;
  int prefixes[2] ;
  int orig_errno ;
  char *tmp___77 ;
  char *tmp___78 ;
  char *tmp___79 ;
  char *tmp___80 ;
  char *tmp___81 ;
  char *tmp___82 ;
  char *tmp___83 ;
  char *tmp___84 ;
  size_t n___1 ;
  char const   *mp ;
  char *tmp___85 ;
  char const   *tmp___86 ;
  size_t n___2 ;
  char const   *mp___0 ;
  char *tmp___87 ;
  char const   *tmp___88 ;
  char *tmp___89 ;
  char *tmp___90 ;
  char *tmp___91 ;
  unsigned int tmp___92 ;
  unsigned int tmp___93 ;
  size_t memory_size___2 ;
  char *memory___2 ;
  size_t tmp___94 ;
  size_t __attribute__((__pure__))  tmp___95 ;
  size_t __attribute__((__pure__))  tmp___96 ;
  void *tmp___97 ;
  void *tmp___98 ;
  size_t __attribute__((__pure__))  tmp___99 ;
  int *tmp___100 ;
  int count___0 ;
  int retcount ;
  size_t maxlen ;
  int *tmp___101 ;
  int arg___2 ;
  int __attribute__((__artificial__))  tmp___102 ;
  int __attribute__((__artificial__))  tmp___103 ;
  int __attribute__((__artificial__))  tmp___104 ;
  unsigned int arg___3 ;
  int __attribute__((__artificial__))  tmp___105 ;
  int __attribute__((__artificial__))  tmp___106 ;
  int __attribute__((__artificial__))  tmp___107 ;
  int arg___4 ;
  int __attribute__((__artificial__))  tmp___108 ;
  int __attribute__((__artificial__))  tmp___109 ;
  int __attribute__((__artificial__))  tmp___110 ;
  unsigned int arg___5 ;
  int __attribute__((__artificial__))  tmp___111 ;
  int __attribute__((__artificial__))  tmp___112 ;
  int __attribute__((__artificial__))  tmp___113 ;
  int arg___6 ;
  int __attribute__((__artificial__))  tmp___114 ;
  int __attribute__((__artificial__))  tmp___115 ;
  int __attribute__((__artificial__))  tmp___116 ;
  unsigned int arg___7 ;
  int __attribute__((__artificial__))  tmp___117 ;
  int __attribute__((__artificial__))  tmp___118 ;
  int __attribute__((__artificial__))  tmp___119 ;
  long arg___8 ;
  int __attribute__((__artificial__))  tmp___120 ;
  int __attribute__((__artificial__))  tmp___121 ;
  int __attribute__((__artificial__))  tmp___122 ;
  unsigned long arg___9 ;
  int __attribute__((__artificial__))  tmp___123 ;
  int __attribute__((__artificial__))  tmp___124 ;
  int __attribute__((__artificial__))  tmp___125 ;
  long long arg___10 ;
  int __attribute__((__artificial__))  tmp___126 ;
  int __attribute__((__artificial__))  tmp___127 ;
  int __attribute__((__artificial__))  tmp___128 ;
  unsigned long long arg___11 ;
  int __attribute__((__artificial__))  tmp___129 ;
  int __attribute__((__artificial__))  tmp___130 ;
  int __attribute__((__artificial__))  tmp___131 ;
  double arg___12 ;
  int __attribute__((__artificial__))  tmp___132 ;
  int __attribute__((__artificial__))  tmp___133 ;
  int __attribute__((__artificial__))  tmp___134 ;
  long double arg___13 ;
  int __attribute__((__artificial__))  tmp___135 ;
  int __attribute__((__artificial__))  tmp___136 ;
  int __attribute__((__artificial__))  tmp___137 ;
  int arg___14 ;
  int __attribute__((__artificial__))  tmp___138 ;
  int __attribute__((__artificial__))  tmp___139 ;
  int __attribute__((__artificial__))  tmp___140 ;
  wint_t arg___15 ;
  int __attribute__((__artificial__))  tmp___141 ;
  int __attribute__((__artificial__))  tmp___142 ;
  int __attribute__((__artificial__))  tmp___143 ;
  char const   *arg___16 ;
  int __attribute__((__artificial__))  tmp___144 ;
  int __attribute__((__artificial__))  tmp___145 ;
  int __attribute__((__artificial__))  tmp___146 ;
  wchar_t const   *arg___17 ;
  int __attribute__((__artificial__))  tmp___147 ;
  int __attribute__((__artificial__))  tmp___148 ;
  int __attribute__((__artificial__))  tmp___149 ;
  void *arg___18 ;
  int __attribute__((__artificial__))  tmp___150 ;
  int __attribute__((__artificial__))  tmp___151 ;
  int __attribute__((__artificial__))  tmp___152 ;
  int saved_errno ;
  int *tmp___153 ;
  int *tmp___154 ;
  int tmp___155 ;
  size_t n___3 ;
  size_t tmp___156 ;
  size_t __attribute__((__pure__))  tmp___157 ;
  size_t __attribute__((__pure__))  tmp___158 ;
  size_t memory_size___3 ;
  char *memory___3 ;
  size_t tmp___159 ;
  void *tmp___160 ;
  void *tmp___161 ;
  int *tmp___162 ;
  int tmp___163 ;
  size_t memory_size___4 ;
  char *memory___4 ;
  size_t tmp___164 ;
  size_t __attribute__((__pure__))  tmp___165 ;
  size_t __attribute__((__pure__))  tmp___166 ;
  void *tmp___167 ;
  void *tmp___168 ;
  size_t __attribute__((__pure__))  tmp___169 ;
  char *memory___5 ;
  void *tmp___170 ;
  int *tmp___171 ;
  int *tmp___172 ;

  {
#line 1753
  tmp = printf_parse(format, & d, & a);
#line 1753
  if (tmp < 0) {
#line 1755
    return ((char *)((void *)0));
  }
#line 1763
  tmp___1 = printf_fetchargs(args, & a);
#line 1763
  if (tmp___1 < 0) {
#line 1765
    if ((unsigned long )d.dir != (unsigned long )(d.direct_alloc_dir)) {
#line 1765
      free((void *)d.dir);
    }
#line 1765
    if ((unsigned long )a.arg != (unsigned long )(a.direct_alloc_arg)) {
#line 1765
      free((void *)a.arg);
    }
#line 1766
    tmp___0 = __errno_location();
#line 1766
    *tmp___0 = 22;
#line 1767
    return ((char *)((void *)0));
  }
#line 1784
  tmp___2 = xsum4((size_t )7, d.max_width_length, d.max_precision_length, (size_t )6);
#line 1784
  buf_neededlength = (size_t )tmp___2;
#line 1787
  if (buf_neededlength < 4000UL / sizeof(char )) {
#line 1789
    tmp___3 = __builtin_alloca(buf_neededlength * sizeof(char ));
#line 1789
    buf___1 = (char *)tmp___3;
#line 1790
    buf_malloced = (char *)((void *)0);
  } else {
#line 1795
    if (buf_neededlength <= 0xffffffffffffffffUL / sizeof(char )) {
#line 1795
      tmp___4 = buf_neededlength * sizeof(char );
    } else {
#line 1795
      tmp___4 = 0xffffffffffffffffUL;
    }
#line 1795
    buf_memsize = tmp___4;
#line 1796
    if (buf_memsize == 0xffffffffffffffffUL) {
#line 1797
      goto out_of_memory_1;
    }
#line 1798
    tmp___5 = malloc(buf_memsize);
#line 1798
    buf___1 = (char *)tmp___5;
#line 1799
    if ((unsigned long )buf___1 == (unsigned long )((void *)0)) {
#line 1800
      goto out_of_memory_1;
    }
#line 1801
    buf_malloced = buf___1;
  }
#line 1804
  if ((unsigned long )resultbuf != (unsigned long )((void *)0)) {
#line 1806
    result = resultbuf;
#line 1807
    allocated = *lengthp;
  } else {
#line 1811
    result = (char *)((void *)0);
#line 1812
    allocated = (size_t )0;
  }
#line 1814
  length = (size_t )0;
#line 1844
  cp = format;
#line 1844
  i = (size_t )0;
#line 1844
  dp = d.dir + 0;
#line 1844
  while (1) {
#line 1846
    if ((unsigned long )cp != (unsigned long )dp->dir_start) {
#line 1848
      n = (size_t )(dp->dir_start - cp);
#line 1849
      tmp___6 = xsum(length, n);
#line 1849
      augmented_length = (size_t )tmp___6;
#line 1851
      if (augmented_length > allocated) {
#line 1851
        if (allocated > 0UL) {
#line 1851
          if (allocated <= 9223372036854775807UL) {
#line 1851
            tmp___7 = allocated * 2UL;
          } else {
#line 1851
            tmp___7 = 0xffffffffffffffffUL;
          }
#line 1851
          allocated = tmp___7;
        } else {
#line 1851
          allocated = (size_t )12;
        }
#line 1851
        if (augmented_length > allocated) {
#line 1851
          allocated = augmented_length;
        }
#line 1851
        if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
#line 1851
          memory_size = allocated * sizeof(char );
        } else {
#line 1851
          memory_size = 0xffffffffffffffffUL;
        }
#line 1851
        if (memory_size == 0xffffffffffffffffUL) {
#line 1851
          goto out_of_memory;
        }
#line 1851
        if ((unsigned long )result == (unsigned long )resultbuf) {
#line 1851
          tmp___8 = malloc(memory_size);
#line 1851
          memory = (char *)tmp___8;
        } else
#line 1851
        if ((unsigned long )result == (unsigned long )((void *)0)) {
#line 1851
          tmp___8 = malloc(memory_size);
#line 1851
          memory = (char *)tmp___8;
        } else {
#line 1851
          tmp___9 = realloc((void *)result, memory_size);
#line 1851
          memory = (char *)tmp___9;
        }
#line 1851
        if ((unsigned long )memory == (unsigned long )((void *)0)) {
#line 1851
          goto out_of_memory;
        }
#line 1851
        if ((unsigned long )result == (unsigned long )resultbuf) {
#line 1851
          if (length > 0UL) {
#line 1851
            memcpy((void * __restrict  )memory, (void const   * __restrict  )result,
                   length);
          }
        }
#line 1851
        result = memory;
      }
#line 1855
      if (sizeof(char ) == sizeof(char )) {
#line 1857
        memcpy((void * __restrict  )(result + length), (void const   * __restrict  )cp,
               n);
#line 1858
        length = augmented_length;
      } else {
#line 1862
        while (1) {
#line 1863
          tmp___10 = length;
#line 1863
          length ++;
#line 1863
          tmp___11 = cp;
#line 1863
          cp ++;
#line 1863
          *(result + tmp___10) = (char )((unsigned char )*tmp___11);
#line 1862
          n --;
#line 1862
          if (! (n > 0UL)) {
#line 1862
            break;
          }
        }
      }
    }
#line 1867
    if (i == d.count) {
#line 1868
      break;
    }
#line 1871
    if ((int )dp->conversion == 37) {
#line 1875
      if (! (dp->arg_index == 0xffffffffffffffffUL)) {
#line 1876
        abort();
      }
#line 1877
      tmp___12 = xsum(length, (size_t )1);
#line 1877
      augmented_length___0 = (size_t )tmp___12;
#line 1878
      if (augmented_length___0 > allocated) {
#line 1878
        if (allocated > 0UL) {
#line 1878
          if (allocated <= 9223372036854775807UL) {
#line 1878
            tmp___13 = allocated * 2UL;
          } else {
#line 1878
            tmp___13 = 0xffffffffffffffffUL;
          }
#line 1878
          allocated = tmp___13;
        } else {
#line 1878
          allocated = (size_t )12;
        }
#line 1878
        if (augmented_length___0 > allocated) {
#line 1878
          allocated = augmented_length___0;
        }
#line 1878
        if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
#line 1878
          memory_size___0 = allocated * sizeof(char );
        } else {
#line 1878
          memory_size___0 = 0xffffffffffffffffUL;
        }
#line 1878
        if (memory_size___0 == 0xffffffffffffffffUL) {
#line 1878
          goto out_of_memory;
        }
#line 1878
        if ((unsigned long )result == (unsigned long )resultbuf) {
#line 1878
          tmp___14 = malloc(memory_size___0);
#line 1878
          memory___0 = (char *)tmp___14;
        } else
#line 1878
        if ((unsigned long )result == (unsigned long )((void *)0)) {
#line 1878
          tmp___14 = malloc(memory_size___0);
#line 1878
          memory___0 = (char *)tmp___14;
        } else {
#line 1878
          tmp___15 = realloc((void *)result, memory_size___0);
#line 1878
          memory___0 = (char *)tmp___15;
        }
#line 1878
        if ((unsigned long )memory___0 == (unsigned long )((void *)0)) {
#line 1878
          goto out_of_memory;
        }
#line 1878
        if ((unsigned long )result == (unsigned long )resultbuf) {
#line 1878
          if (length > 0UL) {
#line 1878
            memcpy((void * __restrict  )memory___0, (void const   * __restrict  )result,
                   length);
          }
        }
#line 1878
        result = memory___0;
      }
#line 1879
      *(result + length) = (char )'%';
#line 1880
      length = augmented_length___0;
    } else {
#line 1884
      if (! (dp->arg_index != 0xffffffffffffffffUL)) {
#line 1885
        abort();
      }
#line 1887
      if ((int )dp->conversion == 110) {
#line 1889
        switch ((int )(a.arg + dp->arg_index)->type) {
        case 18: 
#line 1892
        *((a.arg + dp->arg_index)->a.a_count_schar_pointer) = (signed char )length;
#line 1893
        break;
        case 19: 
#line 1895
        *((a.arg + dp->arg_index)->a.a_count_short_pointer) = (short )length;
#line 1896
        break;
        case 20: 
#line 1898
        *((a.arg + dp->arg_index)->a.a_count_int_pointer) = (int )length;
#line 1899
        break;
        case 21: 
#line 1901
        *((a.arg + dp->arg_index)->a.a_count_longint_pointer) = (long )length;
#line 1902
        break;
        case 22: 
#line 1905
        *((a.arg + dp->arg_index)->a.a_count_longlongint_pointer) = (long long )length;
#line 1906
        break;
        default: 
#line 1909
        abort();
        }
      } else
#line 3393
      if ((int )dp->conversion == 102) {
#line 3393
        goto _L___11;
      } else
#line 3393
      if ((int )dp->conversion == 70) {
#line 3393
        goto _L___11;
      } else
#line 3393
      if ((int )dp->conversion == 101) {
#line 3393
        goto _L___11;
      } else
#line 3393
      if ((int )dp->conversion == 69) {
#line 3393
        goto _L___11;
      } else
#line 3393
      if ((int )dp->conversion == 103) {
#line 3393
        goto _L___11;
      } else
#line 3393
      if ((int )dp->conversion == 71) {
#line 3393
        goto _L___11;
      } else
#line 3393
      if ((int )dp->conversion == 97) {
#line 3393
        goto _L___11;
      } else
#line 3393
      if ((int )dp->conversion == 65) {
        _L___11: 
#line 3393
        if ((unsigned int )(a.arg + dp->arg_index)->type == 12U) {
#line 3393
          tmp___163 = is_infinite_or_zerol((a.arg + dp->arg_index)->a.a_longdouble);
#line 3393
          if (tmp___163) {
#line 3422
            flags = dp->flags;
#line 3433
            has_width = 0;
#line 3434
            width = (size_t )0;
#line 3435
            if ((unsigned long )dp->width_start != (unsigned long )dp->width_end) {
#line 3437
              if (dp->width_arg_index != 0xffffffffffffffffUL) {
#line 3441
                if (! ((unsigned int )(a.arg + dp->width_arg_index)->type == 5U)) {
#line 3442
                  abort();
                }
#line 3443
                arg = (a.arg + dp->width_arg_index)->a.a_int;
#line 3444
                if (arg < 0) {
#line 3448
                  flags |= 2;
#line 3449
                  width = (size_t )((unsigned int )(- arg));
                } else {
#line 3452
                  width = (size_t )arg;
                }
              } else {
#line 3456
                digitp = dp->width_start;
#line 3458
                while (1) {
#line 3459
                  tmp___17 = digitp;
#line 3459
                  digitp ++;
#line 3459
                  if (width <= 1844674407370955161UL) {
#line 3459
                    tmp___18 = width * 10UL;
                  } else {
#line 3459
                    tmp___18 = 0xffffffffffffffffUL;
                  }
#line 3459
                  tmp___19 = xsum(tmp___18, (size_t )((int const   )*tmp___17 - 48));
#line 3459
                  width = (size_t )tmp___19;
#line 3458
                  if (! ((unsigned long )digitp != (unsigned long )dp->width_end)) {
#line 3458
                    break;
                  }
                }
              }
#line 3462
              has_width = 1;
            }
#line 3465
            has_precision = 0;
#line 3466
            precision = (size_t )0;
#line 3467
            if ((unsigned long )dp->precision_start != (unsigned long )dp->precision_end) {
#line 3469
              if (dp->precision_arg_index != 0xffffffffffffffffUL) {
#line 3473
                if (! ((unsigned int )(a.arg + dp->precision_arg_index)->type == 5U)) {
#line 3474
                  abort();
                }
#line 3475
                arg___0 = (a.arg + dp->precision_arg_index)->a.a_int;
#line 3478
                if (arg___0 >= 0) {
#line 3480
                  precision = (size_t )arg___0;
#line 3481
                  has_precision = 1;
                }
              } else {
#line 3486
                digitp___0 = dp->precision_start + 1;
#line 3488
                precision = (size_t )0;
#line 3489
                while ((unsigned long )digitp___0 != (unsigned long )dp->precision_end) {
#line 3490
                  tmp___20 = digitp___0;
#line 3490
                  digitp___0 ++;
#line 3490
                  if (precision <= 1844674407370955161UL) {
#line 3490
                    tmp___21 = precision * 10UL;
                  } else {
#line 3490
                    tmp___21 = 0xffffffffffffffffUL;
                  }
#line 3490
                  tmp___22 = xsum(tmp___21, (size_t )((int const   )*tmp___20 - 48));
#line 3490
                  precision = (size_t )tmp___22;
                }
#line 3491
                has_precision = 1;
              }
            }
#line 3499
            if (! has_precision) {
#line 3500
              if (! ((int )dp->conversion == 97)) {
#line 3500
                if (! ((int )dp->conversion == 65)) {
#line 3501
                  precision = (size_t )6;
                }
              }
            }
#line 3513
            tmp_length = (size_t )0;
#line 3515
            if (tmp_length < precision) {
#line 3516
              tmp_length = precision;
            }
#line 3550
            tmp___23 = xsum(tmp_length, (size_t )12);
#line 3550
            tmp_length = (size_t )tmp___23;
#line 3552
            if (tmp_length < width) {
#line 3553
              tmp_length = width;
            }
#line 3555
            tmp___24 = xsum(tmp_length, (size_t )1);
#line 3555
            tmp_length = (size_t )tmp___24;
#line 3557
            if (tmp_length <= sizeof(tmpbuf) / sizeof(char )) {
#line 3558
              tmp___16 = tmpbuf;
            } else {
#line 3561
              if (tmp_length <= 0xffffffffffffffffUL / sizeof(char )) {
#line 3561
                tmp___25 = tmp_length * sizeof(char );
              } else {
#line 3561
                tmp___25 = 0xffffffffffffffffUL;
              }
#line 3561
              tmp_memsize = tmp___25;
#line 3563
              if (tmp_memsize == 0xffffffffffffffffUL) {
#line 3565
                goto out_of_memory;
              }
#line 3566
              tmp___26 = malloc(tmp_memsize);
#line 3566
              tmp___16 = (char *)tmp___26;
#line 3567
              if ((unsigned long )tmp___16 == (unsigned long )((void *)0)) {
#line 3569
                goto out_of_memory;
              }
            }
#line 3572
            pad_ptr = (char *)((void *)0);
#line 3573
            p = tmp___16;
#line 3580
            arg___1 = (a.arg + dp->arg_index)->a.a_longdouble;
#line 3582
            tmp___69 = rpl_isnanl(arg___1);
#line 3582
            if (tmp___69) {
#line 3584
              if ((int )dp->conversion >= 65) {
#line 3584
                if ((int )dp->conversion <= 90) {
#line 3586
                  tmp___27 = p;
#line 3586
                  p ++;
#line 3586
                  *tmp___27 = (char )'N';
#line 3586
                  tmp___28 = p;
#line 3586
                  p ++;
#line 3586
                  *tmp___28 = (char )'A';
#line 3586
                  tmp___29 = p;
#line 3586
                  p ++;
#line 3586
                  *tmp___29 = (char )'N';
                } else {
#line 3584
                  goto _L;
                }
              } else {
                _L: 
#line 3590
                tmp___30 = p;
#line 3590
                p ++;
#line 3590
                *tmp___30 = (char )'n';
#line 3590
                tmp___31 = p;
#line 3590
                p ++;
#line 3590
                *tmp___31 = (char )'a';
#line 3590
                tmp___32 = p;
#line 3590
                p ++;
#line 3590
                *tmp___32 = (char )'n';
              }
            } else {
#line 3595
              sign = 0;
#line 3598
              __asm__  volatile   ("fnstcw %0": "=m" (_cw));
#line 3598
              oldcw = _cw;
#line 3598
              _ncw = (fpucw_t )(((int )oldcw & -769) | 768);
#line 3598
              __asm__  volatile   ("fldcw %0": : "m" (_ncw));
#line 3600
              if (sizeof(arg___1) == sizeof(long double )) {
#line 3600
                tmp___33 = __builtin_signbitl(arg___1);
#line 3600
                tmp___37 = tmp___33;
              } else {
#line 3600
                if (sizeof(arg___1) == sizeof(double )) {
#line 3600
                  tmp___34 = __builtin_signbit(arg___1);
#line 3600
                  tmp___36 = tmp___34;
                } else {
#line 3600
                  tmp___35 = __builtin_signbitf(arg___1);
#line 3600
                  tmp___36 = tmp___35;
                }
#line 3600
                tmp___37 = tmp___36;
              }
#line 3600
              if (tmp___37) {
#line 3602
                sign = -1;
#line 3603
                arg___1 = - arg___1;
              }
#line 3606
              if (sign < 0) {
#line 3607
                tmp___38 = p;
#line 3607
                p ++;
#line 3607
                *tmp___38 = (char )'-';
              } else
#line 3608
              if (flags & 4) {
#line 3609
                tmp___39 = p;
#line 3609
                p ++;
#line 3609
                *tmp___39 = (char )'+';
              } else
#line 3610
              if (flags & 8) {
#line 3611
                tmp___40 = p;
#line 3611
                p ++;
#line 3611
                *tmp___40 = (char )' ';
              }
#line 3613
              if (arg___1 > 0.0L) {
#line 3613
                if (arg___1 + arg___1 == arg___1) {
#line 3615
                  if ((int )dp->conversion >= 65) {
#line 3615
                    if ((int )dp->conversion <= 90) {
#line 3617
                      tmp___41 = p;
#line 3617
                      p ++;
#line 3617
                      *tmp___41 = (char )'I';
#line 3617
                      tmp___42 = p;
#line 3617
                      p ++;
#line 3617
                      *tmp___42 = (char )'N';
#line 3617
                      tmp___43 = p;
#line 3617
                      p ++;
#line 3617
                      *tmp___43 = (char )'F';
                    } else {
#line 3615
                      goto _L___0;
                    }
                  } else {
                    _L___0: 
#line 3621
                    tmp___44 = p;
#line 3621
                    p ++;
#line 3621
                    *tmp___44 = (char )'i';
#line 3621
                    tmp___45 = p;
#line 3621
                    p ++;
#line 3621
                    *tmp___45 = (char )'n';
#line 3621
                    tmp___46 = p;
#line 3621
                    p ++;
#line 3621
                    *tmp___46 = (char )'f';
                  }
                } else {
#line 3613
                  goto _L___8;
                }
              } else {
                _L___8: 
#line 3977
                if (! (arg___1 == 0.0L)) {
#line 3978
                  abort();
                }
#line 3980
                pad_ptr = p;
#line 3982
                if ((int )dp->conversion == 102) {
#line 3982
                  goto _L___7;
                } else
#line 3982
                if ((int )dp->conversion == 70) {
                  _L___7: 
#line 3984
                  tmp___47 = p;
#line 3984
                  p ++;
#line 3984
                  *tmp___47 = (char )'0';
#line 3985
                  if (flags & 16) {
#line 3985
                    goto _L___1;
                  } else
#line 3985
                  if (precision > 0UL) {
                    _L___1: 
#line 3987
                    tmp___48 = p;
#line 3987
                    p ++;
#line 3987
                    *tmp___48 = decimal_point_char();
#line 3988
                    while (precision > 0UL) {
#line 3989
                      tmp___49 = p;
#line 3989
                      p ++;
#line 3989
                      *tmp___49 = (char )'0';
#line 3988
                      precision --;
                    }
                  }
                } else
#line 3992
                if ((int )dp->conversion == 101) {
#line 3992
                  goto _L___6;
                } else
#line 3992
                if ((int )dp->conversion == 69) {
                  _L___6: 
#line 3994
                  tmp___50 = p;
#line 3994
                  p ++;
#line 3994
                  *tmp___50 = (char )'0';
#line 3995
                  if (flags & 16) {
#line 3995
                    goto _L___2;
                  } else
#line 3995
                  if (precision > 0UL) {
                    _L___2: 
#line 3997
                    tmp___51 = p;
#line 3997
                    p ++;
#line 3997
                    *tmp___51 = decimal_point_char();
#line 3998
                    while (precision > 0UL) {
#line 3999
                      tmp___52 = p;
#line 3999
                      p ++;
#line 3999
                      *tmp___52 = (char )'0';
#line 3998
                      precision --;
                    }
                  }
#line 4001
                  tmp___53 = p;
#line 4001
                  p ++;
#line 4001
                  *tmp___53 = dp->conversion;
#line 4002
                  tmp___54 = p;
#line 4002
                  p ++;
#line 4002
                  *tmp___54 = (char )'+';
#line 4003
                  tmp___55 = p;
#line 4003
                  p ++;
#line 4003
                  *tmp___55 = (char )'0';
#line 4004
                  tmp___56 = p;
#line 4004
                  p ++;
#line 4004
                  *tmp___56 = (char )'0';
                } else
#line 4006
                if ((int )dp->conversion == 103) {
#line 4006
                  goto _L___5;
                } else
#line 4006
                if ((int )dp->conversion == 71) {
                  _L___5: 
#line 4008
                  tmp___57 = p;
#line 4008
                  p ++;
#line 4008
                  *tmp___57 = (char )'0';
#line 4009
                  if (flags & 16) {
#line 4011
                    if (precision > 0UL) {
#line 4011
                      tmp___58 = precision - 1UL;
                    } else {
#line 4011
                      tmp___58 = (size_t )0;
                    }
#line 4011
                    ndigits = tmp___58;
#line 4013
                    tmp___59 = p;
#line 4013
                    p ++;
#line 4013
                    *tmp___59 = decimal_point_char();
#line 4014
                    while (ndigits > 0UL) {
#line 4015
                      tmp___60 = p;
#line 4015
                      p ++;
#line 4015
                      *tmp___60 = (char )'0';
#line 4014
                      ndigits --;
                    }
                  }
                } else
#line 4018
                if ((int )dp->conversion == 97) {
#line 4018
                  goto _L___4;
                } else
#line 4018
                if ((int )dp->conversion == 65) {
                  _L___4: 
#line 4020
                  tmp___61 = p;
#line 4020
                  p ++;
#line 4020
                  *tmp___61 = (char )'0';
#line 4021
                  tmp___62 = p;
#line 4021
                  p ++;
#line 4021
                  *tmp___62 = (char )(((int )dp->conversion - 65) + 88);
#line 4022
                  pad_ptr = p;
#line 4023
                  tmp___63 = p;
#line 4023
                  p ++;
#line 4023
                  *tmp___63 = (char )'0';
#line 4024
                  if (flags & 16) {
#line 4024
                    goto _L___3;
                  } else
#line 4024
                  if (precision > 0UL) {
                    _L___3: 
#line 4026
                    tmp___64 = p;
#line 4026
                    p ++;
#line 4026
                    *tmp___64 = decimal_point_char();
#line 4027
                    while (precision > 0UL) {
#line 4028
                      tmp___65 = p;
#line 4028
                      p ++;
#line 4028
                      *tmp___65 = (char )'0';
#line 4027
                      precision --;
                    }
                  }
#line 4030
                  tmp___66 = p;
#line 4030
                  p ++;
#line 4030
                  *tmp___66 = (char )(((int )dp->conversion - 65) + 80);
#line 4031
                  tmp___67 = p;
#line 4031
                  p ++;
#line 4031
                  *tmp___67 = (char )'+';
#line 4032
                  tmp___68 = p;
#line 4032
                  p ++;
#line 4032
                  *tmp___68 = (char )'0';
                } else {
#line 4035
                  abort();
                }
              }
#line 4039
              _ncw___0 = oldcw;
#line 4039
              __asm__  volatile   ("fldcw %0": : "m" (_ncw___0));
            }
#line 4519
            if (has_width) {
#line 4519
              if ((size_t )(p - tmp___16) < width) {
#line 4521
                pad = width - (size_t )(p - tmp___16);
#line 4522
                end = p + pad;
#line 4524
                if (flags & 2) {
#line 4527
                  while (pad > 0UL) {
#line 4528
                    tmp___70 = p;
#line 4528
                    p ++;
#line 4528
                    *tmp___70 = (char )' ';
#line 4527
                    pad --;
                  }
                } else
#line 4530
                if (flags & 32) {
#line 4530
                  if ((unsigned long )pad_ptr != (unsigned long )((void *)0)) {
#line 4533
                    q = end;
#line 4535
                    while ((unsigned long )p > (unsigned long )pad_ptr) {
#line 4536
                      q --;
#line 4536
                      p --;
#line 4536
                      *q = *p;
                    }
#line 4537
                    while (pad > 0UL) {
#line 4538
                      tmp___71 = p;
#line 4538
                      p ++;
#line 4538
                      *tmp___71 = (char )'0';
#line 4537
                      pad --;
                    }
                  } else {
#line 4530
                    goto _L___9;
                  }
                } else {
                  _L___9: 
#line 4543
                  q___0 = end;
#line 4545
                  while ((unsigned long )p > (unsigned long )tmp___16) {
#line 4546
                    q___0 --;
#line 4546
                    p --;
#line 4546
                    *q___0 = *p;
                  }
#line 4547
                  while (pad > 0UL) {
#line 4548
                    tmp___72 = p;
#line 4548
                    p ++;
#line 4548
                    *tmp___72 = (char )' ';
#line 4547
                    pad --;
                  }
                }
#line 4551
                p = end;
              }
            }
#line 4555
            count = (size_t )(p - tmp___16);
#line 4557
            if (count >= tmp_length) {
#line 4560
              abort();
            }
#line 4563
            if (count >= allocated - length) {
#line 4565
              tmp___73 = xsum(length, count);
#line 4565
              n___0 = (size_t )tmp___73;
#line 4567
              if (n___0 > allocated) {
#line 4567
                if (allocated > 0UL) {
#line 4567
                  if (allocated <= 9223372036854775807UL) {
#line 4567
                    tmp___74 = allocated * 2UL;
                  } else {
#line 4567
                    tmp___74 = 0xffffffffffffffffUL;
                  }
#line 4567
                  allocated = tmp___74;
                } else {
#line 4567
                  allocated = (size_t )12;
                }
#line 4567
                if (n___0 > allocated) {
#line 4567
                  allocated = n___0;
                }
#line 4567
                if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
#line 4567
                  memory_size___1 = allocated * sizeof(char );
                } else {
#line 4567
                  memory_size___1 = 0xffffffffffffffffUL;
                }
#line 4567
                if (memory_size___1 == 0xffffffffffffffffUL) {
#line 4567
                  goto out_of_memory;
                }
#line 4567
                if ((unsigned long )result == (unsigned long )resultbuf) {
#line 4567
                  tmp___75 = malloc(memory_size___1);
#line 4567
                  memory___1 = (char *)tmp___75;
                } else
#line 4567
                if ((unsigned long )result == (unsigned long )((void *)0)) {
#line 4567
                  tmp___75 = malloc(memory_size___1);
#line 4567
                  memory___1 = (char *)tmp___75;
                } else {
#line 4567
                  tmp___76 = realloc((void *)result, memory_size___1);
#line 4567
                  memory___1 = (char *)tmp___76;
                }
#line 4567
                if ((unsigned long )memory___1 == (unsigned long )((void *)0)) {
#line 4567
                  goto out_of_memory;
                }
#line 4567
                if ((unsigned long )result == (unsigned long )resultbuf) {
#line 4567
                  if (length > 0UL) {
#line 4567
                    memcpy((void * __restrict  )memory___1, (void const   * __restrict  )result,
                           length);
                  }
                }
#line 4567
                result = memory___1;
              }
            }
#line 4571
            memcpy((void * __restrict  )(result + length), (void const   * __restrict  )tmp___16,
                   count * sizeof(char ));
#line 4572
            if ((unsigned long )tmp___16 != (unsigned long )(tmpbuf)) {
#line 4573
              free((void *)tmp___16);
            }
#line 4574
            length += count;
          } else {
#line 3393
            goto _L___10;
          }
        } else {
#line 3393
          goto _L___10;
        }
      } else {
        _L___10: 
#line 4580
        type = (a.arg + dp->arg_index)->type;
#line 4581
        flags___0 = dp->flags;
#line 4742
        fbp = buf___1;
#line 4743
        tmp___77 = fbp;
#line 4743
        fbp ++;
#line 4743
        *tmp___77 = (char )'%';
#line 4749
        if (flags___0 & 1) {
#line 4750
          tmp___78 = fbp;
#line 4750
          fbp ++;
#line 4750
          *tmp___78 = (char )'\'';
        }
#line 4752
        if (flags___0 & 2) {
#line 4753
          tmp___79 = fbp;
#line 4753
          fbp ++;
#line 4753
          *tmp___79 = (char )'-';
        }
#line 4754
        if (flags___0 & 4) {
#line 4755
          tmp___80 = fbp;
#line 4755
          fbp ++;
#line 4755
          *tmp___80 = (char )'+';
        }
#line 4756
        if (flags___0 & 8) {
#line 4757
          tmp___81 = fbp;
#line 4757
          fbp ++;
#line 4757
          *tmp___81 = (char )' ';
        }
#line 4758
        if (flags___0 & 16) {
#line 4759
          tmp___82 = fbp;
#line 4759
          fbp ++;
#line 4759
          *tmp___82 = (char )'#';
        }
#line 4761
        if (flags___0 & 64) {
#line 4762
          tmp___83 = fbp;
#line 4762
          fbp ++;
#line 4762
          *tmp___83 = (char )'I';
        }
#line 4766
        if (flags___0 & 32) {
#line 4767
          tmp___84 = fbp;
#line 4767
          fbp ++;
#line 4767
          *tmp___84 = (char )'0';
        }
#line 4768
        if ((unsigned long )dp->width_start != (unsigned long )dp->width_end) {
#line 4770
          n___1 = (size_t )(dp->width_end - dp->width_start);
#line 4773
          if (sizeof(char ) == sizeof(char )) {
#line 4775
            memcpy((void * __restrict  )fbp, (void const   * __restrict  )dp->width_start,
                   n___1 * sizeof(char ));
#line 4776
            fbp += n___1;
          } else {
#line 4780
            mp = dp->width_start;
#line 4781
            while (1) {
#line 4782
              tmp___85 = fbp;
#line 4782
              fbp ++;
#line 4782
              tmp___86 = mp;
#line 4782
              mp ++;
#line 4782
              *tmp___85 = (char )((unsigned char )*tmp___86);
#line 4781
              n___1 --;
#line 4781
              if (! (n___1 > 0UL)) {
#line 4781
                break;
              }
            }
          }
        }
#line 4789
        if ((unsigned long )dp->precision_start != (unsigned long )dp->precision_end) {
#line 4791
          n___2 = (size_t )(dp->precision_end - dp->precision_start);
#line 4794
          if (sizeof(char ) == sizeof(char )) {
#line 4796
            memcpy((void * __restrict  )fbp, (void const   * __restrict  )dp->precision_start,
                   n___2 * sizeof(char ));
#line 4797
            fbp += n___2;
          } else {
#line 4801
            mp___0 = dp->precision_start;
#line 4802
            while (1) {
#line 4803
              tmp___87 = fbp;
#line 4803
              fbp ++;
#line 4803
              tmp___88 = mp___0;
#line 4803
              mp___0 ++;
#line 4803
              *tmp___87 = (char )((unsigned char )*tmp___88);
#line 4802
              n___2 --;
#line 4802
              if (! (n___2 > 0UL)) {
#line 4802
                break;
              }
            }
          }
        }
#line 4809
        switch ((int )type) {
        case 9: 
        case 10: 
#line 4820
        tmp___89 = fbp;
#line 4820
        fbp ++;
#line 4820
        *tmp___89 = (char )'l';
        case 7: 
        case 8: 
        case 14: 
        case 16: 
#line 4832
        tmp___90 = fbp;
#line 4832
        fbp ++;
#line 4832
        *tmp___90 = (char )'l';
#line 4833
        break;
        case 12: 
#line 4835
        tmp___91 = fbp;
#line 4835
        fbp ++;
#line 4835
        *tmp___91 = (char )'L';
#line 4836
        break;
        default: 
#line 4838
        break;
        }
#line 4845
        *fbp = dp->conversion;
#line 4876
        *(fbp + 1) = (char )'\000';
#line 4883
        prefix_count = 0U;
#line 4884
        if (dp->width_arg_index != 0xffffffffffffffffUL) {
#line 4886
          if (! ((unsigned int )(a.arg + dp->width_arg_index)->type == 5U)) {
#line 4887
            abort();
          }
#line 4888
          tmp___92 = prefix_count;
#line 4888
          prefix_count ++;
#line 4888
          prefixes[tmp___92] = (a.arg + dp->width_arg_index)->a.a_int;
        }
#line 4890
        if (dp->precision_arg_index != 0xffffffffffffffffUL) {
#line 4892
          if (! ((unsigned int )(a.arg + dp->precision_arg_index)->type == 5U)) {
#line 4893
            abort();
          }
#line 4894
          tmp___93 = prefix_count;
#line 4894
          prefix_count ++;
#line 4894
          prefixes[tmp___93] = (a.arg + dp->precision_arg_index)->a.a_int;
        }
#line 4906
        tmp___99 = xsum(length, ((2UL + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char )));
#line 4906
        if (tmp___99 > (size_t __attribute__((__pure__))  )allocated) {
#line 4906
          if (allocated > 0UL) {
#line 4906
            if (allocated <= 9223372036854775807UL) {
#line 4906
              tmp___94 = allocated * 2UL;
            } else {
#line 4906
              tmp___94 = 0xffffffffffffffffUL;
            }
#line 4906
            allocated = tmp___94;
          } else {
#line 4906
            allocated = (size_t )12;
          }
#line 4906
          tmp___96 = xsum(length, ((2UL + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char )));
#line 4906
          if (tmp___96 > (size_t __attribute__((__pure__))  )allocated) {
#line 4906
            tmp___95 = xsum(length, ((2UL + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char )));
#line 4906
            allocated = (size_t )tmp___95;
          }
#line 4906
          if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
#line 4906
            memory_size___2 = allocated * sizeof(char );
          } else {
#line 4906
            memory_size___2 = 0xffffffffffffffffUL;
          }
#line 4906
          if (memory_size___2 == 0xffffffffffffffffUL) {
#line 4906
            goto out_of_memory;
          }
#line 4906
          if ((unsigned long )result == (unsigned long )resultbuf) {
#line 4906
            tmp___97 = malloc(memory_size___2);
#line 4906
            memory___2 = (char *)tmp___97;
          } else
#line 4906
          if ((unsigned long )result == (unsigned long )((void *)0)) {
#line 4906
            tmp___97 = malloc(memory_size___2);
#line 4906
            memory___2 = (char *)tmp___97;
          } else {
#line 4906
            tmp___98 = realloc((void *)result, memory_size___2);
#line 4906
            memory___2 = (char *)tmp___98;
          }
#line 4906
          if ((unsigned long )memory___2 == (unsigned long )((void *)0)) {
#line 4906
            goto out_of_memory;
          }
#line 4906
          if ((unsigned long )result == (unsigned long )resultbuf) {
#line 4906
            if (length > 0UL) {
#line 4906
              memcpy((void * __restrict  )memory___2, (void const   * __restrict  )result,
                     length);
            }
          }
#line 4906
          result = memory___2;
        }
#line 4911
        *(result + length) = (char )'\000';
#line 4914
        tmp___100 = __errno_location();
#line 4914
        orig_errno = *tmp___100;
#line 4916
        while (1) {
#line 4918
          count___0 = -1;
#line 4921
          retcount = 0;
#line 4922
          maxlen = allocated - length;
#line 4925
          if (maxlen > 2147483647UL / (sizeof(char ) / sizeof(char ))) {
#line 4926
            maxlen = 2147483647UL / (sizeof(char ) / sizeof(char ));
          }
#line 4927
          maxlen *= sizeof(char ) / sizeof(char );
#line 4969
          tmp___101 = __errno_location();
#line 4969
          *tmp___101 = 0;
#line 4970
          switch ((int )type) {
          case 1: 
#line 4974
          arg___2 = (int )(a.arg + dp->arg_index)->a.a_schar;
#line 4975
          switch ((int )prefix_count) {
          case 0: 
#line 4975
          tmp___102 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               arg___2, & count___0);
#line 4975
          retcount = (int )tmp___102;
#line 4975
          break;
          case 1: 
#line 4975
          tmp___103 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], arg___2, & count___0);
#line 4975
          retcount = (int )tmp___103;
#line 4975
          break;
          case 2: 
#line 4975
          tmp___104 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], prefixes[1], arg___2, & count___0);
#line 4975
          retcount = (int )tmp___104;
#line 4975
          break;
          default: 
#line 4975
          abort();
          }
#line 4977
          break;
          case 2: 
#line 4980
          arg___3 = (unsigned int )(a.arg + dp->arg_index)->a.a_uchar;
#line 4981
          switch ((int )prefix_count) {
          case 0: 
#line 4981
          tmp___105 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               arg___3, & count___0);
#line 4981
          retcount = (int )tmp___105;
#line 4981
          break;
          case 1: 
#line 4981
          tmp___106 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], arg___3, & count___0);
#line 4981
          retcount = (int )tmp___106;
#line 4981
          break;
          case 2: 
#line 4981
          tmp___107 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], prefixes[1], arg___3, & count___0);
#line 4981
          retcount = (int )tmp___107;
#line 4981
          break;
          default: 
#line 4981
          abort();
          }
#line 4983
          break;
          case 3: 
#line 4986
          arg___4 = (int )(a.arg + dp->arg_index)->a.a_short;
#line 4987
          switch ((int )prefix_count) {
          case 0: 
#line 4987
          tmp___108 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               arg___4, & count___0);
#line 4987
          retcount = (int )tmp___108;
#line 4987
          break;
          case 1: 
#line 4987
          tmp___109 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], arg___4, & count___0);
#line 4987
          retcount = (int )tmp___109;
#line 4987
          break;
          case 2: 
#line 4987
          tmp___110 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], prefixes[1], arg___4, & count___0);
#line 4987
          retcount = (int )tmp___110;
#line 4987
          break;
          default: 
#line 4987
          abort();
          }
#line 4989
          break;
          case 4: 
#line 4992
          arg___5 = (unsigned int )(a.arg + dp->arg_index)->a.a_ushort;
#line 4993
          switch ((int )prefix_count) {
          case 0: 
#line 4993
          tmp___111 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               arg___5, & count___0);
#line 4993
          retcount = (int )tmp___111;
#line 4993
          break;
          case 1: 
#line 4993
          tmp___112 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], arg___5, & count___0);
#line 4993
          retcount = (int )tmp___112;
#line 4993
          break;
          case 2: 
#line 4993
          tmp___113 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], prefixes[1], arg___5, & count___0);
#line 4993
          retcount = (int )tmp___113;
#line 4993
          break;
          default: 
#line 4993
          abort();
          }
#line 4995
          break;
          case 5: 
#line 4998
          arg___6 = (a.arg + dp->arg_index)->a.a_int;
#line 4999
          switch ((int )prefix_count) {
          case 0: 
#line 4999
          tmp___114 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               arg___6, & count___0);
#line 4999
          retcount = (int )tmp___114;
#line 4999
          break;
          case 1: 
#line 4999
          tmp___115 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], arg___6, & count___0);
#line 4999
          retcount = (int )tmp___115;
#line 4999
          break;
          case 2: 
#line 4999
          tmp___116 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], prefixes[1], arg___6, & count___0);
#line 4999
          retcount = (int )tmp___116;
#line 4999
          break;
          default: 
#line 4999
          abort();
          }
#line 5001
          break;
          case 6: 
#line 5004
          arg___7 = (a.arg + dp->arg_index)->a.a_uint;
#line 5005
          switch ((int )prefix_count) {
          case 0: 
#line 5005
          tmp___117 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               arg___7, & count___0);
#line 5005
          retcount = (int )tmp___117;
#line 5005
          break;
          case 1: 
#line 5005
          tmp___118 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], arg___7, & count___0);
#line 5005
          retcount = (int )tmp___118;
#line 5005
          break;
          case 2: 
#line 5005
          tmp___119 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], prefixes[1], arg___7, & count___0);
#line 5005
          retcount = (int )tmp___119;
#line 5005
          break;
          default: 
#line 5005
          abort();
          }
#line 5007
          break;
          case 7: 
#line 5010
          arg___8 = (a.arg + dp->arg_index)->a.a_longint;
#line 5011
          switch ((int )prefix_count) {
          case 0: 
#line 5011
          tmp___120 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               arg___8, & count___0);
#line 5011
          retcount = (int )tmp___120;
#line 5011
          break;
          case 1: 
#line 5011
          tmp___121 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], arg___8, & count___0);
#line 5011
          retcount = (int )tmp___121;
#line 5011
          break;
          case 2: 
#line 5011
          tmp___122 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], prefixes[1], arg___8, & count___0);
#line 5011
          retcount = (int )tmp___122;
#line 5011
          break;
          default: 
#line 5011
          abort();
          }
#line 5013
          break;
          case 8: 
#line 5016
          arg___9 = (a.arg + dp->arg_index)->a.a_ulongint;
#line 5017
          switch ((int )prefix_count) {
          case 0: 
#line 5017
          tmp___123 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               arg___9, & count___0);
#line 5017
          retcount = (int )tmp___123;
#line 5017
          break;
          case 1: 
#line 5017
          tmp___124 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], arg___9, & count___0);
#line 5017
          retcount = (int )tmp___124;
#line 5017
          break;
          case 2: 
#line 5017
          tmp___125 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], prefixes[1], arg___9, & count___0);
#line 5017
          retcount = (int )tmp___125;
#line 5017
          break;
          default: 
#line 5017
          abort();
          }
#line 5019
          break;
          case 9: 
#line 5023
          arg___10 = (a.arg + dp->arg_index)->a.a_longlongint;
#line 5024
          switch ((int )prefix_count) {
          case 0: 
#line 5024
          tmp___126 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               arg___10, & count___0);
#line 5024
          retcount = (int )tmp___126;
#line 5024
          break;
          case 1: 
#line 5024
          tmp___127 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], arg___10, & count___0);
#line 5024
          retcount = (int )tmp___127;
#line 5024
          break;
          case 2: 
#line 5024
          tmp___128 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], prefixes[1], arg___10, & count___0);
#line 5024
          retcount = (int )tmp___128;
#line 5024
          break;
          default: 
#line 5024
          abort();
          }
#line 5026
          break;
          case 10: 
#line 5029
          arg___11 = (a.arg + dp->arg_index)->a.a_ulonglongint;
#line 5030
          switch ((int )prefix_count) {
          case 0: 
#line 5030
          tmp___129 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               arg___11, & count___0);
#line 5030
          retcount = (int )tmp___129;
#line 5030
          break;
          case 1: 
#line 5030
          tmp___130 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], arg___11, & count___0);
#line 5030
          retcount = (int )tmp___130;
#line 5030
          break;
          case 2: 
#line 5030
          tmp___131 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], prefixes[1], arg___11, & count___0);
#line 5030
          retcount = (int )tmp___131;
#line 5030
          break;
          default: 
#line 5030
          abort();
          }
#line 5032
          break;
          case 11: 
#line 5036
          arg___12 = (a.arg + dp->arg_index)->a.a_double;
#line 5037
          switch ((int )prefix_count) {
          case 0: 
#line 5037
          tmp___132 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               arg___12, & count___0);
#line 5037
          retcount = (int )tmp___132;
#line 5037
          break;
          case 1: 
#line 5037
          tmp___133 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], arg___12, & count___0);
#line 5037
          retcount = (int )tmp___133;
#line 5037
          break;
          case 2: 
#line 5037
          tmp___134 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], prefixes[1], arg___12, & count___0);
#line 5037
          retcount = (int )tmp___134;
#line 5037
          break;
          default: 
#line 5037
          abort();
          }
#line 5039
          break;
          case 12: 
#line 5042
          arg___13 = (a.arg + dp->arg_index)->a.a_longdouble;
#line 5043
          switch ((int )prefix_count) {
          case 0: 
#line 5043
          tmp___135 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               arg___13, & count___0);
#line 5043
          retcount = (int )tmp___135;
#line 5043
          break;
          case 1: 
#line 5043
          tmp___136 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], arg___13, & count___0);
#line 5043
          retcount = (int )tmp___136;
#line 5043
          break;
          case 2: 
#line 5043
          tmp___137 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], prefixes[1], arg___13, & count___0);
#line 5043
          retcount = (int )tmp___137;
#line 5043
          break;
          default: 
#line 5043
          abort();
          }
#line 5045
          break;
          case 13: 
#line 5048
          arg___14 = (a.arg + dp->arg_index)->a.a_char;
#line 5049
          switch ((int )prefix_count) {
          case 0: 
#line 5049
          tmp___138 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               arg___14, & count___0);
#line 5049
          retcount = (int )tmp___138;
#line 5049
          break;
          case 1: 
#line 5049
          tmp___139 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], arg___14, & count___0);
#line 5049
          retcount = (int )tmp___139;
#line 5049
          break;
          case 2: 
#line 5049
          tmp___140 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], prefixes[1], arg___14, & count___0);
#line 5049
          retcount = (int )tmp___140;
#line 5049
          break;
          default: 
#line 5049
          abort();
          }
#line 5051
          break;
          case 14: 
#line 5055
          arg___15 = (a.arg + dp->arg_index)->a.a_wide_char;
#line 5056
          switch ((int )prefix_count) {
          case 0: 
#line 5056
          tmp___141 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               arg___15, & count___0);
#line 5056
          retcount = (int )tmp___141;
#line 5056
          break;
          case 1: 
#line 5056
          tmp___142 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], arg___15, & count___0);
#line 5056
          retcount = (int )tmp___142;
#line 5056
          break;
          case 2: 
#line 5056
          tmp___143 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], prefixes[1], arg___15, & count___0);
#line 5056
          retcount = (int )tmp___143;
#line 5056
          break;
          default: 
#line 5056
          abort();
          }
#line 5058
          break;
          case 15: 
#line 5062
          arg___16 = (a.arg + dp->arg_index)->a.a_string;
#line 5063
          switch ((int )prefix_count) {
          case 0: 
#line 5063
          tmp___144 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               arg___16, & count___0);
#line 5063
          retcount = (int )tmp___144;
#line 5063
          break;
          case 1: 
#line 5063
          tmp___145 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], arg___16, & count___0);
#line 5063
          retcount = (int )tmp___145;
#line 5063
          break;
          case 2: 
#line 5063
          tmp___146 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], prefixes[1], arg___16, & count___0);
#line 5063
          retcount = (int )tmp___146;
#line 5063
          break;
          default: 
#line 5063
          abort();
          }
#line 5065
          break;
          case 16: 
#line 5069
          arg___17 = (a.arg + dp->arg_index)->a.a_wide_string;
#line 5070
          switch ((int )prefix_count) {
          case 0: 
#line 5070
          tmp___147 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               arg___17, & count___0);
#line 5070
          retcount = (int )tmp___147;
#line 5070
          break;
          case 1: 
#line 5070
          tmp___148 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], arg___17, & count___0);
#line 5070
          retcount = (int )tmp___148;
#line 5070
          break;
          case 2: 
#line 5070
          tmp___149 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], prefixes[1], arg___17, & count___0);
#line 5070
          retcount = (int )tmp___149;
#line 5070
          break;
          default: 
#line 5070
          abort();
          }
#line 5072
          break;
          case 17: 
#line 5076
          arg___18 = (a.arg + dp->arg_index)->a.a_pointer;
#line 5077
          switch ((int )prefix_count) {
          case 0: 
#line 5077
          tmp___150 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               arg___18, & count___0);
#line 5077
          retcount = (int )tmp___150;
#line 5077
          break;
          case 1: 
#line 5077
          tmp___151 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], arg___18, & count___0);
#line 5077
          retcount = (int )tmp___151;
#line 5077
          break;
          case 2: 
#line 5077
          tmp___152 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], prefixes[1], arg___18, & count___0);
#line 5077
          retcount = (int )tmp___152;
#line 5077
          break;
          default: 
#line 5077
          abort();
          }
#line 5079
          break;
          default: 
#line 5081
          abort();
          }
#line 5089
          if (count___0 >= 0) {
#line 5093
            if ((size_t )count___0 < maxlen) {
#line 5093
              if ((int )*((result + length) + count___0) != 0) {
#line 5095
                abort();
              }
            }
#line 5097
            if (retcount > count___0) {
#line 5098
              count___0 = retcount;
            }
          } else
#line 5104
          if ((int )*(fbp + 1) != 0) {
#line 5108
            *(fbp + 1) = (char )'\000';
#line 5109
            goto __Cont;
          } else
#line 5114
          if (! (retcount < 0)) {
#line 5156
            count___0 = retcount;
          }
#line 5162
          if (count___0 < 0) {
#line 5166
            tmp___153 = __errno_location();
#line 5166
            saved_errno = *tmp___153;
#line 5168
            if (! ((unsigned long )result == (unsigned long )resultbuf)) {
#line 5168
              if (! ((unsigned long )result == (unsigned long )((void *)0))) {
#line 5169
                free((void *)result);
              }
            }
#line 5170
            if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
#line 5171
              free((void *)buf_malloced);
            }
#line 5172
            if ((unsigned long )d.dir != (unsigned long )(d.direct_alloc_dir)) {
#line 5172
              free((void *)d.dir);
            }
#line 5172
            if ((unsigned long )a.arg != (unsigned long )(a.direct_alloc_arg)) {
#line 5172
              free((void *)a.arg);
            }
#line 5173
            tmp___154 = __errno_location();
#line 5173
            if (saved_errno != 0) {
#line 5173
              *tmp___154 = saved_errno;
            } else {
#line 5173
              if ((int )dp->conversion == 99) {
#line 5173
                tmp___155 = 84;
              } else
#line 5173
              if ((int )dp->conversion == 115) {
#line 5173
                tmp___155 = 84;
              } else {
#line 5173
                tmp___155 = 22;
              }
#line 5173
              *tmp___154 = tmp___155;
            }
#line 5179
            return ((char *)((void *)0));
          }
#line 5188
          if ((size_t )((unsigned int )count___0 + 1U) >= maxlen) {
#line 5193
            if (maxlen == 2147483647UL / (sizeof(char ) / sizeof(char ))) {
#line 5194
              goto overflow;
            } else {
#line 5206
              if (allocated <= 9223372036854775807UL) {
#line 5206
                tmp___156 = allocated * 2UL;
              } else {
#line 5206
                tmp___156 = 0xffffffffffffffffUL;
              }
#line 5206
              tmp___157 = xsum(length, (((unsigned long )((unsigned int )count___0 + 2U) + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char )));
#line 5206
              tmp___158 = xmax((size_t )tmp___157, tmp___156);
#line 5206
              n___3 = (size_t )tmp___158;
#line 5213
              if (n___3 > allocated) {
#line 5213
                if (allocated > 0UL) {
#line 5213
                  if (allocated <= 9223372036854775807UL) {
#line 5213
                    tmp___159 = allocated * 2UL;
                  } else {
#line 5213
                    tmp___159 = 0xffffffffffffffffUL;
                  }
#line 5213
                  allocated = tmp___159;
                } else {
#line 5213
                  allocated = (size_t )12;
                }
#line 5213
                if (n___3 > allocated) {
#line 5213
                  allocated = n___3;
                }
#line 5213
                if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
#line 5213
                  memory_size___3 = allocated * sizeof(char );
                } else {
#line 5213
                  memory_size___3 = 0xffffffffffffffffUL;
                }
#line 5213
                if (memory_size___3 == 0xffffffffffffffffUL) {
#line 5213
                  goto out_of_memory;
                }
#line 5213
                if ((unsigned long )result == (unsigned long )resultbuf) {
#line 5213
                  tmp___160 = malloc(memory_size___3);
#line 5213
                  memory___3 = (char *)tmp___160;
                } else
#line 5213
                if ((unsigned long )result == (unsigned long )((void *)0)) {
#line 5213
                  tmp___160 = malloc(memory_size___3);
#line 5213
                  memory___3 = (char *)tmp___160;
                } else {
#line 5213
                  tmp___161 = realloc((void *)result, memory_size___3);
#line 5213
                  memory___3 = (char *)tmp___161;
                }
#line 5213
                if ((unsigned long )memory___3 == (unsigned long )((void *)0)) {
#line 5213
                  goto out_of_memory;
                }
#line 5213
                if ((unsigned long )result == (unsigned long )resultbuf) {
#line 5213
                  if (length > 0UL) {
#line 5213
                    memcpy((void * __restrict  )memory___3, (void const   * __restrict  )result,
                           length);
                  }
                }
#line 5213
                result = memory___3;
              }
#line 5214
              goto __Cont;
            }
          }
#line 5510
          length += (size_t )count___0;
#line 5511
          break;
          __Cont: ;
        }
#line 5513
        tmp___162 = __errno_location();
#line 5513
        *tmp___162 = orig_errno;
      }
    }
#line 1844
    cp = dp->dir_end;
#line 1844
    i ++;
#line 1844
    dp ++;
  }
#line 5521
  tmp___169 = xsum(length, (size_t )1);
#line 5521
  if (tmp___169 > (size_t __attribute__((__pure__))  )allocated) {
#line 5521
    if (allocated > 0UL) {
#line 5521
      if (allocated <= 9223372036854775807UL) {
#line 5521
        tmp___164 = allocated * 2UL;
      } else {
#line 5521
        tmp___164 = 0xffffffffffffffffUL;
      }
#line 5521
      allocated = tmp___164;
    } else {
#line 5521
      allocated = (size_t )12;
    }
#line 5521
    tmp___166 = xsum(length, (size_t )1);
#line 5521
    if (tmp___166 > (size_t __attribute__((__pure__))  )allocated) {
#line 5521
      tmp___165 = xsum(length, (size_t )1);
#line 5521
      allocated = (size_t )tmp___165;
    }
#line 5521
    if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
#line 5521
      memory_size___4 = allocated * sizeof(char );
    } else {
#line 5521
      memory_size___4 = 0xffffffffffffffffUL;
    }
#line 5521
    if (memory_size___4 == 0xffffffffffffffffUL) {
#line 5521
      goto out_of_memory;
    }
#line 5521
    if ((unsigned long )result == (unsigned long )resultbuf) {
#line 5521
      tmp___167 = malloc(memory_size___4);
#line 5521
      memory___4 = (char *)tmp___167;
    } else
#line 5521
    if ((unsigned long )result == (unsigned long )((void *)0)) {
#line 5521
      tmp___167 = malloc(memory_size___4);
#line 5521
      memory___4 = (char *)tmp___167;
    } else {
#line 5521
      tmp___168 = realloc((void *)result, memory_size___4);
#line 5521
      memory___4 = (char *)tmp___168;
    }
#line 5521
    if ((unsigned long )memory___4 == (unsigned long )((void *)0)) {
#line 5521
      goto out_of_memory;
    }
#line 5521
    if ((unsigned long )result == (unsigned long )resultbuf) {
#line 5521
      if (length > 0UL) {
#line 5521
        memcpy((void * __restrict  )memory___4, (void const   * __restrict  )result,
               length);
      }
    }
#line 5521
    result = memory___4;
  }
#line 5522
  *(result + length) = (char )'\000';
#line 5524
  if ((unsigned long )result != (unsigned long )resultbuf) {
#line 5524
    if (length + 1UL < allocated) {
#line 5529
      tmp___170 = realloc((void *)result, (length + 1UL) * sizeof(char ));
#line 5529
      memory___5 = (char *)tmp___170;
#line 5530
      if ((unsigned long )memory___5 != (unsigned long )((void *)0)) {
#line 5531
        result = memory___5;
      }
    }
  }
#line 5534
  if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
#line 5535
    free((void *)buf_malloced);
  }
#line 5536
  if ((unsigned long )d.dir != (unsigned long )(d.direct_alloc_dir)) {
#line 5536
    free((void *)d.dir);
  }
#line 5536
  if ((unsigned long )a.arg != (unsigned long )(a.direct_alloc_arg)) {
#line 5536
    free((void *)a.arg);
  }
#line 5537
  *lengthp = length;
#line 5542
  return (result);
  overflow: 
#line 5546
  if (! ((unsigned long )result == (unsigned long )resultbuf)) {
#line 5546
    if (! ((unsigned long )result == (unsigned long )((void *)0))) {
#line 5547
      free((void *)result);
    }
  }
#line 5548
  if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
#line 5549
    free((void *)buf_malloced);
  }
#line 5550
  if ((unsigned long )d.dir != (unsigned long )(d.direct_alloc_dir)) {
#line 5550
    free((void *)d.dir);
  }
#line 5550
  if ((unsigned long )a.arg != (unsigned long )(a.direct_alloc_arg)) {
#line 5550
    free((void *)a.arg);
  }
#line 5551
  tmp___171 = __errno_location();
#line 5551
  *tmp___171 = 75;
#line 5552
  return ((char *)((void *)0));
  out_of_memory: 
#line 5556
  if (! ((unsigned long )result == (unsigned long )resultbuf)) {
#line 5556
    if (! ((unsigned long )result == (unsigned long )((void *)0))) {
#line 5557
      free((void *)result);
    }
  }
#line 5558
  if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
#line 5559
    free((void *)buf_malloced);
  }
  out_of_memory_1: 
#line 5561
  if ((unsigned long )d.dir != (unsigned long )(d.direct_alloc_dir)) {
#line 5561
    free((void *)d.dir);
  }
#line 5561
  if ((unsigned long )a.arg != (unsigned long )(a.direct_alloc_arg)) {
#line 5561
    free((void *)a.arg);
  }
#line 5562
  tmp___172 = __errno_location();
#line 5562
  *tmp___172 = 12;
#line 5563
  return ((char *)((void *)0));
}
}
#line 1 "vasprintf.o"
#pragma merger(0,"/tmp/cil-erGuNYNJ.i","-g,-O2")
#line 35 "vasprintf.c"
int rpl_vasprintf(char **resultp , char const   *format , va_list args )  __attribute__((__nonnull__(1,2))) ;
#line 35 "vasprintf.c"
int rpl_vasprintf(char **resultp , char const   *format , va_list args ) 
{ size_t length ;
  char *result ;
  char *tmp ;
  int *tmp___0 ;

  {
#line 39
  tmp = vasnprintf((char *)((void *)0), & length, format, args);
#line 39
  result = tmp;
#line 40
  if ((unsigned long )result == (unsigned long )((void *)0)) {
#line 41
    return (-1);
  }
#line 43
  if (length > 2147483647UL) {
#line 45
    free((void *)result);
#line 46
    tmp___0 = __errno_location();
#line 46
    *tmp___0 = 75;
#line 47
    return (-1);
  }
#line 50
  *resultp = result;
#line 52
  return ((int )length);
}
}
#line 1 "vfprintf.o"
#pragma merger(0,"/tmp/cil-8LxvdfxO.i","-g,-O2")
#line 37 "vfprintf.c"
int rpl_vfprintf(FILE *fp , char const   *format , va_list args )  __attribute__((__nonnull__(1,2))) ;
#line 37 "vfprintf.c"
int rpl_vfprintf(FILE *fp , char const   *format , va_list args ) 
{ char buf___1[2000] ;
  char *output ;
  size_t len ;
  size_t lenbuf ;
  int saved_errno ;
  int *tmp ;
  int *tmp___0 ;
  size_t __attribute__((__nonnull__(1,4)))  tmp___1 ;
  int *tmp___2 ;

  {
#line 43
  lenbuf = sizeof(buf___1);
#line 45
  output = vasnprintf(buf___1, & lenbuf, format, args);
#line 46
  len = lenbuf;
#line 48
  if (! output) {
#line 50
    fseterr(fp);
#line 51
    return (-1);
  }
#line 54
  tmp___1 = rpl_fwrite((void const   *)output, (size_t )1, len, fp);
#line 54
  if (tmp___1 < (size_t __attribute__((__nonnull__(1,4)))  )len) {
#line 56
    if ((unsigned long )output != (unsigned long )(buf___1)) {
#line 58
      tmp = __errno_location();
#line 58
      saved_errno = *tmp;
#line 59
      free((void *)output);
#line 60
      tmp___0 = __errno_location();
#line 60
      *tmp___0 = saved_errno;
    }
#line 62
    return (-1);
  }
#line 65
  if ((unsigned long )output != (unsigned long )(buf___1)) {
#line 66
    free((void *)output);
  }
#line 68
  if (len > 2147483647UL) {
#line 70
    tmp___2 = __errno_location();
#line 70
    *tmp___2 = 75;
#line 71
    fseterr(fp);
#line 72
    return (-1);
  }
#line 75
  return ((int )len);
}
}
#line 1 "vprintf.o"
#pragma merger(0,"/tmp/cil-zqCZTQVt.i","-g,-O2")
#line 31 "vprintf.c"
int rpl_vprintf(char const   *format , va_list args )  __attribute__((__nonnull__(1))) ;
#line 31 "vprintf.c"
int rpl_vprintf(char const   *format , va_list args ) 
{ int tmp ;

  {
#line 34
  tmp = rpl_vfprintf(stdout, format, args);
#line 34
  return (tmp);
}
}
#line 1 "euidaccess-stat.o"
#pragma merger(0,"/tmp/cil-5AJPyIUq.i","-g,-O2")
#line 5 "euidaccess-stat.h"
_Bool euidaccess_stat(struct stat  const  *st , int mode ) ;
#line 703 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __gid_t getegid(void) ;
#line 712
extern  __attribute__((__nothrow__)) int group_member(__gid_t __gid ) ;
#line 41 "euidaccess-stat.c"
_Bool euidaccess_stat(struct stat  const  *st , int mode ) 
{ uid_t euid ;
  unsigned int granted ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  gid_t egid ;
  __gid_t tmp___11 ;
  int tmp___12 ;

  {
#line 49
  mode &= 7;
#line 55
  if (mode == 0) {
#line 56
    return ((_Bool)1);
  }
#line 58
  euid = geteuid();
#line 62
  if (euid == 0U) {
#line 62
    if ((mode & 1) == 0) {
#line 64
      return ((_Bool)1);
    } else
#line 62
    if (st->st_mode & (unsigned int const   )((64 | (64 >> 3)) | ((64 >> 3) >> 3))) {
#line 64
      return ((_Bool)1);
    }
  }
#line 67
  if (256 == 4 << 6) {
#line 67
    if (128 == 2 << 6) {
#line 67
      if (64 == 1 << 6) {
#line 67
        if (256 >> 3 == 4 << 3) {
#line 67
          if (128 >> 3 == 2 << 3) {
#line 67
            if (64 >> 3 == 1 << 3) {
#line 67
              if ((256 >> 3) >> 3 == 4) {
#line 67
                if ((128 >> 3) >> 3 == 2) {
#line 67
                  if ((64 >> 3) >> 3 == 1) {
#line 76
                    granted = (unsigned int )st->st_mode;
                  } else {
#line 67
                    goto _L___6;
                  }
                } else {
#line 67
                  goto _L___6;
                }
              } else {
#line 67
                goto _L___6;
              }
            } else {
#line 67
              goto _L___6;
            }
          } else {
#line 67
            goto _L___6;
          }
        } else {
#line 67
          goto _L___6;
        }
      } else {
#line 67
        goto _L___6;
      }
    } else {
#line 67
      goto _L___6;
    }
  } else {
    _L___6: 
#line 78
    if (st->st_mode & 256U) {
#line 78
      tmp___2 = 4 << 6;
    } else {
#line 78
      tmp___2 = 0;
    }
#line 78
    if (st->st_mode & 128U) {
#line 78
      tmp___3 = 2 << 6;
    } else {
#line 78
      tmp___3 = 0;
    }
#line 78
    if (st->st_mode & 64U) {
#line 78
      tmp___4 = 1 << 6;
    } else {
#line 78
      tmp___4 = 0;
    }
#line 78
    if (st->st_mode & (unsigned int const   )(256 >> 3)) {
#line 78
      tmp___5 = 4 << 3;
    } else {
#line 78
      tmp___5 = 0;
    }
#line 78
    if (st->st_mode & (unsigned int const   )(128 >> 3)) {
#line 78
      tmp___6 = 2 << 3;
    } else {
#line 78
      tmp___6 = 0;
    }
#line 78
    if (st->st_mode & (unsigned int const   )(64 >> 3)) {
#line 78
      tmp___7 = 1 << 3;
    } else {
#line 78
      tmp___7 = 0;
    }
#line 78
    if (st->st_mode & (unsigned int const   )((256 >> 3) >> 3)) {
#line 78
      tmp___8 = 4;
    } else {
#line 78
      tmp___8 = 0;
    }
#line 78
    if (st->st_mode & (unsigned int const   )((128 >> 3) >> 3)) {
#line 78
      tmp___9 = 2;
    } else {
#line 78
      tmp___9 = 0;
    }
#line 78
    if (st->st_mode & (unsigned int const   )((64 >> 3) >> 3)) {
#line 78
      tmp___10 = 1;
    } else {
#line 78
      tmp___10 = 0;
    }
#line 78
    granted = (unsigned int )((((((((tmp___2 + tmp___3) + tmp___4) + tmp___5) + tmp___6) + tmp___7) + tmp___8) + tmp___9) + tmp___10);
  }
#line 88
  if (euid == (uid_t )st->st_uid) {
#line 89
    granted >>= 6;
  } else {
#line 92
    tmp___11 = getegid();
#line 92
    egid = tmp___11;
#line 93
    if (egid == (gid_t )st->st_gid) {
#line 94
      granted >>= 3;
    } else {
#line 93
      tmp___12 = group_member((__gid_t )st->st_gid);
#line 93
      if (tmp___12) {
#line 94
        granted >>= 3;
      }
    }
  }
#line 97
  if (((unsigned int )mode & ~ granted) == 0U) {
#line 98
    return ((_Bool)1);
  }
#line 100
  return ((_Bool)0);
}
}
#line 1 "fd-reopen.o"
#pragma merger(0,"/tmp/cil-Vxw0xUtd.i","-g,-O2")
#line 22 "fd-reopen.h"
int fd_reopen(int desired_fd , char const   *file , int flags , mode_t mode ) ;
#line 31 "fd-reopen.c"
int fd_reopen(int desired_fd , char const   *file , int flags , mode_t mode ) 
{ int fd ;
  int __attribute__((__artificial__))  tmp ;
  int fd2 ;
  int tmp___0 ;
  int saved_errno ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
#line 34
  tmp = open(file, flags, mode);
#line 34
  fd = (int )tmp;
#line 36
  if (fd == desired_fd) {
#line 37
    return (fd);
  } else
#line 36
  if (fd < 0) {
#line 37
    return (fd);
  } else {
#line 40
    tmp___0 = dup2(fd, desired_fd);
#line 40
    fd2 = tmp___0;
#line 41
    tmp___1 = __errno_location();
#line 41
    saved_errno = *tmp___1;
#line 42
    close(fd);
#line 43
    tmp___2 = __errno_location();
#line 43
    *tmp___2 = saved_errno;
#line 44
    return (fd2);
  }
}
}
#line 1 "xfts.o"
#pragma merger(0,"/tmp/cil-qAsTti2K.i","-g,-O2")
#line 4 "xfts.h"
FTS *xfts_open(char * const  *argv , int options , int (*compar)(FTSENT const   ** ,
                                                                 FTSENT const   ** ) ) ;
#line 8
_Bool cycle_warning_required(FTS const   *fts , FTSENT const   *ent )  __attribute__((__pure__)) ;
#line 32 "xfts.c"
FTS *xfts_open(char * const  *argv , int options , int (*compar)(FTSENT const   ** ,
                                                                 FTSENT const   ** ) ) 
{ FTS *fts ;
  FTS *tmp ;
  int *tmp___0 ;

  {
#line 36
  tmp = fts_open(argv, options | 512, compar);
#line 36
  fts = tmp;
#line 37
  if ((unsigned long )fts == (unsigned long )((void *)0)) {
#line 41
    tmp___0 = __errno_location();
#line 41
    if (! (*tmp___0 != 22)) {
#line 41
      __assert_fail("(*__errno_location ()) != 22", "xfts.c", 41U, "xfts_open");
    }
#line 42
    xalloc_die();
  }
#line 45
  return (fts);
}
}
#line 55
_Bool cycle_warning_required(FTS const   *fts , FTSENT const   *ent )  __attribute__((__pure__)) ;
#line 55 "xfts.c"
_Bool cycle_warning_required(FTS const   *fts , FTSENT const   *ent ) 
{ int tmp ;

  {
#line 62
  if (fts->fts_options & 16) {
#line 62
    if (! (fts->fts_options & 1)) {
#line 62
      tmp = 1;
    } else {
#line 62
      goto _L;
    }
  } else
  _L: 
#line 62
  if (fts->fts_options & 16) {
#line 62
    if (fts->fts_options & 1) {
#line 62
      if (ent->fts_level != 0L) {
#line 62
        tmp = 1;
      } else {
#line 62
        tmp = 0;
      }
    } else {
#line 62
      tmp = 0;
    }
  } else {
#line 62
    tmp = 0;
  }
#line 62
  return ((_Bool )tmp);
}
}
#line 1 "strintcmp.o"
#pragma merger(0,"/tmp/cil-ifXXJfgr.i","-g,-O2")
#line 1 "strnumcmp.h"
int strintcmp(char const   *a , char const   *b )  __attribute__((__pure__)) ;
#line 74 "strnumcmp-in.h"
__inline static int __attribute__((__pure__))  fraccompare(char const   *a , char const   *b ,
                                                           char decimal_point ) 
{ char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 77
  if ((int const   )*a == (int const   )decimal_point) {
#line 77
    if ((int const   )*b == (int const   )decimal_point) {
#line 79
      while (1) {
#line 79
        a ++;
#line 79
        b ++;
#line 79
        if (! ((int const   )*a == (int const   )*b)) {
#line 79
          break;
        }
#line 80
        if (! ((unsigned int )*a - 48U <= 9U)) {
#line 81
          return ((int __attribute__((__pure__))  )0);
        }
      }
#line 82
      if ((unsigned int )*a - 48U <= 9U) {
#line 82
        if ((unsigned int )*b - 48U <= 9U) {
#line 83
          return ((int __attribute__((__pure__))  )((int const   )*a - (int const   )*b));
        }
      }
#line 84
      if ((unsigned int )*a - 48U <= 9U) {
#line 85
        goto a_trailing_nonzero;
      }
#line 86
      if ((unsigned int )*b - 48U <= 9U) {
#line 87
        goto b_trailing_nonzero;
      }
#line 88
      return ((int __attribute__((__pure__))  )0);
    } else {
#line 77
      goto _L;
    }
  } else {
    _L: 
#line 90
    tmp___0 = a;
#line 90
    a ++;
#line 90
    if ((int const   )*tmp___0 == (int const   )decimal_point) {
      a_trailing_nonzero: 
#line 93
      while ((int const   )*a == 48) {
#line 94
        a ++;
      }
#line 95
      return ((int __attribute__((__pure__))  )((unsigned int )*a - 48U <= 9U));
    } else {
#line 97
      tmp = b;
#line 97
      b ++;
#line 97
      if ((int const   )*tmp == (int const   )decimal_point) {
        b_trailing_nonzero: 
#line 100
        while ((int const   )*b == 48) {
#line 101
          b ++;
        }
#line 102
        return ((int __attribute__((__pure__))  )(- ((unsigned int )*b - 48U <= 9U)));
      }
    }
  }
#line 104
  return ((int __attribute__((__pure__))  )0);
}
}
#line 114 "strnumcmp-in.h"
__inline static int __attribute__((__pure__))  numcompare(char const   *a , char const   *b ,
                                                          int decimal_point , int thousands_sep ) 
{ unsigned char tmpa ;
  unsigned char tmpb ;
  int tmp ;
  size_t log_a ;
  size_t log_b ;
  int __attribute__((__pure__))  tmp___0 ;
  int tmp___1 ;
  int __attribute__((__pure__))  tmp___2 ;
  int tmp___3 ;

  {
#line 118
  tmpa = (unsigned char )*a;
#line 119
  tmpb = (unsigned char )*b;
#line 124
  if ((int )tmpa == 45) {
#line 126
    while (1) {
#line 127
      a ++;
#line 127
      tmpa = (unsigned char )*a;
#line 126
      if (! ((int )tmpa == 48)) {
#line 126
        if (! ((int )tmpa == thousands_sep)) {
#line 126
          break;
        }
      }
    }
#line 129
    if ((int )tmpb != 45) {
#line 131
      if ((int )tmpa == decimal_point) {
#line 132
        while (1) {
#line 133
          a ++;
#line 133
          tmpa = (unsigned char )*a;
#line 132
          if (! ((int )tmpa == 48)) {
#line 132
            break;
          }
        }
      }
#line 135
      if ((unsigned int )tmpa - 48U <= 9U) {
#line 136
        return ((int __attribute__((__pure__))  )-1);
      }
#line 137
      while (1) {
#line 137
        if (! ((int )tmpb == 48)) {
#line 137
          if (! ((int )tmpb == thousands_sep)) {
#line 137
            break;
          }
        }
#line 138
        b ++;
#line 138
        tmpb = (unsigned char )*b;
      }
#line 139
      if ((int )tmpb == decimal_point) {
#line 140
        while (1) {
#line 141
          b ++;
#line 141
          tmpb = (unsigned char )*b;
#line 140
          if (! ((int )tmpb == 48)) {
#line 140
            break;
          }
        }
      }
#line 143
      return ((int __attribute__((__pure__))  )(- ((unsigned int )tmpb - 48U <= 9U)));
    }
#line 145
    while (1) {
#line 146
      b ++;
#line 146
      tmpb = (unsigned char )*b;
#line 145
      if (! ((int )tmpb == 48)) {
#line 145
        if (! ((int )tmpb == thousands_sep)) {
#line 145
          break;
        }
      }
    }
#line 149
    while (1) {
#line 149
      if ((int )tmpa == (int )tmpb) {
#line 149
        if (! ((unsigned int )tmpa - 48U <= 9U)) {
#line 149
          break;
        }
      } else {
#line 149
        break;
      }
#line 151
      while (1) {
#line 152
        a ++;
#line 152
        tmpa = (unsigned char )*a;
#line 151
        if (! ((int )tmpa == thousands_sep)) {
#line 151
          break;
        }
      }
#line 154
      while (1) {
#line 155
        b ++;
#line 155
        tmpb = (unsigned char )*b;
#line 154
        if (! ((int )tmpb == thousands_sep)) {
#line 154
          break;
        }
      }
    }
#line 159
    if ((int )tmpa == decimal_point) {
#line 159
      if (! ((unsigned int )tmpb - 48U <= 9U)) {
#line 161
        tmp___0 = fraccompare(b, a, (char )decimal_point);
#line 161
        return (tmp___0);
      } else {
#line 159
        goto _L;
      }
    } else
    _L: 
#line 159
    if ((int )tmpb == decimal_point) {
#line 159
      if (! ((unsigned int )tmpa - 48U <= 9U)) {
#line 161
        tmp___0 = fraccompare(b, a, (char )decimal_point);
#line 161
        return (tmp___0);
      }
    }
#line 163
    tmp = (int )tmpb - (int )tmpa;
#line 165
    log_a = (size_t )0;
#line 165
    while ((unsigned int )tmpa - 48U <= 9U) {
#line 166
      while (1) {
#line 167
        a ++;
#line 167
        tmpa = (unsigned char )*a;
#line 166
        if (! ((int )tmpa == thousands_sep)) {
#line 166
          break;
        }
      }
#line 165
      log_a ++;
    }
#line 170
    log_b = (size_t )0;
#line 170
    while ((unsigned int )tmpb - 48U <= 9U) {
#line 171
      while (1) {
#line 172
        b ++;
#line 172
        tmpb = (unsigned char )*b;
#line 171
        if (! ((int )tmpb == thousands_sep)) {
#line 171
          break;
        }
      }
#line 170
      log_b ++;
    }
#line 175
    if (log_a != log_b) {
#line 176
      if (log_a < log_b) {
#line 176
        tmp___1 = 1;
      } else {
#line 176
        tmp___1 = -1;
      }
#line 176
      return ((int __attribute__((__pure__))  )tmp___1);
    }
#line 178
    if (! log_a) {
#line 179
      return ((int __attribute__((__pure__))  )0);
    }
#line 181
    return ((int __attribute__((__pure__))  )tmp);
  } else
#line 183
  if ((int )tmpb == 45) {
#line 185
    while (1) {
#line 186
      b ++;
#line 186
      tmpb = (unsigned char )*b;
#line 185
      if (! ((int )tmpb == 48)) {
#line 185
        if (! ((int )tmpb == thousands_sep)) {
#line 185
          break;
        }
      }
    }
#line 188
    if ((int )tmpb == decimal_point) {
#line 189
      while (1) {
#line 190
        b ++;
#line 190
        tmpb = (unsigned char )*b;
#line 189
        if (! ((int )tmpb == 48)) {
#line 189
          break;
        }
      }
    }
#line 192
    if ((unsigned int )tmpb - 48U <= 9U) {
#line 193
      return ((int __attribute__((__pure__))  )1);
    }
#line 194
    while (1) {
#line 194
      if (! ((int )tmpa == 48)) {
#line 194
        if (! ((int )tmpa == thousands_sep)) {
#line 194
          break;
        }
      }
#line 195
      a ++;
#line 195
      tmpa = (unsigned char )*a;
    }
#line 196
    if ((int )tmpa == decimal_point) {
#line 197
      while (1) {
#line 198
        a ++;
#line 198
        tmpa = (unsigned char )*a;
#line 197
        if (! ((int )tmpa == 48)) {
#line 197
          break;
        }
      }
    }
#line 200
    return ((int __attribute__((__pure__))  )((unsigned int )tmpa - 48U <= 9U));
  } else {
#line 204
    while (1) {
#line 204
      if (! ((int )tmpa == 48)) {
#line 204
        if (! ((int )tmpa == thousands_sep)) {
#line 204
          break;
        }
      }
#line 205
      a ++;
#line 205
      tmpa = (unsigned char )*a;
    }
#line 206
    while (1) {
#line 206
      if (! ((int )tmpb == 48)) {
#line 206
        if (! ((int )tmpb == thousands_sep)) {
#line 206
          break;
        }
      }
#line 207
      b ++;
#line 207
      tmpb = (unsigned char )*b;
    }
#line 209
    while (1) {
#line 209
      if ((int )tmpa == (int )tmpb) {
#line 209
        if (! ((unsigned int )tmpa - 48U <= 9U)) {
#line 209
          break;
        }
      } else {
#line 209
        break;
      }
#line 211
      while (1) {
#line 212
        a ++;
#line 212
        tmpa = (unsigned char )*a;
#line 211
        if (! ((int )tmpa == thousands_sep)) {
#line 211
          break;
        }
      }
#line 214
      while (1) {
#line 215
        b ++;
#line 215
        tmpb = (unsigned char )*b;
#line 214
        if (! ((int )tmpb == thousands_sep)) {
#line 214
          break;
        }
      }
    }
#line 219
    if ((int )tmpa == decimal_point) {
#line 219
      if (! ((unsigned int )tmpb - 48U <= 9U)) {
#line 221
        tmp___2 = fraccompare(a, b, (char )decimal_point);
#line 221
        return (tmp___2);
      } else {
#line 219
        goto _L___0;
      }
    } else
    _L___0: 
#line 219
    if ((int )tmpb == decimal_point) {
#line 219
      if (! ((unsigned int )tmpa - 48U <= 9U)) {
#line 221
        tmp___2 = fraccompare(a, b, (char )decimal_point);
#line 221
        return (tmp___2);
      }
    }
#line 223
    tmp = (int )tmpa - (int )tmpb;
#line 225
    log_a = (size_t )0;
#line 225
    while ((unsigned int )tmpa - 48U <= 9U) {
#line 226
      while (1) {
#line 227
        a ++;
#line 227
        tmpa = (unsigned char )*a;
#line 226
        if (! ((int )tmpa == thousands_sep)) {
#line 226
          break;
        }
      }
#line 225
      log_a ++;
    }
#line 230
    log_b = (size_t )0;
#line 230
    while ((unsigned int )tmpb - 48U <= 9U) {
#line 231
      while (1) {
#line 232
        b ++;
#line 232
        tmpb = (unsigned char )*b;
#line 231
        if (! ((int )tmpb == thousands_sep)) {
#line 231
          break;
        }
      }
#line 230
      log_b ++;
    }
#line 235
    if (log_a != log_b) {
#line 236
      if (log_a < log_b) {
#line 236
        tmp___3 = -1;
      } else {
#line 236
        tmp___3 = 1;
      }
#line 236
      return ((int __attribute__((__pure__))  )tmp___3);
    }
#line 238
    if (! log_a) {
#line 239
      return ((int __attribute__((__pure__))  )0);
    }
#line 241
    return ((int __attribute__((__pure__))  )tmp);
  }
}
}
#line 28 "strintcmp.c"
int strintcmp(char const   *a , char const   *b )  __attribute__((__pure__)) ;
#line 28 "strintcmp.c"
int strintcmp(char const   *a , char const   *b ) 
{ int __attribute__((__pure__))  tmp ;

  {
#line 31
  tmp = numcompare(a, b, -1, -1);
#line 31
  return ((int )tmp);
}
}
#line 1 "strnumcmp.o"
#pragma merger(0,"/tmp/cil-_niqOVMY.i","-g,-O2")
#line 2 "strnumcmp.h"
int __attribute__((__pure__))  strnumcmp(char const   *a , char const   *b , int decimal_point ,
                                         int thousands_sep ) ;
#line 26 "strnumcmp.c"
int __attribute__((__pure__))  strnumcmp(char const   *a , char const   *b , int decimal_point ,
                                         int thousands_sep ) 
{ int __attribute__((__pure__))  tmp ;

  {
#line 30
  tmp = numcompare(a, b, decimal_point, thousands_sep);
#line 30
  return (tmp);
}
}
#line 1 "cil-Wz7vPnXO.o"
#pragma merger(0,"/tmp/cil-vFlNs1iW.i","")
#line 2 "version.c"
char const   *Version  =    "8.13.14-081e2-dirty";
#line 1 "cil-m5nExzQE.o"
#pragma merger(0,"/tmp/cil-SytB_onS.i","")
#line 798 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
#line 518 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int atexit(void (*__func)(void) )  __attribute__((__nonnull__(1))) ;
#line 40 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *gettext(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 83
extern  __attribute__((__nothrow__)) char *textdomain(char const   *__domainname ) ;
#line 87
extern  __attribute__((__nothrow__)) char *bindtextdomain(char const   *__domainname ,
                                                          char const   *__dirname ) ;
#line 519 "system.h"
__inline static void emit_ancillary_info(void) 
{ char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char const   *lc_messages ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
#line 522
  tmp = last_component(program_name);
#line 522
  tmp___0 = gettext("\nReport %s bugs to %s\n");
#line 522
  printf((char const   * __restrict  )tmp___0, tmp, "bug-coreutils@gnu.org");
#line 524
  tmp___1 = gettext("%s home page: <%s>\n");
#line 524
  printf((char const   * __restrict  )tmp___1, "GNU coreutils", "http://www.gnu.org/software/coreutils/");
#line 525
  tmp___2 = gettext("General help using GNU software: <http://www.gnu.org/gethelp/>\n");
#line 525
  fputs_unlocked((char const   * __restrict  )tmp___2, (FILE * __restrict  )stdout);
#line 529
  tmp___3 = setlocale(5, (char const   *)((void *)0));
#line 529
  lc_messages = (char const   *)tmp___3;
#line 530
  if (lc_messages) {
#line 530
    tmp___6 = strncmp(lc_messages, "en_", sizeof("en_") - 1UL);
#line 530
    if (tmp___6) {
#line 536
      tmp___4 = last_component(program_name);
#line 536
      tmp___5 = gettext("Report %s translation bugs to <http://translationproject.org/team/>\n");
#line 536
      printf((char const   * __restrict  )tmp___5, tmp___4);
    }
  }
#line 540
  tmp___7 = last_component(program_name);
#line 540
  tmp___8 = gettext("For complete documentation, run: info coreutils \'%s invocation\'\n");
#line 540
  printf((char const   * __restrict  )tmp___8, tmp___7);
#line 542
  return;
}
}
#line 277 "copy.h"
extern _Bool copy(char const   *src_name , char const   *dst_name , _Bool nonexistent_dst ,
                  struct cp_options  const  *options , _Bool *copy_into_self , _Bool *rename_succeeded ) ;
#line 281
extern void dest_info_init(struct cp_options *x ) ;
#line 284
extern void cp_options_default(struct cp_options *x ) ;
#line 1 "cp-hash.h"
extern void hash_init(void) ;
#line 92 "remove.h"
enum RM_status rm(char * const  *file , struct rm_options  const  *x ) ;
#line 40 "../lib/priv-set.h"
__inline static int priv_set_remove_linkdir(void) 
{ 

  {
#line 42
  return (-1);
}
}
#line 53 "mv.c"
static _Bool remove_trailing_slashes  ;
#line 55 "mv.c"
static struct rpl_option  const  long_options___0[13]  = 
#line 55
  {      {"backup", 2, (int *)((void *)0), 'b'}, 
        {"force", 0, (int *)((void *)0), 'f'}, 
        {"interactive", 0, (int *)((void *)0), 'i'}, 
        {"no-clobber", 0, (int *)((void *)0), 'n'}, 
        {"no-target-directory", 0, (int *)((void *)0), 'T'}, 
        {"strip-trailing-slashes", 0, (int *)((void *)0), 128}, 
        {"suffix", 1, (int *)((void *)0), 'S'}, 
        {"target-directory", 1, (int *)((void *)0), 't'}, 
        {"update", 0, (int *)((void *)0), 'u'}, 
        {"verbose", 0, (int *)((void *)0), 'v'}, 
        {"help", 0, (int *)((void *)0), -130}, 
        {"version", 0, (int *)((void *)0), -131}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
#line 93 "mv.c"
static struct dev_ino dev_ino_buf  ;
#line 72 "mv.c"
static void rm_option_init(struct rm_options *x ) 
{ char const   *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;

  {
#line 75
  x->ignore_missing_files = (_Bool)0;
#line 76
  x->recursive = (_Bool)1;
#line 77
  x->one_file_system = (_Bool)0;
#line 81
  x->interactive = (enum rm_interactive )5;
#line 82
  x->stdin_tty = (_Bool)0;
#line 84
  x->verbose = (_Bool)0;
#line 90
  x->require_restore_cwd = (_Bool)1;
#line 94
  x->root_dev_ino = get_root_dev_ino(& dev_ino_buf);
#line 95
  if ((unsigned long )x->root_dev_ino == (unsigned long )((void *)0)) {
#line 96
    tmp = quote("/");
#line 96
    tmp___0 = gettext("failed to get attributes of %s");
#line 96
    tmp___1 = __errno_location();
#line 96
    error(1, *tmp___1, (char const   *)tmp___0, tmp);
  }
#line 99
  return;
}
}
#line 101 "mv.c"
static void cp_option_init(struct cp_options *x ) 
{ _Bool selinux_enabled ;
  int tmp ;

  {
#line 104
  selinux_enabled = (_Bool)0;
#line 106
  cp_options_default(x);
#line 107
  x->copy_as_regular = (_Bool)0;
#line 108
  x->reflink_mode = (enum Reflink_type )0;
#line 109
  x->dereference = (enum Dereference_symlink )2;
#line 110
  x->unlink_dest_before_opening = (_Bool)0;
#line 111
  x->unlink_dest_after_failed_open = (_Bool)0;
#line 112
  x->hard_link = (_Bool)0;
#line 113
  x->interactive = (enum Interactive )4;
#line 114
  x->move_mode = (_Bool)1;
#line 115
  x->one_file_system = (_Bool)0;
#line 116
  x->preserve_ownership = (_Bool)1;
#line 117
  x->preserve_links = (_Bool)1;
#line 118
  x->preserve_mode = (_Bool)1;
#line 119
  x->preserve_timestamps = (_Bool)1;
#line 120
  x->preserve_security_context = selinux_enabled;
#line 121
  x->reduce_diagnostics = (_Bool)0;
#line 122
  x->data_copy_required = (_Bool)1;
#line 123
  x->require_preserve = (_Bool)0;
#line 124
  x->require_preserve_context = (_Bool)0;
#line 125
  x->preserve_xattr = (_Bool)1;
#line 126
  x->require_preserve_xattr = (_Bool)0;
#line 127
  x->recursive = (_Bool)1;
#line 128
  x->sparse_mode = (enum Sparse_type )2;
#line 129
  x->symbolic_link = (_Bool)0;
#line 130
  x->set_mode = (_Bool)0;
#line 131
  x->mode = (mode_t )0;
#line 132
  tmp = isatty(0);
#line 132
  x->stdin_tty = (_Bool )tmp;
#line 134
  x->open_dangling_dest_symlink = (_Bool)0;
#line 135
  x->update = (_Bool)0;
#line 136
  x->verbose = (_Bool)0;
#line 137
  x->dest_info = (Hash_table *)((void *)0);
#line 138
  x->src_info = (Hash_table *)((void *)0);
#line 139
  return;
}
}
#line 145 "mv.c"
static _Bool target_directory_operand(char const   *file ) 
{ struct stat st ;
  int err ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  _Bool is_a_dir ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;

  {
#line 149
  tmp___2 = stat((char const   * __restrict  )file, (struct stat * __restrict  )(& st));
#line 149
  if (tmp___2 == 0) {
#line 149
    tmp___1 = 0;
  } else {
#line 149
    tmp___0 = __errno_location();
#line 149
    tmp___1 = *tmp___0;
  }
#line 149
  err = tmp___1;
#line 150
  if (! err) {
#line 150
    if ((st.st_mode & 61440U) == 16384U) {
#line 150
      tmp___3 = 1;
    } else {
#line 150
      tmp___3 = 0;
    }
  } else {
#line 150
    tmp___3 = 0;
  }
#line 150
  is_a_dir = (_Bool )tmp___3;
#line 151
  if (err) {
#line 151
    if (err != 2) {
#line 152
      tmp___4 = quote(file);
#line 152
      tmp___5 = gettext("accessing %s");
#line 152
      error(1, err, (char const   *)tmp___5, tmp___4);
    }
  }
#line 153
  return (is_a_dir);
}
}
#line 160 "mv.c"
static _Bool do_move(char const   *source , char const   *dest , struct cp_options  const  *x ) 
{ _Bool copy_into_self ;
  _Bool rename_succeeded ;
  _Bool ok ;
  _Bool tmp ;
  char const   *dir_to_remove ;
  struct rm_options rm_options ;
  enum RM_status status ;
  char const   *dir[2] ;

  {
#line 165
  tmp = copy(source, dest, (_Bool)0, x, & copy_into_self, & rename_succeeded);
#line 165
  ok = tmp;
#line 167
  if (ok) {
#line 170
    if (copy_into_self) {
#line 183
      dir_to_remove = (char const   *)((void *)0);
#line 184
      ok = (_Bool)0;
    } else
#line 186
    if (rename_succeeded) {
#line 190
      dir_to_remove = (char const   *)((void *)0);
    } else {
#line 216
      dir_to_remove = source;
    }
#line 219
    if ((unsigned long )dir_to_remove != (unsigned long )((void *)0)) {
#line 225
      rm_option_init(& rm_options);
#line 226
      rm_options.verbose = (_Bool )x->verbose;
#line 227
      dir[0] = dir_to_remove;
#line 228
      dir[1] = (char const   *)((void *)0);
#line 230
      status = rm((char * const  *)((void *)(dir)), (struct rm_options  const  *)(& rm_options));
#line 231
      if (! ((unsigned int )status == 2U)) {
#line 231
        if (! ((unsigned int )status == 3U)) {
#line 231
          if (! ((unsigned int )status == 4U)) {
#line 231
            __assert_fail("((status) == RM_OK || (status) == RM_USER_DECLINED || (status) == RM_ERROR)",
                          "mv.c", 231U, "do_move");
          }
        }
      }
#line 232
      if ((unsigned int )status == 4U) {
#line 233
        ok = (_Bool)0;
      }
    }
  }
#line 237
  return (ok);
}
}
#line 244 "mv.c"
static _Bool movefile(char *source , char *dest , _Bool dest_is_dir , struct cp_options  const  *x ) 
{ _Bool ok ;
  char const   *src_basename ;
  char *tmp ;
  char *new_dest ;
  char *tmp___0 ;

  {
#line 257
  if (remove_trailing_slashes) {
#line 258
    strip_trailing_slashes(source);
  }
#line 260
  if (dest_is_dir) {
#line 263
    tmp = last_component((char const   *)source);
#line 263
    src_basename = (char const   *)tmp;
#line 264
    tmp___0 = file_name_concat((char const   *)dest, src_basename, (char **)((void *)0));
#line 264
    new_dest = tmp___0;
#line 265
    strip_trailing_slashes(new_dest);
#line 266
    ok = do_move((char const   *)source, (char const   *)new_dest, x);
#line 267
    free((void *)new_dest);
  } else {
#line 271
    ok = do_move((char const   *)source, (char const   *)dest, x);
  }
#line 274
  return (ok);
}
}
#line 277
 __attribute__((__noreturn__)) void usage(int status ) ;
#line 277 "mv.c"
void usage(int status ) 
{ char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;

  {
#line 280
  if (status != 0) {
#line 281
    tmp = gettext("Try `%s --help\' for more information.\n");
#line 281
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp, program_name);
  } else {
#line 285
    tmp___0 = gettext("Usage: %s [OPTION]... [-T] SOURCE DEST\n  or:  %s [OPTION]... SOURCE... DIRECTORY\n  or:  %s [OPTION]... -t DIRECTORY SOURCE...\n");
#line 285
    printf((char const   * __restrict  )tmp___0, program_name, program_name, program_name);
#line 291
    tmp___1 = gettext("Rename SOURCE to DEST, or move SOURCE(s) to DIRECTORY.\n\n");
#line 291
    fputs_unlocked((char const   * __restrict  )tmp___1, (FILE * __restrict  )stdout);
#line 295
    tmp___2 = gettext("Mandatory arguments to long options are mandatory for short options too.\n");
#line 295
    fputs_unlocked((char const   * __restrict  )tmp___2, (FILE * __restrict  )stdout);
#line 298
    tmp___3 = gettext("      --backup[=CONTROL]       make a backup of each existing destination file\n  -b                           like --backup but does not accept an argument\n  -f, --force                  do not prompt before overwriting\n  -i, --interactive            prompt before overwrite\n  -n, --no-clobber             do not overwrite an existing file\nIf you specify more than one of -i, -f, -n, only the final one takes effect.\n");
#line 298
    fputs_unlocked((char const   * __restrict  )tmp___3, (FILE * __restrict  )stdout);
#line 307
    tmp___4 = gettext("      --strip-trailing-slashes  remove any trailing slashes from each SOURCE\n                                 argument\n  -S, --suffix=SUFFIX          override the usual backup suffix\n");
#line 307
    fputs_unlocked((char const   * __restrict  )tmp___4, (FILE * __restrict  )stdout);
#line 312
    tmp___5 = gettext("  -t, --target-directory=DIRECTORY  move all SOURCE arguments into DIRECTORY\n  -T, --no-target-directory    treat DEST as a normal file\n  -u, --update                 move only when the SOURCE file is newer\n                                 than the destination file or when the\n                                 destination file is missing\n  -v, --verbose                explain what is being done\n");
#line 312
    fputs_unlocked((char const   * __restrict  )tmp___5, (FILE * __restrict  )stdout);
#line 320
    tmp___6 = gettext("      --help     display this help and exit\n");
#line 320
    fputs_unlocked((char const   * __restrict  )tmp___6, (FILE * __restrict  )stdout);
#line 321
    tmp___7 = gettext("      --version  output version information and exit\n");
#line 321
    fputs_unlocked((char const   * __restrict  )tmp___7, (FILE * __restrict  )stdout);
#line 322
    tmp___8 = gettext("\nThe backup suffix is `~\', unless set with --suffix or SIMPLE_BACKUP_SUFFIX.\nThe version control method may be selected via the --backup option or through\nthe VERSION_CONTROL environment variable.  Here are the values:\n\n");
#line 322
    fputs_unlocked((char const   * __restrict  )tmp___8, (FILE * __restrict  )stdout);
#line 329
    tmp___9 = gettext("  none, off       never make backups (even if --backup is given)\n  numbered, t     make numbered backups\n  existing, nil   numbered if numbered backups exist, simple otherwise\n  simple, never   always make simple backups\n");
#line 329
    fputs_unlocked((char const   * __restrict  )tmp___9, (FILE * __restrict  )stdout);
#line 335
    emit_ancillary_info();
  }
#line 337
  exit(status);
}
}
#line 340 "mv.c"
int main(int argc , char **argv ) 
{ int c ;
  _Bool ok ;
  _Bool make_backups ;
  char *backup_suffix_string ;
  char *version_control_string ;
  struct cp_options x ;
  char *target_directory ;
  _Bool no_target_directory ;
  int n_files ;
  char **file ;
  char *tmp ;
  struct stat st ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char const   *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char const   *tmp___10 ;
  char *tmp___11 ;
  char const   *tmp___12 ;
  char *tmp___13 ;
  _Bool tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  enum backup_type tmp___18 ;
  int i ;
  _Bool tmp___19 ;
  int tmp___20 ;

  {
#line 345
  make_backups = (_Bool)0;
#line 347
  version_control_string = (char *)((void *)0);
#line 349
  target_directory = (char *)((void *)0);
#line 350
  no_target_directory = (_Bool)0;
#line 355
  set_program_name((char const   *)*(argv + 0));
#line 356
  setlocale(6, "");
#line 357
  bindtextdomain("coreutils", "/usr/local/share/locale");
#line 358
  textdomain("coreutils");
#line 360
  atexit(& close_stdin);
#line 362
  cp_option_init(& x);
#line 365
  priv_set_remove_linkdir();
#line 369
  backup_suffix_string = getenv("SIMPLE_BACKUP_SUFFIX");
#line 371
  while (1) {
#line 371
    c = rpl_getopt_long(argc, argv, "bfint:uvS:T", long_options___0, (int *)((void *)0));
#line 371
    if (! (c != -1)) {
#line 371
      break;
    }
#line 374
    switch (c) {
    case 98: 
#line 377
    make_backups = (_Bool)1;
#line 378
    if (rpl_optarg) {
#line 379
      version_control_string = rpl_optarg;
    }
#line 380
    break;
    case 102: 
#line 382
    x.interactive = (enum Interactive )1;
#line 383
    break;
    case 105: 
#line 385
    x.interactive = (enum Interactive )3;
#line 386
    break;
    case 110: 
#line 388
    x.interactive = (enum Interactive )2;
#line 389
    break;
    case 128: 
#line 391
    remove_trailing_slashes = (_Bool)1;
#line 392
    break;
    case 116: 
#line 394
    if (target_directory) {
#line 395
      tmp = gettext("multiple target directories specified");
#line 395
      error(1, 0, (char const   *)tmp);
    } else {
#line 399
      tmp___3 = stat((char const   * __restrict  )rpl_optarg, (struct stat * __restrict  )(& st));
#line 399
      if (tmp___3 != 0) {
#line 400
        tmp___0 = quote((char const   *)rpl_optarg);
#line 400
        tmp___1 = gettext("accessing %s");
#line 400
        tmp___2 = __errno_location();
#line 400
        error(1, *tmp___2, (char const   *)tmp___1, tmp___0);
      }
#line 401
      if (! ((st.st_mode & 61440U) == 16384U)) {
#line 402
        tmp___4 = quote((char const   *)rpl_optarg);
#line 402
        tmp___5 = gettext("target %s is not a directory");
#line 402
        error(1, 0, (char const   *)tmp___5, tmp___4);
      }
    }
#line 405
    target_directory = rpl_optarg;
#line 406
    break;
    case 84: 
#line 408
    no_target_directory = (_Bool)1;
#line 409
    break;
    case 117: 
#line 411
    x.update = (_Bool)1;
#line 412
    break;
    case 118: 
#line 414
    x.verbose = (_Bool)1;
#line 415
    break;
    case 83: 
#line 417
    make_backups = (_Bool)1;
#line 418
    backup_suffix_string = rpl_optarg;
#line 419
    break;
    case -130: 
#line 420
    usage(0);
#line 420
    break;
    case -131: 
#line 421
    version_etc(stdout, "mv", "GNU coreutils", Version, "Mike Parker", "David MacKenzie",
                "Jim Meyering", (char *)((void *)0));
#line 421
    exit(0);
#line 421
    break;
    default: 
#line 423
    usage(1);
    }
  }
#line 427
  n_files = argc - rpl_optind;
#line 428
  file = argv + rpl_optind;
#line 430
  if (n_files <= ! target_directory) {
#line 432
    if (n_files <= 0) {
#line 433
      tmp___6 = gettext("missing file operand");
#line 433
      error(0, 0, (char const   *)tmp___6);
    } else {
#line 435
      tmp___7 = quote((char const   *)*(file + 0));
#line 435
      tmp___8 = gettext("missing destination file operand after %s");
#line 435
      error(0, 0, (char const   *)tmp___8, tmp___7);
    }
#line 437
    usage(1);
  }
#line 440
  if (no_target_directory) {
#line 442
    if (target_directory) {
#line 443
      tmp___9 = gettext("cannot combine --target-directory (-t) and --no-target-directory (-T)");
#line 443
      error(1, 0, (char const   *)tmp___9);
    }
#line 446
    if (2 < n_files) {
#line 448
      tmp___10 = quote((char const   *)*(file + 2));
#line 448
      tmp___11 = gettext("extra operand %s");
#line 448
      error(0, 0, (char const   *)tmp___11, tmp___10);
#line 449
      usage(1);
    }
  } else
#line 452
  if (! target_directory) {
#line 454
    if (! (2 <= n_files)) {
#line 454
      __assert_fail("2 <= n_files", "mv.c", 454U, "main");
    }
#line 455
    tmp___14 = target_directory_operand((char const   *)*(file + (n_files - 1)));
#line 455
    if (tmp___14) {
#line 456
      n_files --;
#line 456
      target_directory = *(file + n_files);
    } else
#line 457
    if (2 < n_files) {
#line 458
      tmp___12 = quote((char const   *)*(file + (n_files - 1)));
#line 458
      tmp___13 = gettext("target %s is not a directory");
#line 458
      error(1, 0, (char const   *)tmp___13, tmp___12);
    }
  }
#line 462
  if (make_backups) {
#line 462
    if ((unsigned int )x.interactive == 2U) {
#line 464
      tmp___15 = gettext("options --backup and --no-clobber are mutually exclusive");
#line 464
      error(0, 0, (char const   *)tmp___15);
#line 466
      usage(1);
    }
  }
#line 469
  if (backup_suffix_string) {
#line 470
    tmp___16 = xstrdup((char const   *)backup_suffix_string);
#line 470
    simple_backup_suffix = (char const   *)tmp___16;
  }
#line 472
  if (make_backups) {
#line 472
    tmp___17 = gettext("backup type");
#line 472
    tmp___18 = xget_version((char const   *)tmp___17, (char const   *)version_control_string);
#line 472
    x.backup_type = tmp___18;
  } else {
#line 472
    x.backup_type = (enum backup_type )0;
  }
#line 477
  hash_init();
#line 479
  if (target_directory) {
#line 486
    if (2 <= n_files) {
#line 487
      dest_info_init(& x);
    }
#line 489
    ok = (_Bool)1;
#line 490
    i = 0;
#line 490
    while (i < n_files) {
#line 491
      tmp___19 = movefile(*(file + i), target_directory, (_Bool)1, (struct cp_options  const  *)(& x));
#line 491
      ok = (_Bool )((int )ok & (int )tmp___19);
#line 490
      i ++;
    }
  } else {
#line 494
    ok = movefile(*(file + 0), *(file + 1), (_Bool)0, (struct cp_options  const  *)(& x));
  }
#line 496
  if (ok) {
#line 496
    tmp___20 = 0;
  } else {
#line 496
    tmp___20 = 1;
  }
#line 496
  exit(tmp___20);
}
}
#line 1 "cil-NgDbTrs8.o"
#pragma merger(0,"/tmp/cil-iAuJtyFD.i","")
#line 177 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int rename(char const   *__old , char const   *__new ) ;
#line 42 "/usr/include/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
#line 65 "../lib/selinux/selinux.h"
__inline static void freecon(char *con  __attribute__((__unused__)) ) 
{ 

  {
#line 65
  return;
}
}
#line 68 "../lib/selinux/selinux.h"
__inline static int getfscreatecon(char **con  __attribute__((__unused__)) ) 
{ int *tmp ;

  {
#line 69
  tmp = __errno_location();
#line 69
  *tmp = 95;
#line 69
  return (-1);
}
}
#line 70 "../lib/selinux/selinux.h"
__inline static int setfscreatecon(char *con  __attribute__((__unused__)) ) 
{ int *tmp ;

  {
#line 71
  tmp = __errno_location();
#line 71
  *tmp = 95;
#line 71
  return (-1);
}
}
#line 91 "../lib/selinux/selinux.h"
__inline static int fsetfilecon(int fd  __attribute__((__unused__)) , char *con  __attribute__((__unused__)) ) 
{ int *tmp ;

  {
#line 93
  tmp = __errno_location();
#line 93
  *tmp = 95;
#line 93
  return (-1);
}
}
#line 314 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t umask(__mode_t __mask ) ;
#line 352
extern  __attribute__((__nothrow__)) int mkfifo(char const   *__path , __mode_t __mode )  __attribute__((__nonnull__(1))) ;
#line 293 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int euidaccess(char const   *__name , int __type )  __attribute__((__nonnull__(1))) ;
#line 822
extern  __attribute__((__nothrow__)) int symlink(char const   *__from , char const   *__to )  __attribute__((__nonnull__(1,2))) ;
#line 992
extern  __attribute__((__nothrow__)) int getpagesize(void)  __attribute__((__const__)) ;
#line 1029
extern  __attribute__((__nothrow__)) int ftruncate(int __fd , __off_t __length ) ;
#line 143 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int strcmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 243 "system.h"
__inline static _Bool dot_or_dotdot(char const   *file_name___1 ) 
{ char sep ;
  int tmp ;

  {
#line 246
  if ((int const   )*(file_name___1 + 0) == 46) {
#line 248
    sep = (char )*(file_name___1 + (((int const   )*(file_name___1 + 1) == 46) + 1));
#line 249
    if (! sep) {
#line 249
      tmp = 1;
    } else
#line 249
    if ((int )sep == 47) {
#line 249
      tmp = 1;
    } else {
#line 249
      tmp = 0;
    }
#line 249
    return ((_Bool )tmp);
  } else {
#line 252
    return ((_Bool)0);
  }
}
}
#line 442
__inline static size_t gcd(size_t u , size_t v )  __attribute__((__const__)) ;
#line 442 "system.h"
__inline static size_t gcd(size_t u , size_t v ) 
{ size_t t ;

  {
#line 445
  while (1) {
#line 447
    t = u % v;
#line 448
    u = v;
#line 449
    v = t;
#line 445
    if (! v) {
#line 445
      break;
    }
  }
#line 453
  return (u);
}
}
#line 460
__inline static size_t lcm(size_t u , size_t v )  __attribute__((__const__)) ;
#line 460 "system.h"
__inline static size_t lcm(size_t u , size_t v ) 
{ size_t tmp ;

  {
#line 463
  tmp = gcd(u, v);
#line 463
  return (u * (v / tmp));
}
}
#line 471 "system.h"
__inline static void *ptr_align(void const   *ptr , size_t alignment ) 
{ char const   *p0 ;
  char const   *p1 ;

  {
#line 474
  p0 = (char const   *)ptr;
#line 475
  p1 = (p0 + alignment) - 1;
#line 476
  return ((void *)(p1 - (size_t )p1 % alignment));
}
}
#line 282 "copy.h"
extern void src_info_init(struct cp_options *x ) ;
#line 285
extern _Bool chown_failure_ok(struct cp_options  const  *x )  __attribute__((__pure__)) ;
#line 286
extern mode_t cached_umask(void) ;
#line 3 "cp-hash.h"
extern void forget_created(ino_t ino , dev_t dev ) ;
#line 4
extern char *remember_copied(char const   *name , ino_t ino , dev_t dev ) ;
#line 5
extern char *src_to_dest_lookup(ino_t ino , dev_t dev ) ;
#line 61 "extent-scan.h"
extern void extent_scan_init(int src_fd , struct extent_scan *scan ) ;
#line 63
extern _Bool extent_scan_read(struct extent_scan *scan ) ;
#line 65 "extent-scan.h"
__inline static void extent_scan_free(struct extent_scan *scan ) 
{ 

  {
#line 68
  free((void *)scan->ext_info);
#line 69
  scan->ext_info = (struct extent_info *)((void *)0);
#line 70
  scan->ei_count = (uint32_t )0;
#line 71
  return;
}
}
#line 62 "ioblksize.h"
__inline static size_t io_blksize(struct stat sb ) 
{ __blksize_t tmp___0 ;
  __blksize_t tmp___1 ;
  __blksize_t tmp___2 ;

  {
#line 65
  if (0L < sb.st_blksize) {
#line 65
    if ((size_t )sb.st_blksize <= 2305843009213693952UL) {
#line 65
      tmp___2 = sb.st_blksize;
    } else {
#line 65
      tmp___2 = (__blksize_t )512;
    }
  } else {
#line 65
    tmp___2 = (__blksize_t )512;
  }
#line 65
  if (32768L > tmp___2) {
#line 65
    tmp___1 = (__blksize_t )32768;
  } else {
#line 65
    if (0L < sb.st_blksize) {
#line 65
      if ((size_t )sb.st_blksize <= 2305843009213693952UL) {
#line 65
        tmp___0 = sb.st_blksize;
      } else {
#line 65
        tmp___0 = (__blksize_t )512;
      }
    } else {
#line 65
      tmp___0 = (__blksize_t )512;
    }
#line 65
    tmp___1 = tmp___0;
  }
#line 65
  return ((size_t )tmp___1);
}
}
#line 107 "copy.c"
static _Bool copy_internal(char const   *src_name , char const   *dst_name , _Bool new_dst ,
                           dev_t device , struct dir_list *ancestors , struct cp_options  const  *x ,
                           _Bool command_line_arg , _Bool *first_dir_created_per_command_line_arg ,
                           _Bool *copy_into_self , _Bool *rename_succeeded ) ;
#line 115
static _Bool owner_failure_ok(struct cp_options  const  *x ) ;
#line 119 "copy.c"
static char const   *top_level_src_name  ;
#line 120 "copy.c"
static char const   *top_level_dst_name  ;
#line 124 "copy.c"
__inline static int utimens_symlink(char const   *file , struct timespec  const  *timespec ) 
{ int err ;
  int tmp ;
  int *tmp___0 ;

  {
#line 127
  tmp = lutimens(file, (struct timespec  const  *)timespec);
#line 127
  err = tmp;
#line 131
  if (err) {
#line 131
    tmp___0 = __errno_location();
#line 131
    if (*tmp___0 == 38) {
#line 132
      err = 0;
    }
  }
#line 133
  return (err);
}
}
#line 147 "copy.c"
static _Bool sparse_copy(int src_fd , int dest_fd , char *buf___1 , size_t buf_size ,
                         _Bool make_holes , char const   *src_name , char const   *dst_name ,
                         uintmax_t max_n_read , off_t *total_n_read , _Bool *last_write_made_hole ) 
{ word *wp ;
  ssize_t n_read ;
  uintmax_t tmp ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *cp ;
  word *tmp___5 ;
  char *tmp___6 ;
  char const   *tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;
  __off_t tmp___10 ;
  size_t n ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  int *tmp___13 ;
  size_t tmp___14 ;

  {
#line 155
  *last_write_made_hole = (_Bool)0;
#line 156
  *total_n_read = (off_t )0;
#line 158
  while (max_n_read) {
#line 160
    wp = (word *)((void *)0);
#line 162
    if (max_n_read < buf_size) {
#line 162
      tmp = max_n_read;
    } else {
#line 162
      tmp = buf_size;
    }
#line 162
    tmp___0 = (ssize_t )read(src_fd, (void *)buf___1, tmp);
#line 162
    n_read = tmp___0;
#line 163
    if (n_read < 0L) {
#line 165
      tmp___1 = __errno_location();
#line 165
      if (*tmp___1 == 4) {
#line 166
        continue;
      }
#line 167
      tmp___2 = quote(src_name);
#line 167
      tmp___3 = gettext("reading %s");
#line 167
      tmp___4 = __errno_location();
#line 167
      error(0, *tmp___4, (char const   *)tmp___3, tmp___2);
#line 168
      return ((_Bool)0);
    }
#line 170
    if (n_read == 0L) {
#line 171
      break;
    }
#line 172
    max_n_read -= (uintmax_t )n_read;
#line 173
    *total_n_read += n_read;
#line 175
    if (make_holes) {
#line 180
      *(buf___1 + n_read) = (char )'\001';
#line 193
      wp = (word *)buf___1;
#line 194
      while (1) {
#line 194
        tmp___5 = wp;
#line 194
        wp ++;
#line 194
        if (! (*tmp___5 == 0UL)) {
#line 194
          break;
        }
#line 195
        continue;
      }
#line 199
      cp = (char *)(wp - 1);
#line 200
      while (1) {
#line 200
        tmp___6 = cp;
#line 200
        cp ++;
#line 200
        if (! ((int )*tmp___6 == 0)) {
#line 200
          break;
        }
#line 201
        continue;
      }
#line 203
      if ((unsigned long )cp <= (unsigned long )(buf___1 + n_read)) {
#line 205
        wp = (word *)((void *)0);
      } else {
#line 210
        tmp___10 = lseek(dest_fd, n_read, 1);
#line 210
        if (tmp___10 < 0L) {
#line 212
          tmp___7 = quote(dst_name);
#line 212
          tmp___8 = gettext("cannot lseek %s");
#line 212
          tmp___9 = __errno_location();
#line 212
          error(0, *tmp___9, (char const   *)tmp___8, tmp___7);
#line 213
          return ((_Bool)0);
        }
#line 215
        *last_write_made_hole = (_Bool)1;
      }
    }
#line 219
    if (! wp) {
#line 221
      n = (size_t )n_read;
#line 222
      tmp___14 = full_write(dest_fd, (void const   *)buf___1, n);
#line 222
      if (tmp___14 != n) {
#line 224
        tmp___11 = quote(dst_name);
#line 224
        tmp___12 = gettext("writing %s");
#line 224
        tmp___13 = __errno_location();
#line 224
        error(0, *tmp___13, (char const   *)tmp___12, tmp___11);
#line 225
        return ((_Bool)0);
      }
#line 227
      *last_write_made_hole = (_Bool)0;
    }
  }
#line 236
  return ((_Bool)1);
}
}
#line 241 "copy.c"
__inline static int clone_file(int dest_fd , int src_fd ) 
{ int tmp ;

  {
#line 249
  tmp = ioctl(dest_fd, (unsigned long )(((1U << 30) | (unsigned int )(148 << 8)) | 9U) | (sizeof(int ) << 16),
              src_fd);
#line 249
  return (tmp);
}
}
#line 263 "copy.c"
static char *zeros  ;
#line 264
static _Bool write_zeros(int fd , uint64_t n_bytes ) ;
#line 264 "copy.c"
static size_t nz  =    (size_t )32768;
#line 271 "copy.c"
static char fallback[1024]  ;
#line 260 "copy.c"
static _Bool write_zeros(int fd , uint64_t n_bytes ) 
{ void *tmp ;
  uint64_t n ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 269
  if ((unsigned long )zeros == (unsigned long )((void *)0)) {
#line 272
    tmp = calloc(nz, (size_t )1);
#line 272
    zeros = (char *)tmp;
#line 273
    if ((unsigned long )zeros == (unsigned long )((void *)0)) {
#line 275
      zeros = fallback;
#line 276
      nz = sizeof(fallback);
    }
  }
#line 280
  while (n_bytes) {
#line 282
    if (nz < n_bytes) {
#line 282
      tmp___0 = nz;
    } else {
#line 282
      tmp___0 = n_bytes;
    }
#line 282
    n = tmp___0;
#line 283
    tmp___1 = full_write(fd, (void const   *)zeros, n);
#line 283
    if (tmp___1 != n) {
#line 284
      return ((_Bool)0);
    }
#line 285
    n_bytes -= n;
  }
#line 288
  return ((_Bool)1);
}
}
#line 298 "copy.c"
static _Bool extent_copy(int src_fd , int dest_fd , char *buf___1 , size_t buf_size ,
                         off_t src_total_size , enum Sparse_type sparse_mode , char const   *src_name ,
                         char const   *dst_name , _Bool *require_normal_copy ) 
{ struct extent_scan scan ;
  off_t last_ext_start ;
  uint64_t last_ext_len ;
  off_t dest_pos ;
  _Bool wrote_hole_at_eof ;
  _Bool ok ;
  _Bool tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  unsigned int i ;
  _Bool empty_extent ;
  off_t ext_start ;
  uint64_t ext_len ;
  uint64_t hole_size ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  __off_t tmp___6 ;
  char const   *tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;
  __off_t tmp___10 ;
  off_t nzeros ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  int *tmp___13 ;
  _Bool tmp___14 ;
  off_t n_read ;
  _Bool tmp___15 ;
  char const   *tmp___16 ;
  char *tmp___17 ;
  int *tmp___18 ;
  int tmp___19 ;
  _Bool tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 305
  last_ext_start = (off_t )0;
#line 306
  last_ext_len = (uint64_t )0;
#line 310
  dest_pos = (off_t )0;
#line 312
  extent_scan_init(src_fd, & scan);
#line 314
  *require_normal_copy = (_Bool)0;
#line 315
  wrote_hole_at_eof = (_Bool)1;
#line 316
  while (1) {
#line 318
    tmp = extent_scan_read(& scan);
#line 318
    ok = tmp;
#line 319
    if (! ok) {
#line 321
      if (scan.hit_final_extent) {
#line 322
        break;
      }
#line 324
      if (scan.initial_scan_failed) {
#line 326
        *require_normal_copy = (_Bool)1;
#line 327
        return ((_Bool)0);
      }
#line 330
      tmp___0 = quote(src_name);
#line 330
      tmp___1 = gettext("%s: failed to get extents info");
#line 330
      tmp___2 = __errno_location();
#line 330
      error(0, *tmp___2, (char const   *)tmp___1, tmp___0);
#line 332
      return ((_Bool)0);
    }
#line 336
    empty_extent = (_Bool)0;
#line 337
    i = 0U;
#line 337
    while (1) {
#line 337
      if (! (i < scan.ei_count)) {
#line 337
        if (! empty_extent) {
#line 337
          break;
        }
      }
#line 343
      if (i < scan.ei_count) {
#line 345
        ext_start = (scan.ext_info + i)->ext_logical;
#line 346
        ext_len = (scan.ext_info + i)->ext_length;
      } else {
#line 350
        i --;
#line 351
        ext_start = (off_t )((uint64_t )last_ext_start + (scan.ext_info + i)->ext_length);
#line 352
        ext_len = (uint64_t )0;
      }
#line 355
      hole_size = (uint64_t )(ext_start - last_ext_start) - last_ext_len;
#line 357
      wrote_hole_at_eof = (_Bool)0;
#line 359
      if (hole_size) {
#line 361
        tmp___6 = lseek(src_fd, ext_start, 0);
#line 361
        if (tmp___6 < 0L) {
#line 363
          tmp___3 = quote(src_name);
#line 363
          tmp___4 = gettext("cannot lseek %s");
#line 363
          tmp___5 = __errno_location();
#line 363
          error(0, *tmp___5, (char const   *)tmp___4, tmp___3);
          fail: 
#line 365
          extent_scan_free(& scan);
#line 366
          return ((_Bool)0);
        }
#line 369
        if (empty_extent) {
#line 369
          if ((unsigned int )sparse_mode == 3U) {
#line 369
            goto _L;
          } else {
#line 369
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 369
        if (! empty_extent) {
#line 369
          if ((unsigned int )sparse_mode != 1U) {
            _L: /* CIL Label */ 
#line 372
            tmp___10 = lseek(dest_fd, ext_start, 0);
#line 372
            if (tmp___10 < 0L) {
#line 374
              tmp___7 = quote(dst_name);
#line 374
              tmp___8 = gettext("cannot lseek %s");
#line 374
              tmp___9 = __errno_location();
#line 374
              error(0, *tmp___9, (char const   *)tmp___8, tmp___7);
#line 375
              goto fail;
            }
#line 377
            wrote_hole_at_eof = (_Bool)1;
          } else {
#line 369
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
#line 384
          nzeros = (off_t )hole_size;
#line 385
          if (empty_extent) {
#line 386
            if ((uint64_t )(src_total_size - dest_pos) < hole_size) {
#line 386
              nzeros = src_total_size - dest_pos;
            } else {
#line 386
              nzeros = (off_t )hole_size;
            }
          }
#line 388
          tmp___14 = write_zeros(dest_fd, (uint64_t )nzeros);
#line 388
          if (! tmp___14) {
#line 390
            tmp___11 = quote(dst_name);
#line 390
            tmp___12 = gettext("%s: write failed");
#line 390
            tmp___13 = __errno_location();
#line 390
            error(0, *tmp___13, (char const   *)tmp___12, tmp___11);
#line 391
            goto fail;
          }
#line 394
          if (src_total_size < ext_start) {
#line 394
            dest_pos = src_total_size;
          } else {
#line 394
            dest_pos = ext_start;
          }
        }
      }
#line 398
      last_ext_start = ext_start;
#line 416
      empty_extent = (_Bool)0;
#line 417
      last_ext_len = ext_len;
#line 419
      tmp___15 = sparse_copy(src_fd, dest_fd, buf___1, buf_size, (_Bool )((unsigned int )sparse_mode == 3U),
                             src_name, dst_name, ext_len, & n_read, & wrote_hole_at_eof);
#line 419
      if (! tmp___15) {
#line 423
        goto fail;
      }
#line 425
      dest_pos = ext_start + n_read;
#line 433
      if (dest_pos == src_total_size) {
#line 435
        scan.hit_final_extent = (_Bool)1;
#line 436
        break;
      }
#line 337
      i ++;
    }
#line 441
    extent_scan_free(& scan);
#line 316
    if (! (! scan.hit_final_extent)) {
#line 316
      break;
    }
  }
#line 454
  if (dest_pos < src_total_size) {
#line 454
    goto _L___2;
  } else
#line 454
  if (wrote_hole_at_eof) {
    _L___2: /* CIL Label */ 
#line 454
    if ((unsigned int )sparse_mode != 1U) {
#line 454
      tmp___19 = ftruncate(dest_fd, src_total_size);
#line 454
      tmp___22 = tmp___19;
    } else {
#line 454
      tmp___20 = write_zeros(dest_fd, (uint64_t )(src_total_size - dest_pos));
#line 454
      if (tmp___20) {
#line 454
        tmp___21 = 0;
      } else {
#line 454
        tmp___21 = 1;
      }
#line 454
      tmp___22 = tmp___21;
    }
#line 454
    if (tmp___22) {
#line 459
      tmp___16 = quote(dst_name);
#line 459
      tmp___17 = gettext("failed to extend %s");
#line 459
      tmp___18 = __errno_location();
#line 459
      error(0, *tmp___18, (char const   *)tmp___17, tmp___16);
#line 460
      return ((_Bool)0);
    }
  }
#line 463
  return ((_Bool)1);
}
}
#line 471 "copy.c"
static _Bool __attribute__((__pure__))  is_ancestor(struct stat  const  *sb , struct dir_list  const  *ancestors ) 
{ 

  {
#line 474
  while ((unsigned long )ancestors != (unsigned long )((struct dir_list  const  *)0)) {
#line 476
    if (ancestors->ino == sb->st_ino) {
#line 476
      if (ancestors->dev == sb->st_dev) {
#line 477
        return ((_Bool __attribute__((__pure__))  )1);
      }
    }
#line 478
    ancestors = (struct dir_list  const  *)ancestors->parent;
  }
#line 480
  return ((_Bool __attribute__((__pure__))  )0);
}
}
#line 483 "copy.c"
static _Bool errno_unsupported(int err ) 
{ int tmp ;

  {
#line 486
  if (err == 95) {
#line 486
    tmp = 1;
  } else
#line 486
  if (err == 61) {
#line 486
    tmp = 1;
  } else {
#line 486
    tmp = 0;
  }
#line 486
  return ((_Bool )tmp);
}
}
#line 558 "copy.c"
static _Bool copy_attr(char const   *src_path  __attribute__((__unused__)) , int src_fd  __attribute__((__unused__)) ,
                       char const   *dst_path  __attribute__((__unused__)) , int dst_fd  __attribute__((__unused__)) ,
                       struct cp_options  const  *x  __attribute__((__unused__)) ) 
{ 

  {
#line 565
  return ((_Bool)1);
}
}
#line 581 "copy.c"
static _Bool copy_dir(char const   *src_name_in , char const   *dst_name_in , _Bool new_dst ,
                      struct stat  const  *src_sb , struct dir_list *ancestors , struct cp_options  const  *x ,
                      _Bool *first_dir_created_per_command_line_arg , _Bool *copy_into_self ) 
{ char *name_space ;
  char *namep ;
  struct cp_options non_command_line_options ;
  _Bool ok ;
  char const   *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  _Bool new_first_dir_created ;
  _Bool local_copy_into_self ;
  char *src_name ;
  char *tmp___2 ;
  char *dst_name ;
  char *tmp___3 ;
  _Bool first_dir_created ;
  _Bool tmp___4 ;
  size_t tmp___5 ;

  {
#line 590
  non_command_line_options = *x;
#line 591
  ok = (_Bool)1;
#line 593
  name_space = savedir(src_name_in);
#line 594
  if ((unsigned long )name_space == (unsigned long )((void *)0)) {
#line 598
    tmp = quote(src_name_in);
#line 598
    tmp___0 = gettext("cannot access %s");
#line 598
    tmp___1 = __errno_location();
#line 598
    error(0, *tmp___1, (char const   *)tmp___0, tmp);
#line 599
    return ((_Bool)0);
  }
#line 604
  if ((unsigned int const   )x->dereference == 3U) {
#line 605
    non_command_line_options.dereference = (enum Dereference_symlink )2;
  }
#line 607
  new_first_dir_created = (_Bool)0;
#line 608
  namep = name_space;
#line 609
  while ((int )*namep != 0) {
#line 612
    tmp___2 = file_name_concat(src_name_in, (char const   *)namep, (char **)((void *)0));
#line 612
    src_name = tmp___2;
#line 613
    tmp___3 = file_name_concat(dst_name_in, (char const   *)namep, (char **)((void *)0));
#line 613
    dst_name = tmp___3;
#line 614
    first_dir_created = *first_dir_created_per_command_line_arg;
#line 616
    tmp___4 = copy_internal((char const   *)src_name, (char const   *)dst_name, new_dst,
                            (dev_t )src_sb->st_dev, ancestors, (struct cp_options  const  *)(& non_command_line_options),
                            (_Bool)0, & first_dir_created, & local_copy_into_self,
                            (_Bool *)((void *)0));
#line 616
    ok = (_Bool )((int )ok & (int )tmp___4);
#line 620
    *copy_into_self = (_Bool )((int )*copy_into_self | (int )local_copy_into_self);
#line 622
    free((void *)dst_name);
#line 623
    free((void *)src_name);
#line 628
    if (local_copy_into_self) {
#line 629
      break;
    }
#line 631
    new_first_dir_created = (_Bool )((int )new_first_dir_created | (int )first_dir_created);
#line 632
    tmp___5 = strlen((char const   *)namep);
#line 632
    namep += tmp___5 + 1UL;
  }
#line 634
  free((void *)name_space);
#line 635
  *first_dir_created_per_command_line_arg = new_first_dir_created;
#line 637
  return (ok);
}
}
#line 652 "copy.c"
static int set_owner(struct cp_options  const  *x , char const   *dst_name , int dest_desc ,
                     struct stat  const  *src_sb , _Bool new_dst , struct stat  const  *dst_sb ) 
{ uid_t uid ;
  gid_t gid ;
  mode_t old_mode ;
  mode_t new_mode ;
  __mode_t tmp ;
  mode_t restrictive_temp_mode ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  _Bool tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int saved_errno ;
  int *tmp___6 ;
  int __x ;
  int tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;
  int saved_errno___0 ;
  int *tmp___12 ;
  int __x___0 ;
  int tmp___13 ;
  int *tmp___14 ;
  int *tmp___15 ;
  int *tmp___16 ;
  char const   *tmp___17 ;
  char *tmp___18 ;
  int *tmp___19 ;
  _Bool tmp___20 ;

  {
#line 657
  uid = (uid_t )src_sb->st_uid;
#line 658
  gid = (gid_t )src_sb->st_gid;
#line 666
  if (! new_dst) {
#line 666
    if (x->preserve_mode) {
#line 666
      goto _L;
    } else
#line 666
    if (x->move_mode) {
#line 666
      goto _L;
    } else
#line 666
    if (x->set_mode) {
      _L: /* CIL Label */ 
#line 668
      old_mode = (mode_t )dst_sb->st_mode;
#line 669
      if (x->preserve_mode) {
#line 669
        tmp = src_sb->st_mode;
      } else
#line 669
      if (x->move_mode) {
#line 669
        tmp = src_sb->st_mode;
      } else {
#line 669
        tmp = x->mode;
      }
#line 669
      new_mode = (mode_t )tmp;
#line 671
      restrictive_temp_mode = (old_mode & new_mode) & 448U;
#line 673
      if ((old_mode & (unsigned int )((4032 | (448 >> 3)) | ((448 >> 3) >> 3))) & (((~ new_mode | 2048U) | 1024U) | 512U)) {
#line 673
        tmp___4 = qset_acl(dst_name, dest_desc, restrictive_temp_mode);
#line 673
        if (tmp___4 != 0) {
#line 678
          tmp___3 = owner_failure_ok(x);
#line 678
          if (! tmp___3) {
#line 679
            tmp___0 = quote(dst_name);
#line 679
            tmp___1 = gettext("clearing permissions for %s");
#line 679
            tmp___2 = __errno_location();
#line 679
            error(0, *tmp___2, (char const   *)tmp___1, tmp___0);
          }
#line 681
          return ((int )(- ((int const   )x->require_preserve)));
        }
      }
    }
  }
#line 685
  if (dest_desc != -1) {
#line 687
    tmp___5 = fchown(dest_desc, uid, gid);
#line 687
    if (tmp___5 == 0) {
#line 688
      return (1);
    }
#line 689
    tmp___9 = __errno_location();
#line 689
    if (*tmp___9 == 1) {
#line 689
      goto _L___0;
    } else {
#line 689
      tmp___10 = __errno_location();
#line 689
      if (*tmp___10 == 22) {
        _L___0: /* CIL Label */ 
#line 693
        tmp___6 = __errno_location();
#line 693
        saved_errno = *tmp___6;
#line 694
        tmp___7 = fchown(dest_desc, (__uid_t )-1, gid);
#line 694
        __x = tmp___7;
#line 695
        tmp___8 = __errno_location();
#line 695
        *tmp___8 = saved_errno;
      }
    }
  } else {
#line 700
    tmp___11 = lchown(dst_name, uid, gid);
#line 700
    if (tmp___11 == 0) {
#line 701
      return (1);
    }
#line 702
    tmp___15 = __errno_location();
#line 702
    if (*tmp___15 == 1) {
#line 702
      goto _L___1;
    } else {
#line 702
      tmp___16 = __errno_location();
#line 702
      if (*tmp___16 == 22) {
        _L___1: /* CIL Label */ 
#line 706
        tmp___12 = __errno_location();
#line 706
        saved_errno___0 = *tmp___12;
#line 707
        tmp___13 = lchown(dst_name, (__uid_t )-1, gid);
#line 707
        __x___0 = tmp___13;
#line 708
        tmp___14 = __errno_location();
#line 708
        *tmp___14 = saved_errno___0;
      }
    }
  }
#line 712
  tmp___20 = chown_failure_ok(x);
#line 712
  if (! tmp___20) {
#line 714
    tmp___17 = quote(dst_name);
#line 714
    tmp___18 = gettext("failed to preserve ownership for %s");
#line 714
    tmp___19 = __errno_location();
#line 714
    error(0, *tmp___19, (char const   *)tmp___18, tmp___17);
#line 716
    if (x->require_preserve) {
#line 717
      return (-1);
    }
  }
#line 720
  return (0);
}
}
#line 728 "copy.c"
static void set_author(char const   *dst_name , int dest_desc , struct stat  const  *src_sb ) 
{ 

  {
#line 754
  return;
}
}
#line 759 "copy.c"
static int fchmod_or_lchmod(int desc , char const   *name , mode_t mode ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 763
  if (0 <= desc) {
#line 764
    tmp = fchmod(desc, mode);
#line 764
    return (tmp);
  }
#line 766
  tmp___0 = chmod(name, mode);
#line 766
  return (tmp___0);
}
}
#line 777 "copy.c"
static _Bool is_probably_sparse(struct stat  const  *sb ) 
{ int tmp ;

  {
#line 780
  if ((sb->st_mode & 61440U) == 32768U) {
#line 780
    if (sb->st_blocks < sb->st_size / 512L) {
#line 780
      tmp = 1;
    } else {
#line 780
      tmp = 0;
    }
  } else {
#line 780
    tmp = 0;
  }
#line 780
  return ((_Bool )tmp);
}
}
#line 798 "copy.c"
static _Bool copy_reg(char const   *src_name , char const   *dst_name , struct cp_options  const  *x ,
                      mode_t dst_mode , mode_t omitted_permissions , _Bool *new_dst ,
                      struct stat  const  *src_sb ) 
{ char *buf___1 ;
  char *buf_alloc ;
  char *name_alloc ;
  int dest_desc ;
  int dest_errno ;
  int source_desc ;
  mode_t src_mode ;
  struct stat sb ;
  struct stat src_open_sb ;
  _Bool return_val ;
  _Bool data_copy_required ;
  int tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;
  _Bool all_errors ;
  int tmp___10 ;
  _Bool some_errors ;
  int tmp___11 ;
  char *con ;
  char *tmp___12 ;
  int *tmp___13 ;
  int *tmp___14 ;
  _Bool tmp___15 ;
  int tmp___16 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;
  char *tmp___19 ;
  int *tmp___20 ;
  int *tmp___21 ;
  _Bool tmp___22 ;
  int tmp___23 ;
  char const   *tmp___24 ;
  char *tmp___25 ;
  int *tmp___26 ;
  int tmp___27 ;
  char const   *tmp___28 ;
  char *tmp___29 ;
  int open_flags ;
  int *tmp___30 ;
  struct stat dangling_link_sb ;
  int *tmp___31 ;
  char const   *tmp___32 ;
  char *tmp___33 ;
  int tmp___34 ;
  size_t tmp___35 ;
  char const   *tmp___36 ;
  char *tmp___37 ;
  char const   *tmp___38 ;
  char *tmp___39 ;
  int *tmp___40 ;
  int tmp___41 ;
  _Bool clone_ok ;
  int tmp___42 ;
  char const   *tmp___43 ;
  char const   *tmp___44 ;
  char *tmp___45 ;
  int *tmp___46 ;
  size_t buf_alignment ;
  int tmp___47 ;
  size_t tmp___48 ;
  size_t buf_alignment_slop ;
  size_t buf_size ;
  size_t tmp___49 ;
  _Bool make_holes ;
  _Bool sparse_src ;
  size_t blcm_max ;
  size_t blcm ;
  size_t tmp___50 ;
  size_t tmp___51 ;
  void *tmp___52 ;
  void *tmp___53 ;
  _Bool normal_copy_required ;
  unsigned int tmp___54 ;
  _Bool tmp___55 ;
  off_t n_read ;
  _Bool wrote_hole_at_eof ;
  char const   *tmp___56 ;
  char *tmp___57 ;
  int *tmp___58 ;
  _Bool tmp___59 ;
  int tmp___60 ;
  struct timespec timespec[2] ;
  char const   *tmp___61 ;
  char *tmp___62 ;
  int *tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  _Bool access_changed ;
  int tmp___66 ;
  __uid_t tmp___67 ;
  _Bool tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  mode_t tmp___71 ;
  char const   *tmp___72 ;
  char *tmp___73 ;
  int *tmp___74 ;
  int tmp___75 ;
  char const   *tmp___76 ;
  char *tmp___77 ;
  int *tmp___78 ;
  int tmp___79 ;
  char const   *tmp___80 ;
  char *tmp___81 ;
  int *tmp___82 ;
  int tmp___83 ;

  {
#line 805
  buf_alloc = (char *)((void *)0);
#line 806
  name_alloc = (char *)((void *)0);
#line 810
  src_mode = (mode_t )src_sb->st_mode;
#line 813
  return_val = (_Bool)1;
#line 814
  data_copy_required = (_Bool )x->data_copy_required;
#line 816
  if ((unsigned int const   )x->dereference == 2U) {
#line 816
    tmp = 131072;
  } else {
#line 816
    tmp = 0;
  }
#line 816
  source_desc = open_safer(src_name, tmp);
#line 819
  if (source_desc < 0) {
#line 821
    tmp___0 = quote(src_name);
#line 821
    tmp___1 = gettext("cannot open %s for reading");
#line 821
    tmp___2 = __errno_location();
#line 821
    error(0, *tmp___2, (char const   *)tmp___1, tmp___0);
#line 822
    return ((_Bool)0);
  }
#line 825
  tmp___6 = fstat(source_desc, & src_open_sb);
#line 825
  if (tmp___6 != 0) {
#line 827
    tmp___3 = quote(src_name);
#line 827
    tmp___4 = gettext("cannot fstat %s");
#line 827
    tmp___5 = __errno_location();
#line 827
    error(0, *tmp___5, (char const   *)tmp___4, tmp___3);
#line 828
    return_val = (_Bool)0;
#line 829
    goto close_src_desc;
  }
#line 834
  if (src_sb->st_ino == (__ino_t const   )src_open_sb.st_ino) {
#line 834
    if (! (src_sb->st_dev == (__dev_t const   )src_open_sb.st_dev)) {
#line 836
      tmp___7 = quote(src_name);
#line 836
      tmp___8 = gettext("skipping file %s, as it was replaced while being copied");
#line 836
      error(0, 0, (char const   *)tmp___8, tmp___7);
#line 839
      return_val = (_Bool)0;
#line 840
      goto close_src_desc;
    }
  } else {
#line 836
    tmp___7 = quote(src_name);
#line 836
    tmp___8 = gettext("skipping file %s, as it was replaced while being copied");
#line 836
    error(0, 0, (char const   *)tmp___8, tmp___7);
#line 839
    return_val = (_Bool)0;
#line 840
    goto close_src_desc;
  }
#line 845
  if (! *new_dst) {
#line 847
    dest_desc = open_safer(dst_name, 513);
#line 848
    tmp___9 = __errno_location();
#line 848
    dest_errno = *tmp___9;
#line 855
    if (x->preserve_security_context) {
#line 855
      if (0 <= dest_desc) {
#line 857
        if (! x->data_copy_required) {
#line 857
          tmp___10 = 1;
        } else
#line 857
        if (x->require_preserve_context) {
#line 857
          tmp___10 = 1;
        } else {
#line 857
          tmp___10 = 0;
        }
#line 857
        all_errors = (_Bool )tmp___10;
#line 859
        if (! all_errors) {
#line 859
          if (! x->reduce_diagnostics) {
#line 859
            tmp___11 = 1;
          } else {
#line 859
            tmp___11 = 0;
          }
        } else {
#line 859
          tmp___11 = 0;
        }
#line 859
        some_errors = (_Bool )tmp___11;
#line 860
        con = (char *)((void *)0);
#line 862
        tmp___16 = getfscreatecon(& con);
#line 862
        if (tmp___16 < 0) {
#line 864
          if (all_errors) {
#line 865
            tmp___12 = gettext("failed to get file system create context");
#line 865
            tmp___13 = __errno_location();
#line 865
            error(0, *tmp___13, (char const   *)tmp___12);
          } else
#line 864
          if (some_errors) {
#line 864
            tmp___14 = __errno_location();
#line 864
            tmp___15 = errno_unsupported(*tmp___14);
#line 864
            if (! tmp___15) {
#line 865
              tmp___12 = gettext("failed to get file system create context");
#line 865
              tmp___13 = __errno_location();
#line 865
              error(0, *tmp___13, (char const   *)tmp___12);
            }
          }
#line 866
          if (x->require_preserve_context) {
#line 868
            return_val = (_Bool)0;
#line 869
            goto close_src_and_dst_desc;
          }
        }
#line 873
        if (con) {
#line 875
          tmp___23 = fsetfilecon(dest_desc, con);
#line 875
          if (tmp___23 < 0) {
#line 877
            if (all_errors) {
#line 878
              tmp___17 = quote_n(1, (char const   *)con);
#line 878
              tmp___18 = quote_n(0, dst_name);
#line 878
              tmp___19 = gettext("failed to set the security context of %s to %s");
#line 878
              tmp___20 = __errno_location();
#line 878
              error(0, *tmp___20, (char const   *)tmp___19, tmp___18, tmp___17);
            } else
#line 877
            if (some_errors) {
#line 877
              tmp___21 = __errno_location();
#line 877
              tmp___22 = errno_unsupported(*tmp___21);
#line 877
              if (! tmp___22) {
#line 878
                tmp___17 = quote_n(1, (char const   *)con);
#line 878
                tmp___18 = quote_n(0, dst_name);
#line 878
                tmp___19 = gettext("failed to set the security context of %s to %s");
#line 878
                tmp___20 = __errno_location();
#line 878
                error(0, *tmp___20, (char const   *)tmp___19, tmp___18, tmp___17);
              }
            }
#line 881
            if (x->require_preserve_context) {
#line 883
              return_val = (_Bool)0;
#line 884
              freecon(con);
#line 885
              goto close_src_and_dst_desc;
            }
          }
#line 888
          freecon(con);
        }
      }
    }
#line 892
    if (dest_desc < 0) {
#line 892
      if (x->unlink_dest_after_failed_open) {
#line 894
        tmp___27 = unlink(dst_name);
#line 894
        if (tmp___27 != 0) {
#line 896
          tmp___24 = quote(dst_name);
#line 896
          tmp___25 = gettext("cannot remove %s");
#line 896
          tmp___26 = __errno_location();
#line 896
          error(0, *tmp___26, (char const   *)tmp___25, tmp___24);
#line 897
          return_val = (_Bool)0;
#line 898
          goto close_src_desc;
        }
#line 900
        if (x->verbose) {
#line 901
          tmp___28 = quote(dst_name);
#line 901
          tmp___29 = gettext("removed %s\n");
#line 901
          printf((char const   * __restrict  )tmp___29, tmp___28);
        }
#line 904
        *new_dst = (_Bool)1;
      }
    }
  }
#line 908
  if (*new_dst) {
#line 910
    open_flags = 65;
#line 911
    dest_desc = open_safer(dst_name, open_flags | 128, dst_mode & ~ omitted_permissions);
#line 913
    tmp___30 = __errno_location();
#line 913
    dest_errno = *tmp___30;
#line 925
    if (dest_desc < 0) {
#line 925
      if (dest_errno == 17) {
#line 925
        if (! x->move_mode) {
#line 928
          tmp___34 = lstat((char const   * __restrict  )dst_name, (struct stat * __restrict  )(& dangling_link_sb));
#line 928
          if (tmp___34 == 0) {
#line 928
            if ((dangling_link_sb.st_mode & 61440U) == 40960U) {
#line 931
              if (x->open_dangling_dest_symlink) {
#line 933
                dest_desc = open_safer(dst_name, open_flags, dst_mode & ~ omitted_permissions);
#line 935
                tmp___31 = __errno_location();
#line 935
                dest_errno = *tmp___31;
              } else {
#line 939
                tmp___32 = quote(dst_name);
#line 939
                tmp___33 = gettext("not writing through dangling symlink %s");
#line 939
                error(0, 0, (char const   *)tmp___33, tmp___32);
#line 941
                return_val = (_Bool)0;
#line 942
                goto close_src_desc;
              }
            }
          }
        }
      }
    }
#line 949
    if (dest_desc < 0) {
#line 949
      if (dest_errno == 21) {
#line 949
        if (*dst_name) {
#line 949
          tmp___35 = strlen(dst_name);
#line 949
          if ((int const   )*(dst_name + (tmp___35 - 1UL)) == 47) {
#line 951
            dest_errno = 20;
          }
        }
      }
    }
  } else {
#line 955
    omitted_permissions = (mode_t )0;
  }
#line 958
  if (dest_desc < 0) {
#line 960
    tmp___36 = quote(dst_name);
#line 960
    tmp___37 = gettext("cannot create regular file %s");
#line 960
    error(0, dest_errno, (char const   *)tmp___37, tmp___36);
#line 962
    return_val = (_Bool)0;
#line 963
    goto close_src_desc;
  }
#line 966
  tmp___41 = fstat(dest_desc, & sb);
#line 966
  if (tmp___41 != 0) {
#line 968
    tmp___38 = quote(dst_name);
#line 968
    tmp___39 = gettext("cannot fstat %s");
#line 968
    tmp___40 = __errno_location();
#line 968
    error(0, *tmp___40, (char const   *)tmp___39, tmp___38);
#line 969
    return_val = (_Bool)0;
#line 970
    goto close_src_and_dst_desc;
  }
#line 974
  if (data_copy_required) {
#line 974
    if (x->reflink_mode) {
#line 976
      tmp___42 = clone_file(dest_desc, source_desc);
#line 976
      clone_ok = (_Bool )(tmp___42 == 0);
#line 977
      if (clone_ok) {
#line 977
        goto _L;
      } else
#line 977
      if ((unsigned int const   )x->reflink_mode == 2U) {
        _L: /* CIL Label */ 
#line 979
        if (! clone_ok) {
#line 981
          tmp___43 = quote_n(1, src_name);
#line 981
          tmp___44 = quote_n(0, dst_name);
#line 981
          tmp___45 = gettext("failed to clone %s from %s");
#line 981
          tmp___46 = __errno_location();
#line 981
          error(0, *tmp___46, (char const   *)tmp___45, tmp___44, tmp___43);
#line 983
          return_val = (_Bool)0;
#line 984
          goto close_src_and_dst_desc;
        }
#line 986
        data_copy_required = (_Bool)0;
      }
    }
  }
#line 990
  if (data_copy_required) {
#line 995
    tmp___47 = getpagesize();
#line 995
    tmp___48 = lcm((size_t )tmp___47, sizeof(word___0 ));
#line 995
    buf_alignment = tmp___48;
#line 996
    buf_alignment_slop = (sizeof(word___0 ) + buf_alignment) - 1UL;
#line 997
    tmp___49 = io_blksize(sb);
#line 997
    buf_size = tmp___49;
#line 1000
    make_holes = (_Bool)0;
#line 1001
    sparse_src = (_Bool)0;
#line 1003
    if ((sb.st_mode & 61440U) == 32768U) {
#line 1007
      if ((unsigned int const   )x->sparse_mode == 3U) {
#line 1008
        make_holes = (_Bool)1;
      }
#line 1014
      sparse_src = is_probably_sparse((struct stat  const  *)(& src_open_sb));
#line 1015
      if ((unsigned int const   )x->sparse_mode == 2U) {
#line 1015
        if (sparse_src) {
#line 1016
          make_holes = (_Bool)1;
        }
      }
    }
#line 1021
    if (! make_holes) {
#line 1025
      blcm_max = 9223372036854775807UL - buf_alignment_slop;
#line 1026
      tmp___50 = io_blksize(src_open_sb);
#line 1026
      tmp___51 = buffer_lcm(tmp___50, buf_size, blcm_max);
#line 1026
      blcm = tmp___51;
#line 1031
      if ((src_open_sb.st_mode & 61440U) == 32768U) {
#line 1031
        if ((size_t )src_open_sb.st_size < buf_size) {
#line 1032
          buf_size = (size_t )(src_open_sb.st_size + 1L);
        }
      }
#line 1037
      buf_size += blcm - 1UL;
#line 1038
      buf_size -= buf_size % blcm;
#line 1039
      if (buf_size == 0UL) {
#line 1040
        buf_size = blcm;
      } else
#line 1039
      if (blcm_max < buf_size) {
#line 1040
        buf_size = blcm;
      }
    }
#line 1044
    tmp___52 = xmalloc(buf_size + buf_alignment_slop);
#line 1044
    buf_alloc = (char *)tmp___52;
#line 1045
    tmp___53 = ptr_align((void const   *)buf_alloc, buf_alignment);
#line 1045
    buf___1 = (char *)tmp___53;
#line 1047
    if (sparse_src) {
#line 1055
      if ((sb.st_mode & 61440U) == 32768U) {
#line 1055
        tmp___54 = (unsigned int const   )x->sparse_mode;
      } else {
#line 1055
        tmp___54 = (unsigned int const   )1;
      }
#line 1055
      tmp___55 = extent_copy(source_desc, dest_desc, buf___1, buf_size, src_open_sb.st_size,
                             (enum Sparse_type )tmp___54, src_name, dst_name, & normal_copy_required);
#line 1055
      if (tmp___55) {
#line 1059
        goto preserve_metadata;
      }
#line 1061
      if (! normal_copy_required) {
#line 1063
        return_val = (_Bool)0;
#line 1064
        goto close_src_and_dst_desc;
      }
    }
#line 1070
    tmp___59 = sparse_copy(source_desc, dest_desc, buf___1, buf_size, make_holes,
                           src_name, dst_name, 0xffffffffffffffffUL, & n_read, & wrote_hole_at_eof);
#line 1070
    if (tmp___59) {
#line 1070
      if (wrote_hole_at_eof) {
#line 1070
        tmp___60 = ftruncate(dest_desc, n_read);
#line 1070
        if (tmp___60 < 0) {
          _L___0: /* CIL Label */ 
#line 1077
          tmp___56 = quote(dst_name);
#line 1077
          tmp___57 = gettext("failed to extend %s");
#line 1077
          tmp___58 = __errno_location();
#line 1077
          error(0, *tmp___58, (char const   *)tmp___57, tmp___56);
#line 1078
          return_val = (_Bool)0;
#line 1079
          goto close_src_and_dst_desc;
        }
      }
    } else {
#line 1070
      goto _L___0;
    }
  }
  preserve_metadata: 
#line 1084
  if (x->preserve_timestamps) {
#line 1087
    timespec[0] = get_stat_atime(src_sb);
#line 1088
    timespec[1] = get_stat_mtime(src_sb);
#line 1090
    tmp___64 = fdutimens(dest_desc, dst_name, (struct timespec  const  *)(timespec));
#line 1090
    if (tmp___64 != 0) {
#line 1092
      tmp___61 = quote(dst_name);
#line 1092
      tmp___62 = gettext("preserving times for %s");
#line 1092
      tmp___63 = __errno_location();
#line 1092
      error(0, *tmp___63, (char const   *)tmp___62, tmp___61);
#line 1093
      if (x->require_preserve) {
#line 1095
        return_val = (_Bool)0;
#line 1096
        goto close_src_and_dst_desc;
      }
    }
  }
#line 1103
  if (x->preserve_ownership) {
#line 1103
    if (src_sb->st_uid == (__uid_t const   )sb.st_uid) {
#line 1103
      if (! (src_sb->st_gid == (__gid_t const   )sb.st_gid)) {
#line 1103
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 1105
      tmp___65 = set_owner(x, dst_name, dest_desc, src_sb, *new_dst, (struct stat  const  *)(& sb));
#line 1105
      switch (tmp___65) {
      case -1: 
#line 1108
      return_val = (_Bool)0;
#line 1109
      goto close_src_and_dst_desc;
      case 0: 
#line 1112
      src_mode &= 4294963711U;
#line 1113
      break;
      }
    }
  }
#line 1120
  if (x->preserve_xattr) {
#line 1122
    access_changed = (_Bool)0;
#line 1124
    if (! (sb.st_mode & 128U)) {
#line 1124
      tmp___67 = geteuid();
#line 1124
      if (tmp___67 != 0U) {
#line 1125
        tmp___66 = fchmod_or_lchmod(dest_desc, dst_name, (mode_t )384);
#line 1125
        access_changed = (_Bool )(tmp___66 == 0);
      }
    }
#line 1127
    tmp___68 = copy_attr(src_name, source_desc, dst_name, dest_desc, x);
#line 1127
    if (! tmp___68) {
#line 1127
      if (x->require_preserve_xattr) {
#line 1129
        return_val = (_Bool)0;
      }
    }
#line 1131
    if (access_changed) {
#line 1132
      fchmod_or_lchmod(dest_desc, dst_name, dst_mode & ~ omitted_permissions);
    }
  }
#line 1135
  set_author(dst_name, dest_desc, src_sb);
#line 1137
  if (x->preserve_mode) {
#line 1137
    goto _L___2;
  } else
#line 1137
  if (x->move_mode) {
    _L___2: /* CIL Label */ 
#line 1139
    tmp___69 = copy_acl(src_name, source_desc, dst_name, dest_desc, src_mode);
#line 1139
    if (tmp___69 != 0) {
#line 1139
      if (x->require_preserve) {
#line 1141
        return_val = (_Bool)0;
      }
    }
  } else
#line 1143
  if (x->set_mode) {
#line 1145
    tmp___70 = set_acl(dst_name, dest_desc, (mode_t )x->mode);
#line 1145
    if (tmp___70 != 0) {
#line 1146
      return_val = (_Bool)0;
    }
  } else
#line 1148
  if (omitted_permissions) {
#line 1150
    tmp___71 = cached_umask();
#line 1150
    omitted_permissions &= ~ tmp___71;
#line 1151
    if (omitted_permissions) {
#line 1151
      tmp___75 = fchmod_or_lchmod(dest_desc, dst_name, dst_mode);
#line 1151
      if (tmp___75 != 0) {
#line 1154
        tmp___72 = quote(dst_name);
#line 1154
        tmp___73 = gettext("preserving permissions for %s");
#line 1154
        tmp___74 = __errno_location();
#line 1154
        error(0, *tmp___74, (char const   *)tmp___73, tmp___72);
#line 1156
        if (x->require_preserve) {
#line 1157
          return_val = (_Bool)0;
        }
      }
    }
  }
  close_src_and_dst_desc: 
#line 1162
  tmp___79 = close(dest_desc);
#line 1162
  if (tmp___79 < 0) {
#line 1164
    tmp___76 = quote(dst_name);
#line 1164
    tmp___77 = gettext("closing %s");
#line 1164
    tmp___78 = __errno_location();
#line 1164
    error(0, *tmp___78, (char const   *)tmp___77, tmp___76);
#line 1165
    return_val = (_Bool)0;
  }
  close_src_desc: 
#line 1168
  tmp___83 = close(source_desc);
#line 1168
  if (tmp___83 < 0) {
#line 1170
    tmp___80 = quote(src_name);
#line 1170
    tmp___81 = gettext("closing %s");
#line 1170
    tmp___82 = __errno_location();
#line 1170
    error(0, *tmp___82, (char const   *)tmp___81, tmp___80);
#line 1171
    return_val = (_Bool)0;
  }
#line 1174
  free((void *)buf_alloc);
#line 1175
  free((void *)name_alloc);
#line 1176
  return (return_val);
}
}
#line 1196 "copy.c"
static _Bool same_file_ok(char const   *src_name , struct stat  const  *src_sb , char const   *dst_name ,
                          struct stat  const  *dst_sb , struct cp_options  const  *x ,
                          _Bool *return_now , _Bool *unlink_src ) 
{ struct stat  const  *src_sb_link ;
  struct stat  const  *dst_sb_link ;
  struct stat tmp_dst_sb ;
  struct stat tmp_src_sb ;
  _Bool same_link ;
  _Bool same ;
  int tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  _Bool tmp___5 ;
  int tmp___6 ;
  _Bool tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 1207
  if (src_sb->st_ino == dst_sb->st_ino) {
#line 1207
    if (src_sb->st_dev == dst_sb->st_dev) {
#line 1207
      tmp = 1;
    } else {
#line 1207
      tmp = 0;
    }
  } else {
#line 1207
    tmp = 0;
  }
#line 1207
  same = (_Bool )tmp;
#line 1209
  *return_now = (_Bool)0;
#line 1210
  *unlink_src = (_Bool)0;
#line 1217
  if (same) {
#line 1217
    if (x->hard_link) {
#line 1219
      *return_now = (_Bool)1;
#line 1220
      return ((_Bool)1);
    }
  }
#line 1223
  if ((unsigned int const   )x->dereference == 2U) {
#line 1225
    same_link = same;
#line 1230
    if ((src_sb->st_mode & 61440U) == 40960U) {
#line 1230
      if ((dst_sb->st_mode & 61440U) == 40960U) {
#line 1231
        tmp___0 = same_name(src_name, dst_name);
#line 1231
        if (tmp___0) {
#line 1231
          tmp___1 = 0;
        } else {
#line 1231
          tmp___1 = 1;
        }
#line 1231
        return ((_Bool )tmp___1);
      }
    }
#line 1233
    src_sb_link = src_sb;
#line 1234
    dst_sb_link = dst_sb;
  } else {
#line 1238
    if (! same) {
#line 1239
      return ((_Bool)1);
    }
#line 1241
    tmp___2 = lstat((char const   * __restrict  )dst_name, (struct stat * __restrict  )(& tmp_dst_sb));
#line 1241
    if (tmp___2 != 0) {
#line 1243
      return ((_Bool)1);
    } else {
#line 1241
      tmp___3 = lstat((char const   * __restrict  )src_name, (struct stat * __restrict  )(& tmp_src_sb));
#line 1241
      if (tmp___3 != 0) {
#line 1243
        return ((_Bool)1);
      }
    }
#line 1245
    src_sb_link = (struct stat  const  *)(& tmp_src_sb);
#line 1246
    dst_sb_link = (struct stat  const  *)(& tmp_dst_sb);
#line 1248
    if (src_sb_link->st_ino == dst_sb_link->st_ino) {
#line 1248
      if (src_sb_link->st_dev == dst_sb_link->st_dev) {
#line 1248
        tmp___4 = 1;
      } else {
#line 1248
        tmp___4 = 0;
      }
    } else {
#line 1248
      tmp___4 = 0;
    }
#line 1248
    same_link = (_Bool )tmp___4;
#line 1255
    if ((src_sb_link->st_mode & 61440U) == 40960U) {
#line 1255
      if ((dst_sb_link->st_mode & 61440U) == 40960U) {
#line 1255
        if (x->unlink_dest_before_opening) {
#line 1257
          return ((_Bool)1);
        }
      }
    }
  }
#line 1265
  if ((unsigned int const   )x->backup_type != 0U) {
#line 1267
    if (! same_link) {
#line 1285
      if (! x->move_mode) {
#line 1285
        if ((unsigned int const   )x->dereference != 2U) {
#line 1285
          if ((src_sb_link->st_mode & 61440U) == 40960U) {
#line 1285
            if (! ((dst_sb_link->st_mode & 61440U) == 40960U)) {
#line 1289
              return ((_Bool)0);
            }
          }
        }
      }
#line 1291
      return ((_Bool)1);
    }
#line 1294
    tmp___5 = same_name(src_name, dst_name);
#line 1294
    if (tmp___5) {
#line 1294
      tmp___6 = 0;
    } else {
#line 1294
      tmp___6 = 1;
    }
#line 1294
    return ((_Bool )tmp___6);
  }
#line 1319
  if (x->move_mode) {
#line 1319
    goto _L;
  } else
#line 1319
  if (x->unlink_dest_before_opening) {
    _L: /* CIL Label */ 
#line 1321
    if ((dst_sb_link->st_mode & 61440U) == 40960U) {
#line 1322
      return ((_Bool)1);
    }
#line 1324
    if (same_link) {
#line 1324
      if (1UL < dst_sb_link->st_nlink) {
#line 1324
        tmp___7 = same_name(src_name, dst_name);
#line 1324
        if (! tmp___7) {
#line 1328
          if (x->move_mode) {
#line 1330
            *unlink_src = (_Bool)1;
#line 1331
            *return_now = (_Bool)1;
          }
#line 1333
          return ((_Bool)1);
        }
      }
    }
  }
#line 1339
  if (! ((src_sb_link->st_mode & 61440U) == 40960U)) {
#line 1339
    if (! ((dst_sb_link->st_mode & 61440U) == 40960U)) {
#line 1341
      if (src_sb_link->st_ino == dst_sb_link->st_ino) {
#line 1341
        if (! (src_sb_link->st_dev == dst_sb_link->st_dev)) {
#line 1342
          return ((_Bool)1);
        }
      } else {
#line 1342
        return ((_Bool)1);
      }
#line 1345
      if (x->hard_link) {
#line 1347
        *return_now = (_Bool)1;
#line 1348
        return ((_Bool)1);
      }
    }
  }
#line 1355
  if (x->unlink_dest_before_opening) {
#line 1355
    if ((dst_sb_link->st_mode & 61440U) == 40960U) {
#line 1357
      return ((_Bool )(dst_sb_link->st_dev == src_sb_link->st_dev));
    }
  }
#line 1359
  if ((unsigned int const   )x->dereference == 2U) {
#line 1361
    if (! ((src_sb_link->st_mode & 61440U) == 40960U)) {
#line 1362
      tmp_src_sb = (struct stat )*src_sb_link;
    } else {
#line 1363
      tmp___8 = stat((char const   * __restrict  )src_name, (struct stat * __restrict  )(& tmp_src_sb));
#line 1363
      if (tmp___8 != 0) {
#line 1364
        return ((_Bool)1);
      }
    }
#line 1366
    if (! ((dst_sb_link->st_mode & 61440U) == 40960U)) {
#line 1367
      tmp_dst_sb = (struct stat )*dst_sb_link;
    } else {
#line 1368
      tmp___9 = stat((char const   * __restrict  )dst_name, (struct stat * __restrict  )(& tmp_dst_sb));
#line 1368
      if (tmp___9 != 0) {
#line 1369
        return ((_Bool)1);
      }
    }
#line 1371
    if (tmp_src_sb.st_ino == tmp_dst_sb.st_ino) {
#line 1371
      if (! (tmp_src_sb.st_dev == tmp_dst_sb.st_dev)) {
#line 1372
        return ((_Bool)1);
      }
    } else {
#line 1372
      return ((_Bool)1);
    }
#line 1375
    if (x->hard_link) {
#line 1377
      *return_now = (_Bool)1;
#line 1378
      return ((_Bool)1);
    }
  }
#line 1382
  return ((_Bool)0);
}
}
#line 1387 "copy.c"
static _Bool writable_destination(char const   *file , mode_t mode ) 
{ _Bool tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1390
  if ((mode & 61440U) == 40960U) {
#line 1390
    tmp___1 = 1;
  } else {
#line 1390
    tmp = can_write_any_file();
#line 1390
    if (tmp) {
#line 1390
      tmp___1 = 1;
    } else {
#line 1390
      tmp___0 = euidaccess(file, 2);
#line 1390
      if (tmp___0 == 0) {
#line 1390
        tmp___1 = 1;
      } else {
#line 1390
        tmp___1 = 0;
      }
    }
  }
#line 1390
  return ((_Bool )tmp___1);
}
}
#line 1395 "copy.c"
static void overwrite_prompt(char const   *dst_name , struct stat  const  *dst_sb ) 
{ char perms[12] ;
  char const   *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  _Bool tmp___3 ;

  {
#line 1398
  tmp___3 = writable_destination(dst_name, (mode_t )dst_sb->st_mode);
#line 1398
  if (tmp___3) {
#line 1411
    tmp___1 = quote(dst_name);
#line 1411
    tmp___2 = gettext("%s: overwrite %s? ");
#line 1411
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___2, program_name,
            tmp___1);
  } else {
#line 1401
    strmode((mode_t )dst_sb->st_mode, perms);
#line 1402
    perms[10] = (char )'\000';
#line 1403
    tmp = quote(dst_name);
#line 1403
    tmp___0 = gettext("%s: try to overwrite %s, overriding mode %04lo (%s)? ");
#line 1403
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___0, program_name,
            tmp, (unsigned long )(dst_sb->st_mode & (unsigned int const   )((4032 | (448 >> 3)) | ((448 >> 3) >> 3))),
            & perms[1]);
  }
#line 1414
  return;
}
}
#line 1418 "copy.c"
extern void dest_info_init(struct cp_options *x ) 
{ 

  {
#line 1421
  x->dest_info = hash_initialize((size_t )61, (Hash_tuning const   *)((void *)0),
                                 & triple_hash, & triple_compare, & triple_free);
#line 1427
  return;
}
}
#line 1431 "copy.c"
extern void src_info_init(struct cp_options *x ) 
{ 

  {
#line 1443
  x->src_info = hash_initialize((size_t )61, (Hash_tuning const   *)((void *)0), & triple_hash_no_name,
                                & triple_compare, & triple_free);
#line 1449
  return;
}
}
#line 1457 "copy.c"
static _Bool abandon_move(struct cp_options  const  *x , char const   *dst_name ,
                          struct stat  const  *dst_sb ) 
{ _Bool tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;

  {
#line 1462
  if (! x->move_mode) {
#line 1462
    __assert_fail("x->move_mode", "copy.c", 1462U, "abandon_move");
  }
#line 1463
  if ((unsigned int const   )x->interactive == 2U) {
#line 1463
    tmp___1 = 1;
  } else
#line 1463
  if ((unsigned int const   )x->interactive == 3U) {
#line 1463
    goto _L;
  } else
#line 1463
  if ((unsigned int const   )x->interactive == 4U) {
#line 1463
    if (x->stdin_tty) {
#line 1463
      tmp = writable_destination(dst_name, (mode_t )dst_sb->st_mode);
#line 1463
      if (tmp) {
#line 1463
        tmp___1 = 0;
      } else {
        _L: /* CIL Label */ 
#line 1463
        overwrite_prompt(dst_name, dst_sb);
#line 1463
        tmp___0 = yesno();
#line 1463
        if (tmp___0) {
#line 1463
          tmp___1 = 0;
        } else {
#line 1463
          tmp___1 = 1;
        }
      }
    } else {
#line 1463
      tmp___1 = 0;
    }
  } else {
#line 1463
    tmp___1 = 0;
  }
#line 1463
  return ((_Bool )tmp___1);
}
}
#line 1475 "copy.c"
static void emit_verbose(char const   *src , char const   *dst , char const   *backup_dst_name ) 
{ char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;

  {
#line 1478
  tmp = quote_n(1, dst);
#line 1478
  tmp___0 = quote_n(0, src);
#line 1478
  printf((char const   * __restrict  )"%s -> %s", tmp___0, tmp);
#line 1479
  if (backup_dst_name) {
#line 1480
    tmp___1 = quote(backup_dst_name);
#line 1480
    tmp___2 = gettext(" (backup: %s)");
#line 1480
    printf((char const   * __restrict  )tmp___2, tmp___1);
  }
#line 1481
  putchar_unlocked('\n');
#line 1482
  return;
}
}
#line 1485 "copy.c"
static void restore_default_fscreatecon_or_die(void) 
{ char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
#line 1488
  tmp___1 = setfscreatecon((char *)((void *)0));
#line 1488
  if (tmp___1 != 0) {
#line 1489
    tmp = gettext("failed to restore the default file creation context");
#line 1489
    tmp___0 = __errno_location();
#line 1489
    error(1, *tmp___0, (char const   *)tmp);
  }
#line 1491
  return;
}
}
#line 1499 "copy.c"
static _Bool create_hard_link(char const   *src_name , char const   *dst_name , _Bool replace ,
                              _Bool verbose ) 
{ _Bool link_failed ;
  int tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;

  {
#line 1504
  tmp = rpl_linkat(-100, src_name, -100, dst_name, 0);
#line 1504
  link_failed = (_Bool )(tmp != 0);
#line 1508
  if (link_failed) {
#line 1508
    if (replace) {
#line 1508
      tmp___7 = __errno_location();
#line 1508
      if (*tmp___7 == 17) {
#line 1510
        tmp___3 = unlink(dst_name);
#line 1510
        if (tmp___3 != 0) {
#line 1512
          tmp___0 = quote(dst_name);
#line 1512
          tmp___1 = gettext("cannot remove %s");
#line 1512
          tmp___2 = __errno_location();
#line 1512
          error(0, *tmp___2, (char const   *)tmp___1, tmp___0);
#line 1513
          return ((_Bool)0);
        }
#line 1515
        if (verbose) {
#line 1516
          tmp___4 = quote(dst_name);
#line 1516
          tmp___5 = gettext("removed %s\n");
#line 1516
          printf((char const   * __restrict  )tmp___5, tmp___4);
        }
#line 1517
        tmp___6 = rpl_linkat(-100, src_name, -100, dst_name, 0);
#line 1517
        link_failed = (_Bool )(tmp___6 != 0);
      }
    }
  }
#line 1520
  if (link_failed) {
#line 1522
    tmp___8 = quote_n(1, src_name);
#line 1522
    tmp___9 = quote_n(0, dst_name);
#line 1522
    tmp___10 = gettext("cannot create hard link %s to %s");
#line 1522
    tmp___11 = __errno_location();
#line 1522
    error(0, *tmp___11, (char const   *)tmp___10, tmp___9, tmp___8);
#line 1524
    return ((_Bool)0);
  }
#line 1527
  return ((_Bool)1);
}
}
#line 1542 "copy.c"
static _Bool copy_internal(char const   *src_name , char const   *dst_name , _Bool new_dst ,
                           dev_t device , struct dir_list *ancestors , struct cp_options  const  *x ,
                           _Bool command_line_arg , _Bool *first_dir_created_per_command_line_arg ,
                           _Bool *copy_into_self , _Bool *rename_succeeded ) 
{ struct stat src_sb ;
  struct stat dst_sb ;
  mode_t src_mode ;
  mode_t dst_mode ;
  mode_t dst_mode_bits ;
  mode_t omitted_permissions ;
  _Bool restore_dst_mode ;
  char *earlier_file ;
  char *dst_backup ;
  _Bool backup_succeeded ;
  _Bool delayed_ok ;
  _Bool copied_as_regular ;
  _Bool dest_is_symlink ;
  _Bool have_dst_lstat ;
  char const   *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  char const   *tmp___7 ;
  char *tmp___8 ;
  _Bool tmp___9 ;
  _Bool use_stat ;
  int tmp___10 ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  int *tmp___13 ;
  int *tmp___14 ;
  _Bool return_now ;
  _Bool unlink_src ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  char *tmp___17 ;
  _Bool tmp___18 ;
  int options ;
  int tmp___19 ;
  _Bool tmp___20 ;
  int tmp___21 ;
  char const   *tmp___22 ;
  char *tmp___23 ;
  _Bool tmp___24 ;
  int tmp___25 ;
  char const   *tmp___26 ;
  char *tmp___27 ;
  int *tmp___28 ;
  _Bool tmp___29 ;
  char const   *tmp___30 ;
  char const   *tmp___31 ;
  char *tmp___32 ;
  char const   *tmp___33 ;
  char const   *tmp___34 ;
  char *tmp___35 ;
  _Bool tmp___36 ;
  char const   *tmp___37 ;
  char *tmp___38 ;
  char const   *tmp___39 ;
  char const   *tmp___40 ;
  char *tmp___41 ;
  char *tmp_backup ;
  char *tmp___42 ;
  char const   *fmt___0 ;
  char *tmp___43 ;
  char *tmp___44 ;
  char const   *tmp___45 ;
  char const   *tmp___46 ;
  int tmp___47 ;
  char const   *__old ;
  size_t __len ;
  size_t tmp___48 ;
  char *__new ;
  void *tmp___49 ;
  void *tmp___50 ;
  char const   *tmp___51 ;
  char *tmp___52 ;
  int *tmp___53 ;
  int *tmp___54 ;
  int tmp___55 ;
  char const   *tmp___56 ;
  char *tmp___57 ;
  int *tmp___58 ;
  int tmp___59 ;
  int *tmp___60 ;
  char const   *tmp___61 ;
  char *tmp___62 ;
  char *tmp___63 ;
  _Bool tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  _Bool lstat_ok ;
  struct stat tmp_buf ;
  struct stat *dst_lstat_sb ;
  int tmp___68 ;
  char const   *tmp___69 ;
  char const   *tmp___70 ;
  char *tmp___71 ;
  _Bool tmp___72 ;
  char *tmp___73 ;
  char const   *tmp___74 ;
  char const   *tmp___75 ;
  char *tmp___76 ;
  char const   *tmp___77 ;
  char const   *tmp___78 ;
  char *tmp___79 ;
  _Bool tmp___80 ;
  _Bool tmp___81 ;
  char *tmp___82 ;
  int tmp___83 ;
  char const   *tmp___84 ;
  char const   *tmp___85 ;
  char *tmp___86 ;
  int *tmp___87 ;
  char const   *tmp___88 ;
  char const   *tmp___89 ;
  char *tmp___90 ;
  int *tmp___91 ;
  int *tmp___92 ;
  char const   *tmp___93 ;
  char const   *tmp___94 ;
  char *tmp___95 ;
  int *tmp___96 ;
  int tmp___97 ;
  int *tmp___98 ;
  mode_t tmp___99 ;
  int tmp___100 ;
  int tmp___101 ;
  _Bool all_errors ;
  int tmp___102 ;
  _Bool some_errors ;
  int tmp___103 ;
  char *con ;
  char const   *tmp___104 ;
  char *tmp___105 ;
  int *tmp___106 ;
  int *tmp___107 ;
  _Bool tmp___108 ;
  int tmp___109 ;
  char const   *tmp___110 ;
  char *tmp___111 ;
  int *tmp___112 ;
  int *tmp___113 ;
  _Bool tmp___114 ;
  int tmp___115 ;
  struct dir_list *dir ;
  char const   *tmp___116 ;
  char *tmp___117 ;
  _Bool __attribute__((__pure__))  tmp___118 ;
  void *tmp___119 ;
  char const   *tmp___120 ;
  char *tmp___121 ;
  int *tmp___122 ;
  int tmp___123 ;
  char const   *tmp___124 ;
  char *tmp___125 ;
  int *tmp___126 ;
  char const   *tmp___127 ;
  char *tmp___128 ;
  int *tmp___129 ;
  int tmp___130 ;
  int tmp___131 ;
  struct stat dot_sb ;
  struct stat dst_parent_sb ;
  char *dst_parent ;
  _Bool in_current_dir ;
  int tmp___132 ;
  int tmp___133 ;
  int tmp___134 ;
  int tmp___135 ;
  char const   *tmp___136 ;
  char *tmp___137 ;
  char const   *tmp___138 ;
  char const   *tmp___139 ;
  char *tmp___140 ;
  int *tmp___141 ;
  int tmp___142 ;
  _Bool tmp___143 ;
  _Bool tmp___144 ;
  char const   *tmp___145 ;
  char *tmp___146 ;
  int *tmp___147 ;
  int tmp___148 ;
  int tmp___149 ;
  char const   *tmp___150 ;
  char *tmp___151 ;
  int *tmp___152 ;
  int tmp___153 ;
  char *src_link_val ;
  char *tmp___154 ;
  char const   *tmp___155 ;
  char *tmp___156 ;
  int *tmp___157 ;
  int saved_errno ;
  int *tmp___158 ;
  _Bool same_link ;
  char *dest_link_val ;
  char *tmp___159 ;
  int tmp___160 ;
  size_t tmp___161 ;
  char const   *tmp___162 ;
  char *tmp___163 ;
  int tmp___164 ;
  char *tmp___165 ;
  int *tmp___166 ;
  int tmp___167 ;
  _Bool tmp___168 ;
  char const   *tmp___169 ;
  char *tmp___170 ;
  struct stat sb ;
  int tmp___171 ;
  struct timespec timespec[2] ;
  char const   *tmp___172 ;
  char *tmp___173 ;
  int *tmp___174 ;
  int tmp___175 ;
  int tmp___176 ;
  int tmp___177 ;
  int tmp___178 ;
  _Bool tmp___179 ;
  int tmp___180 ;
  int tmp___181 ;
  mode_t tmp___182 ;
  char const   *tmp___183 ;
  char *tmp___184 ;
  int *tmp___185 ;
  int tmp___186 ;
  char const   *tmp___187 ;
  char *tmp___188 ;
  int *tmp___189 ;
  int tmp___190 ;
  char const   *tmp___191 ;
  char *tmp___192 ;
  int *tmp___193 ;
  char const   *tmp___194 ;
  char const   *tmp___195 ;
  char *tmp___196 ;
  int tmp___197 ;

  {
#line 1559
  restore_dst_mode = (_Bool)0;
#line 1560
  earlier_file = (char *)((void *)0);
#line 1561
  dst_backup = (char *)((void *)0);
#line 1562
  backup_succeeded = (_Bool)0;
#line 1564
  copied_as_regular = (_Bool)0;
#line 1565
  dest_is_symlink = (_Bool)0;
#line 1566
  have_dst_lstat = (_Bool)0;
#line 1568
  if (x->move_mode) {
#line 1568
    if (rename_succeeded) {
#line 1569
      *rename_succeeded = (_Bool)0;
    }
  }
#line 1571
  *copy_into_self = (_Bool)0;
#line 1573
  if ((unsigned int const   )x->dereference == 2U) {
#line 1573
    tmp___2 = lstat((char const   * __restrict  )src_name, (struct stat * __restrict  )(& src_sb));
#line 1573
    tmp___4 = tmp___2;
  } else {
#line 1573
    tmp___3 = stat((char const   * __restrict  )src_name, (struct stat * __restrict  )(& src_sb));
#line 1573
    tmp___4 = tmp___3;
  }
#line 1573
  if (tmp___4 != 0) {
#line 1575
    tmp = quote(src_name);
#line 1575
    tmp___0 = gettext("cannot stat %s");
#line 1575
    tmp___1 = __errno_location();
#line 1575
    error(0, *tmp___1, (char const   *)tmp___0, tmp);
#line 1576
    return ((_Bool)0);
  }
#line 1579
  src_mode = src_sb.st_mode;
#line 1581
  if ((src_mode & 61440U) == 16384U) {
#line 1581
    if (! x->recursive) {
#line 1583
      tmp___5 = quote(src_name);
#line 1583
      tmp___6 = gettext("omitting directory %s");
#line 1583
      error(0, 0, (char const   *)tmp___6, tmp___5);
#line 1584
      return ((_Bool)0);
    }
  }
#line 1591
  if (command_line_arg) {
#line 1593
    if (! ((src_sb.st_mode & 61440U) == 16384U)) {
#line 1593
      if ((unsigned int const   )x->backup_type == 0U) {
#line 1593
        tmp___9 = seen_file((Hash_table const   *)x->src_info, src_name, (struct stat  const  *)(& src_sb));
#line 1593
        if (tmp___9) {
#line 1597
          tmp___7 = quote(src_name);
#line 1597
          tmp___8 = gettext("warning: source file %s specified more than once");
#line 1597
          error(0, 0, (char const   *)tmp___8, tmp___7);
#line 1599
          return ((_Bool)1);
        }
      }
    }
#line 1602
    record_file((Hash_table *)x->src_info, src_name, (struct stat  const  *)(& src_sb));
  }
#line 1605
  if (! new_dst) {
#line 1613
    if ((src_mode & 61440U) == 32768U) {
#line 1613
      goto _L;
    } else
#line 1613
    if (x->copy_as_regular) {
#line 1613
      if ((src_mode & 61440U) == 16384U) {
#line 1613
        tmp___10 = 0;
      } else
#line 1613
      if ((src_mode & 61440U) == 40960U) {
#line 1613
        tmp___10 = 0;
      } else
      _L: /* CIL Label */ 
#line 1613
      if (x->move_mode) {
#line 1613
        tmp___10 = 0;
      } else
#line 1613
      if (x->symbolic_link) {
#line 1613
        tmp___10 = 0;
      } else
#line 1613
      if (x->hard_link) {
#line 1613
        tmp___10 = 0;
      } else
#line 1613
      if ((unsigned int const   )x->backup_type != 0U) {
#line 1613
        tmp___10 = 0;
      } else
#line 1613
      if (x->unlink_dest_before_opening) {
#line 1613
        tmp___10 = 0;
      } else {
#line 1613
        tmp___10 = 1;
      }
    } else {
#line 1613
      tmp___10 = 0;
    }
#line 1613
    use_stat = (_Bool )tmp___10;
#line 1620
    if (use_stat) {
#line 1620
      tmp___65 = stat((char const   * __restrict  )dst_name, (struct stat * __restrict  )(& dst_sb));
#line 1620
      tmp___67 = tmp___65;
    } else {
#line 1620
      tmp___66 = lstat((char const   * __restrict  )dst_name, (struct stat * __restrict  )(& dst_sb));
#line 1620
      tmp___67 = tmp___66;
    }
#line 1620
    if (tmp___67 != 0) {
#line 1625
      tmp___14 = __errno_location();
#line 1625
      if (*tmp___14 != 2) {
#line 1627
        tmp___11 = quote(dst_name);
#line 1627
        tmp___12 = gettext("cannot stat %s");
#line 1627
        tmp___13 = __errno_location();
#line 1627
        error(0, *tmp___13, (char const   *)tmp___12, tmp___11);
#line 1628
        return ((_Bool)0);
      } else {
#line 1632
        new_dst = (_Bool)1;
      }
    } else {
#line 1641
      have_dst_lstat = (_Bool )(! use_stat);
#line 1642
      tmp___18 = same_file_ok(src_name, (struct stat  const  *)(& src_sb), dst_name,
                              (struct stat  const  *)(& dst_sb), x, & return_now,
                              & unlink_src);
#line 1642
      if (! tmp___18) {
#line 1645
        tmp___15 = quote_n(1, dst_name);
#line 1645
        tmp___16 = quote_n(0, src_name);
#line 1645
        tmp___17 = gettext("%s and %s are the same file");
#line 1645
        error(0, 0, (char const   *)tmp___17, tmp___16, tmp___15);
#line 1647
        return ((_Bool)0);
      }
#line 1650
      if (! ((src_mode & 61440U) == 16384U)) {
#line 1650
        if (x->update) {
#line 1656
          if (x->preserve_timestamps) {
#line 1656
            if (x->move_mode) {
#line 1656
              if (dst_sb.st_dev == src_sb.st_dev) {
#line 1656
                tmp___19 = 0;
              } else {
#line 1656
                tmp___19 = 1;
              }
            } else {
#line 1656
              tmp___19 = 1;
            }
          } else {
#line 1656
            tmp___19 = 0;
          }
#line 1656
          options = tmp___19;
#line 1662
          tmp___21 = utimecmp(dst_name, (struct stat  const  *)(& dst_sb), (struct stat  const  *)(& src_sb),
                              options);
#line 1662
          if (0 <= tmp___21) {
#line 1668
            if (rename_succeeded) {
#line 1669
              *rename_succeeded = (_Bool)1;
            }
#line 1676
            earlier_file = remember_copied(dst_name, src_sb.st_ino, src_sb.st_dev);
#line 1678
            if (earlier_file) {
#line 1682
              tmp___20 = create_hard_link((char const   *)earlier_file, dst_name,
                                          (_Bool)1, (_Bool )x->verbose);
#line 1682
              if (! tmp___20) {
#line 1685
                goto un_backup;
              }
            }
#line 1689
            return ((_Bool)1);
          }
        }
      }
#line 1700
      if (x->move_mode) {
#line 1702
        tmp___24 = abandon_move(x, dst_name, (struct stat  const  *)(& dst_sb));
#line 1702
        if (tmp___24) {
#line 1702
          goto _L___0;
        } else
#line 1702
        if (unlink_src) {
#line 1702
          tmp___25 = unlink(src_name);
#line 1702
          if (tmp___25 == 0) {
            _L___0: /* CIL Label */ 
#line 1707
            if (rename_succeeded) {
#line 1708
              *rename_succeeded = (_Bool)1;
            }
#line 1709
            if (unlink_src) {
#line 1709
              if (x->verbose) {
#line 1710
                tmp___22 = quote(src_name);
#line 1710
                tmp___23 = gettext("removed %s\n");
#line 1710
                printf((char const   * __restrict  )tmp___23, tmp___22);
              }
            }
#line 1711
            return ((_Bool)1);
          }
        }
#line 1713
        if (unlink_src) {
#line 1715
          tmp___26 = quote(src_name);
#line 1715
          tmp___27 = gettext("cannot remove %s");
#line 1715
          tmp___28 = __errno_location();
#line 1715
          error(0, *tmp___28, (char const   *)tmp___27, tmp___26);
#line 1716
          return ((_Bool)0);
        }
      } else
#line 1721
      if (! ((src_mode & 61440U) == 16384U)) {
#line 1721
        if ((unsigned int const   )x->interactive == 2U) {
#line 1726
          return ((_Bool)1);
        } else
#line 1721
        if ((unsigned int const   )x->interactive == 3U) {
#line 1721
          overwrite_prompt(dst_name, (struct stat  const  *)(& dst_sb));
#line 1721
          tmp___29 = yesno();
#line 1721
          if (! tmp___29) {
#line 1726
            return ((_Bool)1);
          }
        }
      }
#line 1729
      if (return_now) {
#line 1730
        return ((_Bool)1);
      }
#line 1732
      if (! ((dst_sb.st_mode & 61440U) == 16384U)) {
#line 1734
        if ((src_mode & 61440U) == 16384U) {
#line 1736
          if (x->move_mode) {
#line 1736
            if (! ((unsigned int const   )x->backup_type != 0U)) {
#line 1743
              tmp___30 = quote_n(1, src_name);
#line 1743
              tmp___31 = quote_n(0, dst_name);
#line 1743
              tmp___32 = gettext("cannot overwrite non-directory %s with directory %s");
#line 1743
              error(0, 0, (char const   *)tmp___32, tmp___31, tmp___30);
#line 1746
              return ((_Bool)0);
            }
          } else {
#line 1743
            tmp___30 = quote_n(1, src_name);
#line 1743
            tmp___31 = quote_n(0, dst_name);
#line 1743
            tmp___32 = gettext("cannot overwrite non-directory %s with directory %s");
#line 1743
            error(0, 0, (char const   *)tmp___32, tmp___31, tmp___30);
#line 1746
            return ((_Bool)0);
          }
        }
#line 1757
        if (command_line_arg) {
#line 1757
          if ((unsigned int const   )x->backup_type != 3U) {
#line 1757
            tmp___36 = seen_file((Hash_table const   *)x->dest_info, dst_name, (struct stat  const  *)(& dst_sb));
#line 1757
            if (tmp___36) {
#line 1761
              tmp___33 = quote_n(1, src_name);
#line 1761
              tmp___34 = quote_n(0, dst_name);
#line 1761
              tmp___35 = gettext("will not overwrite just-created %s with %s");
#line 1761
              error(0, 0, (char const   *)tmp___35, tmp___34, tmp___33);
#line 1764
              return ((_Bool)0);
            }
          }
        }
      }
#line 1768
      if (! ((src_mode & 61440U) == 16384U)) {
#line 1770
        if ((dst_sb.st_mode & 61440U) == 16384U) {
#line 1772
          if (x->move_mode) {
#line 1772
            if (! ((unsigned int const   )x->backup_type != 0U)) {
#line 1779
              tmp___37 = quote(dst_name);
#line 1779
              tmp___38 = gettext("cannot overwrite directory %s with non-directory");
#line 1779
              error(0, 0, (char const   *)tmp___38, tmp___37);
#line 1782
              return ((_Bool)0);
            }
          } else {
#line 1779
            tmp___37 = quote(dst_name);
#line 1779
            tmp___38 = gettext("cannot overwrite directory %s with non-directory");
#line 1779
            error(0, 0, (char const   *)tmp___38, tmp___37);
#line 1782
            return ((_Bool)0);
          }
        }
      }
#line 1787
      if (x->move_mode) {
#line 1790
        if ((src_sb.st_mode & 61440U) == 16384U) {
#line 1790
          if (! ((dst_sb.st_mode & 61440U) == 16384U)) {
#line 1790
            if ((unsigned int const   )x->backup_type == 0U) {
#line 1793
              tmp___39 = quote_n(0, dst_name);
#line 1793
              tmp___40 = quote_n(0, src_name);
#line 1793
              tmp___41 = gettext("cannot move directory onto non-directory: %s -> %s");
#line 1793
              error(0, 0, (char const   *)tmp___41, tmp___40, tmp___39);
#line 1796
              return ((_Bool)0);
            }
          }
        }
      }
#line 1800
      if ((unsigned int const   )x->backup_type != 0U) {
#line 1800
        tmp___63 = last_component(src_name);
#line 1800
        tmp___64 = dot_or_dotdot((char const   *)tmp___63);
#line 1800
        if (tmp___64) {
#line 1800
          goto _L___5;
        } else
#line 1800
        if (x->move_mode) {
#line 1800
          goto _L___4;
        } else
#line 1800
        if (! ((dst_sb.st_mode & 61440U) == 16384U)) {
          _L___4: /* CIL Label */ 
#line 1811
          tmp___42 = find_backup_file_name(dst_name, (enum backup_type )x->backup_type);
#line 1811
          tmp_backup = tmp___42;
#line 1820
          tmp___47 = strcmp((char const   *)tmp_backup, src_name);
#line 1820
          if (tmp___47 == 0) {
#line 1823
            if (x->move_mode) {
#line 1823
              tmp___43 = gettext("backing up %s would destroy source;  %s not moved");
#line 1823
              fmt___0 = (char const   *)tmp___43;
            } else {
#line 1823
              tmp___44 = gettext("backing up %s would destroy source;  %s not copied");
#line 1823
              fmt___0 = (char const   *)tmp___44;
            }
#line 1826
            tmp___45 = quote_n(1, src_name);
#line 1826
            tmp___46 = quote_n(0, dst_name);
#line 1826
            error(0, 0, fmt___0, tmp___46, tmp___45);
#line 1829
            free((void *)tmp_backup);
#line 1830
            return ((_Bool)0);
          }
#line 1838
          while (1) {
#line 1838
            __old = (char const   *)tmp_backup;
#line 1838
            tmp___48 = strlen(__old);
#line 1838
            __len = tmp___48 + 1UL;
#line 1838
            tmp___49 = __builtin_alloca(__len);
#line 1838
            __new = (char *)tmp___49;
#line 1838
            tmp___50 = (void *)memcpy((void * __restrict  )__new, (void const   * __restrict  )__old,
                                      __len);
#line 1838
            dst_backup = (char *)tmp___50;
#line 1838
            break;
          }
#line 1839
          free((void *)tmp_backup);
#line 1840
          tmp___55 = rename(dst_name, (char const   *)dst_backup);
#line 1840
          if (tmp___55 != 0) {
#line 1842
            tmp___54 = __errno_location();
#line 1842
            if (*tmp___54 != 2) {
#line 1844
              tmp___51 = quote(dst_name);
#line 1844
              tmp___52 = gettext("cannot backup %s");
#line 1844
              tmp___53 = __errno_location();
#line 1844
              error(0, *tmp___53, (char const   *)tmp___52, tmp___51);
#line 1845
              return ((_Bool)0);
            } else {
#line 1849
              dst_backup = (char *)((void *)0);
            }
          } else {
#line 1854
            backup_succeeded = (_Bool)1;
          }
#line 1856
          new_dst = (_Bool)1;
        } else {
#line 1800
          goto _L___5;
        }
      } else
      _L___5: /* CIL Label */ 
#line 1858
      if (! ((dst_sb.st_mode & 61440U) == 16384U)) {
#line 1858
        if (! x->move_mode) {
#line 1858
          if (x->unlink_dest_before_opening) {
#line 1858
            goto _L___1;
          } else
#line 1858
          if (x->preserve_links) {
#line 1858
            if (1UL < dst_sb.st_nlink) {
#line 1858
              goto _L___1;
            } else {
#line 1858
              goto _L___2;
            }
          } else
          _L___2: /* CIL Label */ 
#line 1858
          if ((unsigned int const   )x->dereference == 2U) {
#line 1858
            if (! ((src_sb.st_mode & 61440U) == 32768U)) {
              _L___1: /* CIL Label */ 
#line 1867
              tmp___59 = unlink(dst_name);
#line 1867
              if (tmp___59 != 0) {
#line 1867
                tmp___60 = __errno_location();
#line 1867
                if (*tmp___60 != 2) {
#line 1869
                  tmp___56 = quote(dst_name);
#line 1869
                  tmp___57 = gettext("cannot remove %s");
#line 1869
                  tmp___58 = __errno_location();
#line 1869
                  error(0, *tmp___58, (char const   *)tmp___57, tmp___56);
#line 1870
                  return ((_Bool)0);
                }
              }
#line 1872
              new_dst = (_Bool)1;
#line 1873
              if (x->verbose) {
#line 1874
                tmp___61 = quote(dst_name);
#line 1874
                tmp___62 = gettext("removed %s\n");
#line 1874
                printf((char const   * __restrict  )tmp___62, tmp___61);
              }
            }
          }
        }
      }
    }
  }
#line 1881
  if (command_line_arg) {
#line 1881
    if (x->dest_info) {
#line 1881
      if (! x->move_mode) {
#line 1881
        if ((unsigned int const   )x->backup_type == 0U) {
#line 1886
          lstat_ok = (_Bool)1;
#line 1892
          if (have_dst_lstat) {
#line 1893
            dst_lstat_sb = & dst_sb;
          } else {
#line 1896
            tmp___68 = lstat((char const   * __restrict  )dst_name, (struct stat * __restrict  )(& tmp_buf));
#line 1896
            if (tmp___68 == 0) {
#line 1897
              dst_lstat_sb = & tmp_buf;
            } else {
#line 1899
              lstat_ok = (_Bool)0;
            }
          }
#line 1903
          if (lstat_ok) {
#line 1903
            if ((dst_lstat_sb->st_mode & 61440U) == 40960U) {
#line 1903
              tmp___72 = seen_file((Hash_table const   *)x->dest_info, dst_name, (struct stat  const  *)dst_lstat_sb);
#line 1903
              if (tmp___72) {
#line 1907
                tmp___69 = quote_n(1, dst_name);
#line 1907
                tmp___70 = quote_n(0, src_name);
#line 1907
                tmp___71 = gettext("will not copy %s through just-created symlink %s");
#line 1907
                error(0, 0, (char const   *)tmp___71, tmp___70, tmp___69);
#line 1910
                return ((_Bool)0);
              }
            }
          }
        }
      }
    }
  }
#line 1917
  if (x->verbose) {
#line 1917
    if (! ((src_mode & 61440U) == 16384U)) {
#line 1918
      if (backup_succeeded) {
#line 1918
        tmp___73 = dst_backup;
      } else {
#line 1918
        tmp___73 = (char *)((void *)0);
      }
#line 1918
      emit_verbose(src_name, dst_name, (char const   *)tmp___73);
    }
  }
#line 1950
  if (x->move_mode) {
#line 1950
    if (src_sb.st_nlink == 1UL) {
#line 1952
      earlier_file = src_to_dest_lookup(src_sb.st_ino, src_sb.st_dev);
    } else {
#line 1950
      goto _L___9;
    }
  } else
  _L___9: /* CIL Label */ 
#line 1954
  if (x->preserve_links) {
#line 1954
    if (! x->hard_link) {
#line 1954
      if (1UL < src_sb.st_nlink) {
#line 1961
        earlier_file = remember_copied(dst_name, src_sb.st_ino, src_sb.st_dev);
      } else
#line 1954
      if (command_line_arg) {
#line 1954
        if ((unsigned int const   )x->dereference == 3U) {
#line 1961
          earlier_file = remember_copied(dst_name, src_sb.st_ino, src_sb.st_dev);
        } else {
#line 1954
          goto _L___7;
        }
      } else
      _L___7: /* CIL Label */ 
#line 1954
      if ((unsigned int const   )x->dereference == 4U) {
#line 1961
        earlier_file = remember_copied(dst_name, src_sb.st_ino, src_sb.st_dev);
      } else {
#line 1954
        goto _L___8;
      }
    } else {
#line 1954
      goto _L___8;
    }
  } else
  _L___8: /* CIL Label */ 
#line 1963
  if (x->recursive) {
#line 1963
    if ((src_mode & 61440U) == 16384U) {
#line 1965
      if (command_line_arg) {
#line 1966
        earlier_file = remember_copied(dst_name, src_sb.st_ino, src_sb.st_dev);
      } else {
#line 1968
        earlier_file = src_to_dest_lookup(src_sb.st_ino, src_sb.st_dev);
      }
    }
  }
#line 1974
  if (earlier_file) {
#line 1979
    if ((src_mode & 61440U) == 16384U) {
#line 1983
      tmp___80 = same_name(src_name, (char const   *)earlier_file);
#line 1983
      if (tmp___80) {
#line 1985
        tmp___74 = quote_n(1, top_level_dst_name);
#line 1985
        tmp___75 = quote_n(0, top_level_src_name);
#line 1985
        tmp___76 = gettext("cannot copy a directory, %s, into itself, %s");
#line 1985
        error(0, 0, (char const   *)tmp___76, tmp___75, tmp___74);
#line 1988
        *copy_into_self = (_Bool)1;
#line 1989
        goto un_backup;
      } else
#line 1991
      if (! ((unsigned int const   )x->dereference == 4U)) {
#line 2002
        tmp___77 = quote_n(1, (char const   *)earlier_file);
#line 2002
        tmp___78 = quote_n(0, dst_name);
#line 2002
        tmp___79 = gettext("will not create hard link %s to directory %s");
#line 2002
        error(0, 0, (char const   *)tmp___79, tmp___78, tmp___77);
#line 2004
        goto un_backup;
      }
    } else {
#line 2009
      tmp___81 = create_hard_link((char const   *)earlier_file, dst_name, (_Bool)1,
                                  (_Bool )x->verbose);
#line 2009
      if (! tmp___81) {
#line 2010
        goto un_backup;
      }
#line 2012
      return ((_Bool)1);
    }
  }
#line 2016
  if (x->move_mode) {
#line 2018
    tmp___83 = rename(src_name, dst_name);
#line 2018
    if (tmp___83 == 0) {
#line 2020
      if (x->verbose) {
#line 2020
        if ((src_mode & 61440U) == 16384U) {
#line 2021
          if (backup_succeeded) {
#line 2021
            tmp___82 = dst_backup;
          } else {
#line 2021
            tmp___82 = (char *)((void *)0);
          }
#line 2021
          emit_verbose(src_name, dst_name, (char const   *)tmp___82);
        }
      }
#line 2024
      if (rename_succeeded) {
#line 2025
        *rename_succeeded = (_Bool)1;
      }
#line 2027
      if (command_line_arg) {
#line 2036
        record_file((Hash_table *)x->dest_info, dst_name, (struct stat  const  *)(& src_sb));
      }
#line 2039
      return ((_Bool)1);
    }
#line 2047
    tmp___87 = __errno_location();
#line 2047
    if (*tmp___87 == 22) {
#line 2052
      tmp___84 = quote_n(1, top_level_dst_name);
#line 2052
      tmp___85 = quote_n(0, top_level_src_name);
#line 2052
      tmp___86 = gettext("cannot move %s to a subdirectory of itself, %s");
#line 2052
      error(0, 0, (char const   *)tmp___86, tmp___85, tmp___84);
#line 2060
      *copy_into_self = (_Bool)1;
#line 2064
      return ((_Bool)1);
    }
#line 2082
    tmp___92 = __errno_location();
#line 2082
    if (*tmp___92 != 18) {
#line 2094
      tmp___88 = quote_n(1, dst_name);
#line 2094
      tmp___89 = quote_n(0, src_name);
#line 2094
      tmp___90 = gettext("cannot move %s to %s");
#line 2094
      tmp___91 = __errno_location();
#line 2094
      error(0, *tmp___91, (char const   *)tmp___90, tmp___89, tmp___88);
#line 2097
      forget_created(src_sb.st_ino, src_sb.st_dev);
#line 2098
      return ((_Bool)0);
    }
#line 2104
    tmp___97 = unlink(dst_name);
#line 2104
    if (tmp___97 != 0) {
#line 2104
      tmp___98 = __errno_location();
#line 2104
      if (*tmp___98 != 2) {
#line 2106
        tmp___93 = quote_n(1, dst_name);
#line 2106
        tmp___94 = quote_n(0, src_name);
#line 2106
        tmp___95 = gettext("inter-device move failed: %s to %s; unable to remove target");
#line 2106
        tmp___96 = __errno_location();
#line 2106
        error(0, *tmp___96, (char const   *)tmp___95, tmp___94, tmp___93);
#line 2109
        forget_created(src_sb.st_ino, src_sb.st_dev);
#line 2110
        return ((_Bool)0);
      }
    }
#line 2113
    new_dst = (_Bool)1;
  }
#line 2120
  if (x->set_mode) {
#line 2120
    tmp___99 = x->mode;
  } else {
#line 2120
    tmp___99 = (mode_t const   )src_mode;
  }
#line 2120
  dst_mode_bits = (mode_t )(tmp___99 & (unsigned int const   )((4032 | (448 >> 3)) | ((448 >> 3) >> 3)));
#line 2121
  if (x->preserve_ownership) {
#line 2121
    tmp___101 = (448 >> 3) | ((448 >> 3) >> 3);
  } else {
#line 2121
    if ((src_mode & 61440U) == 16384U) {
#line 2121
      tmp___100 = (128 >> 3) | ((128 >> 3) >> 3);
    } else {
#line 2121
      tmp___100 = 0;
    }
#line 2121
    tmp___101 = tmp___100;
  }
#line 2121
  omitted_permissions = dst_mode_bits & (unsigned int )tmp___101;
#line 2127
  delayed_ok = (_Bool)1;
#line 2129
  if (x->preserve_security_context) {
#line 2131
    if (! x->data_copy_required) {
#line 2131
      tmp___102 = 1;
    } else
#line 2131
    if (x->require_preserve_context) {
#line 2131
      tmp___102 = 1;
    } else {
#line 2131
      tmp___102 = 0;
    }
#line 2131
    all_errors = (_Bool )tmp___102;
#line 2132
    if (! all_errors) {
#line 2132
      if (! x->reduce_diagnostics) {
#line 2132
        tmp___103 = 1;
      } else {
#line 2132
        tmp___103 = 0;
      }
    } else {
#line 2132
      tmp___103 = 0;
    }
#line 2132
    some_errors = (_Bool )tmp___103;
#line 2135
    tmp___115 = getfilecon(src_name, & con);
#line 2135
    if (0 <= tmp___115) {
#line 2137
      tmp___109 = setfscreatecon(con);
#line 2137
      if (tmp___109 < 0) {
#line 2139
        if (all_errors) {
#line 2140
          tmp___104 = quote((char const   *)con);
#line 2140
          tmp___105 = gettext("failed to set default file creation context to %s");
#line 2140
          tmp___106 = __errno_location();
#line 2140
          error(0, *tmp___106, (char const   *)tmp___105, tmp___104);
        } else
#line 2139
        if (some_errors) {
#line 2139
          tmp___107 = __errno_location();
#line 2139
          tmp___108 = errno_unsupported(*tmp___107);
#line 2139
          if (! tmp___108) {
#line 2140
            tmp___104 = quote((char const   *)con);
#line 2140
            tmp___105 = gettext("failed to set default file creation context to %s");
#line 2140
            tmp___106 = __errno_location();
#line 2140
            error(0, *tmp___106, (char const   *)tmp___105, tmp___104);
          }
        }
#line 2143
        if (x->require_preserve_context) {
#line 2145
          freecon(con);
#line 2146
          return ((_Bool)0);
        }
      }
#line 2149
      freecon(con);
    } else {
#line 2153
      if (all_errors) {
#line 2155
        tmp___110 = quote(src_name);
#line 2155
        tmp___111 = gettext("failed to get security context of %s");
#line 2155
        tmp___112 = __errno_location();
#line 2155
        error(0, *tmp___112, (char const   *)tmp___111, tmp___110);
      } else
#line 2153
      if (some_errors) {
#line 2153
        tmp___113 = __errno_location();
#line 2153
        tmp___114 = errno_unsupported(*tmp___113);
#line 2153
        if (! tmp___114) {
#line 2155
          tmp___110 = quote(src_name);
#line 2155
          tmp___111 = gettext("failed to get security context of %s");
#line 2155
          tmp___112 = __errno_location();
#line 2155
          error(0, *tmp___112, (char const   *)tmp___111, tmp___110);
        }
      }
#line 2159
      if (x->require_preserve_context) {
#line 2160
        return ((_Bool)0);
      }
    }
  }
#line 2164
  if ((src_mode & 61440U) == 16384U) {
#line 2173
    tmp___118 = is_ancestor((struct stat  const  *)(& src_sb), (struct dir_list  const  *)ancestors);
#line 2173
    if (tmp___118) {
#line 2175
      tmp___116 = quote(src_name);
#line 2175
      tmp___117 = gettext("cannot copy cyclic symbolic link %s");
#line 2175
      error(0, 0, (char const   *)tmp___117, tmp___116);
#line 2177
      goto un_backup;
    }
#line 2182
    tmp___119 = __builtin_alloca(sizeof(*dir));
#line 2182
    dir = (struct dir_list *)tmp___119;
#line 2183
    dir->parent = ancestors;
#line 2184
    dir->ino = src_sb.st_ino;
#line 2185
    dir->dev = src_sb.st_dev;
#line 2187
    if (new_dst) {
#line 2187
      goto _L___10;
    } else
#line 2187
    if (! ((dst_sb.st_mode & 61440U) == 16384U)) {
      _L___10: /* CIL Label */ 
#line 2193
      tmp___123 = mkdir(dst_name, dst_mode_bits & ~ omitted_permissions);
#line 2193
      if (tmp___123 != 0) {
#line 2195
        tmp___120 = quote(dst_name);
#line 2195
        tmp___121 = gettext("cannot create directory %s");
#line 2195
        tmp___122 = __errno_location();
#line 2195
        error(0, *tmp___122, (char const   *)tmp___121, tmp___120);
#line 2197
        goto un_backup;
      }
#line 2204
      tmp___131 = lstat((char const   * __restrict  )dst_name, (struct stat * __restrict  )(& dst_sb));
#line 2204
      if (tmp___131 != 0) {
#line 2206
        tmp___124 = quote(dst_name);
#line 2206
        tmp___125 = gettext("cannot stat %s");
#line 2206
        tmp___126 = __errno_location();
#line 2206
        error(0, *tmp___126, (char const   *)tmp___125, tmp___124);
#line 2207
        goto un_backup;
      } else
#line 2209
      if ((dst_sb.st_mode & 448U) != 448U) {
#line 2213
        dst_mode = dst_sb.st_mode;
#line 2214
        restore_dst_mode = (_Bool)1;
#line 2216
        tmp___130 = chmod(dst_name, dst_mode | 448U);
#line 2216
        if (tmp___130 != 0) {
#line 2218
          tmp___127 = quote(dst_name);
#line 2218
          tmp___128 = gettext("setting permissions for %s");
#line 2218
          tmp___129 = __errno_location();
#line 2218
          error(0, *tmp___129, (char const   *)tmp___128, tmp___127);
#line 2220
          goto un_backup;
        }
      }
#line 2228
      if (! *first_dir_created_per_command_line_arg) {
#line 2230
        remember_copied(dst_name, dst_sb.st_ino, dst_sb.st_dev);
#line 2231
        *first_dir_created_per_command_line_arg = (_Bool)1;
      }
#line 2234
      if (x->verbose) {
#line 2235
        emit_verbose(src_name, dst_name, (char const   *)((void *)0));
      }
    } else {
#line 2239
      omitted_permissions = (mode_t )0;
    }
#line 2243
    if (x->one_file_system) {
#line 2243
      if (device != 0UL) {
#line 2243
        if (! (device != src_sb.st_dev)) {
#line 2254
          delayed_ok = copy_dir(src_name, dst_name, new_dst, (struct stat  const  *)(& src_sb),
                                dir, x, first_dir_created_per_command_line_arg, copy_into_self);
        }
      } else {
#line 2254
        delayed_ok = copy_dir(src_name, dst_name, new_dst, (struct stat  const  *)(& src_sb),
                              dir, x, first_dir_created_per_command_line_arg, copy_into_self);
      }
    } else {
#line 2254
      delayed_ok = copy_dir(src_name, dst_name, new_dst, (struct stat  const  *)(& src_sb),
                            dir, x, first_dir_created_per_command_line_arg, copy_into_self);
    }
  } else
#line 2259
  if (x->symbolic_link) {
#line 2261
    dest_is_symlink = (_Bool)1;
#line 2262
    if ((int const   )*src_name != 47) {
#line 2270
      dst_parent = dir_name(dst_name);
#line 2272
      tmp___132 = strcmp(".", (char const   *)dst_parent);
#line 2272
      if (tmp___132 == 0) {
#line 2272
        tmp___135 = 1;
      } else {
#line 2272
        tmp___133 = stat((char const   * __restrict  )".", (struct stat * __restrict  )(& dot_sb));
#line 2272
        if (tmp___133 != 0) {
#line 2272
          tmp___135 = 1;
        } else {
#line 2272
          tmp___134 = stat((char const   * __restrict  )dst_parent, (struct stat * __restrict  )(& dst_parent_sb));
#line 2272
          if (tmp___134 != 0) {
#line 2272
            tmp___135 = 1;
          } else
#line 2272
          if (dot_sb.st_ino == dst_parent_sb.st_ino) {
#line 2272
            if (dot_sb.st_dev == dst_parent_sb.st_dev) {
#line 2272
              tmp___135 = 1;
            } else {
#line 2272
              tmp___135 = 0;
            }
          } else {
#line 2272
            tmp___135 = 0;
          }
        }
      }
#line 2272
      in_current_dir = (_Bool )tmp___135;
#line 2279
      free((void *)dst_parent);
#line 2281
      if (! in_current_dir) {
#line 2283
        tmp___136 = quote(dst_name);
#line 2283
        tmp___137 = gettext("%s: can make relative symbolic links only in current directory");
#line 2283
        error(0, 0, (char const   *)tmp___137, tmp___136);
#line 2286
        goto un_backup;
      }
    }
#line 2289
    tmp___142 = symlink(src_name, dst_name);
#line 2289
    if (tmp___142 != 0) {
#line 2291
      tmp___138 = quote_n(1, src_name);
#line 2291
      tmp___139 = quote_n(0, dst_name);
#line 2291
      tmp___140 = gettext("cannot create symbolic link %s to %s");
#line 2291
      tmp___141 = __errno_location();
#line 2291
      error(0, *tmp___141, (char const   *)tmp___140, tmp___139, tmp___138);
#line 2293
      goto un_backup;
    }
  } else
#line 2312
  if (x->hard_link) {
#line 2316
    tmp___143 = create_hard_link(src_name, dst_name, (_Bool)0, (_Bool)0);
#line 2316
    if (! tmp___143) {
#line 2317
      goto un_backup;
    }
  } else
#line 2319
  if ((src_mode & 61440U) == 32768U) {
#line 2319
    goto _L___12;
  } else
#line 2319
  if (x->copy_as_regular) {
#line 2319
    if (! ((src_mode & 61440U) == 40960U)) {
      _L___12: /* CIL Label */ 
#line 2322
      copied_as_regular = (_Bool)1;
#line 2327
      tmp___144 = copy_reg(src_name, dst_name, x, src_mode & (unsigned int )((448 | (448 >> 3)) | ((448 >> 3) >> 3)),
                           omitted_permissions, & new_dst, (struct stat  const  *)(& src_sb));
#line 2327
      if (! tmp___144) {
#line 2329
        goto un_backup;
      }
    } else {
#line 2319
      goto _L___13;
    }
  } else
  _L___13: /* CIL Label */ 
#line 2331
  if ((src_mode & 61440U) == 4096U) {
#line 2337
    tmp___149 = mknod(dst_name, src_mode & ~ omitted_permissions, (__dev_t )0);
#line 2337
    if (tmp___149 != 0) {
#line 2338
      tmp___148 = mkfifo(dst_name, (src_mode & 4294963199U) & ~ omitted_permissions);
#line 2338
      if (tmp___148 != 0) {
#line 2340
        tmp___145 = quote(dst_name);
#line 2340
        tmp___146 = gettext("cannot create fifo %s");
#line 2340
        tmp___147 = __errno_location();
#line 2340
        error(0, *tmp___147, (char const   *)tmp___146, tmp___145);
#line 2341
        goto un_backup;
      }
    }
  } else
#line 2344
  if ((src_mode & 61440U) == 24576U) {
#line 2344
    goto _L___11;
  } else
#line 2344
  if ((src_mode & 61440U) == 8192U) {
#line 2344
    goto _L___11;
  } else
#line 2344
  if ((src_mode & 61440U) == 49152U) {
    _L___11: /* CIL Label */ 
#line 2346
    tmp___153 = mknod(dst_name, src_mode & ~ omitted_permissions, src_sb.st_rdev);
#line 2346
    if (tmp___153 != 0) {
#line 2349
      tmp___150 = quote(dst_name);
#line 2349
      tmp___151 = gettext("cannot create special file %s");
#line 2349
      tmp___152 = __errno_location();
#line 2349
      error(0, *tmp___152, (char const   *)tmp___151, tmp___150);
#line 2351
      goto un_backup;
    }
  } else
#line 2354
  if ((src_mode & 61440U) == 40960U) {
#line 2356
    tmp___154 = areadlink_with_size(src_name, (size_t )src_sb.st_size);
#line 2356
    src_link_val = tmp___154;
#line 2357
    dest_is_symlink = (_Bool)1;
#line 2358
    if ((unsigned long )src_link_val == (unsigned long )((void *)0)) {
#line 2360
      tmp___155 = quote(src_name);
#line 2360
      tmp___156 = gettext("cannot read symbolic link %s");
#line 2360
      tmp___157 = __errno_location();
#line 2360
      error(0, *tmp___157, (char const   *)tmp___156, tmp___155);
#line 2361
      goto un_backup;
    }
#line 2364
    tmp___164 = symlink((char const   *)src_link_val, dst_name);
#line 2364
    if (tmp___164 == 0) {
#line 2365
      free((void *)src_link_val);
    } else {
#line 2368
      tmp___158 = __errno_location();
#line 2368
      saved_errno = *tmp___158;
#line 2369
      same_link = (_Bool)0;
#line 2370
      if (x->update) {
#line 2370
        if (! new_dst) {
#line 2370
          if ((dst_sb.st_mode & 61440U) == 40960U) {
#line 2370
            tmp___161 = strlen((char const   *)src_link_val);
#line 2370
            if ((size_t )dst_sb.st_size == tmp___161) {
#line 2377
              tmp___159 = areadlink_with_size(dst_name, (size_t )dst_sb.st_size);
#line 2377
              dest_link_val = tmp___159;
#line 2379
              if (dest_link_val) {
#line 2379
                tmp___160 = strcmp((char const   *)dest_link_val, (char const   *)src_link_val);
#line 2379
                if (tmp___160 == 0) {
#line 2380
                  same_link = (_Bool)1;
                }
              }
#line 2381
              free((void *)dest_link_val);
            }
          }
        }
      }
#line 2383
      free((void *)src_link_val);
#line 2385
      if (! same_link) {
#line 2387
        tmp___162 = quote(dst_name);
#line 2387
        tmp___163 = gettext("cannot create symbolic link %s");
#line 2387
        error(0, saved_errno, (char const   *)tmp___163, tmp___162);
#line 2389
        goto un_backup;
      }
    }
#line 2393
    if (x->preserve_security_context) {
#line 2394
      restore_default_fscreatecon_or_die();
    }
#line 2396
    if (x->preserve_ownership) {
#line 2400
      tmp___167 = lchown(dst_name, src_sb.st_uid, src_sb.st_gid);
#line 2400
      if (tmp___167 != 0) {
#line 2400
        tmp___168 = chown_failure_ok(x);
#line 2400
        if (! tmp___168) {
#line 2404
          tmp___165 = gettext("failed to preserve ownership for %s");
#line 2404
          tmp___166 = __errno_location();
#line 2404
          error(0, *tmp___166, (char const   *)tmp___165, dst_name);
#line 2406
          goto un_backup;
        }
      }
    }
  } else {
#line 2419
    tmp___169 = quote(src_name);
#line 2419
    tmp___170 = gettext("%s has unknown file type");
#line 2419
    error(0, 0, (char const   *)tmp___170, tmp___169);
#line 2420
    goto un_backup;
  }
#line 2423
  if (command_line_arg) {
#line 2423
    if (x->dest_info) {
#line 2428
      tmp___171 = lstat((char const   * __restrict  )dst_name, (struct stat * __restrict  )(& sb));
#line 2428
      if (tmp___171 == 0) {
#line 2429
        record_file((Hash_table *)x->dest_info, dst_name, (struct stat  const  *)(& sb));
      }
    }
  }
#line 2434
  if (x->hard_link) {
#line 2434
    if (! ((src_mode & 61440U) == 16384U)) {
#line 2437
      return (delayed_ok);
    }
  }
#line 2439
  if (copied_as_regular) {
#line 2440
    return (delayed_ok);
  }
#line 2454
  if (x->preserve_timestamps) {
#line 2457
    timespec[0] = get_stat_atime((struct stat  const  *)(& src_sb));
#line 2458
    timespec[1] = get_stat_mtime((struct stat  const  *)(& src_sb));
#line 2460
    if (dest_is_symlink) {
#line 2460
      tmp___175 = utimens_symlink(dst_name, (struct timespec  const  *)(timespec));
#line 2460
      tmp___177 = tmp___175;
    } else {
#line 2460
      tmp___176 = utimens(dst_name, (struct timespec  const  *)(timespec));
#line 2460
      tmp___177 = tmp___176;
    }
#line 2460
    if (tmp___177 != 0) {
#line 2465
      tmp___172 = quote(dst_name);
#line 2465
      tmp___173 = gettext("preserving times for %s");
#line 2465
      tmp___174 = __errno_location();
#line 2465
      error(0, *tmp___174, (char const   *)tmp___173, tmp___172);
#line 2466
      if (x->require_preserve) {
#line 2467
        return ((_Bool)0);
      }
    }
  }
#line 2472
  if (dest_is_symlink) {
#line 2473
    return (delayed_ok);
  }
#line 2476
  if (x->preserve_ownership) {
#line 2476
    if (new_dst) {
#line 2476
      goto _L___16;
    } else
#line 2476
    if (src_sb.st_uid == dst_sb.st_uid) {
#line 2476
      if (! (src_sb.st_gid == dst_sb.st_gid)) {
#line 2476
        goto _L___16;
      }
    } else {
      _L___16: /* CIL Label */ 
#line 2479
      tmp___178 = set_owner(x, dst_name, -1, (struct stat  const  *)(& src_sb), new_dst,
                            (struct stat  const  *)(& dst_sb));
#line 2479
      switch (tmp___178) {
      case -1: 
#line 2482
      return ((_Bool)0);
      case 0: 
#line 2485
      src_mode &= 4294963711U;
#line 2486
      break;
      }
    }
  }
#line 2490
  set_author(dst_name, -1, (struct stat  const  *)(& src_sb));
#line 2492
  if (x->preserve_xattr) {
#line 2492
    tmp___179 = copy_attr(src_name, -1, dst_name, -1, x);
#line 2492
    if (! tmp___179) {
#line 2492
      if (x->require_preserve_xattr) {
#line 2494
        return ((_Bool)0);
      }
    }
  }
#line 2496
  if (x->preserve_mode) {
#line 2496
    goto _L___17;
  } else
#line 2496
  if (x->move_mode) {
    _L___17: /* CIL Label */ 
#line 2498
    tmp___180 = copy_acl(src_name, -1, dst_name, -1, src_mode);
#line 2498
    if (tmp___180 != 0) {
#line 2498
      if (x->require_preserve) {
#line 2500
        return ((_Bool)0);
      }
    }
  } else
#line 2502
  if (x->set_mode) {
#line 2504
    tmp___181 = set_acl(dst_name, -1, (mode_t )x->mode);
#line 2504
    if (tmp___181 != 0) {
#line 2505
      return ((_Bool)0);
    }
  } else {
#line 2509
    if (omitted_permissions) {
#line 2511
      tmp___182 = cached_umask();
#line 2511
      omitted_permissions &= ~ tmp___182;
#line 2513
      if (omitted_permissions) {
#line 2513
        if (! restore_dst_mode) {
#line 2521
          if (new_dst) {
#line 2521
            tmp___186 = lstat((char const   * __restrict  )dst_name, (struct stat * __restrict  )(& dst_sb));
#line 2521
            if (tmp___186 != 0) {
#line 2523
              tmp___183 = quote(dst_name);
#line 2523
              tmp___184 = gettext("cannot stat %s");
#line 2523
              tmp___185 = __errno_location();
#line 2523
              error(0, *tmp___185, (char const   *)tmp___184, tmp___183);
#line 2524
              return ((_Bool)0);
            }
          }
#line 2526
          dst_mode = dst_sb.st_mode;
#line 2527
          if (omitted_permissions & ~ dst_mode) {
#line 2528
            restore_dst_mode = (_Bool)1;
          }
        }
      }
    }
#line 2532
    if (restore_dst_mode) {
#line 2534
      tmp___190 = chmod(dst_name, dst_mode | omitted_permissions);
#line 2534
      if (tmp___190 != 0) {
#line 2536
        tmp___187 = quote(dst_name);
#line 2536
        tmp___188 = gettext("preserving permissions for %s");
#line 2536
        tmp___189 = __errno_location();
#line 2536
        error(0, *tmp___189, (char const   *)tmp___188, tmp___187);
#line 2538
        if (x->require_preserve) {
#line 2539
          return ((_Bool)0);
        }
      }
    }
  }
#line 2544
  return (delayed_ok);
  un_backup: 
#line 2548
  if (x->preserve_security_context) {
#line 2549
    restore_default_fscreatecon_or_die();
  }
#line 2557
  if ((unsigned long )earlier_file == (unsigned long )((void *)0)) {
#line 2558
    forget_created(src_sb.st_ino, src_sb.st_dev);
  }
#line 2560
  if (dst_backup) {
#line 2562
    tmp___197 = rename((char const   *)dst_backup, dst_name);
#line 2562
    if (tmp___197 != 0) {
#line 2563
      tmp___191 = quote(dst_name);
#line 2563
      tmp___192 = gettext("cannot un-backup %s");
#line 2563
      tmp___193 = __errno_location();
#line 2563
      error(0, *tmp___193, (char const   *)tmp___192, tmp___191);
    } else
#line 2566
    if (x->verbose) {
#line 2567
      tmp___194 = quote_n(1, dst_name);
#line 2567
      tmp___195 = quote_n(0, (char const   *)dst_backup);
#line 2567
      tmp___196 = gettext("%s -> %s (unbackup)\n");
#line 2567
      printf((char const   * __restrict  )tmp___196, tmp___195, tmp___194);
    }
  }
#line 2571
  return ((_Bool)0);
}
}
#line 2574 "copy.c"
static _Bool __attribute__((__pure__))  valid_options(struct cp_options  const  *co ) 
{ 

  {
#line 2577
  if (! ((unsigned long )co != (unsigned long )((void *)0))) {
#line 2577
    __assert_fail("co != ((void *)0)", "copy.c", 2577U, "valid_options");
  }
#line 2578
  if (! ((unsigned int )co->backup_type <= 3U)) {
#line 2578
    __assert_fail("((unsigned int) (co->backup_type) <= numbered_backups)", "copy.c",
                  2578U, "valid_options");
  }
#line 2579
  if (! ((unsigned int const   )co->sparse_mode == 1U)) {
#line 2579
    if (! ((unsigned int const   )co->sparse_mode == 2U)) {
#line 2579
      if (! ((unsigned int const   )co->sparse_mode == 3U)) {
#line 2579
        __assert_fail("((co->sparse_mode) == SPARSE_NEVER || (co->sparse_mode) == SPARSE_AUTO || (co->sparse_mode) == SPARSE_ALWAYS)",
                      "copy.c", 2579U, "valid_options");
      }
    }
  }
#line 2580
  if (! ((unsigned int const   )co->reflink_mode == 0U)) {
#line 2580
    if (! ((unsigned int const   )co->reflink_mode == 1U)) {
#line 2580
      if (! ((unsigned int const   )co->reflink_mode == 2U)) {
#line 2580
        __assert_fail("((co->reflink_mode) == REFLINK_NEVER || (co->reflink_mode) == REFLINK_AUTO || (co->reflink_mode) == REFLINK_ALWAYS)",
                      "copy.c", 2580U, "valid_options");
      }
    }
  }
#line 2581
  if (co->hard_link) {
#line 2581
    if (co->symbolic_link) {
#line 2581
      __assert_fail("!(co->hard_link && co->symbolic_link)", "copy.c", 2581U, "valid_options");
    }
  }
#line 2582
  if ((unsigned int const   )co->reflink_mode == 2U) {
#line 2582
    if ((unsigned int const   )co->sparse_mode != 2U) {
#line 2582
      __assert_fail("! (co->reflink_mode == REFLINK_ALWAYS && co->sparse_mode != SPARSE_AUTO)",
                    "copy.c", 2584U, "valid_options");
    }
  }
#line 2585
  return ((_Bool __attribute__((__pure__))  )1);
}
}
#line 2597 "copy.c"
extern _Bool copy(char const   *src_name , char const   *dst_name , _Bool nonexistent_dst ,
                  struct cp_options  const  *options , _Bool *copy_into_self , _Bool *rename_succeeded ) 
{ _Bool __attribute__((__pure__))  tmp ;
  _Bool first_dir_created_per_command_line_arg ;
  _Bool tmp___0 ;

  {
#line 2602
  tmp = valid_options(options);
#line 2602
  if (! tmp) {
#line 2602
    __assert_fail("valid_options (options)", "copy.c", 2602U, "copy");
  }
#line 2611
  top_level_src_name = src_name;
#line 2612
  top_level_dst_name = dst_name;
#line 2614
  first_dir_created_per_command_line_arg = (_Bool)0;
#line 2615
  tmp___0 = copy_internal(src_name, dst_name, nonexistent_dst, (dev_t )0, (struct dir_list *)((void *)0),
                          options, (_Bool)1, & first_dir_created_per_command_line_arg,
                          copy_into_self, rename_succeeded);
#line 2615
  return (tmp___0);
}
}
#line 2623 "copy.c"
extern void cp_options_default(struct cp_options *x ) 
{ _Bool tmp ;
  __uid_t tmp___0 ;

  {
#line 2626
  memset((void *)x, 0, sizeof(*x));
#line 2640
  tmp___0 = geteuid();
#line 2640
  tmp = (_Bool )(tmp___0 == 0U);
#line 2640
  x->owner_privileges = tmp;
#line 2640
  x->chown_privileges = tmp;
#line 2642
  return;
}
}
#line 2648
extern _Bool chown_failure_ok(struct cp_options  const  *x )  __attribute__((__pure__)) ;
#line 2648 "copy.c"
extern _Bool chown_failure_ok(struct cp_options  const  *x ) 
{ int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
#line 2655
  tmp = __errno_location();
#line 2655
  if (*tmp == 1) {
#line 2655
    goto _L;
  } else {
#line 2655
    tmp___0 = __errno_location();
#line 2655
    if (*tmp___0 == 22) {
      _L: /* CIL Label */ 
#line 2655
      if (! x->chown_privileges) {
#line 2655
        tmp___1 = 1;
      } else {
#line 2655
        tmp___1 = 0;
      }
    } else {
#line 2655
      tmp___1 = 0;
    }
  }
#line 2655
  return ((_Bool )tmp___1);
}
}
#line 2662 "copy.c"
static _Bool owner_failure_ok(struct cp_options  const  *x ) 
{ int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
#line 2665
  tmp = __errno_location();
#line 2665
  if (*tmp == 1) {
#line 2665
    goto _L;
  } else {
#line 2665
    tmp___0 = __errno_location();
#line 2665
    if (*tmp___0 == 22) {
      _L: /* CIL Label */ 
#line 2665
      if (! x->owner_privileges) {
#line 2665
        tmp___1 = 1;
      } else {
#line 2665
        tmp___1 = 0;
      }
    } else {
#line 2665
      tmp___1 = 0;
    }
  }
#line 2665
  return ((_Bool )tmp___1);
}
}
#line 2673 "copy.c"
static mode_t mask  =    (mode_t )-1;
#line 2670 "copy.c"
extern mode_t cached_umask(void) 
{ 

  {
#line 2674
  if (mask == 4294967295U) {
#line 2676
    mask = umask((__mode_t )0);
#line 2677
    umask(mask);
  }
#line 2679
  return (mask);
}
}
#line 1 "cil-ES_RmQgf.o"
#pragma merger(0,"/tmp/cil-BmGfFHmT.i","")
#line 2 "cp-hash.h"
extern void forget_all(void) ;
#line 45 "cp-hash.c"
static Hash_table *src_to_dest  ;
#line 50 "cp-hash.c"
static size_t src_to_dest_hash(void const   *x , size_t table_size ) 
{ struct Src_to_dest  const  *p ;

  {
#line 53
  p = (struct Src_to_dest  const  *)x;
#line 58
  return ((uintmax_t )p->st_ino % table_size);
}
}
#line 63 "cp-hash.c"
static _Bool src_to_dest_compare(void const   *x , void const   *y ) 
{ struct Src_to_dest  const  *a ;
  struct Src_to_dest  const  *b ;
  int tmp ;

  {
#line 66
  a = (struct Src_to_dest  const  *)x;
#line 67
  b = (struct Src_to_dest  const  *)y;
#line 68
  if (a->st_ino == b->st_ino) {
#line 68
    if (a->st_dev == b->st_dev) {
#line 68
      tmp = 1;
    } else {
#line 68
      tmp = 0;
    }
  } else {
#line 68
    tmp = 0;
  }
#line 68
  return ((_Bool )tmp);
}
}
#line 71 "cp-hash.c"
static void src_to_dest_free(void *x ) 
{ struct Src_to_dest *a ;

  {
#line 74
  a = (struct Src_to_dest *)x;
#line 75
  free((void *)a->name);
#line 76
  free(x);
#line 77
  return;
}
}
#line 81 "cp-hash.c"
extern void forget_created(ino_t ino , dev_t dev ) 
{ struct Src_to_dest probe ;
  struct Src_to_dest *ent ;
  void *tmp ;

  {
#line 87
  probe.st_ino = ino;
#line 88
  probe.st_dev = dev;
#line 89
  probe.name = (char *)((void *)0);
#line 91
  tmp = hash_delete(src_to_dest, (void const   *)(& probe));
#line 91
  ent = (struct Src_to_dest *)tmp;
#line 92
  if (ent) {
#line 93
    src_to_dest_free((void *)ent);
  }
#line 94
  return;
}
}
#line 99 "cp-hash.c"
extern char *src_to_dest_lookup(ino_t ino , dev_t dev ) 
{ struct Src_to_dest ent ;
  struct Src_to_dest  const  *e ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 104
  ent.st_ino = ino;
#line 105
  ent.st_dev = dev;
#line 106
  tmp = hash_lookup((Hash_table const   *)src_to_dest, (void const   *)(& ent));
#line 106
  e = (struct Src_to_dest  const  *)tmp;
#line 107
  if (e) {
#line 107
    tmp___0 = e->name;
  } else {
#line 107
    tmp___0 = (char * const  )((void *)0);
  }
#line 107
  return ((char *)tmp___0);
}
}
#line 114 "cp-hash.c"
extern char *remember_copied(char const   *name , ino_t ino , dev_t dev ) 
{ struct Src_to_dest *ent ;
  struct Src_to_dest *ent_from_table ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 120
  tmp = xmalloc(sizeof(*ent));
#line 120
  ent = (struct Src_to_dest *)tmp;
#line 121
  ent->name = xstrdup(name);
#line 122
  ent->st_ino = ino;
#line 123
  ent->st_dev = dev;
#line 125
  tmp___0 = hash_insert(src_to_dest, (void const   *)ent);
#line 125
  ent_from_table = (struct Src_to_dest *)tmp___0;
#line 126
  if ((unsigned long )ent_from_table == (unsigned long )((void *)0)) {
#line 129
    xalloc_die();
  }
#line 135
  if ((unsigned long )ent_from_table != (unsigned long )ent) {
#line 137
    src_to_dest_free((void *)ent);
#line 138
    return (ent_from_table->name);
  }
#line 142
  return ((char *)((void *)0));
}
}
#line 146 "cp-hash.c"
extern void hash_init(void) 
{ 

  {
#line 149
  src_to_dest = hash_initialize((size_t )103, (Hash_tuning const   *)((void *)0),
                                & src_to_dest_hash, & src_to_dest_compare, & src_to_dest_free);
#line 153
  if ((unsigned long )src_to_dest == (unsigned long )((void *)0)) {
#line 154
    xalloc_die();
  }
#line 155
  return;
}
}
#line 160 "cp-hash.c"
extern void forget_all(void) 
{ 

  {
#line 163
  hash_free(src_to_dest);
#line 164
  return;
}
}
#line 1 "cil-5Qs0sAXI.o"
#pragma merger(0,"/tmp/cil-bdwkgrPU.i","")
#line 119 "../lib/xalloc.h"
__inline static void *xnrealloc(void *p , size_t n , size_t s )  __attribute__((__alloc_size__(2,3))) ;
#line 34 "extent-scan.c"
static _Bool extent_need_sync(void) 
{ 

  {
#line 41
  return ((_Bool)1);
}
}
#line 70 "extent-scan.c"
extern void extent_scan_init(int src_fd , struct extent_scan *scan ) 
{ _Bool tmp___0 ;

  {
#line 73
  scan->fd = src_fd;
#line 74
  scan->ei_count = (uint32_t )0;
#line 75
  scan->ext_info = (struct extent_info *)((void *)0);
#line 76
  scan->scan_start = (off_t )0;
#line 77
  scan->initial_scan_failed = (_Bool)0;
#line 78
  scan->hit_final_extent = (_Bool)0;
#line 79
  tmp___0 = extent_need_sync();
#line 79
  if (tmp___0) {
#line 79
    scan->fm_flags = (uint32_t )1;
  } else {
#line 79
    scan->fm_flags = (uint32_t )0;
  }
#line 80
  return;
}
}
#line 88 "extent-scan.c"
extern _Bool extent_scan_read(struct extent_scan *scan ) 
{ unsigned int si ;
  struct extent_info *last_ei ;
  union __anonunion_fiemap_buf_38 fiemap_buf ;
  struct fiemap *fiemap ;
  struct fiemap_extent *fm_extents ;
  int tmp ;
  void *tmp___0 ;
  unsigned int i ;
  uint64_t new_logical ;
  uint64_t length_adjust ;

  {
#line 91
  si = 0U;
#line 94
  while (1) {
#line 97
    fiemap = & fiemap_buf.f;
#line 98
    fm_extents = & fiemap->fm_extents[0];
#line 105
    memset((void *)(& fiemap_buf), 0, sizeof(fiemap_buf));
#line 107
    fiemap->fm_start = (uint64_t )scan->scan_start;
#line 108
    fiemap->fm_flags = scan->fm_flags;
#line 109
    fiemap->fm_extent_count = (uint32_t )72;
#line 110
    fiemap->fm_length = (uint64_t )(0xffffffffffffffffULL - (unsigned long long )scan->scan_start);
#line 114
    tmp = ioctl(scan->fd, (unsigned long )(((3U << 30) | (unsigned int )(102 << 8)) | 11U) | (sizeof(struct fiemap ) << 16),
                fiemap);
#line 114
    if (tmp < 0) {
#line 116
      if (scan->scan_start == 0L) {
#line 117
        scan->initial_scan_failed = (_Bool)1;
      }
#line 118
      return ((_Bool)0);
    }
#line 122
    if (fiemap->fm_mapped_extents == 0U) {
#line 124
      scan->hit_final_extent = (_Bool)1;
#line 125
      return ((_Bool )(scan->scan_start != 0L));
    }
#line 128
    if (! ((unsigned long )scan->ei_count <= 0xffffffffffffffffUL - (unsigned long )fiemap->fm_mapped_extents)) {
#line 128
      __assert_fail("scan->ei_count <= (18446744073709551615UL) - fiemap->fm_mapped_extents",
                    "extent-scan.c", 128U, "extent_scan_read");
    }
#line 129
    scan->ei_count += fiemap->fm_mapped_extents;
#line 130
    tmp___0 = xnrealloc((void *)scan->ext_info, (size_t )scan->ei_count, sizeof(struct extent_info ));
#line 130
    scan->ext_info = (struct extent_info *)tmp___0;
#line 133
    i = 0U;
#line 134
    i = 0U;
#line 134
    while (i < fiemap->fm_mapped_extents) {
#line 136
      if (! ((fm_extents + i)->fe_logical <= (uint64_t )(((1L << (sizeof(off_t ) * 8UL - 2UL)) - 1L) * 2L + 1L) - (fm_extents + i)->fe_length)) {
#line 136
        __assert_fail("fm_extents[i].fe_logical <= ((off_t) (! (! ((off_t) 0 < (off_t) -1)) ? (off_t) -1 : ((((off_t) 1 << (sizeof (off_t) * 8 - 2)) - 1) * 2 + 1))) - fm_extents[i].fe_length",
                      "extent-scan.c", 137U, "extent_scan_read");
      }
#line 139
      if (si) {
#line 139
        if (last_ei->ext_flags == ((fm_extents + i)->fe_flags & 4294967294U)) {
#line 139
          if ((uint64_t )last_ei->ext_logical + last_ei->ext_length == (fm_extents + i)->fe_logical) {
#line 145
            last_ei->ext_length += (fm_extents + i)->fe_length;
#line 147
            last_ei->ext_flags = (fm_extents + i)->fe_flags;
          } else {
#line 139
            goto _L___2;
          }
        } else {
#line 139
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 149
      if (si == 0U) {
#line 149
        if ((uint64_t )scan->scan_start > (fm_extents + i)->fe_logical) {
#line 149
          goto _L;
        } else {
#line 149
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 149
      if (si) {
#line 149
        if ((uint64_t )last_ei->ext_logical + last_ei->ext_length > (fm_extents + i)->fe_logical) {
          _L: /* CIL Label */ 
#line 159
          if (si == 0U) {
#line 160
            new_logical = (uint64_t )scan->scan_start;
          } else {
#line 165
            new_logical = (uint64_t )last_ei->ext_logical + last_ei->ext_length;
          }
#line 167
          length_adjust = new_logical - (fm_extents + i)->fe_logical;
#line 169
          if (length_adjust < (fm_extents + i)->fe_length) {
#line 171
            if (scan->scan_start == 0L) {
#line 172
              scan->initial_scan_failed = (_Bool)1;
            }
#line 173
            return ((_Bool)0);
          }
#line 175
          (fm_extents + i)->fe_logical = new_logical;
#line 176
          (fm_extents + i)->fe_length -= length_adjust;
#line 178
          i --;
#line 179
          goto __Cont;
        } else {
#line 183
          last_ei = scan->ext_info + si;
#line 184
          last_ei->ext_logical = (off_t )(fm_extents + i)->fe_logical;
#line 185
          last_ei->ext_length = (fm_extents + i)->fe_length;
#line 186
          last_ei->ext_flags = (fm_extents + i)->fe_flags;
#line 187
          si ++;
        }
      } else {
#line 183
        last_ei = scan->ext_info + si;
#line 184
        last_ei->ext_logical = (off_t )(fm_extents + i)->fe_logical;
#line 185
        last_ei->ext_length = (fm_extents + i)->fe_length;
#line 186
        last_ei->ext_flags = (fm_extents + i)->fe_flags;
#line 187
        si ++;
      }
      __Cont: /* CIL Label */ 
#line 134
      i ++;
    }
#line 191
    if (last_ei->ext_flags & 1U) {
#line 192
      scan->hit_final_extent = (_Bool)1;
    }
#line 196
    if (si > 72U) {
#line 196
      if (! scan->hit_final_extent) {
#line 197
        si --;
#line 197
        last_ei = (scan->ext_info + si) - 1;
      }
    }
#line 200
    scan->ei_count = si;
#line 202
    if (scan->hit_final_extent) {
#line 203
      break;
    } else {
#line 205
      scan->scan_start = (off_t )((uint64_t )last_ei->ext_logical + last_ei->ext_length);
    }
#line 207
    if (si >= 72U) {
#line 208
      break;
    }
  }
#line 211
  return ((_Bool)1);
}
}
#line 1 "cil-Iv2kUIDr.o"
#pragma merger(0,"/tmp/cil-opXndWlI.i","")
#line 305 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int faccessat(int __fd , char const   *__file ,
                                                   int __type , int __flag )  __attribute__((__nonnull__(2))) ;
#line 849
extern  __attribute__((__nothrow__)) int unlinkat(int __fd , char const   *__name ,
                                                  int __flag )  __attribute__((__nonnull__(2))) ;
#line 80 "../lib/openat.h"
__inline static int lstatat(int fd , char const   *name , struct stat *st ) 
{ int tmp ;

  {
#line 83
  tmp = fstatat(fd, (char const   * __restrict  )name, (struct stat * __restrict  )st,
                256);
#line 83
  return (tmp);
}
}
#line 256 "system.h"
__inline static struct dirent  const  *readdir_ignoring_dot_and_dotdot(DIR *dirp ) 
{ struct dirent  const  *dp ;
  struct dirent *tmp ;
  _Bool tmp___0 ;

  {
#line 259
  while (1) {
#line 261
    tmp = readdir(dirp);
#line 261
    dp = (struct dirent  const  *)tmp;
#line 262
    if ((unsigned long )dp == (unsigned long )((void *)0)) {
#line 263
      return (dp);
    } else {
#line 262
      tmp___0 = dot_or_dotdot((char const   *)(dp->d_name));
#line 262
      if (! tmp___0) {
#line 263
        return (dp);
      }
    }
  }
}
}
#line 268 "system.h"
__inline static _Bool is_empty_dir(int fd_cwd , char const   *dir ) 
{ DIR *dirp ;
  struct dirent  const  *dp ;
  int saved_errno ;
  int fd ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
#line 274
  tmp = (int )openat(fd_cwd, dir, 198912);
#line 274
  fd = tmp;
#line 278
  if (fd < 0) {
#line 279
    return ((_Bool)0);
  }
#line 281
  dirp = fdopendir(fd);
#line 282
  if ((unsigned long )dirp == (unsigned long )((void *)0)) {
#line 284
    close(fd);
#line 285
    return ((_Bool)0);
  }
#line 288
  tmp___0 = __errno_location();
#line 288
  *tmp___0 = 0;
#line 289
  dp = readdir_ignoring_dot_and_dotdot(dirp);
#line 290
  tmp___1 = __errno_location();
#line 290
  saved_errno = *tmp___1;
#line 291
  closedir(dirp);
#line 292
  if ((unsigned long )dp != (unsigned long )((void *)0)) {
#line 293
    return ((_Bool)0);
  }
#line 294
  if (saved_errno == 0) {
#line 294
    tmp___2 = 1;
  } else {
#line 294
    tmp___2 = 0;
  }
#line 294
  return ((_Bool )tmp___2);
}
}
#line 70 "remove.c"
static int cache_fstatat(int fd , char const   *file , struct stat *st , int flag ) 
{ int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;

  {
#line 73
  if (st->st_size == -1L) {
#line 73
    tmp___0 = fstatat(fd, (char const   * __restrict  )file, (struct stat * __restrict  )st,
                      flag);
#line 73
    if (tmp___0 != 0) {
#line 75
      st->st_size = (__off_t )-2;
#line 76
      tmp = __errno_location();
#line 76
      st->st_ino = (__ino_t )*tmp;
    }
  }
#line 78
  if (0L <= st->st_size) {
#line 79
    return (0);
  }
#line 80
  tmp___1 = __errno_location();
#line 80
  *tmp___1 = (int )st->st_ino;
#line 81
  return (-1);
}
}
#line 85 "remove.c"
__inline static struct stat *cache_stat_init(struct stat *st ) 
{ 

  {
#line 88
  st->st_size = (__off_t )-1;
#line 89
  return (st);
}
}
#line 112 "remove.c"
static int write_protected_non_symlink(int fd_cwd , char const   *file , char const   *full_name ,
                                       struct stat *buf___1 ) 
{ _Bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___3 ;
  int *tmp___4 ;
  size_t file_name_len ;
  size_t tmp___5 ;
  _Bool tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;

  {
#line 118
  tmp = can_write_any_file();
#line 118
  if (tmp) {
#line 119
    return (0);
  }
#line 120
  tmp___0 = cache_fstatat(fd_cwd, file, buf___1, 256);
#line 120
  if (tmp___0 != 0) {
#line 121
    return (-1);
  }
#line 122
  if ((buf___1->st_mode & 61440U) == 40960U) {
#line 123
    return (0);
  }
#line 177
  tmp___1 = faccessat(fd_cwd, file, 2, 512);
#line 177
  if (tmp___1 == 0) {
#line 178
    return (0);
  }
#line 180
  tmp___4 = __errno_location();
#line 180
  if (*tmp___4 == 13) {
#line 180
    tmp___3 = 1;
  } else {
#line 180
    tmp___3 = -1;
  }
#line 180
  return (tmp___3);
#line 184
  tmp___5 = strlen(full_name);
#line 184
  file_name_len = tmp___5;
#line 186
  if (4096UL <= file_name_len) {
#line 187
    tmp___6 = euidaccess_stat((struct stat  const  *)buf___1, 2);
#line 187
    if (tmp___6) {
#line 187
      tmp___7 = 0;
    } else {
#line 187
      tmp___7 = 1;
    }
#line 187
    return (tmp___7);
  }
#line 188
  tmp___8 = euidaccess(full_name, 2);
#line 188
  if (tmp___8 == 0) {
#line 189
    return (0);
  }
#line 190
  tmp___10 = __errno_location();
#line 190
  if (*tmp___10 == 13) {
#line 192
    tmp___9 = __errno_location();
#line 192
    *tmp___9 = 0;
#line 193
    return (1);
  }
#line 198
  return (-1);
}
}
#line 215 "remove.c"
static enum RM_status prompt(FTS const   *fts , FTSENT const   *ent , _Bool is_dir ,
                             struct rm_options  const  *x , enum Prompt_action mode ,
                             Ternary *is_empty_p ) 
{ int fd_cwd ;
  char const   *full_name ;
  char const   *filename ;
  struct stat st ;
  struct stat *sbuf ;
  int dirent_type ;
  int tmp ;
  int write_protected ;
  int wp_errno ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  char const   *quoted_name ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  _Bool is_empty ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  _Bool tmp___15 ;

  {
#line 220
  fd_cwd = (int )fts->fts_cwd_fd;
#line 221
  full_name = (char const   *)ent->fts_path;
#line 222
  filename = (char const   *)ent->fts_accpath;
#line 223
  if (is_empty_p) {
#line 224
    *is_empty_p = (Ternary )2;
  }
#line 227
  sbuf = & st;
#line 228
  cache_stat_init(sbuf);
#line 230
  if (is_dir) {
#line 230
    tmp = 4;
  } else {
#line 230
    tmp = 0;
  }
#line 230
  dirent_type = tmp;
#line 231
  write_protected = 0;
#line 236
  if (ent->fts_number) {
#line 237
    return ((enum RM_status )3);
  }
#line 239
  if ((unsigned int const   )x->interactive == 5U) {
#line 240
    return ((enum RM_status )2);
  }
#line 242
  wp_errno = 0;
#line 243
  if (! x->ignore_missing_files) {
#line 243
    if ((unsigned int const   )x->interactive == 3U) {
#line 243
      goto _L;
    } else
#line 243
    if (x->stdin_tty) {
      _L: /* CIL Label */ 
#line 243
      if (dirent_type != 10) {
#line 247
        write_protected = write_protected_non_symlink(fd_cwd, filename, full_name,
                                                      sbuf);
#line 249
        tmp___0 = __errno_location();
#line 249
        wp_errno = *tmp___0;
      }
    }
  }
#line 252
  if (write_protected) {
#line 252
    goto _L___2;
  } else
#line 252
  if ((unsigned int const   )x->interactive == 3U) {
    _L___2: /* CIL Label */ 
#line 254
    if (0 <= write_protected) {
#line 254
      if (dirent_type == 0) {
#line 256
        tmp___2 = cache_fstatat(fd_cwd, filename, sbuf, 256);
#line 256
        if (tmp___2 == 0) {
#line 258
          if ((sbuf->st_mode & 61440U) == 40960U) {
#line 259
            dirent_type = 10;
          } else
#line 260
          if ((sbuf->st_mode & 61440U) == 16384U) {
#line 261
            dirent_type = 4;
          }
        } else {
#line 267
          write_protected = -1;
#line 268
          tmp___1 = __errno_location();
#line 268
          wp_errno = *tmp___1;
        }
      }
    }
#line 272
    if (0 <= write_protected) {
#line 273
      switch (dirent_type) {
      case 10: 
#line 277
      if ((unsigned int const   )x->interactive != 3U) {
#line 278
        return ((enum RM_status )2);
      }
#line 279
      break;
      case 4: 
#line 282
      if (! x->recursive) {
#line 284
        write_protected = -1;
#line 285
        wp_errno = 21;
      }
#line 287
      break;
      }
    }
#line 290
    tmp___3 = quote(full_name);
#line 290
    quoted_name = tmp___3;
#line 292
    if (write_protected < 0) {
#line 294
      tmp___4 = gettext("cannot remove %s");
#line 294
      error(0, wp_errno, (char const   *)tmp___4, quoted_name);
#line 295
      return ((enum RM_status )4);
    }
#line 299
    if (is_empty_p) {
#line 301
      is_empty = is_empty_dir(fd_cwd, filename);
#line 302
      if (is_empty) {
#line 302
        *is_empty_p = (Ternary )4;
      } else {
#line 302
        *is_empty_p = (Ternary )3;
      }
    } else {
#line 305
      is_empty = (_Bool)0;
    }
#line 308
    if (dirent_type == 4) {
#line 308
      if ((unsigned int )mode == 2U) {
#line 308
        if (! is_empty) {
#line 311
          if (write_protected) {
#line 311
            tmp___5 = gettext("%s: descend into write-protected directory %s? ");
#line 311
            tmp___7 = tmp___5;
          } else {
#line 311
            tmp___6 = gettext("%s: descend into directory %s? ");
#line 311
            tmp___7 = tmp___6;
          }
#line 311
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___7,
                  program_name, quoted_name);
        } else {
#line 308
          goto _L___1;
        }
      } else {
#line 308
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 318
      tmp___10 = cache_fstatat(fd_cwd, filename, sbuf, 256);
#line 318
      if (tmp___10 != 0) {
#line 320
        tmp___8 = gettext("cannot remove %s");
#line 320
        tmp___9 = __errno_location();
#line 320
        error(0, *tmp___9, (char const   *)tmp___8, quoted_name);
#line 321
        return ((enum RM_status )4);
      }
#line 324
      tmp___11 = file_type((struct stat  const  *)sbuf);
#line 324
      if (write_protected) {
#line 324
        tmp___12 = gettext("%s: remove write-protected %s %s? ");
#line 324
        tmp___14 = tmp___12;
      } else {
#line 324
        tmp___13 = gettext("%s: remove %s %s? ");
#line 324
        tmp___14 = tmp___13;
      }
#line 324
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___14,
              program_name, tmp___11, quoted_name);
    }
#line 335
    tmp___15 = yesno();
#line 335
    if (! tmp___15) {
#line 336
      return ((enum RM_status )3);
    }
  }
#line 338
  return ((enum RM_status )2);
}
}
#line 374 "remove.c"
__inline static _Bool nonexistent_file_errno(int errnum ) 
{ 

  {
#line 389
  switch (errnum) {
  case 84: 
  case 22: 
  case 2: 
  case 20: 
#line 395
  return ((_Bool)1);
  default: 
#line 397
  return ((_Bool)0);
  }
}
}
#line 402 "remove.c"
__inline static _Bool ignorable_missing(struct rm_options  const  *x , int errnum ) 
{ _Bool tmp ;
  int tmp___0 ;

  {
#line 405
  if (x->ignore_missing_files) {
#line 405
    tmp = nonexistent_file_errno(errnum);
#line 405
    if (tmp) {
#line 405
      tmp___0 = 1;
    } else {
#line 405
      tmp___0 = 0;
    }
  } else {
#line 405
    tmp___0 = 0;
  }
#line 405
  return ((_Bool )tmp___0);
}
}
#line 409 "remove.c"
static void fts_skip_tree(FTS *fts , FTSENT *ent ) 
{ FTSENT *__x ;
  FTSENT *tmp ;

  {
#line 412
  fts_set(fts, ent, 4);
#line 414
  tmp = fts_read(fts);
#line 414
  __x = tmp;
#line 415
  return;
}
}
#line 420 "remove.c"
static void mark_ancestor_dirs(FTSENT *ent ) 
{ FTSENT *p ;

  {
#line 424
  p = ent->fts_parent;
#line 424
  while (0L <= p->fts_level) {
#line 426
    if (p->fts_number) {
#line 427
      break;
    }
#line 428
    p->fts_number = 1L;
#line 424
    p = p->fts_parent;
  }
#line 430
  return;
}
}
#line 435 "remove.c"
static enum RM_status excise(FTS *fts , FTSENT *ent , struct rm_options  const  *x ,
                             _Bool is_dir ) 
{ int flag ;
  int tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  struct stat st ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  _Bool tmp___10 ;
  int *tmp___11 ;
  char const   *tmp___12 ;
  char *tmp___13 ;
  int *tmp___14 ;

  {
#line 438
  if (is_dir) {
#line 438
    tmp = 512;
  } else {
#line 438
    tmp = 0;
  }
#line 438
  flag = tmp;
#line 439
  tmp___4 = unlinkat(fts->fts_cwd_fd, (char const   *)ent->fts_accpath, flag);
#line 439
  if (tmp___4 == 0) {
#line 441
    if (x->verbose) {
#line 443
      tmp___0 = quote((char const   *)ent->fts_path);
#line 443
      if (is_dir) {
#line 443
        tmp___1 = gettext("removed directory: %s\n");
#line 443
        tmp___3 = tmp___1;
      } else {
#line 443
        tmp___2 = gettext("removed %s\n");
#line 443
        tmp___3 = tmp___2;
      }
#line 443
      printf((char const   * __restrict  )tmp___3, tmp___0);
    }
#line 447
    return ((enum RM_status )2);
  }
#line 454
  tmp___8 = __errno_location();
#line 454
  if (*tmp___8 == 30) {
#line 457
    tmp___6 = lstatat(fts->fts_cwd_fd, (char const   *)ent->fts_accpath, & st);
#line 457
    if (tmp___6) {
#line 457
      tmp___7 = __errno_location();
#line 457
      if (! (*tmp___7 == 2)) {
#line 459
        tmp___5 = __errno_location();
#line 459
        *tmp___5 = 30;
      }
    } else {
#line 459
      tmp___5 = __errno_location();
#line 459
      *tmp___5 = 30;
    }
  }
#line 462
  tmp___9 = __errno_location();
#line 462
  tmp___10 = ignorable_missing(x, *tmp___9);
#line 462
  if (tmp___10) {
#line 463
    return ((enum RM_status )2);
  }
#line 469
  if ((int )ent->fts_info == 4) {
#line 470
    tmp___11 = __errno_location();
#line 470
    *tmp___11 = ent->fts_errno;
  }
#line 471
  tmp___12 = quote((char const   *)ent->fts_path);
#line 471
  tmp___13 = gettext("cannot remove %s");
#line 471
  tmp___14 = __errno_location();
#line 471
  error(0, *tmp___14, (char const   *)tmp___13, tmp___12);
#line 472
  mark_ancestor_dirs(ent);
#line 473
  return ((enum RM_status )4);
}
}
#line 482 "remove.c"
static enum RM_status rm_fts(FTS *fts , FTSENT *ent , struct rm_options  const  *x ) 
{ char const   *tmp ;
  char *tmp___0 ;
  _Bool tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  _Bool tmp___5 ;
  char const   *tmp___6 ;
  char *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  Ternary is_empty_directory ;
  enum RM_status s ;
  enum RM_status tmp___13 ;
  char const   *tmp___14 ;
  char *tmp___15 ;
  _Bool is_dir ;
  int tmp___16 ;
  enum RM_status s___0 ;
  enum RM_status tmp___17 ;
  enum RM_status tmp___18 ;
  char const   *tmp___19 ;
  char *tmp___20 ;
  char const   *tmp___21 ;
  char *tmp___22 ;
  char const   *tmp___23 ;
  char *tmp___24 ;

  {
#line 485
  switch ((int )ent->fts_info) {
  case 1: 
#line 488
  if (! x->recursive) {
#line 492
    tmp = quote((char const   *)ent->fts_path);
#line 492
    tmp___0 = gettext("cannot remove %s");
#line 492
    error(0, 21, (char const   *)tmp___0, tmp);
#line 493
    mark_ancestor_dirs(ent);
#line 494
    fts_skip_tree(fts, ent);
#line 495
    return ((enum RM_status )4);
  }
#line 499
  if (ent->fts_level == 0L) {
#line 501
    tmp___1 = strip_trailing_slashes(ent->fts_path);
#line 501
    if (tmp___1) {
#line 502
      ent->fts_pathlen = strlen((char const   *)ent->fts_path);
    }
#line 506
    tmp___4 = last_component((char const   *)ent->fts_accpath);
#line 506
    tmp___5 = dot_or_dotdot((char const   *)tmp___4);
#line 506
    if (tmp___5) {
#line 508
      tmp___2 = quote((char const   *)ent->fts_path);
#line 508
      tmp___3 = gettext("cannot remove directory: %s");
#line 508
      error(0, 0, (char const   *)tmp___3, tmp___2);
#line 510
      fts_skip_tree(fts, ent);
#line 511
      return ((enum RM_status )4);
    }
#line 516
    if (x->root_dev_ino) {
#line 516
      if (ent->fts_statp[0].st_ino == (x->root_dev_ino)->st_ino) {
#line 516
        if (ent->fts_statp[0].st_dev == (x->root_dev_ino)->st_dev) {
#line 518
          while (1) {
#line 518
            tmp___11 = strcmp((char const   *)ent->fts_path, "/");
#line 518
            if (tmp___11 == 0) {
#line 518
              tmp___6 = quote((char const   *)ent->fts_path);
#line 518
              tmp___7 = gettext("it is dangerous to operate recursively on %s");
#line 518
              error(0, 0, (char const   *)tmp___7, tmp___6);
            } else {
#line 518
              tmp___8 = quote_n(1, "/");
#line 518
              tmp___9 = quote_n(0, (char const   *)ent->fts_path);
#line 518
              tmp___10 = gettext("it is dangerous to operate recursively on %s (same as %s)");
#line 518
              error(0, 0, (char const   *)tmp___10, tmp___9, tmp___8);
            }
#line 518
            tmp___12 = gettext("use --no-preserve-root to override this failsafe");
#line 518
            error(0, 0, (char const   *)tmp___12);
#line 518
            break;
          }
#line 519
          fts_skip_tree(fts, ent);
#line 520
          return ((enum RM_status )4);
        }
      }
    }
  }
#line 526
  tmp___13 = prompt((FTS const   *)fts, (FTSENT const   *)ent, (_Bool)1, x, (enum Prompt_action )2,
                    & is_empty_directory);
#line 526
  s = tmp___13;
#line 529
  if ((unsigned int )s == 2U) {
#line 529
    if ((unsigned int )is_empty_directory == 4U) {
#line 533
      s = excise(fts, ent, x, (_Bool)1);
#line 534
      fts_skip_tree(fts, ent);
    }
  }
#line 537
  if ((unsigned int )s != 2U) {
#line 539
    mark_ancestor_dirs(ent);
#line 540
    fts_skip_tree(fts, ent);
  }
#line 543
  return (s);
  case 8: 
  case 10: 
  case 12: 
  case 13: 
  case 6: 
  case 4: 
  case 11: 
  case 3: 
#line 558
  if ((int )ent->fts_info == 6) {
#line 558
    if (x->one_file_system) {
#line 558
      if (0L < ent->fts_level) {
#line 558
        if (ent->fts_statp[0].st_dev != fts->fts_dev) {
#line 563
          mark_ancestor_dirs(ent);
#line 564
          tmp___14 = quote((char const   *)ent->fts_path);
#line 564
          tmp___15 = gettext("skipping %s, since it\'s on a different device");
#line 564
          error(0, 0, (char const   *)tmp___15, tmp___14);
#line 566
          return ((enum RM_status )4);
        }
      }
    }
  }
#line 569
  if ((int )ent->fts_info == 6) {
#line 569
    tmp___16 = 1;
  } else
#line 569
  if ((int )ent->fts_info == 4) {
#line 569
    tmp___16 = 1;
  } else {
#line 569
    tmp___16 = 0;
  }
#line 569
  is_dir = (_Bool )tmp___16;
#line 570
  tmp___17 = prompt((FTS const   *)fts, (FTSENT const   *)ent, is_dir, x, (enum Prompt_action )3,
                    (Ternary *)((void *)0));
#line 570
  s___0 = tmp___17;
#line 571
  if ((unsigned int )s___0 != 2U) {
#line 572
    return (s___0);
  }
#line 573
  tmp___18 = excise(fts, ent, x, is_dir);
#line 573
  return (tmp___18);
  case 2: 
#line 577
  while (1) {
#line 577
    tmp___19 = quote((char const   *)ent->fts_path);
#line 577
    tmp___20 = gettext("WARNING: Circular directory structure.\nThis almost certainly means that you have a corrupted file system.\nNOTIFY YOUR SYSTEM MANAGER.\nThe following directory is part of the cycle:\n  %s\n");
#line 577
    error(0, 0, (char const   *)tmp___20, tmp___19);
#line 577
    break;
  }
#line 578
  fts_skip_tree(fts, ent);
#line 579
  return ((enum RM_status )4);
  case 7: 
#line 584
  tmp___21 = quote((char const   *)ent->fts_path);
#line 584
  tmp___22 = gettext("traversal failed: %s");
#line 584
  error(0, ent->fts_errno, (char const   *)tmp___22, tmp___21);
#line 586
  fts_skip_tree(fts, ent);
#line 587
  return ((enum RM_status )4);
  default: 
#line 590
  tmp___23 = quote((char const   *)ent->fts_path);
#line 590
  tmp___24 = gettext("unexpected failure: fts_info=%d: %s\nplease report to %s");
#line 590
  error(0, 0, (char const   *)tmp___24, (int )ent->fts_info, tmp___23, "bug-coreutils@gnu.org");
#line 595
  abort();
  }
}
}
#line 601 "remove.c"
enum RM_status rm(char * const  *file , struct rm_options  const  *x ) 
{ enum RM_status rm_status ;
  int bit_flags ;
  FTS *fts ;
  FTS *tmp ;
  FTSENT *ent ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  enum RM_status s ;
  enum RM_status tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;

  {
#line 604
  rm_status = (enum RM_status )2;
#line 606
  if (*file) {
#line 608
    bit_flags = 536;
#line 612
    if (x->one_file_system) {
#line 613
      bit_flags |= 64;
    }
#line 615
    tmp = xfts_open(file, bit_flags, (int (*)(FTSENT const   ** , FTSENT const   ** ))((void *)0));
#line 615
    fts = tmp;
#line 617
    while (1) {
#line 621
      ent = fts_read(fts);
#line 622
      if ((unsigned long )ent == (unsigned long )((void *)0)) {
#line 624
        tmp___2 = __errno_location();
#line 624
        if (*tmp___2 != 0) {
#line 626
          tmp___0 = gettext("fts_read failed");
#line 626
          tmp___1 = __errno_location();
#line 626
          error(0, *tmp___1, (char const   *)tmp___0);
#line 627
          rm_status = (enum RM_status )4;
        }
#line 629
        break;
      }
#line 632
      tmp___3 = rm_fts(fts, ent, x);
#line 632
      s = tmp___3;
#line 634
      if (! ((unsigned int )s == 2U)) {
#line 634
        if (! ((unsigned int )s == 3U)) {
#line 634
          if (! ((unsigned int )s == 4U)) {
#line 634
            __assert_fail("((s) == RM_OK || (s) == RM_USER_DECLINED || (s) == RM_ERROR)",
                          "remove.c", 634U, "rm");
          }
        }
      }
#line 635
      while (1) {
#line 635
        if ((unsigned int )s == 4U) {
#line 635
          rm_status = s;
        } else
#line 635
        if ((unsigned int )s == 3U) {
#line 635
          if ((unsigned int )rm_status == 2U) {
#line 635
            rm_status = s;
          }
        }
#line 635
        break;
      }
    }
#line 638
    tmp___6 = fts_close(fts);
#line 638
    if (tmp___6 != 0) {
#line 640
      tmp___4 = gettext("fts_close failed");
#line 640
      tmp___5 = __errno_location();
#line 640
      error(0, *tmp___5, (char const   *)tmp___4);
#line 641
      rm_status = (enum RM_status )4;
    }
  }
#line 645
  return (rm_status);
}
}
